<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="探讨篇  起源 技术发展趋势 背景：最近几年，随着Go、Node 等新语言、新技术的出现，Java 作为服务器端开发语言老大的地位受到了不小的挑战。虽然Java 的市场地位在短时间内并不会发生改变，但Java 社区还是将挑战视为机遇，并努力、不断地提高自身应对高并发服务器端开发场景的能力  2009 年，微软提出了一个更优雅地实现异步编程的方式—— Reactive Programming ，我"><meta property="og:type" content="article"><meta property="og:title" content="响应式编程"><meta property="og:url" content="https://wugengfeng.cn/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="探讨篇  起源 技术发展趋势 背景：最近几年，随着Go、Node 等新语言、新技术的出现，Java 作为服务器端开发语言老大的地位受到了不小的挑战。虽然Java 的市场地位在短时间内并不会发生改变，但Java 社区还是将挑战视为机遇，并努力、不断地提高自身应对高并发服务器端开发场景的能力  2009 年，微软提出了一个更优雅地实现异步编程的方式—— Reactive Programming ，我"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B.png"><meta property="article:published_time" content="2022-11-12T15:01:00.000Z"><meta property="article:modified_time" content="2023-10-31T08:15:58.317Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="文章已过时"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>响应式编程 - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/banner/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8Bbanner.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="响应式编程"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-11-12 23:01" pubdate>2022年11月12日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 24k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 197 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">响应式编程</h1><div class="markdown-body"><h2 id="探讨篇"><a class="markdownIt-Anchor" href="#探讨篇"></a> 探讨篇</h2><h3 id="起源"><a class="markdownIt-Anchor" href="#起源"></a> 起源</h3><p><code>技术发展趋势</code></p><p><strong>背景</strong>：<span style="border-bottom:2px dashed green">最近几年，随着<code>Go</code>、<code>Node</code> 等新语言、新技术的出现，Java 作为服务器端开发语言老大的地位受到了不小的挑战。</span>虽然Java 的市场地位在短时间内并不会发生改变，但Java 社区还是将挑战视为机遇，并努力、不断地提高自身应对高并发服务器端开发场景的能力</p><ul><li>2009 年，微软提出了一个更优雅地实现异步编程的方式—— <strong>Reactive Programming</strong> ，我们称之为<strong>响应式编程</strong></li><li>JavaScript 语言就在ES6 中通过Promise 机制引入了类似的异步编程方式</li><li>2017 年9 月28 日，<strong>Spring 5</strong> 正式发布。Spring 5 发布最大的意义在于，它将响应式编程技术的普及向前推进了一大步。而同时，作为在背后支持Spring 5 响应式编程的框架Spring Reactor</li></ul><h3 id="是什么"><a class="markdownIt-Anchor" href="#是什么"></a> 是什么？</h3><p><code>面向流</code> <code>变化传播</code> <code>异步编程范式</code></p><p><span style="border-bottom:2px dashed green">响应式编程是一种面向数据流和变化传播的异步编程范式</span>。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/15549849?fr=aladdin">– 百度百科</a></p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E6%B5%81.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong><code>流</code></strong>：官方的解释是<code>一组有序的数据发布者</code>。所谓流，就是数据的流动、传输。通过各种形式将数据从一个地方带到另一个地方。一次Http请求是流，将请求参数带到服务端。一次数据库查询也是流，提交查询参数返回查询结果…<ul><li><strong><code>静态数据流</code></strong>：Java代码中的一个数组、一个List、一次数据库查询结果。它们的特点是数据是固定的，有限的</li><li><strong><code>动态数据流</code></strong>：一个商城的页面埋点就是一个动态数据流（无限流），你永远不知道数据什么时候到来，什么时候结束</li></ul></li><li><strong><code>变化传播</code></strong>：一个值改变之后，会像多米诺骨牌一样，导致直接和间接引用它的值均发生相应变化</li></ul><h3 id="有什么特点"><a class="markdownIt-Anchor" href="#有什么特点"></a> 有什么特点？</h3><ul><li><code>异步编程</code>：提供了合适的异步编程模型，能够挖掘多核 CPU 的能力、提高效率、降低延迟和阻塞等</li><li><code>数据流</code>：基于数据流模型，响应式编程提供一套统一的 Stream 风格的数据处理接口</li><li><code>变化传播</code>：简单来说就是以一个数据流为输入，经过一连串操作转化为另一个数据流，然后分发给各个订阅者的过程</li></ul><h3 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h3><p>以更少的服务器资源承载更高并发的场景</p><h3 id="技术路线"><a class="markdownIt-Anchor" href="#技术路线"></a> 技术路线</h3><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>ProjectReactor</code>是 Spring 响应式编程的基石，<code>ProjectReactor</code>项目由<code>vmware</code>和<code>Pivotal</code>两家公司合作研发</li><li>Spring Webflux 底层的响应式流实现就依赖于<code>ProjectReactor</code></li><li>Spring Cloud Gateway 需要 Spring Boot 和 Spring Webflux 提供的 Netty 运行。它在传统的 Servlet 容器中或构建为 WAR 时不起作用</li></ul><h2 id="概念篇-projecreactor"><a class="markdownIt-Anchor" href="#概念篇-projecreactor"></a> 概念篇 ProjecReactor</h2><p><a target="_blank" rel="noopener" href="http://projectreactor.io/docs/core/release/reference/">官方参考文档地址</a></p><p><a target="_blank" rel="noopener" href="https://htmlpreview.github.io/?https://github.com/get-set/reactor-core/blob/master-zh/src/docs/index.html">中文文档地址(3.2.0)</a></p><p><a target="_blank" rel="noopener" href="https://github.com/get-set/reactor-core/tree/master-zh/src/docs/asciidoc">中文文档源码</a></p><p><a target="_blank" rel="noopener" href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#3-subscription-code">reactive-streams 概念</a></p><h3 id="响应式编程思想"><a class="markdownIt-Anchor" href="#响应式编程思想"></a> 响应式编程思想</h3><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3.png" srcset="/img/loading.gif" lazyload alt></p><p>响应式编程，就像装配一条流水线。<code>Publisher</code> 规定了数据如何生产，中间会有 <code>Operators</code>（操作符）对流水线的数据进行解析，校验，转换等等操作，最终处理好的数据流转到 <code>Subscriber</code></p><p>发布订阅流程</p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E6%A6%82%E5%BF%B5%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="publisher-发布者"><a class="markdownIt-Anchor" href="#publisher-发布者"></a> Publisher 发布者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">Publisher</span> &lt; T &gt; &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  subscribe（Subscriber &lt;？ <span class="hljs-built_in">super</span>  T &gt;  s）;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Publisher</code>是一个或无限发布者元素的发布者，根据从其<code>Subscriber</code>接收到的需求发布它们</li><li>一个<code>Publisher</code>可以在不同的时间点动态地服务于多个<code>Subscriber</code>的订阅</li><li>在被订阅之前，大部分<code>Publisher</code>并不会主动发布元素(<a href="#%E5%86%B7%E4%B8%8E%E7%83%AD">冷与热</a>)，通过 <strong>订阅</strong>，可以将 <code>Publisher</code> 与 <code>Subscriber</code> 进行绑定，从而触发整个链中的数据流动。这是在内部实现的，通过单个 <code>request</code> 信号从 <code>Subscriber</code> 传播到上游，一直传回到 <code>Publisher</code></li></ul><p><code>Mono</code>：一个可以发出[0,1]个元素的异步发布者</p><p><code>Flux</code>：一个可以发出[1,无穷]个元素的异步发布者</p><h3 id="subscriber-订阅者"><a class="markdownIt-Anchor" href="#subscriber-订阅者"></a> Subscriber 订阅者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">Subscriber</span> &lt; T &gt; &#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  onSubscribe（Subscription  s）;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  onNext（T  t）;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  onError（Throwable  t）;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span>  onComplete（）;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在将<code>Subscriber</code>的实例传递给Publisher.subscribe(Subscriber)后，将收到一次对onSubscribe(Subscription)的调用</p></li><li><p>在调用Subscription.request(long)之前不会收到进一步的通知</p></li><li><p>单次调用onError(Throwable)或onComplete()发出终止状态信号，之后将不会发送更多事件(订阅终止)</p></li><li><p>只要<code>Subscriber</code>实例能够处理更多元素，就可以通过Subscription.request(long)发出需求信号(long 是背压数)</p></li></ul><p><code>BaseSubscriber</code>：如果需要自定义订阅者，推荐继承这个类</p><h3 id="subscription-订阅"><a class="markdownIt-Anchor" href="#subscription-订阅"></a> Subscription 订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subscription</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>表示Subscriber消费Publisher发布的一个消息的生命周期</li><li>它只能由单个Subscriber使用一次</li><li>它用于表示对数据的需求和取消需求（并允许资源清理）</li></ul><h3 id="processor-处理器"><a class="markdownIt-Anchor" href="#processor-处理器"></a> Processor 处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span>&lt;T, R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subscriber</span>&lt;T&gt;, Publisher&lt;R&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Processor代表一个处理阶段，它既是Subscriber又是Publisher并且遵守两者的契约</li><li>也就是说它是一个 <code>订阅元素-发布元素-处理</code>的处理过程（<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-core/issues/2431">3.5版本开始废弃，改用Sinks</a>）</li></ul><h3 id="mono"><a class="markdownIt-Anchor" href="#mono"></a> Mono</h3><p><a href="https://wugengfeng.cn/reactor3/reactor/core/publisher/Mono.html">Mono 使用手册</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/test/java/reactor/core/publisher/MonoAllTest.java">单元测试</a></p><p>一个可以发出[0,1]个元素的发布者</p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/Mono%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p><code>简单发布订阅</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Mono&lt;String&gt; source = Mono.just(<span class="hljs-string">&quot;test&quot;</span>)     <span class="hljs-comment">// 定义发布数据的逻辑</span><br>            .map(String::toUpperCase);          <span class="hljs-comment">// 操作符，处理发布的数据</span><br>    <br>    source.subscribe(System.out::println);      <span class="hljs-comment">// 订阅数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="flux"><a class="markdownIt-Anchor" href="#flux"></a> Flux</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/test/java/reactor/core/publisher/FluxArrayTest.java">单元测试</a></p><p>一个可以发出[1,无穷]个元素的发布者</p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/Flux%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p><code>简单发布订阅</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Flux&lt;String&gt; source = Flux.just(<span class="hljs-string">&quot;test&quot;</span>)     <span class="hljs-comment">// 定义发布数据的逻辑</span><br>            .map(String::toUpperCase);          <span class="hljs-comment">// 操作符，处理发布的数据</span><br><br>    source.subscribe(System.out::println);      <span class="hljs-comment">// 订阅数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="disposable"><a class="markdownIt-Anchor" href="#disposable"></a> Disposable</h3><ul><li>所有基于 lambda 的<code>subscribe()</code>都有一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/main/java/reactor/core/Disposable.java">Disposable</a> 返回类型。在这种情况下，<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/main/java/reactor/core/Disposable.java">Disposable</a> 接口表示可以通过调用其 <code>dispose()</code> 方法取消订阅</li><li>对于 Flux 或 Mono，<code>dispose()</code> 是源停止生成元素的信号。但是，它不能保证马上取消，某些源可能会非常快地生成元素，因为在接收到取消指令之前源已完成</li></ul><h3 id="发布元素"><a class="markdownIt-Anchor" href="#发布元素"></a> 发布元素</h3><ul><li><p>just：热发布运算符，在定义后，数据即刻发布(<a href="#%E5%86%B7%E4%B8%8E%E7%83%AD">冷与热</a>)</p></li><li><p>generate：同步单线程且每次回调只能发布一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Flux&lt;String&gt; flux = Flux.generate(<br>    () -&gt; <span class="hljs-number">0</span>, <br>    (state, sink) -&gt; &#123;	<span class="hljs-comment">// SynchronousSink</span><br>      sink.next(<span class="hljs-string">&quot;3 x &quot;</span> + state + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-number">3</span>*state); <br>      <span class="hljs-keyword">if</span> (state == <span class="hljs-number">10</span>) sink.complete(); <br>      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>; <br>    &#125;);<br></code></pre></td></tr></table></figure></li><li><p>create：异步多线程发布元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Flux.create(fluxSink -&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        fluxSink.next(i);   <span class="hljs-comment">// 发布元素</span><br>    &#125;<br><br>    fluxSink.complete();    <span class="hljs-comment">// 完成发布</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>push：异步单线程发布元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Flux.push(fluxSink -&gt; &#123;<br>    fluxSink.next(<span class="hljs-string">&quot;test&quot;</span>);<br>    fluxSink.complete();<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h3 id="背压"><a class="markdownIt-Anchor" href="#背压"></a> 背压</h3><p>向上游传播信号也用作实现 <strong>背压</strong>，我们在组装流水线类比中将其描述为，当工作站的处理速度比上游工作站慢时，沿生产线向上发送反馈信号。<span style="border-bottom:2px dashed green">背压其实就是一种下游向上游传递信号控制上游元素发布速率的一种手段，目的是均衡上下游的生产消费速率，保证稳定。(相当于MQ的拉取模式)</span></p><p><strong>背压策略</strong></p><ul><li>IGNORE： 完全忽略下游背压请求，这可能会在下游队列积满的时候导致 IllegalStateException</li><li>ERROR： 当下游跟不上节奏的时候发出一个 IllegalStateException 的错误信号</li><li>DROP： 当下游没有准备好接收新的元素的时候抛弃这个元素</li><li>LATEST： 让下游只得到上游最新的元素</li><li>BUFFER： （默认的）缓存所有下游没有来得及处理的元素（这个不限大小的缓存可能导致 OutOfMemoryError）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>    Flux&lt;Long&gt; flux = Flux.&lt;Long&gt;create(sink -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                    sink.next(i);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                sink.complete();<br>            &#125;, FluxSink.OverflowStrategy.LATEST)<br>            .publishOn(Schedulers.newSingle(<span class="hljs-string">&quot;newSingle&quot;</span>), <span class="hljs-number">1</span>);<br><br>    flux.subscribe(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseSubscriber</span>&lt;Long&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnSubscribe</span><span class="hljs-params">(Subscription subscription)</span> &#123;<br>            <span class="hljs-comment">// 订阅时设置每次请求元素个数</span><br>            request(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnNext</span><span class="hljs-params">(Long value)</span> &#123;<br>            log.info(<span class="hljs-string">&quot;消费流数据：&#123;&#125;&quot;</span>, value);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-comment">// 每处理完1个数据，就再请求1个</span><br>            request(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnError</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>            log.error(throwable.getMessage(), throwable);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnComplete</span><span class="hljs-params">()</span> &#123;<br>            countDownLatch.countDown();<br>        &#125;<br>    &#125;);<br>    countDownLatch.await();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冷与热"><a class="markdownIt-Anchor" href="#冷与热"></a> 冷与热</h3><ul><li><span style="border-bottom:2px dashed green"><strong>冷</strong> 的发布者为每个订阅者重新生成数据。如果没有创建订阅，则永远不会生成数据。</span>例如，如果源包装了一个 HTTP 调用，则会为每个订阅发出一个新的 HTTP 请求（在订阅前什么都不会发生）</li><li><span style="border-bottom:2px dashed green"><strong>热</strong> 的发布者不会为每个订阅者从头开始。</span>相反，迟到的订阅者会收到他们订阅后发出的信号。但是请注意，一些 <strong>热</strong> 反应流可以缓存或重播全部或部分发布的元素。从一般的角度来看，<strong>热</strong>发布者甚至可以在没有订阅者监听时发布（打破在订阅前什么都不会发生，可能立即发布元素，即使没有订阅者）</li><li><code>just</code>就是为数不多的热发布者运算符，它在组装时直接捕获值，然后将其重播给任何订阅它的人。再次使用 HTTP 调用类比，如果捕获的数据是 HTTP 调用的结果，那么在实例化时只进行一次网络调用</li><li><code>defer</code>可以将热发布者转变为冷发布者，它将我们示例中的 HTTP 请求推迟到订阅时触发（并且会导致对每个新订阅进行单独的网络调用）</li><li><code>share()</code> <code>replay(… )</code>可用于将冷发布者变成热发布者（至少在第一次订阅发生后）</li></ul><p><code>冷发布者重播行为</code></p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%86%B7%E5%8F%91%E5%B8%83%E8%80%85.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clodTest</span><span class="hljs-params">()</span> &#123;<br>        Flux&lt;String&gt; source = Flux.fromIterable(Arrays.asList(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>))<br>                .map(String::toUpperCase);<br><br>        source.subscribe(d -&gt; System.out.println(<span class="hljs-string">&quot;Subscriber 1: &quot;</span>+d));<br>        source.subscribe(d -&gt; System.out.println(<span class="hljs-string">&quot;Subscriber 2: &quot;</span>+d));<br>    &#125;<br><span class="hljs-comment">//    Subscriber 1: BLUE</span><br><span class="hljs-comment">//    Subscriber 1: GREEN</span><br><span class="hljs-comment">//    Subscriber 1: ORANGE</span><br><span class="hljs-comment">//    Subscriber 1: PURPLE</span><br><br><span class="hljs-comment">//    Subscriber 2: BLUE</span><br><span class="hljs-comment">//    Subscriber 2: GREEN</span><br><span class="hljs-comment">//    Subscriber 2: ORANGE</span><br><span class="hljs-comment">//    Subscriber 2: PURPLE</span><br><br></code></pre></td></tr></table></figure><p><code>热发布者广播行为</code></p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%83%AD%E5%8F%91%E5%B8%83%E8%80%85.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hotTest</span><span class="hljs-params">()</span> &#123;<br>        DirectProcessor&lt;String&gt; hotSource = DirectProcessor.create();<br>        Flux&lt;String&gt; hotFlux = hotSource.map(String::toUpperCase);<br><br>        <span class="hljs-comment">// 第一个订阅者</span><br>        hotFlux.subscribe(d -&gt; System.out.println(<span class="hljs-string">&quot;Subscriber 1 to Hot Source: &quot;</span>+d));<br>        hotSource.onNext(<span class="hljs-string">&quot;blue&quot;</span>);<br>        hotSource.onNext(<span class="hljs-string">&quot;green&quot;</span>);<br><br>        <span class="hljs-comment">// 第二个订阅者</span><br>        hotFlux.subscribe(d -&gt; System.out.println(<span class="hljs-string">&quot;Subscriber 2 to Hot Source: &quot;</span>+d));<br>        hotSource.onNext(<span class="hljs-string">&quot;orange&quot;</span>);<br>        hotSource.onNext(<span class="hljs-string">&quot;purple&quot;</span>);<br>        hotSource.onComplete();<br>    &#125;<br><span class="hljs-comment">//    Subscriber 1 to Hot Source: BLUE</span><br><span class="hljs-comment">//    Subscriber 1 to Hot Source: GREEN</span><br><span class="hljs-comment">//    Subscriber 1 to Hot Source: ORANGE</span><br><span class="hljs-comment">//    Subscriber 2 to Hot Source: ORANGE</span><br><span class="hljs-comment">//    Subscriber 1 to Hot Source: PURPLE</span><br><span class="hljs-comment">//    Subscriber 2 to Hot Source: PURPLE</span><br></code></pre></td></tr></table></figure><h3 id="调度器"><a class="markdownIt-Anchor" href="#调度器"></a> 调度器</h3><p><code>要用什么线程池由用户自己决定，只提供配置线程池的方法</code></p><p>元素的发布和订阅可以使用<code>publishOn</code>和<code>subscribeOn</code>方法指定使用的调度线程</p><p>Reactor， 就像 RxJava，也可以被认为是 <strong>并发无关（concurrency agnostic）</strong> 的。意思就是， 它并不强制要求任何并发模型。更进一步，它将选择权交给开发者。不过，它还是提供了一些方便 进行并发执行的库</p><ul><li>使用当前线程<code>Schedulers.immediate()</code></li><li>可重用的单线程<code>Schedulers.single()</code>。注意，这个方法对所有调用者都提供同一个线程来使用</li><li>专用单线程<code>Schedulers.newSingle()</code>。如果想为每个调用都使用一个单独的线程执行则使用这个</li><li>弹性线程池<code>Schedulers.elastic()</code>。它根据需要创建一个线程池，重用空闲线程。线程池如果空闲时间过长 （默认为 60s）就会被废弃，没有线程数上限（新版本已废弃）</li><li>有界弹性线程池<code>Schedulers.boundedElastic()</code>。可以设置最大线程数和最大任务数的弹性线程池</li><li>固定大小线程池（<code>Schedulers.parallel()</code>）。所创建线程池的大小与 CPU 个数等同</li><li>使用JDK或第三方的线程池 <code>Schedulers.fromExecutorService(ExecutorService)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Flux.create 异步多线程发布</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-type">Scheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> Schedulers.boundedElastic();<br><br>    Flux.create(fluxSink -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                    ThreadUtil.sleep(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS);<br>                    log.info(<span class="hljs-string">&quot;发布元素&quot;</span>);<br>                    fluxSink.next(i);<br>                &#125;<br>            &#125;)<br>            .publishOn(scheduler)       <span class="hljs-comment">// 指定发布的线程池</span><br>            .subscribeOn(scheduler)     <span class="hljs-comment">// 指定订阅的线程池</span><br>            .subscribe(data -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;订阅元素：&#123;&#125;&quot;</span>, data);<br>                countDownLatch.countDown();<br>            &#125;);<br><br>    countDownLatch.await();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%BC%82%E5%B8%B8.png" srcset="/img/loading.gif" lazyload alt></p><p>在响应式流中，错误（error）是终止（terminal）事件。当有错误发生时，它会导致流序列停止， 并且错误信号会沿着操作链条向下传递，直至遇到你定义的 <code>Subscriber</code> 及其 <code>onError</code> 方法</p><p>Reactor 提供了其他的用于在链中处理错误的方法，即错误处理操作（error-handling operators）</p><h4 id="静态缺省值"><a class="markdownIt-Anchor" href="#静态缺省值"></a> 静态缺省值</h4><p><code>onErrorReturn</code>：当Publisher出现错误时，返回一个默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Mono&lt;Integer&gt; source = Mono.just(<span class="hljs-number">10</span>)<br>            .map(item -&gt; item / <span class="hljs-number">0</span>)     <span class="hljs-comment">// 除零错误</span><br>            .onErrorReturn(<span class="hljs-number">0</span>);         <span class="hljs-comment">// 异常返回默认值，有重载方法，可根据异常类型，条件决定返回值</span><br><br>    StepVerifier.create(source)<br>            .expectNext(<span class="hljs-number">0</span>)<br>            .verifyComplete();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="捕获并吃掉错误"><a class="markdownIt-Anchor" href="#捕获并吃掉错误"></a> 捕获并吃掉错误</h4><p><code>onErrorComplete</code>：吃掉Error信号，只需将 onError 信号替换为 onComplete 信号即可完成序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Mono</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Mono.just(<span class="hljs-number">1</span>)<br>            .map(item -&gt; &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>            &#125;)<br>            .onErrorComplete();<br><br>    source.subscribe(AssertSubscriber.create()<br>            .assertNoError()<br>            .assertNoValues()<br>            .assertNotComplete());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异常处理方法"><a class="markdownIt-Anchor" href="#异常处理方法"></a> 异常处理方法</h4><p><code>onErrorResume</code>：当Publisher出现错误时，进行方法回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        Mono&lt;String&gt; source = Mono.just(<span class="hljs-string">&quot;&quot;</span>)<br>                .map(item -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == item || <span class="hljs-string">&quot;&quot;</span>.equals(item)) &#123;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> item;<br>                &#125;)<br>                .onErrorResume(<span class="hljs-built_in">this</span>::getDefault);<br><br>        StepVerifier.create(source)<br>                .expectNext(<span class="hljs-string">&quot;default&quot;</span>)<br>                .verifyComplete();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常回调方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> throwable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Mono&lt;String&gt; <span class="hljs-title function_">getDefault</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">&quot;default&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="捕获并重新抛出"><a class="markdownIt-Anchor" href="#捕获并重新抛出"></a> 捕获并重新抛出</h4><p><code>onErrorMap</code>：捕获异常，并重新转换一个新的异常然后继续向下传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Mono</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Mono.just(<span class="hljs-number">1</span>)<br>               .map(item -&gt; item / <span class="hljs-number">0</span>)<br>               .onErrorMap(e -&gt; &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>               &#125;);<br><br>       StepVerifier.create(source)<br>               .expectError(RuntimeException.class)<br>               .verify();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="异常终止触发行为"><a class="markdownIt-Anchor" href="#异常终止触发行为"></a> 异常终止触发行为</h4><p><code>doOnError</code>：添加Mono因异常而终止时触发的行为，首先处理程序被执行，然后 onError 信号被传播到下游</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Mono</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Mono.just(<span class="hljs-number">1</span>)<br>            .map(item -&gt; &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>            &#125;)<br>            .doOnError(throwable -&gt; &#123;<br>                <span class="hljs-comment">// TODO 异常业务处理</span><br>                throwable.printStackTrace();<br>            &#125;);<br><br>    StepVerifier.create(source)<br>            .expectError()<br>            .verify();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用finally"><a class="markdownIt-Anchor" href="#使用finally"></a> 使用Finally</h4><p><code>doFinally</code>：Mono因任何原因终止后添加行为触发（包括取消、终止、完成），会传递一个信号量类型通知你</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Mono</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> Mono.just(<span class="hljs-number">1</span>)<br>               .map(item -&gt; &#123;<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>               &#125;)<br>               .doFinally(signalType -&gt; &#123;<br>                   <span class="hljs-keyword">if</span> (SignalType.ON_ERROR.equals(signalType)) &#123;<br>                       System.out.println(<span class="hljs-string">&quot;异常信号&quot;</span>);<br>                   &#125;<br>               &#125;);<br><br>       StepVerifier.create(source)<br>               .expectError()<br>               .verify();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="try-with-resource"><a class="markdownIt-Anchor" href="#try-with-resource"></a> try-with-resource</h4><p><code>using</code>：主要将一个资源使用工厂方法方式为每个订阅者生成资源，第一个参数在订阅时创建资源，第二个参数 一个Mono工厂创建 Mono， 第三个参数 资源清理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Mono&lt;Object&gt; source = Mono.using(<br>            () -&gt; <span class="hljs-number">1</span>,<br>            resource -&gt; Mono.error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>()),<br>            item -&gt; &#123;<br>                <span class="hljs-comment">// 类似 finally,完成或异常后会执行</span><br>                System.out.println(<span class="hljs-string">&quot;释放资源&quot;</span>);<br>            &#125;);<br><br>    StepVerifier.create(source)<br>            .expectError(RuntimeException.class)<br>            .verify();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="exceptions"><a class="markdownIt-Anchor" href="#exceptions"></a> Exceptions</h4><p>全局 Reactor 核心异常处理和操作工具，使用工具类传播和拆包异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        Mono&lt;Integer&gt; source = Mono.just(<span class="hljs-number">1</span>)<br>                .map(item -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (item == <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 包装传播一个异常</span><br>                        <span class="hljs-keyword">throw</span> Exceptions.propagate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>());<br>                    &#125;<br><br>                    <span class="hljs-keyword">return</span> item;<br>                &#125;);<br><br>        source.subscribe(System.out::print, e -&gt; &#123;<br>            <span class="hljs-comment">// 订阅时处理传播的异常</span><br>            <span class="hljs-keyword">if</span> (Exceptions.unwrap(e) <span class="hljs-keyword">instanceof</span> IllegalArgumentException) &#123;<br>                System.out.println(<span class="hljs-string">&quot;参数非法异常&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="sinks"><a class="markdownIt-Anchor" href="#sinks"></a> Sinks</h3><p>在3.5.0版本之前使用的是<code>Processor</code>，<code>Sinks</code>在新版本之后用于淘汰<code>Processor</code></p><p>在 Reactor 中，sink 是一个允许以独立方式安全手动触发信号的类，创建一个类似于 Publisher 的结构，能够处理多个 Subscriber(单播类型除外)</p><p><code>Sinks.emitNext</code>： 发布元素，<code>EmitFailureHandler</code>,发布失败处理程序</p><p><code>Sinks.Many 终止</code>：（通常通过调用其 emitError(Throwable) 或 emitComplete() 方法），它会允许更多订阅者订阅，但会立即向他们重播终止信号</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/main/java/reactor/core/publisher/Sinks.java">Sinks.UnicastSpec 单播规则</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/main/java/reactor/core/publisher/Sinks.java">Sinks.ManySpec 多播规则</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/main/java/reactor/core/publisher/Sinks.java">Sinks.MulticastSpec 多播规则</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/reactor-core/edit/main/-/reactor-core/src/main/java/reactor/core/publisher/Sinks.java">Sinks.MulticastReplaySpec 多播重播规则</a></p><h4 id="多线程环安全类"><a class="markdownIt-Anchor" href="#多线程环安全类"></a> 多线程环安全类</h4><ul><li>Sinks.One</li><li>Sinks.Many</li></ul><p>Sinks 建造者为主要支持的生产者类型提供了一个引导式 API。您会发现 Flux 中的一些行为，例如 onBackpressureBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br>       <span class="hljs-comment">// 定义一个sinks</span><br>       Sinks.Many&lt;Integer&gt; sinks = Sinks.many().replay().all();<br><br>       <span class="hljs-comment">// 多线程手动调用发布元素</span><br>       executorService.execute(() -&gt; sinks.emitNext(<span class="hljs-number">1</span>, Sinks.EmitFailureHandler.FAIL_FAST));<br>       executorService.execute(() -&gt; sinks.emitNext(<span class="hljs-number">2</span>, Sinks.EmitFailureHandler.FAIL_FAST));<br>       executorService.execute(() -&gt; sinks.emitNext(<span class="hljs-number">3</span>, Sinks.EmitFailureHandler.FAIL_FAST));<br><br>       <span class="hljs-comment">// Sinks.Many 可以转为Flux。同理，Sinks.One可以转为Mono</span><br>       Flux&lt;Integer&gt; flux = sinks.asFlux().log();<br><br>       <span class="hljs-comment">// 多线程发布元素，因此输出的顺序不一定是1,2,3</span><br>       flux.subscribe(System.out::println);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="单播"><a class="markdownIt-Anchor" href="#单播"></a> 单播</h4><p>仅允许一个订阅者订阅，多个订阅者订阅除了第一个订阅之外，其他订阅者会出现<code>IllegalStateException</code>异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Sinks.Many&lt;Integer&gt; sinks = Sinks.many().unicast().onBackpressureBuffer();<br>    sinks.emitNext(<span class="hljs-number">1</span>, Sinks.EmitFailureHandler.FAIL_FAST);<br><br>    Flux&lt;Integer&gt; flux = sinks.asFlux();<br>    flux.subscribe(AssertSubscriber.create().assertNoError().assertNotComplete());<br>    flux.subscribe(AssertSubscriber.create().assertError(IllegalStateException.class).assertNotComplete());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多播"><a class="markdownIt-Anchor" href="#多播"></a> 多播</h4><p>它只会将新推送的数据传输给它的多个订阅者，同时为每个订阅者提供背压</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Sinks.Many&lt;Integer&gt; sinks = Sinks.many().multicast().onBackpressureBuffer();<br>    sinks.emitNext(<span class="hljs-number">1</span>, Sinks.EmitFailureHandler.FAIL_FAST);<br><br>    Flux&lt;Integer&gt; flux = sinks.asFlux();<br>    flux.subscribe(AssertSubscriber.create().assertNoError().assertNotComplete());<br>    flux.subscribe(AssertSubscriber.create().assertNoError().assertNotComplete());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重播"><a class="markdownIt-Anchor" href="#重播"></a> 重播</h4><p>它将向多个Subscriber广播，并能够保留和重播所有历史的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    Sinks.Many&lt;Integer&gt; sinks = Sinks.many().replay().all();<br>    sinks.emitNext(<span class="hljs-number">1</span>, Sinks.EmitFailureHandler.FAIL_FAST);<br><br>    Flux&lt;Integer&gt; flux = sinks.asFlux();<br>    flux.subscribe(AssertSubscriber.create().assertNoError().assertNotComplete());<br>    flux.subscribe(AssertSubscriber.create().assertNoError().assertNotComplete());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="debug调试"><a class="markdownIt-Anchor" href="#debug调试"></a> Debug调试</h3><p>在命令模式开发中，错误代码根据异常堆栈是相对容易定位到的。但是在响应式编程中，由于Publish封装了其操作符，并且调用链可能会很长，根据异常堆栈定位问题相对困难</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Mono&lt;String&gt; source = Flux.just(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>            .filter(item -&gt; <span class="hljs-literal">null</span> != item)<br>            .map(item -&gt; item.toLowerCase())<br>            .single();<br><br>    <span class="hljs-type">Disposable</span> <span class="hljs-variable">subscribe</span> <span class="hljs-operator">=</span> source.subscribe();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxMapFuseable<span class="hljs-variable">$MapFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxMapFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">129</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxFilterFuseable<span class="hljs-variable">$FilterFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxFilterFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">118</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxArray<span class="hljs-variable">$ArrayConditionalSubscription</span><span class="hljs-selector-class">.fastPath</span>(FluxArray<span class="hljs-selector-class">.java</span>:<span class="hljs-number">340</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxArray<span class="hljs-variable">$ArrayConditionalSubscription</span><span class="hljs-selector-class">.request</span>(FluxArray<span class="hljs-selector-class">.java</span>:<span class="hljs-number">263</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxFilterFuseable<span class="hljs-variable">$FilterFuseableSubscriber</span><span class="hljs-selector-class">.request</span>(FluxFilterFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">191</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxMapFuseable<span class="hljs-variable">$MapFuseableSubscriber</span><span class="hljs-selector-class">.request</span>(FluxMapFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">171</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.doOnRequest</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">103</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.Operators<span class="hljs-variable">$MonoInnerProducerBase</span><span class="hljs-selector-class">.request</span>(Operators<span class="hljs-selector-class">.java</span>:<span class="hljs-number">2841</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.LambdaMonoSubscriber</span><span class="hljs-selector-class">.onSubscribe</span>(LambdaMonoSubscriber<span class="hljs-selector-class">.java</span>:<span class="hljs-number">121</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onSubscribe</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">115</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxMapFuseable<span class="hljs-variable">$MapFuseableSubscriber</span><span class="hljs-selector-class">.onSubscribe</span>(FluxMapFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">96</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxFilterFuseable<span class="hljs-variable">$FilterFuseableSubscriber</span><span class="hljs-selector-class">.onSubscribe</span>(FluxFilterFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">87</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.FluxArray</span><span class="hljs-selector-class">.subscribe</span>(FluxArray<span class="hljs-selector-class">.java</span>:<span class="hljs-number">50</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.FluxArray</span><span class="hljs-selector-class">.subscribe</span>(FluxArray<span class="hljs-selector-class">.java</span>:<span class="hljs-number">59</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.Mono</span><span class="hljs-selector-class">.subscribe</span>(Mono<span class="hljs-selector-class">.java</span>:<span class="hljs-number">4716</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.Mono</span><span class="hljs-selector-class">.subscribeWith</span>(Mono<span class="hljs-selector-class">.java</span>:<span class="hljs-number">4784</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.Mono</span><span class="hljs-selector-class">.subscribe</span>(Mono<span class="hljs-selector-class">.java</span>:<span class="hljs-number">4544</span>)<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisherMonoBlockTest</span><span class="hljs-selector-class">.test3</span>(MonoBlockTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">66</span>)<br></code></pre></td></tr></table></figure><p>从异常堆栈中我们得到一个<code>IndexOutOfBoundsException</code>，它告诉我们这个源发布了太多的元素。我们只能猜测是由于<code>Flux</code>发布了多个元素最终调用<code>single</code>方法收敛为一个<code>Mono</code>时元素过多，但是在这个堆栈中我们提取不到任何有价值的信息，这显然对我们进行调试很不友好</p><h4 id="激活调试模式"><a class="markdownIt-Anchor" href="#激活调试模式"></a> 激活调试模式</h4><p>尽管堆栈跟踪仍然能够提取到一些有价值的信息，但我们可以看到，在更高级的情况下，它本身并不理想。幸运的是，Reactor 带有专为调试而设计的汇编时检测，这是通过在应用程序启动时通过 <code>Hooks.onOperatorDebug()</code> 方法激活全局调试模式来完成的（或者至少在可以实例化有异常的 Flux 或 Mono 之前）</p><p>通过包装操作符的构造并在那里捕获堆栈跟踪来检测对 Reactor 操作符方法的调用（它们被组装到链中）。由于这是在声明运算符链时完成的，因此应该在此之前激活<code>Hook</code>，因此最安全的方法是在应用程序开始时立即激活它</p><p>现在继续沿用上面的那段异常代码，我们加入激活调试模式再看看异常堆栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Hooks.onOperatorDebug();<br>    Mono&lt;String&gt; source = Flux.just(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>            .filter(item -&gt; <span class="hljs-literal">null</span> != item)<br>            .map(item -&gt; item.toLowerCase())<br>            .single();	<span class="hljs-comment">// 代码第65行</span><br><br>    <span class="hljs-type">Disposable</span> <span class="hljs-variable">subscribe</span> <span class="hljs-operator">=</span> source.subscribe();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">reactor<span class="hljs-selector-class">.core</span>.Exceptions<span class="hljs-variable">$ErrorCallbackNotImplemented</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)⑴<br>	Suppressed: reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxOnAssembly<span class="hljs-variable">$OnAssemblyException</span>: ⑵<br>Assembly trace from producer <span class="hljs-selector-attr">[reactor.core.publisher.MonoSingle]</span> :⑶<br>	reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.Flux</span><span class="hljs-selector-class">.single</span>(Flux<span class="hljs-selector-class">.java</span>:<span class="hljs-number">8203</span>)<br>	reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.MonoBlockTest</span><span class="hljs-selector-class">.test3</span>(MonoBlockTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">65</span>)<br>Error has been observed at the following <span class="hljs-built_in">site</span>(s):⑷<br>	*__Flux<span class="hljs-selector-class">.single</span> ⇢ at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.MonoBlockTest</span><span class="hljs-selector-class">.test3</span>(MonoBlockTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">65</span>)⑸<br>Original Stack Trace:⑹<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)⑺<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxMapFuseable<span class="hljs-variable">$MapFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxMapFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">129</span>)<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxFilterFuseable<span class="hljs-variable">$FilterFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxFilterFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">118</span>)<br></code></pre></td></tr></table></figure><ul><li>⑴：原始堆栈跟踪到<code>MonoSingle</code>,也就是说我们的元素被截断</li><li>⑵：我们看到了捕获堆栈的包装器运算符。这是回溯开始出现的地方</li><li>⑶：我们得到一些关于操作位置的细节<code>MonoSingle</code></li><li>⑷：我们得到了错误传播的运算符链的观点，从头到尾（错误站点到订阅站点）</li><li>⑸：提到了错误的每个操作以及使用它的用户类和所在行数，这里我们有一个“根”</li><li>⑹：跟踪堆栈的其余部分</li><li>⑺：展示了一些操作的内部结构</li></ul><p>最终根据“根”的提示和分析，我们定位到了<code>single()</code>方法出现异常</p><h4 id="checkpoint"><a class="markdownIt-Anchor" href="#checkpoint"></a> checkpoint</h4><p>调试模式是全局的，会影响应用程序中组装到 Flux 或 Mono 中的每个运算符</p><p>正如我们之前看到的，这种全局知识是以影响性能为代价的（由于填充的堆栈跟踪的数量）。如果我们知道可能存在问题的操作，则可以降低该成本。但是，我们通常不知道哪些操作符可能有问题，除非复现BUG调试</p><p>可以将<code>checkpoint()</code>运算符链接到方法链中。检查点运算符的工作方式类似于<code>Hook</code>，但仅适用于该特定的方法链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Mono&lt;String&gt; source = Flux.just(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>            .filter(item -&gt; <span class="hljs-literal">null</span> != item)<br>            .map(item -&gt; item.toLowerCase())<br>            .checkpoint(<span class="hljs-string">&quot;1&quot;</span>)<br>            .single()<br>            .checkpoint(<span class="hljs-string">&quot;2&quot;</span>);<br><br>    <span class="hljs-type">Disposable</span> <span class="hljs-variable">subscribe</span> <span class="hljs-operator">=</span> source.subscribe();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在一个方法链中插入一些检查点，最终这些检查点会协助我们定位到出现问题的代码，上面代码插入2个检查点，最终在异常堆栈中只输出检查点2，因此我们可以定位问题介于检查点1和2之间</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">reactor<span class="hljs-selector-class">.core</span>.Exceptions<span class="hljs-variable">$ErrorCallbackNotImplemented</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)<br>	Suppressed: reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxOnAssembly<span class="hljs-variable">$OnAssemblyException</span>: <br>Error has been observed at the following <span class="hljs-built_in">site</span>(s):<br>	*__checkpoint ⇢ <span class="hljs-number">2</span><br>Original Stack Trace:<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxMapFuseable<span class="hljs-variable">$MapFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxMapFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">129</span>)<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxFilterFuseable<span class="hljs-variable">$FilterFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxFilterFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">118</span>)<br></code></pre></td></tr></table></figure><h4 id="现成的全局调试方案"><a class="markdownIt-Anchor" href="#现成的全局调试方案"></a> 现成的全局调试方案</h4><p>Project Reactor 附带一个单独的 Java 代理，它可以检测您的代码并添加调试信息，而无需在每次操作调用时捕获堆栈跟踪。该行为与激活调试模式非常相似 - 也称为<code>回溯</code>，但没有运行时性能开销</p><ol><li><p>它需要使用Maven进行依赖集成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.projectreactor<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>reactor-tools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>它还需要显式初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ReactorDebugAgent.init();<br></code></pre></td></tr></table></figure><p>由于该实现将在加载类时对其进行检测，因此最好将其放置在 main(String[]) 方法中的其他所有内容之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ReactorDebugAgent.init();<br>    SpringApplication.run(Application.class, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>ReactorDebugAgent 作为 Java Agent 实现，并使用 <a target="_blank" rel="noopener" href="https://bytebuddy.net/#/">ByteBuddy</a> 进行字节码扩展。可能无法在某些 JVM 上工作，请参阅 <a target="_blank" rel="noopener" href="https://bytebuddy.net/#/">ByteBuddy</a> 的文档以获取更多详细信息</p><p>如果当前开发环境不支持 <a target="_blank" rel="noopener" href="https://bytebuddy.net/#/">ByteBuddy</a> 字节码扩展，可以将 reactor-tools 作为 Java Agent 运行</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">javaagent </span>reactor-tools.<span class="hljs-keyword">jar </span>-<span class="hljs-keyword">jar </span>app.<span class="hljs-keyword">jar</span><br></code></pre></td></tr></table></figure></li></ol><p>修改代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>	ReactorDebugAgent.init();<br>	Mono&lt;String&gt; source = Flux.just(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>			.filter(item -&gt; <span class="hljs-literal">null</span> != item)<br>			.map(item -&gt; item.toLowerCase())<br>			.single();<br><br>	<span class="hljs-type">Disposable</span> <span class="hljs-variable">subscribe</span> <span class="hljs-operator">=</span> source.subscribe();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Test class reactor<span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.agent</span><span class="hljs-selector-class">.ReactorDebugJavaAgentTest</span><br><span class="hljs-selector-attr">[ERROR]</span> (Test worker) Operator called default onErrorDropped - reactor<span class="hljs-selector-class">.core</span>.Exceptions<span class="hljs-variable">$ErrorCallbackNotImplemented</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>reactor<span class="hljs-selector-class">.core</span>.Exceptions<span class="hljs-variable">$ErrorCallbackNotImplemented</span>: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IndexOutOfBoundsException</span>: Source emitted more than one item<br>	at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)<br>	Suppressed: The stacktrace has been enhanced by Reactor, refer to additional information below: <br>Assembly trace from producer <span class="hljs-selector-attr">[reactor.core.publisher.MonoSingle]</span> :<br>	reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.Flux</span><span class="hljs-selector-class">.single</span><br>	reactor<span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.agent</span><span class="hljs-selector-class">.ReactorDebugJavaAgentTest</span><span class="hljs-selector-class">.test</span>(ReactorDebugJavaAgentTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br>Error has been observed at the following <span class="hljs-built_in">site</span>(s):<br>	*__Flux<span class="hljs-selector-class">.single</span> ⇢ at reactor<span class="hljs-selector-class">.tools</span><span class="hljs-selector-class">.agent</span><span class="hljs-selector-class">.ReactorDebugJavaAgentTest</span><span class="hljs-selector-class">.test</span>(ReactorDebugJavaAgentTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>) <span class="hljs-comment">// 根</span><br>Original Stack Trace:<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.MonoSingle<span class="hljs-variable">$SingleSubscriber</span><span class="hljs-selector-class">.onNext</span>(MonoSingle<span class="hljs-selector-class">.java</span>:<span class="hljs-number">134</span>)<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxMapFuseable<span class="hljs-variable">$MapFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxMapFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">129</span>)<br>		at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxFilterFuseable<span class="hljs-variable">$FilterFuseableSubscriber</span><span class="hljs-selector-class">.onNext</span>(FluxFilterFuseable<span class="hljs-selector-class">.java</span>:<span class="hljs-number">118</span>)<br></code></pre></td></tr></table></figure><h4 id="日志记录"><a class="markdownIt-Anchor" href="#日志记录"></a> 日志记录</h4><p>日志操作使用 Loggers 类，它通过 SLF4J 选择常见的日志记录框架，例如 Log4J 和 Logback，如果 SLF4J 不可用，则默认记录到控制台</p><p>在生产环境中使用，应该注意配置底层日志记录框架以使用其最异步和非阻塞的方法——例如，Logback 中的 AsyncAppender 或 Log4j 2 中的 AsyncLogge</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    Mono&lt;String&gt; source = Flux.just(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>)<br>            .log()<br>            .filter(item -&gt; <span class="hljs-literal">null</span> != item)<br>            .map(item -&gt; item.toLowerCase())<br>            .single();<br><br>    <span class="hljs-type">Disposable</span> <span class="hljs-variable">subscribe</span> <span class="hljs-operator">=</span> source.subscribe();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Test <span class="hljs-keyword">class</span> <span class="hljs-title class_">reactor</span>.core.publisher.MonoBlockTest<br><span class="hljs-number">00</span>:08:<span class="hljs-number">19.834</span> [Test worker] INFO  reactor.Flux.Array<span class="hljs-number">.1</span> - | onSubscribe([Synchronous Fuseable] FluxArray.ArrayConditionalSubscription)<br><span class="hljs-number">00</span>:08:<span class="hljs-number">19.846</span> [Test worker] INFO  reactor.Flux.Array<span class="hljs-number">.1</span> - | request(unbounded)<br><span class="hljs-number">00</span>:08:<span class="hljs-number">19.847</span> [Test worker] INFO  reactor.Flux.Array<span class="hljs-number">.1</span> - | onNext(hello)<br><span class="hljs-number">00</span>:08:<span class="hljs-number">19.848</span> [Test worker] INFO  reactor.Flux.Array<span class="hljs-number">.1</span> - | onNext(world)<br><span class="hljs-number">00</span>:08:<span class="hljs-number">19.848</span> [Test worker] INFO  reactor.Flux.Array<span class="hljs-number">.1</span> - | cancel()	<span class="hljs-comment">// 在获取第二个元素后流被取消</span><br><span class="hljs-number">00</span>:08:<span class="hljs-number">19.860</span> [Test worker] ERROR reactor.core.publisher.Operators - Operator called <span class="hljs-keyword">default</span> onErrorDropped<br>reactor.core.Exceptions$ErrorCallbackNotImplemented: java.lang.IndexOutOfBoundsException: Source emitted more than one item<br>Caused by: java.lang.IndexOutOfBoundsException: Source emitted more than one item<br>	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:<span class="hljs-number">134</span>)<br>	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:<span class="hljs-number">129</span>)<br>	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onNext(FluxFilterFuseable.java:<span class="hljs-number">118</span>)<br>	at reactor.core.publisher.FluxPeekFuseable$PeekFuseableConditionalSubscriber.onNext(FluxPeekFuseable.java:<span class="hljs-number">503</span>)<br></code></pre></td></tr></table></figure><p>通过log日志定位后，我们能够定位到当在获取第二个元素时流被取消，结合异常信息和源码，我们知道在调用<code>single()</code>方法时Flux存在多个元素</p><h3 id="性能指标监控"><a class="markdownIt-Anchor" href="#性能指标监控"></a> 性能指标监控</h3><p><strong>TODO</strong>（依赖未发布到Maven仓库）</p><h3 id="高级特性"><a class="markdownIt-Anchor" href="#高级特性"></a> 高级特性</h3><p><a target="_blank" rel="noopener" href="https://projectreactor.io/docs/core/release/reference/#advanced-mutualizing-operator-usage">高级特性</a></p><h3 id="上下文传播"><a class="markdownIt-Anchor" href="#上下文传播"></a> 上下文传播</h3><p>3.5.0版本之后内置了<code>Context-Propagation</code>第三方上下文传播库，能够实现<code>ThreadLocal</code>-&gt;<code>Context</code>的数据传播</p><h2 id="数据库篇"><a class="markdownIt-Anchor" href="#数据库篇"></a> 数据库篇</h2><h3 id="r2dbc"><a class="markdownIt-Anchor" href="#r2dbc"></a> <a target="_blank" rel="noopener" href="https://r2dbc.io/">R2DBC</a></h3><p><code>响应式的关系型数据库驱动规范</code></p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/R2DBC.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>全称是<code>Reactive Relational Database Connectivity</code> 响应式关系型数据库连接</p></li><li><p>和<code>JDBC</code>一样，<code>R2DBC</code>是使用响应式编程实现的关系型数据库驱动规范，是非阻塞型的。而<code>JDBC</code>则是传统编程实现的阻塞型驱动规范</p></li><li><p>注意：如果将传统项目升级为<code>响应式</code>项目，那么最大的阻力就是驱动切换，只有将<code>Spring MVC</code> 升级为<code>webflux</code>并且将<code>JDBC</code>启动替换为<code>R2DBC</code>才是一个响应式项目。如果单升级<code>webflux</code>的关系型数据库项目将毫无意义，不能发挥响应式编程的特性</p></li></ul><p><strong>已经实现R2DBC驱动的数据库</strong></p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/R2DBC%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>已经实现或在调研中的ORM客户端</strong></p><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/R2DBC%E5%AE%A2%E6%88%B7%E7%AB%AF.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="spring-data-r2dbc"><a class="markdownIt-Anchor" href="#spring-data-r2dbc"></a> <a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-r2dbc">spring-data-r2dbc</a></h3><p>spring-data-r2dbc是spring-data项目的一部分（大名顶顶的spring-data项目几乎支持了市面上主流的数据库），实现了<code>R2DBC</code>和<code>JPA</code>协议，是一个响应式的关系型数据库的<code>ORM</code>框架，可以很轻松使用JPA规范去编写响应式数据库操作（JPA规范比较有名的实现是Hibernate）</p><h3 id="reactive-mybatis"><a class="markdownIt-Anchor" href="#reactive-mybatis"></a> <a target="_blank" rel="noopener" href="https://github.com/chenggangpro/reactive-mybatis-support">reactive-mybatis</a></h3><p>基于<a target="_blank" rel="noopener" href="https://github.com/linux-china/mybatis-r2dbc">mybatis-r2dbc</a>改造实现的响应式版mybatis,实现了ORM框架基本功能，目前无法使用Mybatis插件功能</p><h2 id="实践篇"><a class="markdownIt-Anchor" href="#实践篇"></a> 实践篇</h2><h3 id="webflux"><a class="markdownIt-Anchor" href="#webflux"></a> WebFlux</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">官方参考文档地址</a></p><p><a target="_blank" rel="noopener" href="https://github.com/skyding228/webFlux/wiki/WebFlux#11-%E7%AE%80%E4%BB%8B">国人翻译wiki</a></p><p><a target="_blank" rel="noopener" href="https://dzxlar.gitbooks.io/webflux-spring-chinese-document/content/">国人翻译</a></p><h4 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h4><p><img src="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/webFlux%E8%83%8C%E6%99%AF.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h4><p><a target="_blank" rel="noopener" href="https://gitee.com/kenful/ruoyi-webflux-r2dbc-vue3">ruoyi-webflux-r2dbc-vue3</a></p><p>若依是一套全部开源的快速开发平台，毫无保留给个人及企业免费使用。</p><ul><li>这是 RuoYi WebFlux + R2DBC + Vue3 的实现。</li><li>前端技术栈: Vue3 + Element Plus + Vite 是分支于 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fyangzongzhuan%2FRuoYi-Vue3">https://github.com/yangzongzhuan/RuoYi-Vue3</a> (版本: 3.8.2)。</li><li>后端采用 Spring Boot、Spring Security、Redis &amp; Jwt。</li><li>后端采用 Spring Boot WebFlux、R2DBC、MyBatis、MyBatis-R2DBC、Mysql。</li><li>权限认证使用 Jwt，支持多终端认证系统。</li><li>支持加载动态权限菜单，多方式轻松权限控制。</li><li>高效率开发，使用代码生成器可以一键生成前后端代码。</li></ul><p>内置功能</p><ol><li>用户管理：用户是系统操作者，该功能主要完成系统用户配置。</li><li>部门管理：配置系统组织机构（公司、部门、小组），树结构展现支持数据权限。</li><li>岗位管理：配置系统用户所属担任职务。</li><li>菜单管理：配置系统菜单，操作权限，按钮权限标识等。</li><li>角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。</li><li>字典管理：对系统中经常使用的一些较为固定的数据进行维护。</li><li>参数管理：对系统动态配置常用参数。</li><li>通知公告：系统通知公告信息发布维护。</li><li>操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。</li><li>登录日志：系统登录日志记录查询包含登录异常。</li><li>在线用户：当前系统中活跃用户状态监控。</li><li>定时任务：在线（添加、修改、删除)任务调度包含执行结果日志。</li><li>代码生成：前后端代码的生成（java、html、xml、sql）支持 CRUD 下载 。</li><li>系统接口：根据业务代码自动生成相关的 api 接口文档。</li><li>服务监控：监视当前系统 CPU、内存、磁盘、堆栈等相关信息。</li><li>缓存监控：对系统的缓存信息查询，命令统计等。</li><li>在线构建器：拖动表单元素生成相应的 HTML 代码。</li><li>连接池监视：不支持此功能。</li></ol><h3 id="微服务"><a class="markdownIt-Anchor" href="#微服务"></a> 微服务</h3><p><a target="_blank" rel="noopener" href="https://www.vinsguru.com/spring-webclient-with-feign/">Reactive Feign</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%96%87%E7%AB%A0%E5%B7%B2%E8%BF%87%E6%97%B6/">#文章已过时</a></div></div><div class="license-box my-3"><div class="license-title"><div>响应式编程</div><div>https://wugengfeng.cn/2022/11/12/响应式编程/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年11月12日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" title="DDD领域驱动设计"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">DDD领域驱动设计</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/" title="分布式算法理论"><span class="hidden-mobile">分布式算法理论</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>