<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="思维导图  Java 基础  Java 语言有哪些特点  面向对象  封装  对象隐藏内部的属性和实现细节，对外部提供统一的访问方法   继承  子类继承父类的成员和方法，使子类也具有父类相同的行为   多态  对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系 重写 重载     跨平台  JVM虚拟机 字节码   可靠性  强类型检查 异常处理 内存管理   安全性  字节码校验 访问控"><meta property="og:type" content="article"><meta property="og:title" content="java源码"><meta property="og:url" content="https://wugengfeng.cn/2022/04/13/java%E6%BA%90%E7%A0%81/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="思维导图  Java 基础  Java 语言有哪些特点  面向对象  封装  对象隐藏内部的属性和实现细节，对外部提供统一的访问方法   继承  子类继承父类的成员和方法，使子类也具有父类相同的行为   多态  对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系 重写 重载     跨平台  JVM虚拟机 字节码   可靠性  强类型检查 异常处理 内存管理   安全性  字节码校验 访问控"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/java.png"><meta property="article:published_time" content="2022-04-13T14:55:40.000Z"><meta property="article:modified_time" content="2023-08-28T11:03:47.495Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/java.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>java源码 - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="java源码"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-04-13 22:55" pubdate>2022年4月13日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 91k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 755 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">java源码</h1><div class="markdown-body"><p><a target="_blank" rel="noopener" href="https://www.mubu.com/doc/1RSReD4EsbO">思维导图</a></p><h2 id="java-基础"><a class="markdownIt-Anchor" href="#java-基础"></a> Java 基础</h2><h3 id="java-语言有哪些特点"><a class="markdownIt-Anchor" href="#java-语言有哪些特点"></a> Java 语言有哪些特点</h3><ul><li>面向对象<ul><li>封装<ul><li>对象隐藏内部的属性和实现细节，对外部提供统一的访问方法</li></ul></li><li>继承<ul><li>子类继承父类的成员和方法，使子类也具有父类相同的行为</li></ul></li><li>多态<ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系</li><li>重写</li><li>重载</li></ul></li></ul></li><li>跨平台<ul><li>JVM虚拟机</li><li>字节码</li></ul></li><li>可靠性<ul><li>强类型检查</li><li>异常处理</li><li>内存管理</li></ul></li><li>安全性<ul><li>字节码校验</li><li>访问控制（public,private）</li><li>安全沙箱</li></ul></li></ul><h3 id="jdk-jre-jvm"><a class="markdownIt-Anchor" href="#jdk-jre-jvm"></a> JDK、 JRE、 JVM</h3><p class="note note-primary">JDK</p><p>java开发环境</p><ul><li>JRE Java运行环境</li><li>开发工具<ul><li>编译器</li><li>调试器</li></ul></li></ul><p class="note note-primary">JRE</p><p>java 运行环境</p><ul><li>包含java虚拟机</li><li>java类库和Java命令（javac）</li></ul><p class="note note-primary">JVM</p><p>java 虚拟机，用于运行java字节码</p><h3 id="字节码"><a class="markdownIt-Anchor" href="#字节码"></a> 字节码</h3><p><code>字节码</code>：通过 <code>javac</code> 命令编译后的 <code>.class</code> 文件就是字节码，字节码是介于<code>源码</code>和<code>机器码</code>之间的一种编码，面向JVM</p><p><code>好处</code>：</p><ul><li>java 是解释型语言，先把源码编译为字节码能够提高jvm的执行效率</li><li>字节码是跨平台的组成部分，面向jvm执行，jvm是跨平台实现的根本</li></ul><h3 id="java为什么不直接编译为机器码"><a class="markdownIt-Anchor" href="#java为什么不直接编译为机器码"></a> java为什么不直接编译为机器码</h3><p>和java的生态有关，java作为一种灵活的代码，得益于 CGLIB 和 ASM 动态字节码技术，如果全部编译为机器码就会失去这种灵活性</p><h3 id="编译与解释并存"><a class="markdownIt-Anchor" href="#编译与解释并存"></a> 编译与解释并存</h3><p><code>java源码</code> --javac–&gt; <code>字节码</code> --加载–&gt; <code>JVM</code> --解释–&gt; <code>机器码</code> --执行–&gt; <code>cpu</code></p><p><code>编译</code>：将java源码编译为JVM可执行的字节码（.class文件）</p><p><code>解释</code>：JVM加载字节码后一行行进行通过<code>Java解释器</code>解释成系统能够运行的机器码</p><h3 id="continue-break-和-return-的区别"><a class="markdownIt-Anchor" href="#continue-break-和-return-的区别"></a> continue、break 和 return 的区别</h3><ul><li><code>continue</code>：用于跳出本次循环进入下次循环</li><li><code>break</code> ：用于跳出整个循环体</li><li><code>return</code>：用于跳出所在方法</li></ul><h3 id="如何实现跨平台"><a class="markdownIt-Anchor" href="#如何实现跨平台"></a> 如何实现跨平台</h3><ol><li>将Java源码编译成字节码文件</li><li>使用Java虚拟机运行字节码文件</li><li>不同平台有不同的Java虚拟机实现</li></ol><h3 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h3><p>发生在同一个类中（或者父类和子类之间）</p><ul><li>方法名称相同</li><li>参数类型不同，个数不同，顺序不同，返回值和访问修饰符可以不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载 hello() 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello: &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h3><p>子类覆盖父类的方法，有重新的实现</p><p><code>两同两小一大</code></p><ul><li>方法名称相同，参数列表相同</li><li>子类方法返回值类型要小于等于父类方法返回值类型；子类方法声明抛出的异常要小于等于父类方法抛出的异常</li><li>子类方法的访问修饰符要大于等于父类方法的访问修饰符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> RuntimeException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td><td>-32768 ~ 32767</td></tr><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td><td>-2147483648 ~ 2147483647</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td><td>-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td><td>0 ~ 65535</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td><td>1.4E-45 ~ 3.4028235E38</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td><td>4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td><td>true、false</td></tr></tbody></table><p class="note note-primary">封装类型</p><ul><li><em>成员变量包装类型不赋值就是</em> <code>null</code> <em>，而基本类型有默认值且不是</em> <code>null</code></li><li><em>包装类型可用于泛型，而基本类型不可以</em></li><li><code>Byte</code><em>,</em><code>Short</code><em>,</em><code>Integer</code><em>,</em><code>Long</code> <em>这 4 种包装类默认创建了数值</em> <strong>[-128，127]</strong> <em>的相应类型的缓存数据</em></li></ul><p class="note note-primary">装箱、拆箱</p><ul><li><code>装箱</code>：<em>将基本类型用它们对应的引用类型包装起来</em>；</li><li><code>拆箱</code>：<em>将包装类型转换为基本数据类型</em>；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自动装箱,相当于 Integer a = Integer.valueOf(10)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 自动拆箱, 相当于 int b =  a.intValue()</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p><code>注意</code>：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作</p><p class="note note-primary">解决浮点精度丢失</p><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失，必须使用其<code>字符串类型</code>的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br></code></pre></td></tr></table></figure><p class="note note-primary">超过 long 整型的数据应该如何表示</p><p><code>BigInteger</code> <em>内部使用</em> <code>int[]</code> <em>数组来存储任意大小的整形数据</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">BigInteger a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(“<span class="hljs-number">23</span>”);<br>BigInteger b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(“<span class="hljs-number">34</span>”);<br>a. add(b);<br></code></pre></td></tr></table></figure><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低</p><p class="note note-primary">隐式转换（自动转换）</p><ul><li>数值型数据的转换：byte→short→int→long→float→double</li><li>字符型转换为整型：char→int</li><li>两种数据类型彼此兼容</li><li>低级类型数据转换成高级类型数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 类型自动转换为int，因为1是int</span><br><span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>) (a + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// += -= 存在类型自动转换</span><br><span class="hljs-type">short</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a += <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 数据溢出处理</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">900000</span> * <span class="hljs-number">100000</span>;<br><span class="hljs-comment">// 隐式转换转换为long</span><br><span class="hljs-type">long</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">900000</span> * <span class="hljs-number">100000L</span>;<br></code></pre></td></tr></table></figure><p class="note note-primary">显式转换（强制转换）</p><p>两种数据类型不兼容，高级类型向低级类型转换，自动转换将无法进行，这时就需要进行强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5.0</span>;<br>a = (<span class="hljs-type">int</span>)b;<br></code></pre></td></tr></table></figure><h3 id="对象的相等和引用相等的区别"><a class="markdownIt-Anchor" href="#对象的相等和引用相等的区别"></a> 对象的相等和引用相等的区别</h3><ul><li><em>对象的相等一般比较的是内存中存放的内容是否相等</em><ul><li>使用 <code>equals</code> 判断两个对象的内容是否相等</li></ul></li><li><em>引用相等一般比较的是他们指向的内存地址是否相等</em><ul><li>使用 <code>==</code> 判断两个变量是否指向同一个内存地址</li></ul></li></ul><h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3><ul><li>如果不声明构造方法，默认会生成一个无参的构造方法</li><li><em>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了</em></li><li>主要作用是完成对象的初始化工作，在对象被创建后执行</li></ul><p class="note note-primary">特点</p><ul><li>名字与类名相同</li><li>没有返回值，但不能用 void 声明构造函数</li><li>生成类的对象时自动执行，无需调用</li><li><em>构造方法不能被 override（重写）,但是可以 overload（重载）</em></li></ul><h3 id="接口和抽象类有什么共同点和区别"><a class="markdownIt-Anchor" href="#接口和抽象类有什么共同点和区别"></a> 接口和抽象类有什么共同点和区别</h3><p><code>相同</code></p><ul><li>都不能被实例化</li><li>都可以包含抽象方法</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）</li></ul><p><code>区别</code></p><ul><li>一个类只能继承一个类，但是可以实现多个接口</li><li>抽象类可以有构造方法，接口不可以</li><li>接口只能定义常量，抽象类可以定义变量</li></ul><h3 id="浅拷贝和深拷贝"><a class="markdownIt-Anchor" href="#浅拷贝和深拷贝"></a> 浅拷贝和深拷贝</h3><p class="note note-primary">浅拷贝</p><p><code>浅拷贝</code>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> (Test) <span class="hljs-built_in">super</span>.clone();<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">深拷贝</p><p><code>深拷贝</code> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-built_in">this</span>.getAge());<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        clone.setAge(age);<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>深拷贝可以使用序列化和反序列化实现</p><h3 id="object-方法"><a class="markdownIt-Anchor" href="#object-方法"></a> Object 方法</h3><p class="note note-primary">== 和 equals() 的区别</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址</li><li><code>类没有重写 equals()方法</code> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象</li><li><code>类重写了 equals()方法</code> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等</li></ul><p class="note note-primary">为什么重写 equals() 时必须重写 hashCode() 方法</p><p>java约定</p><ul><li>两个对象相等其hashCode必定相等</li><li>两个对象的hashCode相等对象不一定相等（hash冲突）</li></ul><p>hashCode被广泛应用于Java核心类库的集合类中（HashSet，HashMap）。为了维护哈希表的正常运作并维持对象的一致性，确保通过hashCode能够找到正确的对象（HashMap源码有体现，先判断HashCode，存在冲突再遍历对象使用equals方法找出正确对象），因此重写 equals() 时必须重写 hashCode() 方法</p><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><h4 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h4><p class="note note-primary">String不可变</p><p><code>String</code> 是不可变的 (每次变量拼接会生成新的对象，底层由StringBuilder#append实现)，线程不安全的</p><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p class="note note-primary">intern()</p><p>String.intern()方法设计的初衷就是：重用字符串对象，以便节省内存</p><p>JDK1.8, 先判断常量池中当前字符串是否存在</p><ul><li><code>如果不存在</code>：不会将当前字符串复制到常量池，而是将当前字符串的引用复制到常量池</li><li><code>如果存在</code>：不会改变常量池已经存在的引用，并直接返回常量池中字符串引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Ja&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;va&quot;</span>);<br>str1 == str2.intern(); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><code>思路分析</code>：两者分别是堆中的两个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ja&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;va&quot;</span>);<br>str1 == str2.intern(); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>思路分析</code>：String str1 = “java” 会将字符串分配到常量池，str2.intern()直接返回常量池的引用。因此它们属于常量池的同一个引用</p><p class="note note-primary">String 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;R&quot;</span>; <br>一共创建了几个对象<br></code></pre></td></tr></table></figure><p><code>思路分析</code>：&quot;R&quot;是一个字面量，会放在字符串常量池子中</p><ul><li>如果字符串常量池中已经存在“R“，那么创建0个对象，直接返回字符串常量池引用</li><li>如果字符串常量池不存在&quot;R&quot;，那么在常量池中创建1个对象</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;R&quot;</span>); <br>创建了几个对象<br></code></pre></td></tr></table></figure><p><code>思路分析</code>： new 关键字一定会在内存中创建一个对象，还要把字面量“R“提取出来分析</p><ul><li>如果字符串常量池中已经存在&quot;R&quot;，那么创建1个对象(堆中1个)</li><li>如果字符串常量池不存在“R“，那么在常量池中创建2个对象(字符串常量池1个，堆中1个)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;	<span class="hljs-comment">// 常量池没有则在常量池创建一个 Java 对象,有则返回字符串的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;	<span class="hljs-comment">// 直接返回常量池引用</span><br>为什么 str == str2  为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>思路分析</code>：java对于常量（字面量）会存储在字符串常量池中，str1第一次赋值时在常量池中添加了“Java“并返回其引用, str2第二次赋值直接引用字符串常量池。两个都是常量池 “Java” 的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ja&quot;</span> + <span class="hljs-string">&quot;va&quot;</span>;	<span class="hljs-comment">// 编译器对字面量优化 str2 = &quot;Java&quot;</span><br>为什么 str == str2  为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><code>思路分析</code>：参考上面，常量拼接还是常量(编译期优化)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br>为什么 str == str2  为<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><code>思路分析</code>：String str = “Java”; 内存存储区域在字符串常量池，new String(“Java”);内存存储区域在堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ja&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> str2 + <span class="hljs-string">&quot;va&quot;</span>;	<span class="hljs-comment">// 编译器无法优化变量拼接，底层用的是 StringBuilder</span><br>为什么 str1 == str3 为<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><code>思路分析</code>：因为两者属于不同对象，第一个对象在常量池中，第二个对象在堆中</p><p>str2 + “va”; 编译器无法对变量拼接优化。字符串拼接底层使用的是 StringBuilder#append，最终使用StringBuilder#toString方法返回String对象,对象在堆里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 创建一个新的String对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>拼接运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str6</span> <span class="hljs-operator">=</span> str1 + <span class="hljs-string">&quot;ing&quot;</span>;<br><br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br>System.out.println(str4.intern() == str6.intern()); <span class="hljs-comment">// true</span><br>System.out.println(str5 == str6); <span class="hljs-comment">// false</span><br>System.out.println(str4.intern() == str5); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="stringbuilder"><a class="markdownIt-Anchor" href="#stringbuilder"></a> StringBuilder</h4><p>当对字符串进行<code>修改</code>的时候，需要使用 StringBuffer 和 StringBuilder 类</p><p>因为 StringBuffer 和 StringBuilder 都是可变的，调用append 不会产生新的String对象</p><ul><li><p>线程不安全，性能最好</p></li><li><p>默认16个字节</p></li><li><p>扩容：2倍 + 2个字节</p></li></ul><p class="note note-primary">toString</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] value;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>toString 直接使用缓冲区 char数组</p><h4 id="stringbuffe"><a class="markdownIt-Anchor" href="#stringbuffe"></a> StringBuffe</h4><p>和StringBuilder一致，不同的是使用了 <code>Synchronized</code> 保证了线程安全，性能差于StringBuilder</p><ul><li><p>线程安全</p></li><li><p>默认16个字节</p></li><li><p>扩容：2倍 + 2个字节</p></li></ul><p class="note note-primary">toString</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-literal">null</span>) &#123;<br>   <span class="hljs-comment">// 并发场景，会先拷贝一次缓冲区</span><br>   toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(toStringCache, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E5%BC%82%E5%B8%B8.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">Throwable</p><p>所有的异常都有一个共同的祖先</p><p class="note note-primary">Exception 和 Error 有什么区别</p><ul><li><p><code>Exception</code> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)</p><ul><li><p><code>Checked Exception</code> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译</p><p>比如 <code>SQLException</code> <code>IOException</code></p></li><li><p><code>Unchecked Exception</code> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li></ul></li></ul></li><li><p><code>Error</code> ：属于程序无法处理的错误，例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>) 这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止</p></li></ul><p class="note note-primary">try-catch-finally 如何使用</p><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Try</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span> something<br><span class="hljs-keyword">Catch</span> Exception -&gt; RuntimeException<br><span class="hljs-keyword">Finally</span><br></code></pre></td></tr></table></figure><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值</p><p class="note note-primary">try具有缓存功能</p><p>在try语块中返回基本类型，会将return的值进行缓存，如果在finally语块修改返回值则不生效（基本类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            a = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            a = <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 返回值还是1</span><br></code></pre></td></tr></table></figure><p class="note note-primary">catch语块的多种用法</p><p>catch块可以捕获多种类型的异常，但是需要注意以下几点：</p><ol><li><p>异常的捕获顺序：在多个catch块中，应该将具体的异常类型放在前面，将父类异常放在后面。如果将父类异常放在前面，那么子类异常永远不会被捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 代码块</span><br>&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;<br>    <span class="hljs-comment">// 处理数组越界异常</span><br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e) &#123;<br>    <span class="hljs-comment">// 处理下标越界异常</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// 处理其他异常</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>同时处理多个异常类型：在一个catch块中，可以同时捕获多个异常类型，多个异常类型之间使用管道符号 <code>|</code> 分隔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 代码块</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException | SQLException e) &#123;<br>    <span class="hljs-comment">// 处理IO异常和SQL异常</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p class="note note-primary">finally 中的代码一定会执行吗</p><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="java-spi"><a class="markdownIt-Anchor" href="#java-spi"></a> Java SPI</h3><p><a href="/2022/07/13/dubbo3/#java-spi">SPI详解</a></p><p>SPI 全称为 Service Provider Interface（接口服务提供者），它是一种服务发现机制。<span class="green-line">SPI的本质是将接口的实现类配置在文件中，并由服务加载器读取配置文件，进行加载和实例化。</span></p><p>SPI机制的设计初衷是为了解决接口的扩展性问题。在传统的编程模型中，接口的实现类通常是由开发者手动指定或硬编码在代码中的。这种方式存在一个问题，即当需要替换或新增接口的实现类时，必须修改源代码并重新编译、部署应用程序。这种修改源代码的方式增加了耦合性，同时也不够灵活。</p><p>而SPI机制通过将接口的实现类配置在文件中，并由服务加载器动态加载，可以<span class="green-line">实现在不修改源代码的情况下，替换或新增接口的实现类</span>。这样就提高了系统的扩展性和灵活性。</p><p>具体来说，SPI机制的使用步骤如下：</p><ol><li><p>定义接口：首先需要定义一个接口，接口定义了一组方法或规范，表示一种功能或服务的抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现接口：根据接口的定义，编写实现类来实现接口中的方法，提供具体的功能实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Doing something...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建配置文件：在resources/META-INF/services目录下创建一个以接口的全限定名命名的文件，文件内容为接口实现类的全限定名，每行一个。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.example.MyServiceImpl<br></code></pre></td></tr></table></figure></li><li><p>加载实现类：通过服务加载器(ServiceLoader)加载配置文件中的实现类，并进行实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;MyService&gt; serviceLoader = ServiceLoader.load(MyService.class); <span class="hljs-comment">// ServiceLoader 是一个可迭代对象，可以加在1-N个服务</span><br></code></pre></td></tr></table></figure></li><li><p>使用服务：通过服务加载器获取已加载的实现类的实例，并调用其方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (MyService service : serviceLoader) &#123;<br>    service.doSomething();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3><p><code>序列化</code> ：将对象转为字节流的过程，让对象能够保存在本地文件或者在网络中传输</p><p><code>反序列化</code> ：将字节流转回Java对象的过程，根据字节流的信息将流数据转成一个Java对象的过程</p><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/serialization.html#hessian">序列化详解</a></p><p class="note note-primary">Serializable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br> <span class="hljs-keyword">private</span> Integer id; <br> <span class="hljs-keyword">private</span> String title;  <span class="hljs-comment">//文章标题</span><br> <span class="hljs-keyword">private</span> String content;  <span class="hljs-comment">// 文章内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">Externlizable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExternalizableDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Externalizable</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br> <span class="hljs-keyword">private</span> String name;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeExternal</span><span class="hljs-params">(ObjectOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     out.writeUTF(name);<br>     out.writeInt(number);<br> &#125;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readExternal</span><span class="hljs-params">(ObjectInput in)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>     <span class="hljs-built_in">this</span>.name = in.readUTF();<br>     <span class="hljs-built_in">this</span>.number = in.readInt();<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">异同</p><ol><li>序列化内容，Externalizable自定义序列化可以控制序列化的过程和决定哪些属性不被序列化</li><li>Serializable反序列化时不会调用默认的构造器，而Externalizable反序列化时会调用默认构造器的</li><li>使用Externalizable时，<span class="green-line">必须按照写入时的确切顺序读取所有字段状态</span>。否则会产生异常。例如，如果更改ExternalizableDemo类中的number和name属性的读取顺序，则将抛出java.io.EOFException。而Serializable接口没有这个要求</li></ol><p class="note note-primary">transient修饰符</p><p>transient修饰符用于类属性、变量。表示该类的序列化过程用transient修饰该变量，可避免该变量被序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String password;<br></code></pre></td></tr></table></figure><h3 id="为什么-java-中只有值传递"><a class="markdownIt-Anchor" href="#为什么-java-中只有值传递"></a> 为什么 Java 中只有值传递</h3><p><code>基本类型</code>：传递的是实际值的拷贝</p><p><code>引用类型</code>： 传递的是内存地址值的拷贝</p><h3 id="比较器"><a class="markdownIt-Anchor" href="#比较器"></a> 比较器</h3><p class="note note-primary">Comparable 内部比较器</p><p>类继承 <code>Comparable</code> 接口并且实现 <code>compareTo</code> 方法就可以使用 <code>Collections.sort</code> 进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span><br> <span class="hljs-meta">@ToString</span><br> <span class="hljs-meta">@AllArgsConstructor</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;User&gt; &#123;<br><br>     <span class="hljs-keyword">private</span> String name;<br>     <span class="hljs-keyword">private</span> Integer age;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(User o)</span> &#123;<br>         <span class="hljs-comment">// 倒叙</span><br>         <span class="hljs-keyword">return</span> o.getAge() - <span class="hljs-built_in">this</span>.getAge();<br>         <span class="hljs-comment">// 正序</span><br>         <span class="hljs-comment">//return this.getAge() - o.getAge();</span><br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     List&lt;User&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-1&quot;</span>, <span class="hljs-number">12</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-2&quot;</span>, <span class="hljs-number">15</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-3&quot;</span>, <span class="hljs-number">18</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-4&quot;</span>, <span class="hljs-number">14</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-5&quot;</span>, <span class="hljs-number">13</span>));<br><br>     <span class="hljs-comment">// 使用内部比较器排序</span><br>     Collections.sort(userList);<br><span class="hljs-comment">//        userList.forEach(System.out::println);</span><br><span class="hljs-comment">//        OrderService.User(name=test-3, age=18)</span><br><span class="hljs-comment">//        OrderService.User(name=test-2, age=15)</span><br><span class="hljs-comment">//        OrderService.User(name=test-4, age=14)</span><br><span class="hljs-comment">//        OrderService.User(name=test-5, age=13)</span><br><span class="hljs-comment">//        OrderService.User(name=test-1, age=12)</span><br> &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">外部比较器 Comparator</p><p>如果类没有实现 <code>Comparable</code> 接口又要进行排序可使用外部比较器 <code>Comparator</code> 外部比较器重写 <code>compare</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span><br> <span class="hljs-meta">@ToString</span><br> <span class="hljs-meta">@AllArgsConstructor</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>     <span class="hljs-keyword">private</span> String name;<br>     <span class="hljs-keyword">private</span> Integer age;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     List&lt;User&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-1&quot;</span>, <span class="hljs-number">12</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-2&quot;</span>, <span class="hljs-number">15</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-3&quot;</span>, <span class="hljs-number">18</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-4&quot;</span>, <span class="hljs-number">14</span>));<br>     userList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;test-5&quot;</span>, <span class="hljs-number">13</span>));<br><br>     <span class="hljs-comment">// 类内有实现Comparable 但又需要进行排序, 使用外部比较器</span><br>     Comparator&lt;User&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User o1, User o2)</span> &#123;<br>             <span class="hljs-keyword">return</span> o2.getAge() - o1.getAge();<br>             <span class="hljs-comment">// 正序</span><br>             <span class="hljs-comment">//return o1.getAge() - o2.getAge();</span><br>         &#125;<br>     &#125;;<br><br>     <span class="hljs-comment">// 排序</span><br>     Collections.sort(userList, comparator);<br><br>     userList.forEach(System.out::println);<br><span class="hljs-comment">//        OrderService.User(name=test-3, age=18)</span><br><span class="hljs-comment">//        OrderService.User(name=test-2, age=15)</span><br><span class="hljs-comment">//        OrderService.User(name=test-4, age=14)</span><br><span class="hljs-comment">//        OrderService.User(name=test-5, age=13)</span><br><span class="hljs-comment">//        OrderService.User(name=test-1, age=12)</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h3><ul><li><code>静态内部类</code>：不需要依赖外部类的实例而实例化</li><li><code>静态代码块</code>：类初始化时执行</li><li><code>静态方法</code>：使用类名调用</li><li><code>静态变量</code>：类变量分配到方法区</li></ul><h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h1><h3 id="类型擦除"><a class="markdownIt-Anchor" href="#类型擦除"></a> 类型擦除</h3><p>泛型信息只存在于代码编译阶段，但是在java的运行期(已经生成字节码文件后)与泛型相关的信息会被擦除掉，专业术语叫做<code>类型擦除</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; l1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(); <br>ArrayList&lt;String&gt; l2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>System.out.println(l1.getClass()==l2.getClass()); <br><span class="hljs-comment">//运行代码，结果为True</span><br></code></pre></td></tr></table></figure><p>这是因为 <code>ArrayList&lt;String&gt;</code> 和 <code>ArrayList&lt;Integer&gt;</code> 在 jvm 中的 Class 都是 List.class，二者在 jvm 中等同于 <code>List&lt;Object&gt;</code>，所有的泛型在编译后都会变成Object</p><p><span class="green-line">Java的泛型其实是伪泛型，因为编译后都会进行类型擦除，它的作用就是在编码阶段对使用的类型作限制</span></p><h3 id="泛型上下限"><a class="markdownIt-Anchor" href="#泛型上下限"></a> 泛型上下限</h3><p class="note note-primary">无边界擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br><br>List&lt;?&gt; list2 = list;<br><br><span class="hljs-comment">// 获得类型为Object</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 编译不通过</span><br>list2.add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><ul><li>相当于 <code>List&lt;? extends Object&gt;</code>，知道父类是Object</li><li>可以get获取值，返回的是Object</li><li>不清楚使用的是哪种具体类型，因此不能写入数据</li></ul><p class="note note-primary">上界通配</p><ul><li><p><code>&lt;? extends 父类类型&gt;</code></p></li><li><p>可以确定父类型，所以返回的数据是父类型（向上转型）</p></li><li><p>不能写入数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Animal&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());<br><br>List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; list2 = list;<br><span class="hljs-comment">// 返回的是父类型（向上转型）</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 不能写数据，编译不通过</span><br>list2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br></code></pre></td></tr></table></figure><p class="note note-primary">下界通配</p><ul><li><code>&lt;? super 子类类型&gt;</code></li><li>可以确定子类类型，但不确定其有多少父类，所以返回Object</li><li>由于知道子类，所以可以写入父类对象（向上转型是安全的）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Animal&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br><br>List&lt;? <span class="hljs-built_in">super</span> Cat&gt; list2 = list;<br><span class="hljs-comment">// 只知道子类，所以返回的是Object</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 能写数据</span><br>list2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());<br></code></pre></td></tr></table></figure><h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt></p><h2 id="fail-fast机制"><a class="markdownIt-Anchor" href="#fail-fast机制"></a> fail-fast机制</h2><p><span class="green-line">多线程环境保证集合安全性和一致性的错误机制</span></p><p><code>fail-fast</code>(快速失败)机制是java集合(Collection)中的一种错误机制</p><p>当多个线程对同一个集合的内容进行操作时，就可能产生<code>fail-fast</code>事件</p><p>例如：线程A通过Iterator迭代器去遍历某个集合的过程中，如果集合对象的内容被其他线程进行了修改（增加，删除，修改），则会抛出<code>java.util.ConcurrentModificationException</code>异常，产生 <code>fail-fast</code>事件</p><p><code>java.util</code>包下的集合都是快速失败的，不能在多线程并发修改</p><h2 id="fail-safe机制"><a class="markdownIt-Anchor" href="#fail-safe机制"></a> fail-safe机制</h2><p><code>fail-safe</code>(安全失败)机制在遍历时不是在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历，因此它不会抛出<code>java.util.ConcurrentModificationException</code>异常</p><p><code>juc</code>包下的集合都是<code>fail-safe</code>安全失败的，可以在多线程并发下使用，并发修改</p><h2 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h2><h3 id="iterator"><a class="markdownIt-Anchor" href="#iterator"></a> Iterator</h3><ul><li>支持 <code>fail-fast</code> 机制，更加安全</li><li>Iterator是JDK1.2添加的接口，Collection 集合类使用</li><li>速度比Enumeration慢</li><li>允许从集合中移除元素（从循环中删除元素）</li></ul><h3 id="enumeration"><a class="markdownIt-Anchor" href="#enumeration"></a> Enumeration</h3><ul><li>不支持 <code>fail-fast</code> 机制</li><li>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，已过时</li><li>速度比Iterator快</li><li>基础的实现，不支持移除元素</li></ul><h2 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h2><ul><li>提供排序 <code>sort</code> 方法，传入 <code>Comparator</code></li><li>List转Array：调用<code>toArray</code>方法</li><li>Array转List：new ArrayList(Arrays.asList(array))</li><li>List遍历：<code>普通 for</code>，<code>增强 for</code>，<code>迭代器</code>，<code>Stream.foreach</code></li></ul><p class="note note-primary">Arrays.asList</p><ul><li>它的add/remove/clear方法会抛出UnsupportedOperationException()</li><li>返回的是 <code>Arrays.ArrayList</code> 内部类</li><li>要正常使用必须使用 new ArrayList() 包裹</li></ul><h3 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/ArrayList.jpg" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>数据结构</code>：Object[]</li><li><code>初始容量</code>：<strong>10</strong></li><li><code>最大容量</code>：Integer.MAX_VALUE - 8</li><li><code>扩容倍数</code>：<code>oldCapacity + (oldCapacity &gt;&gt; 1) 原容量 + （原容量/2)</code> 1.5倍</li><li><code>扩容实现</code>：<code>System.arraycopy()</code> 数组复制</li><li><code>非线程安全</code></li><li><code>支持随机访问</code></li><li><code>存空间占用</code>：扩容后数组元素可能没有完全利用</li><li><code>特点</code>：数据检索快，数据插入、删除慢（需要移动数组元素）</li></ul><h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h3><ul><li><p><code>数据结构</code>：Object[]</p></li><li><p><code>初始容量</code>：10</p></li><li><p><code>最大容量</code>：Integer.MAX_VALUE - 8</p></li><li><p><code>扩容倍数</code>：<font color="red">2</font></p></li><li><p><code>支持随机访问</code></p></li><li><p><strong>历史遗留的集合类，已经不推荐使用</strong></p></li><li><p><code>线程安全</code>：可以看作线程安全的ArrayList</p></li><li><p><code>线程安全保证</code>：方法使用<code>synchronized</code>修饰</p></li><li><p><code>性能比ArrayList差</code></p></li><li><p>线程安全推荐使用 JUC的 <code>CopyOnWriteArrayList</code></p></li></ul><h3 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/LinkedList.jpg" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>数据结构</code>：<strong>双向链表，节点保存两个指针，前驱和后继</strong></li><li><code>最大容量</code>：理论上没有，取决于内存大小</li><li><code>头节点不存放数据</code>，允许元素为null</li><li><code>不支持随机访问</code>（链表不允许）</li><li><code>内存空间占用</code>：维护额外的前驱后继指针</li><li><code>特点</code>：数据插入删除快，数据检索效率不高</li></ul><h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h2><h3 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/hashMap.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>数据结构：数组 + 单向链表 + 红黑树(hash冲突严重用于优化查询性能)</li><li>负载因子：0.75</li><li>初始容量：16</li><li>扩容条件：当前数组大小 &gt; 当前数组大小 * 0.75 (默认12)</li><li>扩容倍数：<strong>2</strong></li><li>扩容过程：</li><li>不必将所有Key都重新计算一次hash</li><li>将key的hash与数组长度做高位与运算（2n-1），结果为0位置不变，为1位置变为<code>当前下标 + 扩容步长 比如（7 + 16）</code></li><li>链表转红黑树：数组大小&gt;= 64, 链表长度&gt;=8</li><li>红黑树退化链表：链表长度&lt;=6</li><li>允许一个key为null</li><li>非线程安全</li><li>数据添加无序</li><li>put：<code>(n-1) &amp; hash,计算出数组下标位置获取链表进行添加</code>, (n为数组长度，hash为key的hash)</li><li>get: <code>(n-1) &amp; hash，计算素组下标位置获取链表进行遍历，先判断hash是否相等，相等则判断key</code></li><li>JDK1.8的变化：<ul><li>链表和红黑树转换</li><li>hash碰撞，1.7会在链表头部插入；1.8会在链表尾部插入</li><li>Entry被Node替代</li></ul></li></ul><h3 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h3><ul><li>方法使用Synchronized修改，线程安全</li><li>初始容量：<strong>11</strong></li><li>扩容倍数：<strong>2n + 1</strong></li><li><strong>key,value都不能为null</strong></li><li><strong>不支持链表和红黑树互转</strong></li><li>考虑线程安全使用ConcurrentHashMap Node锁效率更高</li></ul><h3 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/LinkedHashMap.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>特点</code>：<strong>保证插入顺序</strong>，使用双向链表保证</li><li><code>数据结构</code>：数组加双向链表（前驱后继保证插入顺序）</li><li>使用<code>before</code>,<code>after</code>指针保证插入顺序</li></ul><p>HashMap的Entry是一个单向链表，用于解决Hash冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>       <span class="hljs-keyword">final</span> K key;<br>       V value;<br>       Node&lt;K,V&gt; next;<br>       ...<br></code></pre></td></tr></table></figure><p>LinkedHashMap的Entry继承HashMap的Node, Entry是一个双向链表，用于保证插入顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;<br>      Entry&lt;K,V&gt; before, after;<br>      Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>          <span class="hljs-built_in">super</span>(hash, key, value, next);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> TreeMap</h3><ul><li>数据结构：红黑树</li><li>实现key的自然排序</li><li>可以在构造函数指定<strong>Comparator</strong>比较器对key排序</li></ul><h3 id="weakhashmap"><a class="markdownIt-Anchor" href="#weakhashmap"></a> WeakHashMap</h3><p><a href="/2022/03/29/jvm/#java%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BC%95%E7%94%A8">Java存在的引用</a></p><ul><li>WeakHashMap：一个weak key的Map</li><li>它能让Map释放其所持有的对象</li><li>如果某个对象除了在Map当中充当键之外 ,在其他地方都没有引用的话，那它将被当作垃圾回收</li><li>使用场景：二三级缓存</li><li>也存在内存溢出可能</li><li>GC回收时进行回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * WeakHashMap：一个weak key的Map，</span><br><span class="hljs-comment"> * 是为某些特殊问题而设计的。它能让Map释放其所持有的对象。</span><br><span class="hljs-comment"> * 如果某个对象除了在Map当中充当键之外，</span><br><span class="hljs-comment"> * 在其他地方都没有引用的话，那它将被当作垃圾回收。</span><br><span class="hljs-comment"> * 使用场景：二三级缓存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakHashMapTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WeakHashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            map.put(i, i);<br>        &#125;<br>        System.out.println(map.size());<br><br>        System.gc();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        System.out.println(map.size());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 1000</span><br><span class="hljs-comment"> * 128</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="identityhashmap"><a class="markdownIt-Anchor" href="#identityhashmap"></a> IdentityHashMap</h3><ul><li>HashMap判断key是否相等是根据<code>k1.hashcode==k2.hashcode &amp;&amp; k1.equals(k2)</code></li><li>IdentityHashMap是只判断内存地址是否相等 <code>k1=k2</code>,换而言之就是同个Class的不同对象都可以存放在map里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 不会判断key的hashcode是否相等，只判断了key的内存地址是否相等</span><br>    IdentityHashMap&lt;Integer, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<br>    map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>);<br>    System.out.println(map);<br>    <br>    <span class="hljs-comment">// 输出</span><br>    <span class="hljs-comment">// &#123;1=2, 1=1&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h2><h3 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h3><p>底层采用HashMap实现，value为空</p><h3 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> LinkedHashSet</h3><p>底层采用LinkedHashMap实现，value为空</p><h3 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> TreeSet</h3><p>底层采用TreeMap实现，value为空</p><h3 id="priorityqueue"><a class="markdownIt-Anchor" href="#priorityqueue"></a> PriorityQueue</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c577796e537a">优先级队列使用</a></p><ul><li><code>优先级队列</code></li><li><code>数据结构</code>：利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>初始容量</code>：11</li><li><code>扩容倍数</code>：1.5</li><li>其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队</li><li>构造器允许传入 <code>Comparator</code> 实现自定义优先级</li><li>是<code>非线程安全</code>的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象</li><li>默认是<code>小顶堆</code>，但可以接收一个 <code>Comparator</code> 作为构造参数</li></ul><h3 id="arraydeque"><a class="markdownIt-Anchor" href="#arraydeque"></a> ArrayDeque</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenglc/p/10722304.html">双端队列使用</a></p><ul><li><p><code>双端队列</code>，支持两边进两边出</p></li><li><p><code>数据结构</code>：可变长数组加双指针（头，尾）</p></li><li><p><code>扩容倍数</code>：2</p></li><li><p><code>初始容量</code>：16</p></li><li><p>不允许数据为null（因为需要比较）</p></li><li><p><code>先进先出</code></p><ul><li>addFirst() 方法 配合pollLast() 方法</li><li>addLast() 方法 配合 pollFirst()方法</li></ul></li><li><p><code>先进后出</code>（栈）</p><ul><li>addFirst() 方法配合 pollFirst()方法</li><li>addLast()方法配合pollLast()方法</li></ul></li></ul><h1 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h1><ul><li><p>Compare and Swap（比较并交换），是一种<code>无锁</code> <code>原子</code>算法，也是一条CPU的原子指令 <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/MESI%E5%8D%8F%E8%AE%AE">MESI协议</a></p></li><li><p>Atomic 内部使用了 <code>volatile</code> 保证了自身的可见性</p></li><li><p>CAS涉及到三个属性</p><ul><li>内存读写位置</li><li>旧值</li><li>需要写入的新值</li></ul><p>CAS具体执行时，当内存中的值等于传入的旧值，就将内存值修改为新值，否则不替换</p></li><li><p><code>Unsafe</code>是CAS的核心类，Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门：Unsafe，它提供了硬件级别的原子操作，<code>一条汇编指令完成数据比较和交换保证了其原子性</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * ac: 需要写入的内存位置</span><br><span class="hljs-comment">        * 第一个参数：预期值</span><br><span class="hljs-comment">        * 第二个参数：修改值</span><br><span class="hljs-comment">        */</span><br>       ac.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>       System.out.println(ac.get());  <span class="hljs-comment">// 1</span><br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="aba"><a class="markdownIt-Anchor" href="#aba"></a> ABA</h2><ul><li>如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题</li><li>对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A</li></ul><h3 id="aba解决"><a class="markdownIt-Anchor" href="#aba解决"></a> ABA解决</h3><p class="note note-primary">AtomicMarkableReference</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicMarkableReferenceTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用boolean 值做版本戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;Integer&gt; mark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br><br>                    <span class="hljs-keyword">if</span> (first.getAndSet(<span class="hljs-literal">false</span>)) &#123;<br>                        <span class="hljs-comment">// CAS需要版本号</span><br>                        mark.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 版本戳不一致，CAS不会成功</span><br>                        mark.compareAndSet(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>                    &#125;<br><br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        System.out.println(mark.getReference());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出10</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p class="note note-primary">AtomicStampedReference</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据一个版本戳解决ABA问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicStampedReferenceTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置版本戳为1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (first.getAndSet(<span class="hljs-literal">false</span>)) &#123;<br>                    <span class="hljs-comment">// 增加 2 个参数 一个是期望版本戳 一个是新版本戳</span><br>                    ref.compareAndSet(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 版本戳不一直， CAS失败</span><br>                    ref.compareAndSet(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        System.out.println(ref.getReference());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出 100</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="atomicboolean"><a class="markdownIt-Anchor" href="#atomicboolean"></a> AtomicBoolean</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicBoolean.html">API文档</a></p><ul><li>需要注意的方法 <code>public final void set(boolean newValue);</code> 无条件设置值，不保证原子性</li><li><code>public final void lazySet(boolean newValue);</code>懒设置值，不会像set一样马上将值刷到主内存中，但最终还是会刷新到主内存，非原子</li><li><code>public boolean weakCompareAndSet(boolean expect,boolean update)；</code>在正常情况下weak版本比<code>compareAndSet</code> 更高效，但是不同的是任何给定的<code>weakCompareAndSet</code>方法的调用都可能会返回一个虚假的失败( 无任何明显的原因 )。一个失败的返回意味着，操作将会重新执行如果需要的话</li></ul><h2 id="atomicinteger"><a class="markdownIt-Anchor" href="#atomicinteger"></a> AtomicInteger</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicInteger.html">API文档</a></p><ul><li><p><code>public final int getAndUpdate(IntUnaryOperator updateFunction)；</code>实现<code>IntUnaryOperator</code> 接口的<code>applyAsInt</code> 可以实现复杂的原子性算法</p></li><li><p><code>getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)；</code>给指定值x,和实现<code>IntBinaryOperator</code>函数式接口实现当前值和给定值x的运算结果，最终通过cas重新设置新值</p></li></ul><h2 id="atomicintegerarray"><a class="markdownIt-Anchor" href="#atomicintegerarray"></a> AtomicIntegerArray</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicIntegerArray.html">API文档</a></p><ul><li><code>public final int getAndUpdate(int i,IntUnaryOperator updateFunction);</code> 和AtomicInteger的类似，只是多了个下标</li><li><code>public final int getAndAccumulate(int i,int x,IntBinaryOperator accumulatorFunction)；</code>和AtomicInteger的类似，只是多了个下标</li><li>初始化 new AtomicIntegerArray(new int[]{1, 2});</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerArrayTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">// 第一个参数是数组下标</span><br>                <span class="hljs-comment">// 第二个参数是指定值</span><br>                <span class="hljs-comment">// 第三个参数是一个函数式接口，根据数组下标当前值和执行值运算返回的新值</span><br>                <span class="hljs-comment">// 最后将计算出来的新值设置到对应的数组下标中</span><br>                <span class="hljs-keyword">while</span> (array.accumulateAndGet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (x, y) -&gt; x + y) &lt; <span class="hljs-number">10</span>) &#123;<br>                &#125;<br>            &#125;).start();<br><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (array.accumulateAndGet(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, (x, y) -&gt; x + y) &lt; <span class="hljs-number">10</span>) &#123;<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        System.out.println(array.get(<span class="hljs-number">0</span>));<br>        System.out.println(array.get(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 19</span><br><span class="hljs-comment"> * 19</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 分析，第一个线程累加1-10，在这累加的过程中其他9条线程也在进行cas操作，最后执行完成</span><br><span class="hljs-comment"> * 第一个线程的执行结果为10</span><br><span class="hljs-comment"> * 第二个线程cas执行结果后为 11</span><br><span class="hljs-comment"> * ...</span><br><span class="hljs-comment"> * 第十个线程cas执行结果后为 19</span><br><span class="hljs-comment"> * 原因是 array.accumulateAndGet(0, 1, (x, y) -&gt; x + y) &lt; 10 这个判断不是一个原子操作，在</span><br><span class="hljs-comment"> * 多线程并发不能保证数据的准确性</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="atomicintegerfieldupdater"><a class="markdownIt-Anchor" href="#atomicintegerfieldupdater"></a> AtomicIntegerFieldUpdater</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html">API文档</a></p><ul><li>主要对对象里的 <code>public</code> <code>volatile</code> <code>int</code> 变量进行原子性操作，其API和AtomicInteger一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerFieldUpdaterTest</span> &#123;<br><br>    <span class="hljs-comment">// 通过反射创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicIntegerFieldUpdater&lt;Test&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test.class, <span class="hljs-string">&quot;num&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                    fieldUpdater.incrementAndGet(test);<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        System.out.println(test.num);<br>        System.out.println(test.getStr());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 100</span><br><span class="hljs-comment"> * null</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 一定要使用 volatile 保证其他线程的可见性</span><br>    <span class="hljs-comment">// 一定要使用public保证外界只直接访问</span><br>    <span class="hljs-comment">// 必须为int类型，Integer封装类型也不允许</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-keyword">private</span> String str;<br><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStr</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStr</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">this</span>.str = str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="atomiclong"><a class="markdownIt-Anchor" href="#atomiclong"></a> AtomicLong</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicLong.html">API文档</a></p><p>和AtomicInteger使用一致，累加建议使用 LongAdder</p><h2 id="atomiclongarray"><a class="markdownIt-Anchor" href="#atomiclongarray"></a> AtomicLongArray</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicLongArray.html">API文档</a></p><p>和AtomicIntegerArray 使用一致</p><h2 id="atomicreference"><a class="markdownIt-Anchor" href="#atomicreference"></a> AtomicReference</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicReference.html">API文档</a></p><ul><li>在低并发情况下可以得到正确的结果,但是高并发情况下就会出现差异.因为自定义的对象在访问时用的是<code>set</code>,<code>get</code>没有<code>CAS</code>,所以导致线程不安全.</li><li><code>atomic</code>包中提供<code>AtomicReferenceFieldUpdater</code>、<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>，原子性的更新某一个类实例的指定的某一个字段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保证对象的原子性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReference&lt;Simple&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Simple</span>(<span class="hljs-number">20</span>, <span class="hljs-string">&quot;&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;<br>                    ref.compareAndSet(ref.get(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Simple</span>(ref.get().getAge() + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>));<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        System.out.println(ref.get().getAge());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 不一定输出 10020</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Simple</span><span class="hljs-params">(<span class="hljs-type">int</span> age, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="atomicreferencefieldupdater"><a class="markdownIt-Anchor" href="#atomicreferencefieldupdater"></a> AtomicReferenceFieldUpdater</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html#compareAndSet-T-V-V-">API文档</a></p><p><code>AtomicReferenceFieldUpdater</code> 是基于反射的工具类，用来将指定类型的指定的<code>volatile</code>引用字段进行原子更新，对应的原子引用字段不能是<code>private</code>的。通常一个类<code>volatile</code>成员属性获取值、设定为某个值两个操作时非原子的，若想将其变为原子的，则可通过<code>AtomicReferenceFieldUpdater</code>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicReferenceFieldUpdater&lt;Simple, Integer&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Simple.class, Integer.class, <span class="hljs-string">&quot;age&quot;</span>);<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-type">Simple</span> <span class="hljs-variable">simple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Simple</span>(<span class="hljs-number">20</span>, <span class="hljs-string">&quot;&quot;</span>);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++) &#123;<br>                 <span class="hljs-comment">// 自旋修改</span><br>                 <span class="hljs-keyword">while</span> (!updater.compareAndSet(simple, simple.getAge(),simple.getAge() + <span class="hljs-number">1</span>));<br>                 <span class="hljs-comment">// 存在ABA问题， 最终不等于 10020, 原因是simple.getAge()只保证可见性，不保证原子性,多个线程会读到同一个值</span><br>                 <span class="hljs-comment">// 如果要修改的值不依赖于 simple.getAge() 则可以直接使用 updater.getAndSet</span><br>                 <span class="hljs-comment">//Integer temp1 = simple.getAge();</span><br>                 <span class="hljs-comment">//Integer temp2 = updater.getAndSet(simple, simple.getAge() + 1);</span><br>                 <span class="hljs-comment">//if (temp1 &gt;= temp2) &#123;</span><br>                 <span class="hljs-comment">//    System.out.println(&quot;ABA&quot;);</span><br>                 <span class="hljs-comment">//    System.out.println(&quot;temp1=&quot; + temp1);</span><br>                 <span class="hljs-comment">//    System.out.println(&quot;temp2=&quot; + temp2);</span><br>                 <span class="hljs-comment">//&#125;</span><br>             &#125;<br>         &#125;).start();<br>     &#125;<br><br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>     System.out.println(simple.getAge());<br> &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Simple</span><span class="hljs-params">(Integer age, String name)</span> &#123;<br>     <span class="hljs-built_in">this</span>.age = age;<br>     <span class="hljs-built_in">this</span>.name = name;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> Integer age;<br> <span class="hljs-keyword">private</span> String name;<br><br> <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> age;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>     <span class="hljs-built_in">this</span>.age = age;<br> &#125;<br><br> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">return</span> name;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>     <span class="hljs-built_in">this</span>.name = name;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="longadder"><a class="markdownIt-Anchor" href="#longadder"></a> LongAdder</h2><p>JDK1.8新增一个原子性操作类LongAdder，用于代替AtomicLong的功能，因为在非常高并发的请求下，AtomicLong的性能是一个很大的瓶颈，因为AtomicLong采用的CAS算法失败后还是通过无限循环的自旋锁不断的尝试</p><p>为了解决这个问题，JDK的开发组就创建了LongAdder，性能要高于AtomicLong很多</p><p><code>缺点</code>：在统计的时候，如果有并发更新，可能会导致统计数据有些误差</p><p class="note note-primary">实现</p><p>LongAdder内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// 底层使用cell数组，每个数组元素都是一个原子资源，高并发只要获得其中一个元素后进行自增即可</span><br><span class="hljs-comment">// 调用get时，返回的是所有cell数组的累加值</span><br><span class="hljs-comment">// 缺点：数值存在偏差</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>       Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;<br>       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>               (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>               !(uncontended = a.cas(v = a.value, v + x)))<br>               longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Equivalent to &#123;<span class="hljs-doctag">@code</span> add(1)&#125;.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>       add(<span class="hljs-number">1L</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="juc"><a class="markdownIt-Anchor" href="#juc"></a> JUC</h1><h2 id="非阻塞"><a class="markdownIt-Anchor" href="#非阻塞"></a> 非阻塞</h2><h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h3><p>单端队列</p><h4 id="concurrentlinkedqueue"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue"></a> ConcurrentLinkedQueue</h4><ul><li><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/ConcurrentLinkedQueue.html">API文档 基于链接节点的无界线程安全queue</a></li><li>FIFO，先进先出</li><li>数据结构：单向链表</li><li>采用cas算法保证线程安全，底层时Unsafe</li><li>元素不能为空（cas）</li><li>add过程<ul><li>如果链表为空，将当前节点通过CAS设置为链表的 head 和 tail</li><li>如果链表不为空，则通过CAS将当前节点追加到链表尾部</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于链接节点的无界线程安全queue 。 这个队列排列元素FIFO（先进先出），</span><br><span class="hljs-comment"> * 像大多数其他并发集合实现一样，此类不允许使用null元素,否则会空指针异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentLinkedQueueTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentLinkedQueue&lt;Integer&gt; query = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">50</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MICROSECONDS.sleep(num);<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s 生产产品编号：%s&quot;</span>, Thread.currentThread().getName(), num));<br>                    query.add(num);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-comment">// 队列为空则返回null</span><br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> query.poll();<br>                <span class="hljs-keyword">if</span> (Objects.nonNull(num)) &#123;<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s 消费产品编号：%s&quot;</span>, Thread.currentThread().getName(), num));<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：1</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：36</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：1</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：36</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：39</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：39</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：34</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：34</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：36</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：36</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：49</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：49</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：32</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：32</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：28</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：28</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：27</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：27</span><br><span class="hljs-comment"> * Thread-0 生产产品编号：13</span><br><span class="hljs-comment"> * Thread-1 消费产品编号：13</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="list-2"><a class="markdownIt-Anchor" href="#list-2"></a> List</h3><p>线程安全的List</p><h4 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> CopyOnWriteArrayList</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CopyOnWriteArrayList.html">API文档 一个线程安全的变体ArrayList ，其中所有可变操作（ add ， get ，等等）通过对底层数组的最新副本实现</a></p><ul><li>底层数据结构采用Object[]</li><li>实现 List 接口</li><li>使用和ArrayList类似</li><li><code>线程安全</code>：使用 <code>ReentrantLock</code> 保证</li><li>CopyOnWrite 简称 <code>COW</code>，<span style="border-bottom:2px dashed green">先复制再写入，就是在添加元素的时候，先把原List列表复制一份，再添加新的元素，添加元素时，先枷锁，再进行复制替换操作，最后释放锁</span></li><li>适合<code>读多写少</code>场景，写操作代价昂贵</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>  	<span class="hljs-comment">// 加锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>      	<span class="hljs-comment">// 复制副本</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>      	<span class="hljs-comment">// 数组替换</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">// get 不加锁</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>      <span class="hljs-keyword">return</span> get(getArray(), index);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="set-2"><a class="markdownIt-Anchor" href="#set-2"></a> Set</h3><h4 id="单端"><a class="markdownIt-Anchor" href="#单端"></a> 单端</h4><p>线程安全的Set</p><h5 id="copyonwritearrayset"><a class="markdownIt-Anchor" href="#copyonwritearrayset"></a> CopyOnWriteArraySet</h5><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CopyOnWriteArraySet.html">API文档</a></p><ul><li>线程安全的 <code>Set</code></li><li>底层数据：<a href="#copyonwritearraylist">CopyOnWriteArrayList</a>，Object[]</li><li><code>ReentrantLock</code> 保证线程安全</li><li><code>去重</code>：每次插入先遍历元素是否存在</li></ul><h4 id="双端"><a class="markdownIt-Anchor" href="#双端"></a> 双端</h4><h5 id="concurrentskiplistset"><a class="markdownIt-Anchor" href="#concurrentskiplistset"></a> ConcurrentSkipListSet</h5><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/ConcurrentSkipListSet.html">API文档</a></p><ul><li>key有序：可以当作线程安全的 <code>TreeSet</code></li><li>提供获取第一个或最后一个元素的能力</li><li>底层数据结构：<a href="#concurrentskiplistmap">ConcurrentSkipListMap</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>       <span class="hljs-keyword">return</span> al.addIfAbsent(e);<br>   &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addIfAbsent</span><span class="hljs-params">(E e)</span> &#123;<br>       Object[] snapshot = getArray();<br>       <span class="hljs-keyword">return</span> indexOf(e, snapshot, <span class="hljs-number">0</span>, snapshot.length) &gt;= <span class="hljs-number">0</span> ? <span class="hljs-literal">false</span> :<br>       	<span class="hljs-comment">// 加锁新增</span><br>           addIfAbsent(e, snapshot);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="map-2"><a class="markdownIt-Anchor" href="#map-2"></a> Map</h3><h4 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/ConcurrentHashMap.html">API文档</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/java-source-code/edit/master/-/java/util/concurrent/ConcurrentHashMap.java">在线源码</a></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/ConcurrentHashMap.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>线程安全，<strong>使用Node锁替换分段锁</strong></p><ul><li>如果链表为空采用cas设置链表头</li><li>否则使用synchronized锁住整个桶</li></ul></li><li><p>放弃分段锁: 分段锁会锁几条链表（数组的几个元素），锁粒度太大，不能很好支持并发</p></li><li><p>支持链表和红黑树互转</p></li><li><p>懒加载，Map创建不会初始化，当put第一个值才会初始化 initTable()</p></li><li><p>sizeCtl</p><ul><li>-1：正在初始化</li><li>-n：正在扩容</li><li>n：下次扩容的阈值</li></ul></li><li><p>扩容时机</p><ul><li>桶数量 &gt;= 数组长度 * 0.75</li></ul></li><li><p>扩容</p><ul><li><p>ForwardingNode</p><ul><li>转义节点</li><li>存放 nextTable 新扩容的Tab</li><li>转义节点Key的 hash = -1</li><li>完成扩容的旧桶放置转义节点，这样做时为了在扩容期间其他线程调用get转义节点能跳转到新Tab获取数据</li></ul></li><li><p>多线程协助扩容</p><ul><li>当调用Put方法定位桶，桶是一个转义节点时协助扩容</li><li>每个协助扩容线程最少负责16个桶</li><li>流程<ul><li>在老的Tab里分配最少16个要扩容的桶</li><li>如果老桶为空，在老Tab插入一个转义节点，用于告诉其他线程当前在扩容</li><li>如果当前是转义节点说明这个桶已经完成扩容，跳过</li><li>如果老桶不为空也不是转义节点，开始扩容<ul><li>对当前桶加锁</li><li>便利链表，进行高位与运算</li><li>在先Tab里分裂为2个链表</li><li>扩容完成，当前桶设置为转义节点</li></ul></li></ul></li></ul></li><li><p>扩容时get</p><ul><li>get不需要加锁</li><li>如果桶不为空，直接加锁链表后遍历i获取数据</li><li>如果为转义节点，则通过转义节点去新的Tab获取数据</li><li>如果桶正在扩容，那么它被其他线程加锁，则等待</li></ul></li></ul></li><li><p>进化红黑树</p><ul><li>hash值为-2，说明当前hash位置下挂的是红黑树</li><li>数组长度&gt;=64</li></ul></li><li><p>链表长度大于8</p></li><li><p>退化红黑树</p><ul><li>红黑树节点数量 &lt;= 6</li></ul></li><li><p>K,V 不能为空</p></li><li><p>计数器优化，思路和 LongAdder 类似，底层采用 CountCell[]</p></li><li><p>HASH_BITS</p><ul><li>第一位是0， 01111111…</li><li>保证运算出来的hash一定是个正数，负数在Map中有特殊含义</li></ul></li></ul><p class="note note-primary">分段锁</p><p>ReentrantLook + N个桶</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E5%88%86%E6%AE%B5%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">Node锁</p><p>JDK1.8放弃分段锁的原因是因为粒度太大，影响并发性能</p><p>node锁</p><ul><li>如果是链表第一个元素，则采用cas算法</li><li>否则就锁链表的第一个node节点 synchroinzed</li></ul><p class="note note-primary">扩容场景</p><ul><li>hash冲突严重，链表节点数超过8，此时先判断数组是否超过64，没有超过就先扩容，超过就转红黑树</li><li>putAll方法，放入一个长度大于本身的Map</li><li>put方法，数组长度超过扩容的阈值</li></ul><h4 id="concurrentskiplistmap"><a class="markdownIt-Anchor" href="#concurrentskiplistmap"></a> ConcurrentSkipListMap</h4><ul><li>1、ConcurrentSkipListMap 的key是有序的。</li><li>2、构造函数支持 <code>Comparator</code>比较器自定义实现key排序</li><li>3、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log（N），和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。</li></ul><h3 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> Deque</h3><p>双端队列</p><h4 id="concurrentlinkeddeque"><a class="markdownIt-Anchor" href="#concurrentlinkeddeque"></a> ConcurrentLinkedDeque</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/ConcurrentLinkedDeque.html">API文档 基于链表实现的无界双端队列</a></p><ul><li>双端对列可以做 <code>FIFO</code>对列，也可以做<code>栈</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于链接节点的无界并发deque 。 并发插入，删除和访问操作可以跨多个线程安全执行</span><br><span class="hljs-comment"> * 像大多数其他并发集合实现一样，此类不允许使用null元素</span><br><span class="hljs-comment"> * 迭代器和分配器是weakly consistent</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentLinkedDequeTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConcurrentLinkedDeque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedDeque</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                deque.add(i);<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 队列头部消费线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">100</span>);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(stop);<br>                    <span class="hljs-comment">// 获取队列头部元素</span><br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> deque.pollFirst();<br>                    <span class="hljs-keyword">if</span> (Objects.nonNull(num)) &#123;<br>                        System.out.println(String.format(<span class="hljs-string">&quot;头部线程消费元素：%d&quot;</span>, num));<br>                        count++;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br><br>        <span class="hljs-comment">// 队列尾部消费线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">100</span>);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(stop);<br>                    <span class="hljs-comment">// 获取队列尾部元素</span><br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> deque.pollLast();<br>                    <span class="hljs-keyword">if</span> (Objects.nonNull(num)) &#123;<br>                        System.out.println(String.format(<span class="hljs-string">&quot;尾部线程消费元素：%d&quot;</span>, num));<br>                        count++;<br>                    &#125;<br><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 尾部线程消费元素：9</span><br><span class="hljs-comment"> * 头部线程消费元素：0</span><br><span class="hljs-comment"> * 头部线程消费元素：1</span><br><span class="hljs-comment"> * 头部线程消费元素：2</span><br><span class="hljs-comment"> * 头部线程消费元素：3</span><br><span class="hljs-comment"> * 尾部线程消费元素：8</span><br><span class="hljs-comment"> * 尾部线程消费元素：7</span><br><span class="hljs-comment"> * 头部线程消费元素：4</span><br><span class="hljs-comment"> * 尾部线程消费元素：6</span><br><span class="hljs-comment"> * 尾部线程消费元素：5</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="阻塞"><a class="markdownIt-Anchor" href="#阻塞"></a> 阻塞</h2><p><code>put</code>: 队列满了阻塞</p><p><code>take</code>: 队列空了阻塞</p><h3 id="queue-2"><a class="markdownIt-Anchor" href="#queue-2"></a> Queue</h3><h4 id="arrayblockingqueue"><a class="markdownIt-Anchor" href="#arrayblockingqueue"></a> ArrayBlockingQueue</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/ArrayBlockingQueue.html">API文档 由数组创建的有界的单端对列</a></p><ul><li><p>有界队列</p></li><li><p>底层数据类型：Object[]</p></li><li><p>采用<code>ReentrantLock</code>保证多线程安全</p></li><li><p>FIFO</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一个有限的blocking queue由数组支持。 这个队列排列元素FIFO（先进先出）</span><br><span class="hljs-comment"> * 底层采用的数据结构是数组，所以在初始化时需要指定长度,创建后，容量无法更改</span><br><span class="hljs-comment"> * 尝试put成满的队列的元件将导致在操作阻挡;</span><br><span class="hljs-comment"> * 尝试take从空队列的元件将类似地阻塞。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueueTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 用add 队列满了会抛出异常</span><br>                    queue.put(i);<br>                    System.out.println(String.format(<span class="hljs-string">&quot;生产线程生产元素：%d&quot;</span>, i));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-comment">// 底层采用ReentrantLock实现线程安全</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 队列为空会阻塞</span><br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(String.format(<span class="hljs-string">&quot;消费线程消费元素：%d&quot;</span>, num));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 生产线程生产元素：0</span><br><span class="hljs-comment"> * 生产线程生产元素：1</span><br><span class="hljs-comment"> * 消费线程消费元素：0</span><br><span class="hljs-comment"> * 生产线程生产元素：2</span><br><span class="hljs-comment"> * 生产线程生产元素：3</span><br><span class="hljs-comment"> * 消费线程消费元素：1</span><br><span class="hljs-comment"> * 消费线程消费元素：2</span><br><span class="hljs-comment"> * 生产线程生产元素：4</span><br><span class="hljs-comment"> * 生产线程生产元素：5</span><br><span class="hljs-comment"> * 消费线程消费元素：3</span><br><span class="hljs-comment"> * 生产线程生产元素：6</span><br><span class="hljs-comment"> * 消费线程消费元素：4</span><br><span class="hljs-comment"> * 消费线程消费元素：5</span><br><span class="hljs-comment"> * 生产线程生产元素：7</span><br><span class="hljs-comment"> * 生产线程生产元素：8</span><br><span class="hljs-comment"> * 消费线程消费元素：6</span><br><span class="hljs-comment"> * 消费线程消费元素：7</span><br><span class="hljs-comment"> * 生产线程生产元素：9</span><br><span class="hljs-comment"> * 消费线程消费元素：8</span><br><span class="hljs-comment"> * 消费线程消费元素：9</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 对列满了则阻塞</span><br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await();<br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 对列空了阻塞</span><br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="linkedblockingqueue"><a class="markdownIt-Anchor" href="#linkedblockingqueue"></a> LinkedBlockingQueue</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/LinkedBlockingQueue.html">API文档 基于链表实现的有界阻塞的单端对列</a></p><p>采用<code>ReentrantLock</code>保证多线程安全</p><p>底层数据结构：单向链表</p><p>FIFO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于链接节点的可选限定的blocking queue 。 这个队列排列元素FIFO（先进先出）</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * LinkedBlockingQueue()</span><br><span class="hljs-comment"> * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE 。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * LinkedBlockingQueue(Collection&lt;? extends E&gt; c)</span><br><span class="hljs-comment"> * 创建一个 LinkedBlockingQueue ，容量为 Integer.MAX_VALUE ，最初包含给定集合的元素，以集合的迭代器的遍历顺序添加。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * LinkedBlockingQueue(int capacity)</span><br><span class="hljs-comment"> * 创建一个具有给定（固定）容量的 LinkedBlockingQueue 。</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 队列满了继续往队列添加元素则阻塞，队列空继续往队列获取元素则阻塞</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueueTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedBlockingQueue&lt;Integer&gt; query = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生产线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 队列满了则阻塞</span><br>                    query.put(i);<br>                    System.out.println(String.format(<span class="hljs-string">&quot;生产线程生成元素：%d&quot;</span>, i));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 消费线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-comment">// 队列为空则阻塞</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> query.take();<br>                    System.out.println(String.format(<span class="hljs-string">&quot;消费线程消费元素：%d&quot;</span>, num));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>       Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.putLock;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>       putLock.lockInterruptibly();<br>       <span class="hljs-keyword">try</span> &#123;<br><br>           <span class="hljs-keyword">while</span> (count.get() == capacity) &#123;<br>               notFull.await();<br>           &#125;<br>           enqueue(node);<br>           c = count.getAndIncrement();<br>           <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; capacity)<br>               notFull.signal();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           putLock.unlock();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>           signalNotEmpty();<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    E x;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.takeLock;<br>    takeLock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count.get() == <span class="hljs-number">0</span>) &#123;<br>            notEmpty.await();<br>        &#125;<br>        x = dequeue();<br>        c = count.getAndDecrement();<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">1</span>)<br>            notEmpty.signal();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        takeLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c == capacity)<br>        signalNotFull();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="priorityblockingqueue"><a class="markdownIt-Anchor" href="#priorityblockingqueue"></a> PriorityBlockingQueue</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/PriorityBlockingQueue.html">API文档 无边界具有优先级的阻塞队列</a></p><ul><li>具有优先级的队列，可根据<code>Comparator</code>自定义优先级排序</li><li>采用ReentrantLock保证多线程安全</li><li>底层数据结构：Object[]</li><li>优先级队列可用于实现<code>大顶堆</code>和<code>小顶堆</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无边界具有优先级的阻塞队列</span><br><span class="hljs-comment"> * 元素加入队列会根据自实现的Comparator比较器自动排序实现优先级</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityBlockingQueueTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 实现正序比较器，按照年龄排序</span><br>        Comparator&lt;User&gt; comparator = (User u1, User u2) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (u1 == u2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge();<br>        &#125;;<br><br>        <span class="hljs-comment">// 设置初始长度和比较器</span><br>        PriorityBlockingQueue&lt;User&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>(<span class="hljs-number">2</span>, comparator);<br><br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">50</span>);<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(String.valueOf(num), num);<br>                queue.add(user);<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    user = queue.take();<br>                    System.out.println(String.format(<span class="hljs-string">&quot;消费元素：%s&quot;</span>, user));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;2&#x27;, age=2&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;6&#x27;, age=6&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;15&#x27;, age=15&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;17&#x27;, age=17&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;21&#x27;, age=21&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;22&#x27;, age=22&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;23&#x27;, age=23&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;32&#x27;, age=32&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;34&#x27;, age=34&#125;</span><br><span class="hljs-comment"> * 消费元素：User&#123;name=&#x27;45&#x27;, age=45&#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="delayqueue"><a class="markdownIt-Anchor" href="#delayqueue"></a> DelayQueue</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/DelayQueue.html">API文档 具有延迟效果的单端队列，只有元素过期才能被获取</a></p><ul><li>延迟队列，延迟时间到达才能释放元素</li><li>底层数据结构：<code>PriorityQueue</code>（优先级队列）</li><li><code>ReentrantLock</code> 实现线程安全</li><li>元素要实现 <code>Delayed</code> 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * delayQueue 延迟队列</span><br><span class="hljs-comment"> * DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，</span><br><span class="hljs-comment"> * 其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象</span><br><span class="hljs-comment"> * 的延迟到期时间最长。注意：不能将null元素放置到这种队列中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueueTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DelayQueue&lt;Order&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生产者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(i, System.currentTimeMillis() + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span> * <span class="hljs-number">5</span>));<br>                queue.put(order);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 消费者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(String.format(<span class="hljs-string">&quot;释放订单：%s&quot;</span>, order));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>    <span class="hljs-comment">// 超时时间为20秒</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIME_OUT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> orderId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> payTime;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(<span class="hljs-type">int</span> orderId, <span class="hljs-type">long</span> payTime)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderId = orderId;<br>        <span class="hljs-built_in">this</span>.payTime = payTime;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrderId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> orderId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderId</span><span class="hljs-params">(<span class="hljs-type">int</span> orderId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderId = orderId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getPayTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> payTime;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPayTime</span><span class="hljs-params">(<span class="hljs-type">long</span> payTime)</span> &#123;<br>        <span class="hljs-built_in">this</span>.payTime = payTime;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来判断是否到了截止时间</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> payTime + TIME_OUT - System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 排序,这个方法很重要,根据下单时间正序排序，保证队列头部一定是最需要释放的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> (Order) o;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.getPayTime() - order.getPayTime());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Order&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;orderId=&quot;</span> + orderId +<br>                <span class="hljs-string">&quot;, payTime=&quot;</span> + payTime +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=0, payTime=1595155223599&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=1, payTime=1595155223901&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=2, payTime=1595155224201&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=3, payTime=1595155224501&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=4, payTime=1595155224801&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=5, payTime=1595155225102&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=6, payTime=1595155225402&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=7, payTime=1595155225702&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=8, payTime=1595155226002&#125;</span><br><span class="hljs-comment"> * 释放订单：Order&#123;orderId=9, payTime=1595155226303&#125;</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="synchronousqueue"><a class="markdownIt-Anchor" href="#synchronousqueue"></a> SynchronousQueue</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/SynchronousQueue.html">API文档 具有单个元素容量的阻塞队列</a></p><ul><li>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素</li><li>底层数据结构：<code>单向链表</code>或<code>栈</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。</span><br><span class="hljs-comment"> * 如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞</span><br><span class="hljs-comment"> * 直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列</span><br><span class="hljs-comment"> * 中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronousQueueTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SynchronousQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 生产队列</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 用add会抛队列满异常</span><br>                    queue.put(i);<br>                    System.out.println(String.format(<span class="hljs-string">&quot;生产线程生产元素：%d&quot;</span>, i));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 消费线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(String.format(<span class="hljs-string">&quot;消费线程消费元素：%d&quot;</span>, num));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * 生产线程生产元素：0</span><br><span class="hljs-comment"> * 消费线程消费元素：0</span><br><span class="hljs-comment"> * 消费线程消费元素：1</span><br><span class="hljs-comment"> * 生产线程生产元素：1</span><br><span class="hljs-comment"> * 生产线程生产元素：2</span><br><span class="hljs-comment"> * 消费线程消费元素：2</span><br><span class="hljs-comment"> * 消费线程消费元素：3</span><br><span class="hljs-comment"> * 生产线程生产元素：3</span><br><span class="hljs-comment"> * 生产线程生产元素：4</span><br><span class="hljs-comment"> * 消费线程消费元素：4</span><br><span class="hljs-comment"> * 消费线程消费元素：5</span><br><span class="hljs-comment"> * 生产线程生产元素：5</span><br><span class="hljs-comment"> * 消费线程消费元素：6</span><br><span class="hljs-comment"> * 生产线程生产元素：6</span><br><span class="hljs-comment"> * 消费线程消费元素：7</span><br><span class="hljs-comment"> * 生产线程生产元素：7</span><br><span class="hljs-comment"> * 消费线程消费元素：8</span><br><span class="hljs-comment"> * 生产线程生产元素：8</span><br><span class="hljs-comment"> * 消费线程消费元素：9</span><br><span class="hljs-comment"> * 生产线程生产元素：9</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="linkedtransferqueue"><a class="markdownIt-Anchor" href="#linkedtransferqueue"></a> LinkedTransferQueue</h4><p>LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。我们称这种节点操作为“匹配”方式</p><h3 id="deque-2"><a class="markdownIt-Anchor" href="#deque-2"></a> Deque</h3><h4 id="linkedblockingdeque"><a class="markdownIt-Anchor" href="#linkedblockingdeque"></a> LinkedBlockingDeque</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/LinkedBlockingDeque.html">API文档</a></p><ul><li>可以做 先进先出的队列，也可以做先进后出的栈</li><li>数据结构：双向链表</li><li>默认容量：Integer.MAX_VALUE</li><li><code>ReentrantLock</code> 保证线程安全</li></ul><h2 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h2><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/AbstractQueuedSynchronizer.html">API文档</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/java-source-code/edit/master/-/java/util/concurrent/locks/AbstractQueuedSynchronizer.java">在线源码</a></p><p>什么是AQS?</p><p>AQS指的是Java中的<code>AbstractQueuedSynchronizer</code>类，翻译过来的意思就是<code>抽象队列同步器</code>，<span style="border-bottom:2px dashed green">它是Java并发用来构建锁和其他同步组件的基础框架，它的核心是一个<code>双端队列</code>，<code>cas算法</code>和<code>一个使用volatile修改的int类型的共享变量state</code>, 当state为0时，表示可以申请锁，为1时表示其他线程获得锁 <span></span></span></p><p>锁的模式：共享锁，排他锁</p><p><code>加锁过程</code>：使用cas算法将state修改为1，并设置同步器的线程归属</p><p><code>未获得锁线程</code>：被封装为一个node节点，并加入等待队列然后调用LockSupport.park挂起线程</p><p><code>解锁过程</code>：将state修改为0，将同步器的线程归属置空，唤醒队列后继节点获取锁</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/aqs.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">为什么AQS是从后往前唤醒节点的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 唤醒节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 丛队列尾部向前开始查找第一个需要唤醒的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加节点，node是当前节点</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//将当前节点追加到队列尾部</span><br>            <span class="hljs-comment">//将新节点的前驱指向上一个节点;AQS节点从后往前遍历就是因为先赋值了prev指针，如果从前往后在高并发情况会发生next指针来不及指向而漏掉后面节点的扫描</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<span class="hljs-comment">//cas设置队尾节点</span><br>                t.next = node;<span class="hljs-comment">//将上一节点的后继指向当前节点</span><br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因是AQS在添加节点的时候，如果队列存在节点</p><ul><li>先将插入节点的 <code>prev</code> 指针指向队列尾部节点</li><li>然后CAS将插入节点替换为队列的 <code>tail</code></li><li>将原 tail 节点的 <code>next</code> 指针指向当前节点</li></ul><p>由此可知 <code>prev</code> 指针比 <code>next</code> 指针有更高的赋值优先级，并发情况下，如果节点从前往后扫描，如果此时新增节点来没来得及对上一个节点的 <code>next</code> 指针赋值，AQS可能出现后继节点漏扫描情况</p><h3 id="reentrantlock"><a class="markdownIt-Anchor" href="#reentrantlock"></a> ReentrantLock</h3><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/ReentrantLock.html">API文档</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/java-source-code/edit/master/-/java/util/concurrent/locks/ReentrantLock.java">在线源码</a></p><p>可重入锁：<code>每次重入 AQS 的 state + 1</code></p><p>底层实现：在<code>AQS</code>基础上构建</p><ul><li>锁模式<ul><li>公平锁</li><li>非公平锁（默认）</li></ul></li></ul><p><code>JUC</code>包下很多同步机制都使用<code>ReentrantLock</code>实现，比如阻塞队列，<code>CopyOnWriteArrayList</code>等</p><p class="note note-primary">可重入</p><p>可重入是如果当前线程获得了锁，那么在获得锁的情况下继续调用lock方法获得锁不会进行阻塞</p><p><span style="border-bottom:2px dashed green">调用了多少次<code>lock</code>方法就必须调用多少次<code>unlock</code>方法，因为每次调用<code>lock</code>方法时，<code>state</code>值都会+1，只有<code>state = 0</code> 才是无锁状态</span></p><p class="note note-primary">公平锁</p><ul><li><code>tryAcquire</code> 尝试获取锁</li><li>公平锁调用<code>lock</code>方法时会调用<code>tryAcquire</code>方法尝试获取锁</li><li>如果state = 0，尝试获取锁</li><li>如果队列存在节点，则排队</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>       sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>   &#125;<br><br><span class="hljs-comment">// 传入 fair 获取公平或非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>       sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>   &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">非公平锁</p><ul><li><code>nonfairTryAcquire</code> 尝试获取锁</li><li>非公平锁调用<code>lock</code>时会通过cas先尝试是否能获取锁，不能才调用<code>nonfairTryAcquire</code>方法<ul><li>排队前插队，再次尝试通过cas将 state由0修改为1，尝试获取锁</li><li>获取不到则排队</li></ul></li></ul><p class="note note-primary">用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            log.info(<span class="hljs-string">&quot;Thread = &#123;&#125;, &#123;&#125;&quot;</span>, Thread.currentThread().getName(), a++);<br>            lock.unlock();<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="reentrantlockcondition"><a class="markdownIt-Anchor" href="#reentrantlockcondition"></a> ReentrantLock.Condition</h4><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/Condition.html">API文档</a></p><p><span style="border-bottom:2px dashed green"><code>Condition</code>是一个多线程间协调通信的工具类</span>，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被带调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁</p><p>作用：有条件地 <code>唤醒线程</code> <code>休眠线程</code></p><ul><li>Condition.await() 让线程休眠，并自动释放Condition关联的锁</li><li>Condition.signal() 唤醒休眠线程，如果线程能够恢复，则说明当前线程获得Condition关联的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 锁</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br> <span class="hljs-comment">// 读条件</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br> <span class="hljs-comment">// 写条件</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">write</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br> <span class="hljs-comment">// 读写索引，数组元素总量</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> putIdx, takeIdx, count;<br><br><br> <span class="hljs-comment">// 写操作</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-comment">// 获取锁</span><br>     lock.lock();<br>     <span class="hljs-keyword">try</span> &#123;<br>         TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>         <span class="hljs-keyword">while</span> (count == arr.length) &#123;<br>             <span class="hljs-comment">// 数组满了，等待</span><br>             write.await();<br>         &#125;<br><br>         arr[putIdx] = obj;<br>         log.info(<span class="hljs-string">&quot;生产者生产了：&#123;&#125;&quot;</span>, obj);<br>         <span class="hljs-comment">// 如果数组写到最后一个元素后则索引复位</span><br>         <span class="hljs-keyword">if</span> (++putIdx == arr.length) &#123;<br>             putIdx = <span class="hljs-number">0</span>;<br>         &#125;<br>         count++;<br>         <span class="hljs-comment">// 唤醒读取线程</span><br>         read.signal();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>     &#125;<br> &#125;<br><br><br> <span class="hljs-comment">// 读操作</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-comment">// 获取锁</span><br>     lock.lock();<br>     <span class="hljs-keyword">try</span> &#123;<br>         TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">200</span>);<br>         <span class="hljs-comment">// 数组为空</span><br>         <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>             read.await();<br>         &#125;<br><br>         <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> arr[takeIdx];<br><br>         <span class="hljs-comment">// 读取到最后一个元素则复位</span><br>         <span class="hljs-keyword">if</span> (++takeIdx == arr.length) &#123;<br>             takeIdx = <span class="hljs-number">0</span>;<br>         &#125;<br><br>         count--;<br>         <span class="hljs-comment">// 唤醒写线程</span><br>         write.signal();<br>         log.info(<span class="hljs-string">&quot;消费者消费了：&#123;&#125;&quot;</span>, result);<br>         <span class="hljs-keyword">return</span> result;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>             <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                     put(System.currentTimeMillis());<br>                 &#125;<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                 e.printStackTrace();<br>             &#125;<br>         &#125;).start();<br>     &#125;<br><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                 take();<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>     &#125;).start();<br><br>     Thread.currentThread().join();<br> &#125;<br><br><span class="hljs-comment">//    01:04:49.824 [Thread-0] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706289722</span><br><span class="hljs-comment">//    01:04:49.929 [Thread-0] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706289829</span><br><span class="hljs-comment">//    01:04:50.029 [Thread-0] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706289929</span><br><span class="hljs-comment">//    01:04:50.129 [Thread-0] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706290029</span><br><span class="hljs-comment">//    01:04:50.229 [Thread-0] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706290129</span><br><span class="hljs-comment">//    01:04:50.329 [Thread-1] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706289722</span><br><span class="hljs-comment">//    01:04:50.429 [Thread-1] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706290329</span><br><span class="hljs-comment">//    01:04:50.529 [Thread-1] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706290429</span><br><span class="hljs-comment">//    01:04:50.629 [Thread-1] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706290529</span><br><span class="hljs-comment">//    01:04:50.729 [Thread-1] INFO com.macro.mall.controller.MinioController - 生产者生产了：1661706290629</span><br><span class="hljs-comment">//    01:04:51.029 [Thread-2] INFO com.macro.mall.controller.MinioController - 消费者消费了：1661706289722</span><br><span class="hljs-comment">//    01:04:51.229 [Thread-2] INFO com.macro.mall.controller.MinioController - 消费者消费了：1661706289829</span><br><span class="hljs-comment">//    01:04:51.429 [Thread-2] INFO com.macro.mall.controller.MinioController - 消费者消费了：1661706289929</span><br></code></pre></td></tr></table></figure><h3 id="reentrantreadwritelock"><a class="markdownIt-Anchor" href="#reentrantreadwritelock"></a> ReentrantReadWriteLock</h3><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/ReentrantReadWriteLock.html">ReentrantReadWriteLock API文档</a></p><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html">ReentrantReadWriteLock.ReadLock API文档</a></p><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html">ReentrantReadWriteLock.WriteLock API文档</a></p><p><span style="border-bottom:2px dashed green">适合读多写少场景</span></p><p>读写锁底层有两把锁，<code>ReadLock</code>和<code>WriteLock</code>。读写锁之间是互斥的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">rwlock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">rlock</span> <span class="hljs-operator">=</span> rwlock.readLock();<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">wlock</span> <span class="hljs-operator">=</span> rwlock.writeLock();<br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>     wlock.lock(); <span class="hljs-comment">// 加写锁</span><br>     <span class="hljs-keyword">try</span> &#123;<br>         counts[index] += <span class="hljs-number">1</span>;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         wlock.unlock(); <span class="hljs-comment">// 释放写锁</span><br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] get() &#123;<br>     rlock.lock(); <span class="hljs-comment">// 加读锁</span><br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">return</span> Arrays.copyOf(counts, counts.length);<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         rlock.unlock(); <span class="hljs-comment">// 释放读锁</span><br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>共享锁（读锁）</strong></p><p>多个线程可以获得同一把锁，不阻塞，但是数据不能修改 (不能写是代码上规范的，共享锁不是真的不让写数据)</p><p><strong>排他锁（写锁）</strong></p><p>多只能一个线程获得锁，其他线程阻塞</p><p><strong>读写互斥</strong></p><p><span style="border-bottom:2px dashed green">当获得共享锁时，需要获得排他锁就必须等待共享锁释放，反之亦然</span></p><p class="note note-primary">底层实现</p><p><code>ReentrantReadWriteLock</code> 还是基于 <code>AQS</code> 实现的，还是对state进行操作，拿到锁资源就去干活，如果没有拿到，依然去AQS队列中排队</p><ul><li><p>将 <code>AQS</code> 中 int (32位)类型的 <code>state</code> 变量标记为读锁或写锁</p></li><li><p><code>读锁操作</code>：基于state的高16位进行操作</p></li><li><p><code>写锁操作</code>：基于state的低16为进行操作</p></li><li><p>ReentrantReadWriteLock依然是可重入锁</p></li></ul><p><code>写锁重入</code>：和 ReentrantLock一致，依然是对 state 进行 +1 操作，只不过范围变小了（低16位）</p><p><code>读锁重入</code>：因为读锁是共享锁。读锁在获取锁资源操作时，是要对state的高16位进行 + 1操作。因为读锁是共享锁，所以同一时间会有多个读线程持有读锁资源。这样一来，多个读操作在持有读锁时，无法确认每个线程读锁重入的次数（多个线程操作 state）。为了去记录读锁重入的次数，每个读操作的线程，都会有一个 <code>ThreadLocal</code> 记录锁重入的次数，当 <code>ThreadLocal</code> 的重入次数为0则释放读锁</p><p><code>写锁的饥饿问题</code>：读锁是共享锁，当有线程持有读锁资源时，再来一个线程想要获取读锁，直接对state修改即可。在读锁资源先被占用后，来了一个写锁资源，然后，大量的需要获取读锁的线程来请求锁资源，如果可以绕过写锁，直接拿资源，会造成写锁长时间无法获取到写锁资源</p><p><span class="green-line">读锁在拿到锁资源后，如果再有读线程需要获取读锁资源，需要去AQS队列排队。如果队列的前面需要写锁资源的线程，那么后续读线程是无法拿到锁资源的。持有读锁的线程，只会让写锁线程之前的读线程拿到锁资源</span></p><h3 id="stampedlock"><a class="markdownIt-Anchor" href="#stampedlock"></a> StampedLock</h3><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309138673991714">参考 廖雪峰文章</a></p><p><span style="border-bottom:2px dashed green"><code>StampedLock</code>是对读写锁的一种优化，先通过获取乐观锁后获取数据，然后再进行版本号验证</span>。如果版本号验证通过则说明获取的数据是安全的，否则申请悲观锁重新获取数据，是<code>乐观锁</code>和<code>悲观锁</code>结合的解决方案，能够有效提高并发（不支持锁的重入）。非常适合在读多写少的场景下使用。底层使用Unsafe的内存屏障保证数据读写的一致性</p><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁</p><p>先获取乐观锁，在读写冲突时，读取数据先获取乐观锁，然后再通过乐观锁版本号判断读取的数据是否最新版本</p><ul><li>版本比较一致，说明当前数据为最新版本，直接返回数据</li><li>版本比较不一致，说明数据被修改，获取悲观锁后重新获取最新版本数据</li></ul><h1 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h1><h2 id="并发三大特性"><a class="markdownIt-Anchor" href="#并发三大特性"></a> 并发三大特性</h2><h3 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h3><p>JMM规定所有变量都会存储在主内存中，在操作的时候，需要从主内存中复制一份到线程内存(CPU内存)，在线程内部做计算。然后再写回主内存中</p><p><code>定义</code>：原子性指一个操作是不可分割的，不可中断的，一个线程在执行时，另一个线程不会影响到他</p><ul><li><a href="/2022/03/29/jvm/#synchronized">synchronized</a> 排它锁，某一时刻只有一个线程能获得锁</li><li><a href="#cas">CAS</a> Compare And Swap也就是比较和交换，他是一条CPU的并发原语</li><li><a href="#aqs">Lock</a> 底层是CAS + AQS排队</li><li>JUC 原子类，比如AtomicInteger</li></ul><h3 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7001122798122827806">MESI协议</a></p><p>可见性问题是基于CPU位置出现的，CPU处理速度非常快，相对CPU来说，去主内存获取数据这个事情太慢了，CPU就提供了L1，L2，L3的三级缓存，每次去主内存拿完数据后，就会存储到CPU的三级缓存，每次去三级缓存拿数据，效率肯定会提升</p><p>这就带来了问题，现在CPU都是多核，每个线程的工作内存(CPU三级缓存)都是独立的会告知每个线程中做修改时，只改自己的工作内存，没有及时的同步到主内存，导致数据不一致问题</p><ul><li><a href="/2022/03/29/jvm/#volatile%E8%AF%AD%E4%B9%89%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C">volatile</a><ul><li>读屏障：将对应的CPU缓存置为无效，强制去主内存读取共享变量</li><li>写屏障：将写入缓存中的数据更新写入主内存，让其他线程可见</li></ul></li><li><a href="/2022/03/29/jvm/#synchronized">synchronized</a><ul><li>获取锁：将内部（同步块、方法）涉及的变量重新去主内存中获取</li><li>释放锁：立即将缓存同步到主内存</li></ul></li><li>final 常量不允许修改，因此可以保证可见性</li></ul><h3 id="有序性"><a class="markdownIt-Anchor" href="#有序性"></a> 有序性</h3><p><a href="/2022/03/29/jvm/#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F">指令重排序</a></p><ul><li><a href="/2022/03/29/jvm/#volatile%E8%AF%AD%E4%B9%89%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C">volatile</a><ul><li>内存屏障，内存屏障是一条CPU指令</li><li>通过插入内存屏障防止内存屏障前后发生指令重排序</li></ul></li></ul><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="线程状态"><a class="markdownIt-Anchor" href="#线程状态"></a> 线程状态</h3><ul><li><code>新建（new）</code>：当线程对象被创建时，线程处于新建状态。此时，该线程还没有启动，也没有分配系统资源</li><li><code>就绪（Runnable)</code>：当线程调用start()方法后，线程进入就绪状态。此时，线程已经分配到了系统资源，但还没有开始执行。在就绪状态下，线程可能会等待其他线程的执行</li><li><code>运行（Running）</code>：当线程获取到CPU资源后，开始执行run()方法，线程处于运行状态。线程会不断地执行run()方法中的代码，直到线程被阻塞或者执行完毕</li><li><code>阻塞（Blocked）</code>：线程在某些情况下可能会被阻塞，例如等待某个资源的释放（synchronized）或者线程调用了sleep()方法暂停执行。在阻塞状态下，线程会暂时停止执行，直到满足某个条件后进入就绪状态</li><li><code>等待（Waiting）</code>：线程在等待某个特定条件发生时，会进入等待状态。例如，线程调用了wait()方法，线程会一直等待直到其他线程调用了notify()或者notifyAll()方法唤醒它们</li><li><code>超时等待（Timed Waiting）</code>：在等待状态中，线程可以设置等待的超时时间。一旦超过时间限制，线程会自动唤醒并进入就绪状态。例如，线程调用了sleep()方法，线程会在指定的时间内暂停执行</li><li><code>终止状态（TERMINATED）</code>：线程任务执行完毕，线程被终止</li></ul><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Thread.html">API文档</a></p><p>创建线程的几种方式</p><p class="note note-primary">继承Thread类 , 重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;myThread&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>    myThread.start();<br>    myThread.join();<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">实现Runnable接口，实现run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;myThread&quot;</span>);<br>        &#125;<br>    &#125;);<br><br>    thread.start();<br>    thread.join();<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">Future / Callable 配合线程池方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>             TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>             a ++;<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> a;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>     <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>     <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>     <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><br>     Future&lt;Integer&gt; submit = executorService.submit(myCallable);<br>     Future&lt;Integer&gt; submit2 = executorService.submit(myCallable2);<br><br>     <span class="hljs-comment">// 阻塞等待结果</span><br>     <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> submit.get();<br>     <span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> submit2.get();<br>     System.out.println(integer + integer2); <span class="hljs-comment">// 20</span><br><br>     <span class="hljs-comment">// 关闭线程池</span><br>     executorService.shutdown();<br> &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">通过线程池创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>    executorService.execute(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 关闭线程池</span><br>    executorService.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><p class="note note-primary">父子关系</p><ul><li>线程的创建是由另一个线程完成的</li><li>被创建线程的父线程是创建它的线程</li></ul><p class="note note-primary">ThreadGroup</p><p>构建一个线程如果没有指定ThreadGroup，则它会用父线程的ThreadGroup</p><p class="note note-primary">Runnable</p><ul><li>Thread负责线程相关职责和控制</li><li>Runnable负责执行逻辑单元</li></ul><p class="note note-primary">stackSize</p><p>-Xss</p><p>线程的堆栈大小，如果没有设置则为0</p><p>设置了更小的堆栈大小，JVM能支持同时存活更多的线程，如果设置大了单个线程拥有更大的递归深度，但是同时存活的线程更少了</p><p class="note note-primary">守护线程</p><ul><li>守护线程有自动退出特性，当JVM没有非守护线程运行时，守护线程会自动退出</li><li>设置线程为守护线程 <code>Thread.setDaemon(boolean)</code>，必须在 <code>start()</code>之前设置</li><li><span style="border-bottom:2px dashed green">守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失</span></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">500</span>);<br>                    System.out.println(<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        thread.setDaemon(<span class="hljs-literal">true</span>);<br>        thread.start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(ThreadGroup group, Runnable target, String name,</span><br><span class="hljs-params">                 <span class="hljs-type">long</span> stackSize)</span> &#123;<br>       init(group, target, name, stackSize);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="sleep"><a class="markdownIt-Anchor" href="#sleep"></a> sleep</h3><p>线程休眠</p><ul><li><strong>sleep不会释放锁，阻塞线程</strong></li><li>睡眠的时间不是一个准确时间，和cpu任务调度有关</li><li>可以使用TimeUnit.SECONDS.sleep(3);更优雅睡眠线程</li><li>一个线程调用sleep,另一个线程调用 interrupt 能捕获中断信号</li></ul><h3 id="yield"><a class="markdownIt-Anchor" href="#yield"></a> yield</h3><p>让出CPU执行时间片</p><ul><li><strong>yield 不会释放对象锁</strong></li><li>让出cpu资源（不一定会让），让同等优先级的线程拥有可执行机会</li><li>让执行中的线程返回就绪状态，和同等优先级线程竞争执行机会</li><li>另外线程调用interrupt不能捕获到中断信号</li></ul><h3 id="suspend-resume-已废弃"><a class="markdownIt-Anchor" href="#suspend-resume-已废弃"></a> suspend / resume (已废弃)</h3><p class="note note-primary">suspend</p><ul><li>线程会被挂起，但不会释放锁</li><li>不推荐使用，在同步块或同步方法等调用suspend 会造成死锁</li></ul><p class="note note-primary">resume</p><ul><li>恢复suspend挂起的线程</li></ul><p class="note note-primary">死锁场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>               <span class="hljs-keyword">synchronized</span> (Object.class) &#123;<br>                   <span class="hljs-keyword">while</span> (message == <span class="hljs-literal">null</span>) &#123;<br>                       System.out.println(<span class="hljs-string">&quot;等待接受消息&quot;</span>);<br>                       Thread.currentThread().suspend();   <span class="hljs-comment">// 这里消费者挂起线程没有释放锁</span><br>                   &#125;<br>                   System.out.println(<span class="hljs-string">&quot;接受消息 =&gt; &quot;</span> + message);<br>                   message = <span class="hljs-literal">null</span>;<br>               &#125;<br>           &#125;<br>       &#125;);<br>       consumer.start();<br><br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>               <span class="hljs-keyword">synchronized</span> (Object.class) &#123;               <span class="hljs-comment">// 这里死锁，一直获取不到锁</span><br>                   <span class="hljs-keyword">try</span> &#123;<br>                       Thread.sleep(<span class="hljs-number">100</span>);<br>                       message = <span class="hljs-string">&quot;Hello , this is &quot;</span> + i++;<br>                       consumer.resume();<br>                   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                       e.printStackTrace();<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;);<br>       producer.start();<br>   &#125;<br>   <span class="hljs-comment">// 输出 等待接受消息</span><br></code></pre></td></tr></table></figure><h3 id="stop"><a class="markdownIt-Anchor" href="#stop"></a> stop</h3><ul><li>暴力停止，不推荐使用</li><li>一个线程几乎可以在任何地方抛出一个ThreadDeath异常，导致逻辑执行不完整</li><li>释放该线程所持有的所有的锁</li></ul><h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> join</h3><p>串行执行</p><ul><li>当一个线程调用另一个线程的<code>join()</code>方法时，调用线程会被阻塞，直到被调用线程执行完毕或者超时。这意味着<code>join()</code>方法可以用来实现线程的串行执行</li><li>被调用join()线程执行完毕，当前线程再继续往下执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待执行完毕后，主线程退出&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    System.out.println(i);<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        <span class="hljs-comment">// 等待调用join 方法的线程执行完后再执行</span><br>        thread.join();<br>        System.out.println(<span class="hljs-string">&quot;主线程继续执行&quot;</span>);<br>    &#125;<br>&#125;<br><br>等待执行完毕后，主线程退出<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br>主线程继续执行<br></code></pre></td></tr></table></figure><h3 id="interrupt"><a class="markdownIt-Anchor" href="#interrupt"></a> interrupt</h3><ul><li>用于打断阻塞线程，打断调用<code>wait</code>、<code>sleep</code>、<code>join</code>的线程</li><li>调用interrupt 方法后，在该线程的run方法会接收到 InterruptedException 异常（信号）</li><li>在线程内部可用 interrupted 判断当前线程是否被中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 休眠60秒</span><br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">60</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// 外部调用interrupt，线程体内部会触发InterruptedException</span><br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(index++);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>    	<span class="hljs-comment">// 线程提内部会触发 InterruptedException</span><br>        thread.interrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>实际上线程休眠3秒后就被主线程打断继续执行</li></ul><h3 id="interrupted"><a class="markdownIt-Anchor" href="#interrupted"></a> interrupted</h3><p>interrupt具有清除状态的功能，线程中断后，连续两次调用，第二次会返回false</p><h3 id="setpriority"><a class="markdownIt-Anchor" href="#setpriority"></a> setPriority</h3><ul><li>取值范围 <code>1~10</code></li><li>设置线程优先级不一定会让线程拥有更多的执行机会</li><li>默认线程优先级都是5，因为Main线程的优先级就是5，其他线程优先级都是派生mail线程</li><li><strong>线程的优先级设置可以理解为线程抢占CPU时间片的概率，虽然概率比较大，但是它不一定就是按照优先级的顺序去抢占CPU时间片的，具体的执行顺序还是要根据谁先抢到了CPU的时间片，谁就先来执行</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;&#125;);<br>    thread.setPriority(<span class="hljs-number">8</span>);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="suspend和wait的区别"><a class="markdownIt-Anchor" href="#suspend和wait的区别"></a> suspend和wait的区别</h3><p class="note note-primary">wait（Object方法）</p><ul><li>暂停当前线程执行并<strong>释放锁</strong>，进入对象等待池(被监视对象的对象等待池)，调用<code>wait</code>方法必须获取对象锁，否则抛出<code>IllegalMonitorStateException</code>异常</li><li>调用wait 必须是获得对象锁的情况下才能调用，只有在获取该对象的锁才能使用</li></ul><p class="note note-primary">notify（Object方法）</p><ul><li>调用notify会获取对象锁，只有在<code>synchronized</code>方法或块中才能调用，调用<code>notify</code>方法必须获取对象锁，否则抛出<code>IllegalMonitorStateException</code>异常</li><li>在对象（被监视对象）等待池中随机移走一个线程并放到锁标志等待池</li></ul><p class="note note-primary">notify all</p><ul><li>notify all 被唤醒的线程会再次去竞争对象锁，必须在<code>synchronized</code>方法或数据块中调用</li><li>从对象（被监视对象）等待池中移走所有等待那个对象的线程并放到锁标志等待池中</li></ul><p class="note note-primary">死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-keyword">for</span> (;;) &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>               System.out.println(<span class="hljs-number">1</span>);<br>           &#125;<br>       &#125;);<br>       thread.start();<br>       thread.wait(); <span class="hljs-comment">//抛出 java.lang.IllegalMonitorStateException，需要获得对象锁才能调用</span><br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>       thread.notify();<br>       TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">正确用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (object) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;使用wait必须获取对象锁，因为要释放对象锁&quot;</span>);<br>                        object.wait();<br>                        System.out.println(<span class="hljs-string">&quot;继续执行&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (object) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;获取对象锁 另外的线程调用 notify 唤醒线程&quot;</span>);<br>                    object.notify();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br><br>输出<br>使用wait必须获取对象锁，因为要释放对象锁<br>获取对象锁 另外的线程调用 notify 唤醒线程<br>继续执行<br></code></pre></td></tr></table></figure><p class="note note-primary">区别</p><ul><li>supend和resume是Thread的方法，wait和notify是Object的方法</li><li>supend不释放对象锁，容易造成死锁，wait和notify必须要获取对象锁才能调用，并且会主动释放对象锁，不会造死锁</li></ul><h3 id="正确关闭线程"><a class="markdownIt-Anchor" href="#正确关闭线程"></a> 正确关闭线程</h3><ul><li><p>线程结束生命周期正常结束</p></li><li><p>等待线程体执行完任务，正常退出</p></li></ul><p class="note note-primary">捕获中断信号结束线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>         <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// 接收线程中断信号</span><br>             <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>                 TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>                 System.out.println(Thread.currentThread().getName());<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             <span class="hljs-comment">// 必须在循环外捕获 InterruptedException</span><br>             System.out.println(<span class="hljs-string">&quot;线程中断&quot;</span>);<br>         &#125;<br>     &#125;);<br><br>     thread.start();<br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>     <span class="hljs-comment">// 中断线程</span><br>     thread.interrupt();<br> &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用 volatile 开关控制</p><p>使用 <code>volatile</code>修饰是要保证多线程环境下的<code>可见性</code></p><p>由于interrupted有清除状态的功能，可以使用一个flag来控制线程结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>         <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>     <span class="hljs-type">TestThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestThread</span>();<br>     thread.start();<br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>     thread.closedThread();<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">closed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">while</span> (!closed) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br><br>         System.out.println(<span class="hljs-built_in">this</span>.getName());<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closedThread</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-built_in">this</span>.closed = <span class="hljs-literal">true</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程通信"><a class="markdownIt-Anchor" href="#线程通信"></a> 线程通信</h2><h3 id="单线程间通信"><a class="markdownIt-Anchor" href="#单线程间通信"></a> 单线程间通信</h3><ul><li><code>join / yield</code></li><li>单线程通信可以使用 <code>synchronized</code> 、<code>wait</code>、<code>notify</code> 完成线程间通信</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟异步非阻塞事件处理</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">EventQuery</span> <span class="hljs-variable">eventQuery</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventQuery</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                eventQuery.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventQuery</span>.Event(i));<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">20</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                eventQuery.take();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事件队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventQuery</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Event&gt; taskQuery = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> eventId;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Event</span><span class="hljs-params">(<span class="hljs-type">int</span> eventId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.eventId = eventId;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Event&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;eventId=&quot;</span> + eventId +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EventQuery</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(MAX_NUM);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EventQuery</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提交事件</span><br><span class="hljs-comment">     * offer 单线程通信</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> event</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.taskQuery) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskQuery.size() &gt;= <span class="hljs-built_in">this</span>.maxSize) &#123;<br>                System.out.println(<span class="hljs-string">&quot;this query full&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.taskQuery.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;this event commit &quot;</span> + event);<br>            <span class="hljs-built_in">this</span>.taskQuery.add(event);<br><br>            <span class="hljs-comment">// 这一步很重要，实现自旋</span><br>            <span class="hljs-built_in">this</span>.taskQuery.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消费事件</span><br><span class="hljs-comment">     * take 单线程通信</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Event <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.taskQuery) &#123;<br>            <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(<span class="hljs-built_in">this</span>.taskQuery)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;this query is empty&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.taskQuery.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 多线程下，可能会执行空的removeFirst,原因是eventQuery 两个线程同时</span><br>            <span class="hljs-comment">// wait,另外一个线程执行offer后顺利执行 take,然后又唤起了wait的take线程</span><br>            event = <span class="hljs-built_in">this</span>.taskQuery.removeFirst();<br>            System.out.println(<span class="hljs-string">&quot;this event take &quot;</span> + event);<br><br>            <span class="hljs-comment">// 这一步很重要，实现自旋</span><br>            <span class="hljs-built_in">this</span>.taskQuery.notify();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> event;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多线程间通信"><a class="markdownIt-Anchor" href="#多线程间通信"></a> 多线程间通信</h3><ul><li><code>synchronized</code> 、<code>wait</code>、<code>notify</code>、<code>notifyAll</code></li><li>ReentrantLock + Condition</li><li>CountDownLatch 计数器</li><li>CyclicBarrier 同步屏障</li><li>Semaphore 信号量</li><li><code>join / yield</code></li><li>BlockingQueue</li><li>…</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟异步非阻塞事件处理</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">EventQuery</span> <span class="hljs-variable">eventQuery</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventQuery</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                eventQuery.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventQuery</span>.Event(i));<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>                eventQuery.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventQuery</span>.Event(i));<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;<br>                eventQuery.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventQuery</span>.Event(i));<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">20</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                eventQuery.take();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">20</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                eventQuery.take();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">20</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                eventQuery.take();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 事件队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventQuery</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Event&gt; taskQuery = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> eventId;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Event</span><span class="hljs-params">(<span class="hljs-type">int</span> eventId)</span> &#123;<br>            <span class="hljs-built_in">this</span>.eventId = eventId;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Event&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;eventId=&quot;</span> + eventId +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EventQuery</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(MAX_NUM);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EventQuery</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提交事件</span><br><span class="hljs-comment">     * offer 单线程通信</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> event</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.taskQuery) &#123;<br><br>            <span class="hljs-comment">// 多线程的场景下，线程每次被重新唤醒必须重新校验一次</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.taskQuery.size() &gt;= <span class="hljs-built_in">this</span>.maxSize) &#123;<br>                System.out.println(<span class="hljs-string">&quot;this query full&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.taskQuery.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;this event commit &quot;</span> + event);<br>            <span class="hljs-built_in">this</span>.taskQuery.add(event);<br><br>            <span class="hljs-comment">// 唤醒所有线程进行锁竞争</span><br>            <span class="hljs-built_in">this</span>.taskQuery.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消费事件</span><br><span class="hljs-comment">     * take 单线程通信</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Event <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Event</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.taskQuery) &#123;<br><br>            <span class="hljs-comment">// 多线程的场景下，线程每次被重新唤醒必须重新校验一次</span><br>            <span class="hljs-keyword">while</span> (CollectionUtils.isEmpty(<span class="hljs-built_in">this</span>.taskQuery)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;this query is empty&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.taskQuery.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 多线程下，可能会执行空的removeFirst,原因是eventQuery 两个线程同时</span><br>            <span class="hljs-comment">// wait,另外一个线程执行offer后顺利执行 take,然后又唤起了wait的take线程</span><br>            event = <span class="hljs-built_in">this</span>.taskQuery.removeFirst();<br>            System.out.println(<span class="hljs-string">&quot;this event take &quot;</span> + event);<br><br>            <span class="hljs-comment">// 这一步很重要，实现自旋</span><br>            <span class="hljs-built_in">this</span>.taskQuery.notifyAll();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> event;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="countdownlatch"><a class="markdownIt-Anchor" href="#countdownlatch"></a> CountDownLatch</h4><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/CountDownLatch.png" srcset="/img/loading.gif" lazyload alt="计数器"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多线程计数器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                    <span class="hljs-keyword">synchronized</span> (CountDownLatchTest.class) &#123;<br>                        num++;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 线程完成计数器减1</span><br>                latch.countDown();<br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-comment">// 阻塞去监听计数器的值是否为0，是则往下执行</span><br>        latch.await();<br>        System.out.println(<span class="hljs-string">&quot;所有子线程执行完毕&quot;</span>);<br>        System.out.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">底层实现</p><ul><li>底层使用 <code>AQS</code></li><li>计数器的数量其实就是 <code>AQS</code> 的 state 值</li><li>当计数器为0（state = 0），调用await()的线程被唤醒</li></ul><h4 id="cyclicbarrier"><a class="markdownIt-Anchor" href="#cyclicbarrier"></a> CyclicBarrier</h4><p>主要用于阻塞子线程，让多个子线程在同一时刻开始执行</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%A0%85%E6%A0%8F.png" srcset="/img/loading.gif" lazyload alt="线程栅栏"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">3</span>);<br><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         System.out.println(<span class="hljs-string">&quot;员工进入会议室&quot;</span>);<br>         <span class="hljs-keyword">try</span> &#123;<br>             cyclicBarrier.await();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>         System.out.println(<span class="hljs-string">&quot;会议开始&quot;</span>);<br>     &#125;).start();<br><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         System.out.println(<span class="hljs-string">&quot;组长进入会议室&quot;</span>);<br>         <span class="hljs-keyword">try</span> &#123;<br>             cyclicBarrier.await();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>         System.out.println(<span class="hljs-string">&quot;会议开始&quot;</span>);<br>     &#125;).start();<br><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         System.out.println(<span class="hljs-string">&quot;CEO进入会议室&quot;</span>);<br>         <span class="hljs-keyword">try</span> &#123;<br>             cyclicBarrier.await();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>         System.out.println(<span class="hljs-string">&quot;会议开始&quot;</span>);<br>     &#125;).start();<br><br><span class="hljs-comment">//        员工进入会议室 </span><br><span class="hljs-comment">//        组长进入会议室</span><br><span class="hljs-comment">//        CEO进入会议室</span><br><span class="hljs-comment">//        会议开始</span><br><span class="hljs-comment">//        会议开始</span><br><span class="hljs-comment">//        会议开始</span><br> &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">底层实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure><ul><li>底层使用 <code>ReentrantLock</code> 和 <code>Condition</code> 实现</li><li>线程都会调用 <code>Condition</code> 的 await 进行阻塞</li><li>当 count 被线程减到0会调用 <code>Condition</code> 的 signalAll() 唤醒所有阻塞线程</li></ul><h4 id="semaphore"><a class="markdownIt-Anchor" href="#semaphore"></a> Semaphore</h4><p><a target="_blank" rel="noopener" href="https://toutiao.io/posts/l7cfixa/preview">互联网项目不能使用 Semaphore 限流，单机版使用 Guava RateLimiter</a></p><p>Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E4%BF%A1%E5%8F%B7%E9%87%8F.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.luckdraw.test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 信号量有限的资源共享</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 每次只有2个线程有许可证获取共享资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> num;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取凭证</span><br>                    semaphore.acquire();<br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s 线程获取资源&quot;</span>, Thread.currentThread().getName()));<br>                    num++;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放凭证</span><br>                    System.out.println(String.format(<span class="hljs-string">&quot;%s 线程释放资源&quot;</span>, Thread.currentThread().getName()));<br>                    semaphore.release();<br>                    latch.countDown();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        latch.await();<br>        System.out.println(num);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 输出</span><br><span class="hljs-comment"> * Thread-2 线程获取资源</span><br><span class="hljs-comment"> * Thread-0 线程获取资源</span><br><span class="hljs-comment"> * Thread-2 线程释放资源</span><br><span class="hljs-comment"> * Thread-0 线程释放资源</span><br><span class="hljs-comment"> * Thread-6 线程获取资源</span><br><span class="hljs-comment"> * Thread-1 线程获取资源</span><br><span class="hljs-comment"> * Thread-6 线程释放资源</span><br><span class="hljs-comment"> * Thread-1 线程释放资源</span><br><span class="hljs-comment"> * Thread-3 线程获取资源</span><br><span class="hljs-comment"> * Thread-4 线程获取资源</span><br><span class="hljs-comment"> * Thread-4 线程释放资源</span><br><span class="hljs-comment"> * Thread-3 线程释放资源</span><br><span class="hljs-comment"> * Thread-5 线程获取资源</span><br><span class="hljs-comment"> * Thread-7 线程获取资源</span><br><span class="hljs-comment"> * Thread-5 线程释放资源</span><br><span class="hljs-comment"> * Thread-7 线程释放资源</span><br><span class="hljs-comment"> * Thread-8 线程获取资源</span><br><span class="hljs-comment"> * Thread-9 线程获取资源</span><br><span class="hljs-comment"> * Thread-8 线程释放资源</span><br><span class="hljs-comment"> * Thread-9 线程释放资源</span><br><span class="hljs-comment"> * 10</span><br><span class="hljs-comment"> *</span><br></code></pre></td></tr></table></figure><p class="note note-primary">底层实现</p><ul><li><code>AQS</code> 的 state 进行控制</li><li>当线程获得凭证后，state 会进行 -1 操作</li><li>当 state = 0 时，不允许线程申请凭证（阻塞）</li><li>当线程释放凭证时，state 会进行 +1 操作</li></ul><h2 id="hook线程钩子"><a class="markdownIt-Anchor" href="#hook线程钩子"></a> Hook线程（钩子）</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/281958d20b04">不建议在线程池中使用异常回调</a></p><ul><li><span style="border-bottom:2px dashed green">用于处理<code>线程异常回调</code>和<code>优雅停机</code></span></li><li>线程异常回调UncaughtExceptionHandler</li><li>JVM退出监控 Hook线程</li></ul><p class="note note-primary">UncaughtExceptionHandler</p><p>线程异常回调需要实现的接口，它是一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>   <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>   &#125;);<br><br>   <span class="hljs-comment">// 对单独线程设置异常回调</span><br>   thread.setUncaughtExceptionHandler((Thread t, Throwable e) -&gt; &#123;<br>       System.out.println(t.getName());<br>       System.out.println(e.getMessage());<br>   &#125;);<br><br>   thread.start();<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">DefaultUncaughtExceptionHandler</p><p>设置线程全局异常回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-comment">// 注入全局线程设置异常接口回调</span><br>      Thread.setDefaultUncaughtExceptionHandler((Thread t, Throwable e) -&gt; &#123;<br>          System.out.println(t.getName());<br>          System.out.println(e.getMessage());<br>      &#125;);<br><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>      &#125;).start();<br>  &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">注入钩子线程[JVM]</p><p>实现优雅停机</p><p><span style="border-bottom:2px dashed green">JVM之所以运行是因为存在活跃的非守护进程，当JVM的所有非守护进程结束，程序退出，这时候就会触发Hook线程</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>      <span class="hljs-comment">// 注入Hook线程</span><br>      Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br><br>          System.out.println(<span class="hljs-string">&quot;The Hook Thread 1 is Run&quot;</span>);<br>      &#125;));<br><br>      <span class="hljs-comment">// Hook线程可以注入多个</span><br>      Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>          &#125;<br><br>          System.out.println(<span class="hljs-string">&quot;The Hook Thread 2 is Run&quot;</span>);<br>      &#125;));<br>  &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">ThreadGroup钩子</p><p>​	<span style="border-bottom:2px dashed green">如果没有在线程注入异常回调接口，线程异常又会如何处理？</span></p><ul><li>getUncaughtExceptionHandler 方法先会判断自身是否存在回调接口</li><li>若线程本身不存在则获取所在ThreadGroup的UncaughtExceptionHandler</li><li>若该ThreadGroup有parent则获取parent的UncaughtExceptionHandler</li><li>一直向上递归，若没有在ThreadGroup找到回调就找Thread的DefaultUncaughtExceptionHandle，若没有就输出异常堆栈</li></ul><p class="note note-primary">Thread 获取回调接口源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> UncaughtExceptionHandler <span class="hljs-title function_">getUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> uncaughtExceptionHandler != <span class="hljs-literal">null</span> ?<br>          uncaughtExceptionHandler : group;<br>  &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">ThreadGroup获取回调接口源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>      <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>          parent.uncaughtException(t, e);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          Thread.<span class="hljs-type">UncaughtExceptionHandler</span> <span class="hljs-variable">ueh</span> <span class="hljs-operator">=</span><br>              Thread.getDefaultUncaughtExceptionHandler();<br>          <span class="hljs-keyword">if</span> (ueh != <span class="hljs-literal">null</span>) &#123;<br>              ueh.uncaughtException(t, e);<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> ThreadDeath)) &#123;<br>              System.err.print(<span class="hljs-string">&quot;Exception in thread \&quot;&quot;</span><br>                               + t.getName() + <span class="hljs-string">&quot;\&quot; &quot;</span>);<br>              e.printStackTrace(System.err);<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="守护线程"><a class="markdownIt-Anchor" href="#守护线程"></a> 守护线程</h2><p><span style="border-bottom:2px dashed green">守护线程，专门用于服务其他的线程，守护线程有自动退出特性，当JVM没有非守护线程运行时，守护线程会自动退出</span>。比如垃圾回收线程，就是最典型的守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>             <span class="hljs-keyword">try</span> &#123;<br>                 TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">300</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                 e.printStackTrace();<br>             &#125;<br>             System.out.println(<span class="hljs-string">&quot;守护线程&quot;</span>);<br>         &#125;<br>     &#125;);<br><br>     <span class="hljs-comment">// 设置为守护线程</span><br>     thread.setDaemon(<span class="hljs-literal">true</span>);<br>     thread.start();<br><br>     <span class="hljs-comment">// 主线程休眠1秒</span><br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br> &#125;<br><br><span class="hljs-comment">// 输出</span><br>守护线程<br>守护线程<br>守护线程<br></code></pre></td></tr></table></figure><h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2><p>​	为什么使用线程池</p><ul><li>减少系统维护线程的开销</li><li>解耦，运行和创建分开</li><li>线程可复用</li></ul><h3 id="threadpoolexecutor"><a class="markdownIt-Anchor" href="#threadpoolexecutor"></a> ThreadPoolExecutor</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                           <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                           <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                           TimeUnit unit,</span><br><span class="hljs-params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                           ThreadFactory threadFactory,</span><br><span class="hljs-params">                           RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><p class="note note-primary">核心参数说明</p><table><thead><tr><th style="text-align:left">参数名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">corePoolSize</td><td style="text-align:left">核心线程池大小</td></tr><tr><td style="text-align:left">maximumPoolSize</td><td style="text-align:left">最大线程池大小</td></tr><tr><td style="text-align:left">keepAliveTime</td><td style="text-align:left">非核心线程最大存活时间</td></tr><tr><td style="text-align:left">TimeUnit</td><td style="text-align:left">非核心线程最大存活时间单位</td></tr><tr><td style="text-align:left">workQueue</td><td style="text-align:left">阻塞任务队列</td></tr><tr><td style="text-align:left">threadFactory(可选)</td><td style="text-align:left">新建线程工厂</td></tr><tr><td style="text-align:left">RejectedExecutionHandler（可选）</td><td style="text-align:left">当提交任务数超过maxmumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler来处理</td></tr></tbody></table><p class="note note-primary">拒绝策略</p><p>​	当提交的任务数大于corePoolSize时，会优先放到队列缓冲区，<strong>只有填满了缓冲区后</strong>，才会判断当前运行的任务是否大于maxPoolSize，小于时会新建线程处理，大于时就触发了拒绝策略</p><table><thead><tr><th>拒绝策略</th><th>说明</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy (默认拒绝策略)</td><td>丢弃任务并抛出RejectedExecutionException异常</td></tr><tr><td>ThreadPoolExecutor.DiscardPolicy</td><td>也是丢弃任务，但是不抛出异常</td></tr><tr><td>ThreadPoolExecutor.DiscardOldestPolicy</td><td>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</td></tr><tr><td>ThreadPoolExecutor.CallerRunsPolicy</td><td>由调用线程处理该任务</td></tr></tbody></table><p class="note note-primary">重点讲解</p><ol><li>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行</li><li>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务</li><li>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理</li><li>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程</li></ol><p class="note note-primary">非核心线程创建时机</p><p>​	<font color="red">当每个核心线程数都在执行时，等待队列已满，就会启用非核心线程处理堆积的任务</font></p><p class="note note-primary">任务队列没满时就只有核心线程在执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            pool.execute(() -&gt; &#123;System.out.println(Thread.currentThread().getName());&#125;);<br>        &#125;<br><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br>    &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">任务队列满了就创建额外线程执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>)<br>        , Executors.defaultThreadFactory(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            pool.execute(() -&gt; &#123;System.out.println(Thread.currentThread().getName());&#125;);<br>        &#125;<br><br><span class="hljs-comment">//        main</span><br><span class="hljs-comment">//        pool-1-thread-3</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-2</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br><span class="hljs-comment">//        pool-1-thread-3</span><br><span class="hljs-comment">//        main</span><br><span class="hljs-comment">//        main</span><br><span class="hljs-comment">//        pool-1-thread-2</span><br><span class="hljs-comment">//        pool-1-thread-1</span><br>    &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">线程池状态</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 线程状态</span><br>    <span class="hljs-comment">// runState is stored in the high-order bits</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>    ...<br></code></pre></td></tr></table></figure><p><code>ctl</code>：一个Integr占4个字节，也就是32位，前三位用来表示线程池的状态，后29位用来表示线程池的工作线程数</p><p><code>RUNNING</code></p><ul><li>状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理</li><li>状态切换：线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0</li></ul><p><code>SHUTDOWN</code></p><ul><li>状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务</li><li>状态切换：调用线程池的 <code>shutdown()</code> 方法时，线程池由RUNNING -&gt; SHUTDOWN</li></ul><p><code>STOP</code></p><ul><li>状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务</li><li>状态切换：调用线程池的 <code>shutdownNow()</code> 方法时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP</li></ul><p><code>TIDYING</code></p><ul><li>状态说明：当所有的任务已终止，<code>ctl</code>记录的工作线程数为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数 <code>terminated()</code>。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现</li><li>状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池工作线程也为空，就会由 SHUTDOWN -&gt; TIDYING，当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING</li></ul><p><code>TERMINATED</code></p><ul><li>状态说明：线程池彻底终止，就变成TERMINATED状态</li><li>状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED</li></ul><p class="note note-primary">线程池执行流程</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123; <br>       <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 健壮性，任务判空</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="hljs-comment">// 判断当前线程数是否少于核心线程数</span><br>           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>)) <span class="hljs-comment">// 如果当前线程数少于核心线程则创建一个新的核心线程执行当前任务，并把线程放入池子</span><br>               <span class="hljs-keyword">return</span>;<br>           c = ctl.get();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="hljs-comment">// 如果当前核心线程满了就将任务放入队列</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>           <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="hljs-comment">// 如果线程池状态停止运行，则行拒绝策略</span><br>               reject(command);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 工作线程数量为0</span><br>               addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 创建一个任务为空的非核心线程</span><br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>)) <span class="hljs-comment">// 任务队列满了就尝试创建一个非核心线程执行任务，否则就执行拒绝策略</span><br>           reject(command);<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>addWorker(null, false)</code> 为什么要添加一个任务为空的非核心线程？</p><ul><li>线程池的核心线程数是允许为0的</li><li>那么就存在线程饥饿问题，就是任务队列里有任务，但是线程池里没有线程处理</li><li>创建一个空任务线程就是防止线程饥饿，先处理堆积任务</li></ul><p class="note note-primary">添加工作线程逻辑</p><ul><li>校验线程池的状态以及工作线程个数</li><li>添加工作线程并且启动工作线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123; <span class="hljs-comment">// 提交的任务以及是否核心线程</span><br>        retry: <span class="hljs-comment">// 外层for的标记，方便在内层for跳出外层for循环</span><br>        <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 外层for在校验线程池的状态</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c); <span class="hljs-comment">// 拿到ctl的高3位</span><br><br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>                ! (rs == SHUTDOWN &amp;&amp; <span class="hljs-comment">//判断线程池是否调用了 shutdown</span><br>                   firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>                   ! workQueue.isEmpty()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">for</span> (;;) &#123;  <span class="hljs-comment">// 内层for在校验工作线程的个数</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c); <span class="hljs-comment">//获取当前线程数</span><br>                <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                    wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="hljs-comment">// 判断当前是否核心线程，当前线程数是否小于核心线程</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断是否大于核心线程数或最大线程数</span><br>                <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="hljs-comment">// cas 线程数 + 1</span><br>                    <span class="hljs-keyword">break</span> retry; <span class="hljs-comment">// 跳出循环</span><br>                c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>                <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                    <span class="hljs-keyword">continue</span> retry;<br>                <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask); <span class="hljs-comment">// 创建一个工作线程</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 判断 Worker 线程是否为空，担心线程工厂有问题</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>                mainLock.lock(); <span class="hljs-comment">// 加锁，存储工作线程的对象是HashSet</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Recheck while holding lock.</span><br>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                    <span class="hljs-comment">// shut down before lock acquired.</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get()); <span class="hljs-comment">// 再次判断线程池运行状态</span><br><br>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                        workers.add(w); <span class="hljs-comment">// 将当前线程加入线程池</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                            largestPoolSize = s;<br>                        workerAdded = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 工作线程创建成功</span><br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mainLock.unlock();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                    t.start(); <span class="hljs-comment">// 开始执行线程</span><br>                    workerStarted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 工作线程启动成功</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (! workerStarted)<br>                addWorkerFailed(w); <span class="hljs-comment">// 如果工作线程启动失败，则进行补偿处理</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted; <span class="hljs-comment">// 返回工作线程是否启动成功</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="executors"><a class="markdownIt-Anchor" href="#executors"></a> Executors</h3><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" srcset="/img/loading.gif" lazyload alt></p><p>java官方提供用于创建线程池的工具类</p><p><em>这个类阿里巴巴的规范不推荐使用，原因是容易造成资源浪费和存在大量任务的时候会OOM</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Executor</span> &#123;<br><br> <span class="hljs-comment">// 提交一个无返回值的任务以供执行</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="executorservice"><a class="markdownIt-Anchor" href="#executorservice"></a> ExecutorService</h3><p>Executors创建线程池返回的对象，是ThreadPoolExecutor的实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br><br> <span class="hljs-comment">// 启动有序关机，执行以前提交的任务，但不接受新任务</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br><br> <span class="hljs-comment">// 尝试停止所有正在执行的任务，停止正在等待的任务的处理，并返回正在等待执行的任务的列表</span><br> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br><br> <span class="hljs-comment">// 如果此执行器已关闭，则返回true</span><br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br><br> <span class="hljs-comment">// 如果关闭后所有任务都已完成，则返回true</span><br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br><br> <span class="hljs-comment">// 阻塞，直到所有任务在关闭请求后完成执行，或超时发生，或当前线程中断（以先发生的为准）</span><br> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException;<br><br> <span class="hljs-comment">// 提交一个有返回值的任务以供执行，并返回一个表示任务执行结果的Future， Future的get()方法将在成功完成后返回任务的结果</span><br> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><br> <span class="hljs-comment">// 提交一个无返回值的任务和返回结果，Future的get()方法得到的结果是传入的result</span><br> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span>;<br><br> <span class="hljs-comment">// 提交一个无返回值的任务，Future的get()方法得到的结果是null</span><br> Future&lt;?&gt; submit(Runnable task);<br><br> <span class="hljs-comment">// 提交一个任务的集合，返回一个Future的集合</span><br> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException;<br><br> <span class="hljs-comment">// 提交一个任务的集合，返回一个Future的集合，多了任务执行超时功能</span><br> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                               <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException;<br><br> <span class="hljs-comment">// 执行集合中任务，返回任意一个任务执行结果</span><br> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><br> <span class="hljs-comment">// 执行集合中任务，返回任意一个任务执行结果，多了任务执行超时功能</span><br> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                 <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="execute方法-无返回值"><a class="markdownIt-Anchor" href="#execute方法-无返回值"></a> execute方法 [无返回值]</h4><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0execute%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">实现原理</p><ul><li>ThreadPoolExecutor维护一组工作线程 Worker</li><li>execute 提交的 Runnable会被加入到任务队列中</li><li>Worker run 方法阻塞循环获取任务队列，然后在其run方法中执行Runnable的 run方法（非start）</li><li>最后启动线程池中 Worker（实现Runnable）线程</li></ul><h4 id="submit方法-有返回值"><a class="markdownIt-Anchor" href="#submit方法-有返回值"></a> submit方法 [有返回值]</h4><p><a href="%E7%BA%BF%E7%A8%8B%E6%B1%A0submit%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png"></a></p><ul><li>Callable提交到线程池</li><li>线程池转为FutureTask并返回，把任务提交到队列中进行计算</li><li><span style="border-bottom:2px dashed green">FutureTask 继承了Runnable并且重写了run方法，run方法调用了Callable的call方法能够获取返回值，其本身就定义了一个返回值成员变量，当调用get的时候就时自旋判断是否有返回值，没有则调用LockSuppot挂起线程</span></li><li><strong>调用get方法，此时如果线程池已计算完任务结果则直接返回，否则睡眠调用线程，直到任务计算完毕返回结果</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        RunnableFuture&lt;T&gt; ftask = newTaskFor(task); <span class="hljs-comment">// 封装成 FutureTask</span><br>        execute(ftask); <span class="hljs-comment">// FutureTask 继承了Runnable并且重写了run方法，其本身就定义了一个返回值成员变量，当调用get的时候就时自旋判断是否有返回值，没有则调用LockSuppot挂起线程</span><br>        <span class="hljs-keyword">return</span> ftask;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (state != NEW ||<br>            !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                         <span class="hljs-literal">null</span>, Thread.currentThread()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Callable&lt;V&gt; c = callable;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>                V result;<br>                <span class="hljs-type">boolean</span> ran;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = c.call();<br>                    ran = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    result = <span class="hljs-literal">null</span>;<br>                    ran = <span class="hljs-literal">false</span>;<br>                    setException(ex);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ran)<br>                	<span class="hljs-comment">// 调用set回写返回值</span><br>                    set(result);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>            <span class="hljs-comment">// prevent concurrent calls to run()</span><br>            runner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>            <span class="hljs-comment">// leaked interrupts</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>                handlePossibleCancellationInterrupt(s);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>	<span class="hljs-comment">// 修改状态回写返回值</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = v;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="futuretaskget-实现"><a class="markdownIt-Anchor" href="#futuretaskget-实现"></a> FutureTask#get() 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br> <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>     s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br> <span class="hljs-keyword">return</span> report(s);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException &#123;<br> <span class="hljs-comment">// 计算等待截止时间</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br> <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br> <span class="hljs-comment">// 自旋</span><br> <span class="hljs-keyword">for</span> (;;) &#123;<br>     <span class="hljs-comment">// 1. 判断阻塞线程是否被中断,如果被中断则在等待队列中删除该节点并抛出InterruptedException异常</span><br>     <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>         removeWaiter(q);<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>     &#125;<br>     <span class="hljs-comment">// 2. 获取当前状态，如果状态大于COMPLETING</span><br>     <span class="hljs-comment">// 说明任务已经结束(要么正常结束，要么异常结束，要么被取消)</span><br>     <span class="hljs-comment">// 则把thread显示置空，并返回结果</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>     <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>         <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>             q.thread = <span class="hljs-literal">null</span>;<br>         <span class="hljs-keyword">return</span> s;<br>     &#125;<br>     <span class="hljs-comment">// 3. 如果状态处于中间状态COMPLETING</span><br>     <span class="hljs-comment">// 表示任务已经结束但是任务执行线程还没来得及给outcome赋值</span><br>     <span class="hljs-comment">// 这个时候让出执行权让其他线程优先执行</span><br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <span class="hljs-comment">// cannot time out yet</span><br>         Thread.<span class="hljs-keyword">yield</span>();<br>     <span class="hljs-comment">// 4. 如果等待节点为空，则构造一个等待节点</span><br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>         q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>     <span class="hljs-comment">// 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters</span><br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>         queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                 q.next = waiters, q);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>         <span class="hljs-comment">// 如果需要等待特定时间，则先计算要等待的时间</span><br>         <span class="hljs-comment">// 如果已经超时，则删除对应节点并返回对应的状态</span><br>         nanos = deadline - System.nanoTime();<br>         <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>             removeWaiter(q);<br>             <span class="hljs-keyword">return</span> state;<br>         &#125;<br>         <span class="hljs-comment">// 6. 阻塞等待特定时间</span><br>         LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>         <span class="hljs-comment">// 6. 阻塞等待直到被其他线程唤醒</span><br>         LockSupport.park(<span class="hljs-built_in">this</span>);<br> &#125;<br><br> <span class="hljs-comment">// 等待节点，链表节点</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>     <span class="hljs-keyword">volatile</span> Thread thread;<br>     <span class="hljs-keyword">volatile</span> WaitNode next;<br>     WaitNode() &#123; thread = Thread.currentThread(); &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="newfixedthreadpool"><a class="markdownIt-Anchor" href="#newfixedthreadpool"></a> newFixedThreadPool</h4><p>固定数量的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;    <br></code></pre></td></tr></table></figure><ul><li>创建一个核心线程数和最大线程数一样</li><li>核心线程最大存活时间无限 <font color="red">（容易造成资源浪费）</font></li><li>使用无边界的链表队列存放待执行的任务<font color="red">（如果存在大量任务容易造成任务堆积导致OOM）</font></li></ul><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                System.out.println(String.format(<span class="hljs-string">&quot;%s %s&quot;</span>, Thread.currentThread().getName(),<br>                        DateFormatUtils.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 提交任务</span><br>        executorService.execute(runnable);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">06</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">06</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:08<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:08<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:09<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:09<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="newsinglethreadexecutor"><a class="markdownIt-Anchor" href="#newsinglethreadexecutor"></a> newSingleThreadExecutor</h4><p><strong>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务,提交的任务按照FIFO顺序执行</strong></p><ul><li>创建一个核心线程数，最大线程数为1的线程池</li><li>任何时候都只有一个活跃的线程</li><li>适用于单个任务顺序执行场景, <strong>但是使用了无边界的BlockingQueue还是存在OOM风险</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                    threadFactory));<br>    &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                System.out.println(String.format(<span class="hljs-string">&quot;%s %s&quot;</span>, Thread.currentThread().getName(),<br>                        DateFormatUtils.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 提交任务</span><br>        executorService.execute(runnable);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">05</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">06</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">07</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:08<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:09<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">10</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">11</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">12</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">13</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">27</span>:<span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>​</p><h4 id="newcachedthreadpool"><a class="markdownIt-Anchor" href="#newcachedthreadpool"></a> newCachedThreadPool</h4><p>具有缓存功能的线程池，无限制创建线程</p><ul><li>创建一个核心线程数为0，没有最大线程数的线程池</li><li>线程的活跃时间为60秒，线程池会根据实际需求创建线程</li><li>如果线程池中有空闲线程未被销毁，则新提交的任务会重用这些线程</li><li>适用于高并发，任务处理时间短场景。长期空闲的池子不会消耗系统资源</li><li>使用<code>SynchronousQueue</code>任务队列只能存储一个任务，其他全部通过创建新的非核心线程执行，大量任务涌入会OOM</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                System.out.println(String.format(<span class="hljs-string">&quot;%s %s&quot;</span>, Thread.currentThread().getName(),<br>                        DateFormatUtils.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 提交任务</span><br>        executorService.execute(runnable);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">7</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">6</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">9</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">8</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">10</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">25</span>:<span class="hljs-number">53</span><br></code></pre></td></tr></table></figure><h4 id="newscheduledthreadpool"><a class="markdownIt-Anchor" href="#newscheduledthreadpool"></a> newScheduledThreadPool</h4><p>创建一个定长线程池，支持定时及周期性任务执行</p><ul><li>创建一个可配置的核心线程数延迟队列</li><li>队列是按延时时间升序排序，不是按照submit时间排序的了以延时时间作为优先级排序，延时时间短的，优先级高，放在前面先执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                System.out.println(String.format(<span class="hljs-string">&quot;%s %s %s&quot;</span>, Thread.currentThread().getName(),<br>                        flag,<br>                        DateFormatUtils.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:SSS&quot;</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 第一个参数： Runnable</span><br><span class="hljs-comment">         * 第二个参数： initialDelay 初始延迟时间</span><br><span class="hljs-comment">         * 第三个参数： period 间隔时长</span><br><span class="hljs-comment">         * 第四个参数： unit 时间单位</span><br><span class="hljs-comment">         */</span><br>        executorService.scheduleAtFixedRate(runnable, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">17</span>:<span class="hljs-number">944</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">17</span>:<span class="hljs-number">937</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">19</span>:<span class="hljs-number">057</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">19</span>:<span class="hljs-number">057</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">20</span>:<span class="hljs-number">057</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">20</span>:<span class="hljs-number">057</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">21</span>:058<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">21</span>:058<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">22</span>:058<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">9</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">22</span>:058<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">23</span>:059<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">23</span>:059<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">24</span>:059<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">24</span>:059<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">25</span>:059<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">25</span>:059<br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">26</span>:<span class="hljs-number">062</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">22</span> <span class="hljs-number">01</span>:<span class="hljs-number">36</span>:<span class="hljs-number">26</span>:<span class="hljs-number">063</span><br></code></pre></td></tr></table></figure><h3 id="completablefuture"><a class="markdownIt-Anchor" href="#completablefuture"></a> CompletableFuture</h3><p><a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CompletableFuture.html">API文档</a></p><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039721242">example1</a></p><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581182447650">example2</a></p><h3 id="completionservice"><a class="markdownIt-Anchor" href="#completionservice"></a> CompletionService</h3><p>CompletionService的实现目标是<strong>任务先完成可优先获取到，即结果按照完成先后顺序排序</strong></p><p>API文档(<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CompletionService.html">https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CompletionService.html</a>)</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shijiaqi1066/p/10454237.html">example</a></p><h2 id="fork-join"><a class="markdownIt-Anchor" href="#fork-join"></a> Fork Join</h2><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/forkJoin.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>核心类</strong></p><ul><li><code>RecursiveTask</code>	递归任务类</li><li><code>ForkJoinPool</code> 线程池</li><li><code>Future</code> 获取结果</li></ul><p>Fork/Join是Java中用于并行计算的框架，它基于工作窃取算法，用于将一个大任务切分为多个子任务，并行地执行，最后合并子任务的执行结果得到最终结果</p><p class="note note-primary">工作窃取算法</p><p>​	工作窃取算法是指某个线程从其他队列里窃取任务来执行。<strong>对于一个比较大的任务，可以把它分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务需要处理，于是它就去其他线程的队列里窃取一个任务来执行。由于此时它们访问同一个队列，为了减小竞争，通常会使用双端队列。被窃取任务的线程永远从双端队列的头部获取任务，窃取任务的线程永远从双端队列的尾部获取任务</strong></p><p class="note note-primary">窃取算法优缺点</p><ul><li><strong>优点</strong>：充分利用线程进行并行计算，减少了线程间的竞争</li><li><strong>缺点</strong>：双端队列只存在一个任务时会导致竞争，会消耗更多的系统资源，因为需要创建多个线程和多个双端队列</li></ul><p class="note note-primary">Fork/Join 框架的异常处理</p><p>​	<strong>ForkJoinTask</strong> 在执行的时候可能抛出异常，但没有办法在主线程中直接捕获异常，所以 ForkJoinTask 提供了 <code>isCompletedAbnormally()</code> 方法检查任务是否已经抛出异常或已经被取消。<code>getException()</code> 方法返回 <code>Throwable</code> 对象，如果任务被取消了则返回 <code>CancellationException</code>，<strong>如果任务没有完成或者没有抛出异常则返回 <code>null</code></strong></p><p class="note note-primary">fork() 方法的实现原理</p><p>​	当调用 ForkJoinTask 的 fork() 方法时，程序会调用 <code>ForkJoinPool.WorkQueue</code> 的 <code>push()</code> 方法异步地执行这个任务，然后立即返回结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​	push() 方法把当前任务存放在一个 ForkJoinTask 数组队列里，然后再调用 <code>ForkJoinPool</code> 的 <code>signalWork()</code> 方法唤醒或创建一个工作线程来执行任务。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> base, s = top, n;<br>    <span class="hljs-keyword">if</span> ((a = array) != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// ignore if queue removed</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> a.length - <span class="hljs-number">1</span>;     <span class="hljs-comment">// fenced write for task visibility</span><br>        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);<br>        U.putOrderedInt(<span class="hljs-built_in">this</span>, QTOP, s + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> ((n = s - b) &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((p = pool) != <span class="hljs-literal">null</span>)<br>                p.signalWork(p.workQueues, <span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= m)<br>            growArray();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">join() 方法的实现原理</p><p>​	当调用 ForkJoinTask 的 join() 方法时，程序会调用 <code>doJoin()</code> 方法，通过 doJoin() 方法来判断返回什么结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>        ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>        externalAwaitDone();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportException</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == CANCELLED)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-keyword">if</span> (s == EXCEPTIONAL)<br>        rethrow(getThrowableException());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p class="note note-primary">1~10累加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RecursiveTask 递归任务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-comment">// 任务递归分解停止的阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 最小计算元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-comment">// 最大计算元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Calculator</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;min:&quot;</span> + start + <span class="hljs-string">&quot; max:&quot;</span> + end);<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 当数据分解的范围小于设定的阈值后才会真正执行计算求sum</span><br>        <span class="hljs-keyword">if</span> ((end - start) &lt; THRESHOLD) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>                sum += i;<br>            &#125;<br>        <span class="hljs-comment">// 任务拆解范围如果还大于阈值，线程工作不参与求值计算，而是进行任务分解后求sum</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> (end + start) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">Calculator</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(start, middle);<br>            <span class="hljs-type">Calculator</span> <span class="hljs-variable">rigth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(middle + <span class="hljs-number">1</span>, end);<br><br>            <span class="hljs-comment">//分解</span><br>            left.fork();<br>            rigth.fork();<br><br>            <span class="hljs-comment">//合并</span><br>            sum = left.join() + rigth.join();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>        Future&lt;Integer&gt; result = forkJoinPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));<br>        System.out.println(result.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/java_example/edit/master/-/src/test/java/com/wgf/unit/thread/ThreadLocalTest.java">在线参考</a></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/ThreadLocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>ThreadLocal是Java中的一个线程局部变量，用于在多线程环境下实现线程的数据隔离。它主要解决的问题是让每个线程都拥有自己的局部变量副本，避免了线程间的数据共享问题</p><p class="note note-primary">ThreadLocal数据存储</p><p>数据直接存储在线程对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br> 	...<br><br>    <span class="hljs-comment">// ThreadLocalMap用于支持一个线程使用多个ThreadLocal   </span><br>    <span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment">     * by the ThreadLocal class. */</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">/*可继承的ThreadLocalMap，用于在父子线程间传递，在Thread构造函数中，如果父线程的这个属性不为空，子线程会复制一个一样的Map</span><br><span class="hljs-comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span><br><span class="hljs-comment">     * maintained by the InheritableThreadLocal class.</span><br><span class="hljs-comment">     */</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>...<br></code></pre></td></tr></table></figure><p class="note note-primary">用法</p><p<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal&lt;User&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试是否每个线程都有副本</span><br><span class="hljs-comment">     * 结果每个hashCode都不同</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hashCodeTest</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                log.info(<span class="hljs-string">&quot;thread：&#123;&#125; hashCode：&#123;&#125;&quot;</span>, Thread.currentThread().getName(), threadLocal.get().hashCode());<br>            &#125;).start();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table><p></p><p class="note note-primary">父子线程不共享ThreadLocal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subThreadTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> threadLocal.get();<br>    user.setName(<span class="hljs-string">&quot;hello&quot;</span>);<br>    threadLocal.set(user);<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, threadLocal.get().getName()); <span class="hljs-comment">// null</span><br>    &#125;).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">核心源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    ...<br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//可继承的ThreadLocalMap，用于在父子线程间传递，在Thread构造函数中，如果父线程的这个属性不为空，子线程会复制一个一样的Map</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    ...<br>&#125;        <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 设置初始值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="hljs-title function_">withInitial</span><span class="hljs-params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier;<br><br>        SuppliedThreadLocal(Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; supplier) &#123;<br>            <span class="hljs-built_in">this</span>.supplier = Objects.requireNonNull(supplier);<br>        &#125;<br><br>        <span class="hljs-comment">// 其实就是返回用户在创建Threadlocal时指定的初始值</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> supplier.get();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取当前线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 获取线程里的 threadLocals</span><br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-comment">// 如果 ThreadLocalMap 不为空，则根据当前 ThreadLocal 去map中获取value</span><br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 线程第一次使用ThreadLocal则创建ThreadLocalMap 并赋予初始值</span><br>        <span class="hljs-keyword">return</span> setInitialValue();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取用户定义withInitial方法给的初始值</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 创建ThreadLocalMap并赋值到线程里的 threadLocals</span><br>            createMap(t, value);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-comment">// 通过Thread获取Map</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-comment">// 如果map不为空，则通过当前ThreadLocal作为key去获取value</span><br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// map为空则创建value</span><br>            createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">ThreadLocal Key 的内存泄露</p><p><a href="/2022/03/29/jvm/#java%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BC%95%E7%94%A8">java存在的引用</a></p><p>如果 <code>ThreadLocal</code> 的引用丢失了（退出了定义ThreadLocal的方法），但是线程还存活，那ThreadLocal是否不会被释放？因为ThreadLocal被当作Key存在线程的 <code>ThreadLocalMap</code> 中，而导致内存泄漏？</p><p><code>防止Key的内存泄露</code>：答案是否定的，当<code>ThreadLocal</code> 的引用丢失线程依然存活，丢失的<code>ThreadLocal</code> 能被回收！原因就是<code>ThreadLocalMap</code> 的Key是一个 <code>弱引用</code>，就算被GC回收了，再次调用 <code>ThreadLocal</code> 的 get 方法生成一个副本即可</p><p>DK建议ThreadLocal定义为<code>private static</code>，这样ThreadLocal的弱引用问题则不存在了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// Thread 源码 </span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>       <span class="hljs-comment">// key是一个弱引用</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>           <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>           Object value;<br><br>           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>               <span class="hljs-built_in">super</span>(k);<br>               value = v;<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">ThreadLocal value 的内存泄露</p><p>当 <code>弱引用</code> 的key（ThreadLocal）被GC线程回收了但是线程依然存活，此时 <code>ThreadLocalMap</code> 里的 value 会因为 key 被回收无法使用（再内存中但是无法通过key获取）从而造成内存泄漏问题，JDK是如何解决的？</p><p><span class="green-line">只要在使用完 ThreadLocal 对象之后，及时调用 remove 方法， 移除 Entry 即可</span></p><h3 id="inheritablethreadlocal"><a class="markdownIt-Anchor" href="#inheritablethreadlocal"></a> InheritableThreadLocal</h3><p>在Thread的构造函数调用<code>init</code>函数中，如果<code>父线程</code>的<code>inheritableThreadLocals</code>的属性不为空，子线程就会复制一份保存到当前的<code>inheritableThreadLocals</code>（浅拷贝，重新创建一个map）属性中，以便于实现ThreadLocal的继承</p><p class="note note-primary">线程间传值</p><p>父线程共享数据给子线程，但是父子线程之间相互独立，互不影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> InheritableThreadLocal&lt;User&gt; inheritableThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inheritableThreadLocalTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;hello&quot;</span>);<br>    inheritableThreadLocal.set(user);<br>    log.info(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, inheritableThreadLocal.get().getName()); <span class="hljs-comment">// hello</span><br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">us</span> <span class="hljs-operator">=</span> inheritableThreadLocal.get();<br>        log.info(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, us.getName()); <span class="hljs-comment">// hello</span><br>        us.setName(<span class="hljs-string">&quot;test2&quot;</span>);<br>    &#125;).start();<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transmittablethreadlocal"><a class="markdownIt-Anchor" href="#transmittablethreadlocal"></a> TransmittableThreadLocal</h3><p><code>解决池化线程复用，实现父线程对ThreadLocal的修改池化线程能够感知到</code></p><p>​	在异步线程之间，实现跨线程的ThreadLocal传递, 简单场景可以用InheritableThreadLocal，但ITL在线程池化场景下不适用，因为ITL是在子线程初始化时，拷贝了父线程的ThreadLocal，但池化场景，子线程是会被多次复用的，但ITL只能在子线程第一次创建时，传递ThreadLocal，之后的复用都无法重新设置ThreadLocal。于是TransmittableThreadLocal出现了，可以解决ThreadLocal在线程池化场景下的传递问题</p><p>​	若希望 <code>TransmittableThreadLocal</code> 在线程池与主线程间传递，需配合 <code>TtlRunnable</code> 和 <code>TtlCallable</code> 使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TransmittableThreadLocal&lt;Integer&gt; transmittableThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransmittableThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transmittableThreadLocalTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br><br>    transmittableThreadLocal.set(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// transmittableThreadLocal 输出1， InheritableThreadLocal 输出1</span><br>    executorService.submit(TtlRunnable.get(() -&gt; log.info(<span class="hljs-string">&quot;value=&#123;&#125;&quot;</span>, transmittableThreadLocal.get())));<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>    transmittableThreadLocal.set(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// transmittableThreadLocal 输出2， InheritableThreadLocal 输出1</span><br>    executorService.submit(TtlRunnable.get(() -&gt; log.info(<span class="hljs-string">&quot;value=&#123;&#125;&quot;</span>, transmittableThreadLocal.get())));<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><br>    transmittableThreadLocal.set(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// transmittableThreadLocal 输出3， InheritableThreadLocal 输出1</span><br>    executorService.submit(TtlRunnable.get(() -&gt; log.info(<span class="hljs-string">&quot;value=&#123;&#125;&quot;</span>, transmittableThreadLocal.get())));<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="exchanger"><a class="markdownIt-Anchor" href="#exchanger"></a> Exchanger</h2><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-juc-tool-exchanger.html">详解</a></p><p><code>Exchanger</code>是Java中的一个同步工具类，用于实现两个线程之间的数据交换。它提供了一个同步点，在这个同步点，两个线程可以交换彼此的数据。当一个线程调用<code>exchange()</code>方法时，它会被阻塞，直到另一个线程也调用了<code>exchange()</code>方法，然后两个线程将彼此的数据进行交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerTest</span> &#123;<br><br> <span class="hljs-meta">@SneakyThrows</span><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 定义交换机</span><br>     Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;value1&quot;</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// 交换数据</span><br>              value1 = exchanger.exchange(value1);<br>             log.info(<span class="hljs-string">&quot;线程1交换数据 value1 = &#123;&#125;&quot;</span>, value1);<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>     &#125;).start();<br><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;value2&quot;</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-comment">// 交换数据</span><br>             value2 = exchanger.exchange(value2);<br>             log.info(<span class="hljs-string">&quot;线程2交换数据 value2 = &#123;&#125;&quot;</span>, value2);<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>     &#125;).start();<br><br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br> &#125;<br><br><span class="hljs-comment">//    线程1交换数据 value1 = value2</span><br><span class="hljs-comment">//    线程1交换数据 value2 = value1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="unsafe-魔法类"><a class="markdownIt-Anchor" href="#unsafe-魔法类"></a> Unsafe 魔法类</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/unsafe.html#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C">Java guide</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/java_example/edit/master/-/src/test/java/com/wgf/unit/unsafe/UnsafeArrayTest.java">在线example参考</a></p><h2 id="locksupport"><a class="markdownIt-Anchor" href="#locksupport"></a> LockSupport</h2><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html#juc%E9%94%81-locksupport%E8%AF%A6%E8%A7%A3">参考</a></p><p>LockSupport是Java中提供的一个用于线程阻塞和唤醒的工具类。可以实现更加灵活的线程同步和通信。</p><p>最重要的方法是park()和unpark()。park()方法用于使当前线程进入阻塞状态，而unpark()方法则用于唤醒被阻塞的线程。</p><p><strong>LockSupport中的<code>blocker</code></strong></p><p>获取其偏移量源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        UNSAFE = sun.misc.Unsafe.getUnsafe();<br>        Class&lt;?&gt; tk = Thread.class;<br>        parkBlockerOffset = UNSAFE.objectFieldOffset<br>            (tk.getDeclaredField(<span class="hljs-string">&quot;parkBlocker&quot;</span>));<br>        SEED = UNSAFE.objectFieldOffset<br>            (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSeed&quot;</span>));<br>        PROBE = UNSAFE.objectFieldOffset<br>            (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomProbe&quot;</span>));<br>        SECONDARY = UNSAFE.objectFieldOffset<br>            (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSecondarySeed&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据对<code>Unsafe</code>的理解可知，<code>blocker</code>其实就是通过<code>Unsafe</code>去操作<code>Thread</code>的<code>parkBlocker</code>属性</p><p><code>parkBlocker</code>是<code>Thread</code>类中的成员变量，<span style="border-bottom:2px dashed green">记录了当前线程阻塞时是被谁阻塞的，用于线程监控和分析</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportTest</span> &#123;<br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkTest</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Thread</span> <span class="hljs-variable">mainThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br>     <span class="hljs-comment">// 子线程3秒后唤醒父线程</span><br>     <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>             log.info(<span class="hljs-string">&quot;唤醒父线程&quot;</span>);<br>             LockSupport.unpark(mainThread);<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br>     &#125;).start();<br><br>     log.info(<span class="hljs-string">&quot;父线程开始阻塞&quot;</span>);<br>     LockSupport.park();<br>     log.info(<span class="hljs-string">&quot;父线程被唤醒&quot;</span>);<br> &#125;<br><span class="hljs-comment">//    16:38:00.410 [main] INFO com.wgf.unit.lock.LockSupportTest - 父线程开始阻塞</span><br><span class="hljs-comment">//    16:38:03.417 [Thread-1] INFO com.wgf.unit.lock.LockSupportTest - 唤醒父线程</span><br><span class="hljs-comment">//    16:38:03.418 [main] INFO com.wgf.unit.lock.LockSupportTest - 父线程被唤醒</span><br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanosTest</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 指定阻塞多少纳秒</span><br>     log.info(<span class="hljs-string">&quot;线程开始阻塞&quot;</span>);<br>     LockSupport.parkNanos(<span class="hljs-number">2</span> * <span class="hljs-number">1000000000L</span>);<br>     log.info(<span class="hljs-string">&quot;线程唤醒&quot;</span>);<br> &#125;<br><span class="hljs-comment">//    16:40:35.576 [main] INFO com.wgf.unit.lock.LockSupportTest - 线程开始阻塞</span><br><span class="hljs-comment">//    16:40:37.583 [main] INFO com.wgf.unit.lock.LockSupportTest - 线程唤醒</span><br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 指定休眠多少ms, ms = 现在的毫秒数 + 需要阻塞的 step</span><br>     <span class="hljs-type">long</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>     ms += <span class="hljs-number">2</span> * <span class="hljs-number">1000</span>;<br><br>     log.info(<span class="hljs-string">&quot;线程开始阻塞&quot;</span>);<br>     LockSupport.parkUntil(ms);<br>     log.info(<span class="hljs-string">&quot;线程唤醒&quot;</span>);<br> &#125;<br><span class="hljs-comment">//    16:43:01.519 [main] INFO com.wgf.unit.lock.LockSupportTest - 线程开始阻塞</span><br><span class="hljs-comment">//    16:43:03.524 [main] INFO com.wgf.unit.lock.LockSupportTest - 线程唤醒</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="网络io"><a class="markdownIt-Anchor" href="#网络io"></a> 网络IO</h1><p><strong>何为 I/O?</strong></p><blockquote><p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong></p></blockquote><p><strong>我们先从计算机结构的角度来解读一下 I/O</strong></p><p>根据<strong>冯.诺依曼结构</strong>，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.png" srcset="/img/loading.gif" lazyload alt></p><p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备</p><p><strong>输入设备向计算机输入数据，输出设备接收计算机输出的数据</strong></p><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程</strong></p><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong></p><br><ul><li>read系统调用，并不是把数据直接从物理设备，读数据到内存。write系统调用，也不是直接把数据，写入到物理设备</li><li>read系统调用，是把数据从<strong>内核缓冲区复制到进程缓冲区</strong>；而write系统调用，是把数据从<strong>进程缓冲区复制到内核缓冲区</strong>。这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的</li></ul><br><p><strong>内核缓冲与进程缓冲区</strong></p><p>缓冲区的目的，是为了减少频繁的系统IO调用。大家都知道，系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要恢复之前的信息，为了减少这种损耗时间、也损耗性能的系统调用，于是出现了缓冲区。</p><p>有了缓冲区，操作系统使用read函数把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区中。等待缓冲区达到一定数量的时候，再进行IO的调用，提升性能。至于什么时候读取和存储则由内核来决定，用户程序不需要关心。</p><p>在linux系统中，系统内核也有个缓冲区叫做内核缓冲区。每个进程有自己独立的缓冲区，叫做进程缓冲区。</p><p>所以，用户程序的IO读写程序，大多数情况下，并没有进行实际的IO操作，而是在读写自己的进程缓冲区。</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA.png" srcset="/img/loading.gif" lazyload alt></p><br><br><h3 id="bioblocking-io"><a class="markdownIt-Anchor" href="#bioblocking-io"></a> BIO（blocking IO ）</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong></p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间 (比如读一个大文件，需要把文件都读取完毕后才能继续往下执行)</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/IO.png" srcset="/img/loading.gif" lazyload alt></p><p>​	在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量</p><br><br><h3 id="nio-nonblocking-io"><a class="markdownIt-Anchor" href="#nio-nonblocking-io"></a> NIO (nonblocking IO)</h3><p><strong>同步非阻塞 I/O</strong></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/10225159.html">10 分钟看懂， Java NIO 底层原理</a></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>架构图</strong></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A82.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p><strong>选择器Selector</strong>: 可以理解为一个IO事件的监听与查询器。通过选择器，一个线程可以查询多个通道的IO事件的就绪状态</p></li><li><p><strong>通道 Channel</strong>：在NIO中，一个网络连接使用一个通道表示，所有NIO的IO操作都是通过连接通道完成的。一个通道类似于BIO中两个流的结合体，既可以从通道读取数据，也可以向通道写入数据（代表用户的一个链接）</p></li><li><p><strong>缓冲区 Buffer</strong>: 缓冲区本质上是一个可以读写数据的内存块，可以理解为是一个<code>容器对象（含数组）</code>，Channel要读写数据必须经过缓冲区</p></li></ul><br><p><strong>IO多路复用</strong>: 服务端的一个线程可以处理多个客户端请求</p><p>​	从编程实现维度来说，IO多路复用编程的第一步是把通道注册到选择器中，第二步是通过选择器所提供的事件查询（select）方法来查询这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。由于一个选择器只需要一个线程进行监控，因此我们可以很简单地使用一个线程，通过选择器去管理多个连接通道</p><br><ul><li>BIO 在读不到请求数据的情况下会选择阻塞，这样就无法处理其他客户端的请求<ul><li>当然BIO也可以对每个客户端创建一个线程，做伪异步，在新建的线程里阻塞请求（read调用），直到能读取数据。但是这样如果有1000个链接就需要创建1000个线程，对系统开销太大，无法满足高并发场景</li></ul></li><li>由于BIO的阻塞问题，NIO就提出了多路复用，每次都先调用select、epoll函数去查询有没有活跃的链接，如果没有活跃的链接也不进行阻塞操作，本次空循环进入下次循环继续查看是否有活跃的链接，有的话调用read函数将数据从内核缓存区复制到进程缓冲区（阻塞），执行业务逻辑后再将数据由进程缓冲区复制到内核缓冲区再到网卡，最终响应给客户端。这样的好处就是做到IO多路复用，服务器的一个线程能够处理多个客户端的请求（selector组件）</li></ul><br><br><h3 id="aio-asynchronous-io"><a class="markdownIt-Anchor" href="#aio-asynchronous-io"></a> AIO (asynchronous IO)</h3><p><strong>异步 I/O</strong></p><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型</p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/%E5%BC%82%E6%AD%A5.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/13/java%E6%BA%90%E7%A0%81/IO%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><br><br><h3 id="tcp-upd"><a class="markdownIt-Anchor" href="#tcp-upd"></a> TCP UPD</h3><br><br><h3 id="序列化-2"><a class="markdownIt-Anchor" href="#序列化-2"></a> 序列化</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></figure></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>java源码</div><div>https://wugengfeng.cn/2022/04/13/java源码/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年4月13日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">设计模式</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/04/07/Mybatis/" title="Mybatis"><span class="hidden-mobile">Mybatis</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>