<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="友情连接 http:&#x2F;&#x2F;coderead.cn&#x2F;   JDBC 完整的JDBC查询过程  加载驱动 连接数据库 预编译sql 执行操作 获取结果  12345678910111213141516171819202122232425262728293031@Slf4jpublic class JdbcTest &amp;#123;    public static void main(String[] ar"><meta property="og:type" content="article"><meta property="og:title" content="Mybatis"><meta property="og:url" content="https://wugengfeng.cn/2022/04/07/Mybatis/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="友情连接 http:&#x2F;&#x2F;coderead.cn&#x2F;   JDBC 完整的JDBC查询过程  加载驱动 连接数据库 预编译sql 执行操作 获取结果  12345678910111213141516171819202122232425262728293031@Slf4jpublic class JdbcTest &amp;#123;    public static void main(String[] ar"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/mybatis.png"><meta property="article:published_time" content="2022-04-07T14:24:25.000Z"><meta property="article:modified_time" content="2023-07-14T06:49:15.080Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/mybatis.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>Mybatis - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Mybatis"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-04-07 22:24" pubdate>2022年4月7日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 30k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 248 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Mybatis</h1><div class="markdown-body"><p>友情连接 <a target="_blank" rel="noopener" href="http://coderead.cn/">http://coderead.cn/</a></p><p><img src="https://img-blog.csdnimg.cn/20200728112447216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0h1TmFuTGVpbQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt></p><h2 id="jdbc"><a class="markdownIt-Anchor" href="#jdbc"></a> JDBC</h2><p>完整的JDBC查询过程</p><ul><li>加载驱动</li><li>连接数据库</li><li>预编译sql</li><li>执行操作</li><li>获取结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br><br>        <span class="hljs-comment">// 加载驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br><br>        <span class="hljs-comment">// 获取连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-comment">// 预编译sql</span><br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * from tb_user where id = ?&quot;</span>);<br><br>        <span class="hljs-comment">// 设置参数，防止sql注入</span><br>        preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 执行查询</span><br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br><br>        <span class="hljs-comment">// 获取查询数据</span><br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>);<br><br>            log.info(<span class="hljs-string">&quot;id: &#123;&#125;&quot;</span>, id);<br>            log.info(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, name);<br>            log.info(<span class="hljs-string">&quot;age: &#123;&#125;&quot;</span>, age);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="mybtais-核心组件介绍"><a class="markdownIt-Anchor" href="#mybtais-核心组件介绍"></a> Mybtais 核心组件介绍</h2><h3 id="configuration"><a class="markdownIt-Anchor" href="#configuration"></a> Configuration</h3><p><img src="/2022/04/07/Mybatis/configuration.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Configuration</span> &#123;<br><br>  <span class="hljs-comment">// &lt;environment&gt;节点的信息</span><br>  <span class="hljs-keyword">protected</span> Environment environment;<br><br>  <span class="hljs-comment">// 以下为&lt;settings&gt;节点中的配置信息</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> safeRowBoundsEnabled;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">safeResultHandlerEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> mapUnderscoreToCamelCase;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> aggressiveLazyLoading;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">multipleResultSetsEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> useGeneratedKeys;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">useColumnLabel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">cacheEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> callSettersOnNulls;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">useActualParamName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> returnInstanceForEmptyRow;<br><br>  <span class="hljs-keyword">protected</span> String logPrefix;<br>  <span class="hljs-keyword">protected</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Log</span>&gt; logImpl;<br>  <span class="hljs-keyword">protected</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">VFS</span>&gt; vfsImpl;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">LocalCacheScope</span> <span class="hljs-variable">localCacheScope</span> <span class="hljs-operator">=</span> LocalCacheScope.SESSION;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">JdbcType</span> <span class="hljs-variable">jdbcTypeForNull</span> <span class="hljs-operator">=</span> JdbcType.OTHER;<br>  <span class="hljs-keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;equals&quot;</span>, <span class="hljs-string">&quot;clone&quot;</span>, <span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>));<br>  <span class="hljs-keyword">protected</span> Integer defaultStatementTimeout;<br>  <span class="hljs-keyword">protected</span> Integer defaultFetchSize;<br>  <span class="hljs-keyword">protected</span> ResultSetType defaultResultSetType;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">ExecutorType</span> <span class="hljs-variable">defaultExecutorType</span> <span class="hljs-operator">=</span> ExecutorType.SIMPLE;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">AutoMappingBehavior</span> <span class="hljs-variable">autoMappingBehavior</span> <span class="hljs-operator">=</span> AutoMappingBehavior.PARTIAL;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">AutoMappingUnknownColumnBehavior</span> <span class="hljs-variable">autoMappingUnknownColumnBehavior</span> <span class="hljs-operator">=</span> AutoMappingUnknownColumnBehavior.NONE;<br>  <span class="hljs-comment">// 以上为&lt;settings&gt;节点中的配置信息</span><br><br>  <span class="hljs-comment">// &lt;properties&gt;节点信息</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">variables</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>  <span class="hljs-comment">// 反射工厂</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">ReflectorFactory</span> <span class="hljs-variable">reflectorFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultReflectorFactory</span>();<br>  <span class="hljs-comment">// 对象工厂</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">ObjectFactory</span> <span class="hljs-variable">objectFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultObjectFactory</span>();<br>  <span class="hljs-comment">// 对象包装工厂</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">ObjectWrapperFactory</span> <span class="hljs-variable">objectWrapperFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultObjectWrapperFactory</span>();<br>  <span class="hljs-comment">// 是否启用懒加载，该配置来自&lt;settings&gt;节点</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lazyLoadingEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 代理工厂</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JavassistProxyFactory</span>(); <span class="hljs-comment">// #224 Using internal Javassist instead of OGNL</span><br>  <span class="hljs-comment">// 数据库编号</span><br>  <span class="hljs-keyword">protected</span> String databaseId;<br>  <span class="hljs-comment">// 配置工厂，用来创建用于加载反序列化的未读属性的配置。</span><br>  <span class="hljs-keyword">protected</span> Class&lt;?&gt; configurationFactory;<br>  <span class="hljs-comment">// 映射注册表</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MapperRegistry</span> <span class="hljs-variable">mapperRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperRegistry</span>(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-comment">// 拦截器链（用来支持插件的插入）</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InterceptorChain</span> <span class="hljs-variable">interceptorChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterceptorChain</span>();<br>  <span class="hljs-comment">// 类型处理器注册表，内置许多，可以通过&lt;typeHandlers&gt;节点补充</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TypeHandlerRegistry</span> <span class="hljs-variable">typeHandlerRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeHandlerRegistry</span>();<br>  <span class="hljs-comment">// 类型别名注册表，内置许多，可以通过&lt;typeAliases&gt;节点补充</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TypeAliasRegistry</span> <span class="hljs-variable">typeAliasRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeAliasRegistry</span>();<br>  <span class="hljs-comment">// 语言驱动注册表</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LanguageDriverRegistry</span> <span class="hljs-variable">languageRegistry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LanguageDriverRegistry</span>();<br>  <span class="hljs-comment">// 映射的数据库操作语句</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrictMap</span>&lt;MappedStatement&gt;(<span class="hljs-string">&quot;Mapped Statements collection&quot;</span>)<br>      .conflictMessageProducer((savedValue, targetValue) -&gt;<br>          <span class="hljs-string">&quot;. please check &quot;</span> + savedValue.getResource() + <span class="hljs-string">&quot; and &quot;</span> + targetValue.getResource());<br>  <span class="hljs-comment">// 缓存</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, Cache&gt; caches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrictMap</span>&lt;&gt;(<span class="hljs-string">&quot;Caches collection&quot;</span>);<br>  <span class="hljs-comment">// 结果映射，即所有的&lt;resultMap&gt;节点</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrictMap</span>&lt;&gt;(<span class="hljs-string">&quot;Result Maps collection&quot;</span>);<br>  <span class="hljs-comment">// 参数映射，即所有的&lt;parameterMap&gt;节点</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrictMap</span>&lt;&gt;(<span class="hljs-string">&quot;Parameter Maps collection&quot;</span>);<br>  <span class="hljs-comment">// 主键生成器映射</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrictMap</span>&lt;&gt;(<span class="hljs-string">&quot;Key Generators collection&quot;</span>);<br>  <span class="hljs-comment">// 载入的资源，例如映射文件资源</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; loadedResources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>  <span class="hljs-comment">// SQL语句片段，即所有的&lt;sql&gt;节点</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, XNode&gt; sqlFragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrictMap</span>&lt;&gt;(<span class="hljs-string">&quot;XML fragments parsed from previous mappers&quot;</span>);<br><br>  <span class="hljs-comment">// 暂存未处理完成的一些节点</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;XMLStatementBuilder&gt; incompleteStatements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;ResultMapResolver&gt; incompleteResultMaps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;MethodResolver&gt; incompleteMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>  <span class="hljs-comment">// 用来存储跨namespace的缓存共享设置</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; cacheRefMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Configuration</span><span class="hljs-params">(Environment environment)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    <span class="hljs-built_in">this</span>.environment = environment;<br>  &#125;<br>....<br></code></pre></td></tr></table></figure><br><p>​	<strong>Mybatis 上下文配置，项目启动会根据配置的<code>mapperLocations</code>加载解析XML文件，最终将解析好的XML配置信息装载到自身属性中，在<code>SqlSessionFactoryBean</code>的<code>afterPropertiesSet</code>方法中被创建</strong></p><ul><li>interceptorChain 拦截器链</li><li>typeHandlerRegistry 类型处理器</li><li>typeAliasRegistry 别名处理器</li><li>resultMaps 返回结果映射</li><li>keyGenerators主键生成映射</li><li>mappedStatements 数据库语句映射（mapper 文件sql）</li><li>sqlFragments SQL语句片段，即所有的<sql>节点</sql></li><li>caches 缓存（一级缓存）</li></ul><p>…</p><br><br><h3 id="sqlsessionfactory"><a class="markdownIt-Anchor" href="#sqlsessionfactory"></a> SqlSessionFactory</h3><p><img src="/2022/04/07/Mybatis/SqlSessionFactory_uml.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/07/Mybatis/SqlSessionFactory.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SqlSessionFactory</span> &#123;<br><br>  <span class="hljs-comment">//8个方法可以用来创建SqlSession实例</span><br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">()</span>;<br>  <span class="hljs-comment">//自动提交</span><br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span>;<br>  <span class="hljs-comment">//连接</span><br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(Connection connection)</span>;<br>  <span class="hljs-comment">//事务隔离级别</span><br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(TransactionIsolationLevel level)</span>;<br>  <span class="hljs-comment">//执行器的类型</span><br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(ExecutorType execType)</span>;<br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(ExecutorType execType, <span class="hljs-type">boolean</span> autoCommit)</span>;<br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level)</span>;<br>  SqlSession <span class="hljs-title function_">openSession</span><span class="hljs-params">(ExecutorType execType, Connection connection)</span>;<br><br>  <span class="hljs-comment">// 持有全局配置 </span><br>  Configuration <span class="hljs-title function_">getConfiguration</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>​	<strong>SqlSession会话工厂，用于获取SqlSession。通过<code>SqlSessionFactoryBean</code>的<code>getObject</code>方法创建，创建SqlSessionFactory的前提是解析Mapper配置文件创建Configuration对象后创建，因为DefaultSqlSessionFactory构造函数需要Configuration参数</strong></p><br><h3 id="sqlsession"><a class="markdownIt-Anchor" href="#sqlsession"></a> SqlSession</h3><p><img src="/2022/04/07/Mybatis/sqlSession_uml.jpg" srcset="/img/loading.gif" lazyload alt></p><br><p><img src="/2022/04/07/Mybatis/SqlSession%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt></p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SqlSession</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Closeable</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a single row mapped from the statement key</span><br><span class="hljs-comment">   * 根据指定的SqlID获取一条记录的封装对象</span><br><span class="hljs-comment">   */</span><br>  &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a single row mapped from the statement key and parameter.</span><br><span class="hljs-comment">   * 根据指定的SqlID获取一条记录的封装对象，只不过这个方法容许我们可以给sql传递一些参数</span><br><span class="hljs-comment">   * 一般在实际使用中，这个参数传递的是pojo，或者Map或者ImmutableMap</span><br><span class="hljs-comment">   */</span><br>  &lt;T&gt; T <span class="hljs-title function_">selectOne</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a list of mapped objects from the statement key and parameter.</span><br><span class="hljs-comment">   * 根据指定的sqlId获取多条记录</span><br><span class="hljs-comment">   */</span><br>  &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a list of mapped objects from the statement key and parameter.</span><br><span class="hljs-comment">   * 获取多条记录，这个方法容许我们可以传递一些参数</span><br><span class="hljs-comment">   */</span><br>  &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a list of mapped objects from the statement key and parameter,</span><br><span class="hljs-comment">   * within the specified row bounds.</span><br><span class="hljs-comment">   * 获取多条记录，这个方法容许我们可以传递一些参数，不过这个方法容许我们进行</span><br><span class="hljs-comment">   * 分页查询。</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 需要注意的是默认情况下，Mybatis为了扩展性，仅仅支持内存分页。也就是会先把</span><br><span class="hljs-comment">   * 所有的数据查询出来以后，然后在内存中进行分页。因此在实际的情况中，需要注意</span><br><span class="hljs-comment">   * 这一点。</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 一般情况下公司都会编写自己的Mybatis 物理分页插件</span><br><span class="hljs-comment">   */</span><br>  &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * The selectMap is a special case in that it is designed to convert a list</span><br><span class="hljs-comment">   * of results into a Map based on one of the properties in the resulting</span><br><span class="hljs-comment">   * objects.</span><br><span class="hljs-comment">   * Eg. Return a of Map[Integer,Author] for selectMap(&quot;selectAuthors&quot;,&quot;id&quot;)</span><br><span class="hljs-comment">   * 将查询到的结果列表转换为Map类型。</span><br><span class="hljs-comment">   */</span><br>  &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title function_">selectMap</span><span class="hljs-params">(String statement, String mapKey)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * The selectMap is a special case in that it is designed to convert a list</span><br><span class="hljs-comment">   * of results into a Map based on one of the properties in the resulting</span><br><span class="hljs-comment">   * objects.</span><br><span class="hljs-comment">   * 将查询到的结果列表转换为Map类型。这个方法容许我们传入需要的参数</span><br><span class="hljs-comment">   */</span><br>  &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title function_">selectMap</span><span class="hljs-params">(String statement, Object parameter, String mapKey)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * The selectMap is a special case in that it is designed to convert a list</span><br><span class="hljs-comment">   * of results into a Map based on one of the properties in the resulting</span><br><span class="hljs-comment">   * objects.</span><br><span class="hljs-comment">   * 获取多条记录,加上分页,并存入Map</span><br><span class="hljs-comment">   */</span><br>  &lt;K, V&gt; Map&lt;K, V&gt; <span class="hljs-title function_">selectMap</span><span class="hljs-params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(String statement, Object parameter, ResultHandler handler)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a single row mapped from the statement</span><br><span class="hljs-comment">   * using a &#123;<span class="hljs-doctag">@code</span> ResultHandler&#125;.</span><br><span class="hljs-comment">   * 获取一条记录,并转交给ResultHandler处理。这个方法容许我们自己定义对</span><br><span class="hljs-comment">   * 查询到的行的处理方式。不过一般用的并不是很多</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(String statement, ResultHandler handler)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve a single row mapped from the statement key and parameter</span><br><span class="hljs-comment">   * using a &#123;<span class="hljs-doctag">@code</span> ResultHandler&#125; and &#123;<span class="hljs-doctag">@code</span> RowBounds&#125;</span><br><span class="hljs-comment">   * 获取一条记录,加上分页,并转交给ResultHandler处理</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute an insert statement.</span><br><span class="hljs-comment">   * 插入记录。一般情况下这个语句在实际项目中用的并不是太多，而且更多使用带参数的insert函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String statement)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute an insert statement with the given parameter object. Any generated</span><br><span class="hljs-comment">   * autoincrement values or selectKey entries will modify the given parameter</span><br><span class="hljs-comment">   * object properties. Only the number of rows affected will be returned.</span><br><span class="hljs-comment">   * 插入记录，容许传入参数。 注意返回的是受影响的行数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute an update statement. The number of rows affected will be returned.</span><br><span class="hljs-comment">   * 更新记录。返回的是受影响的行数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String statement)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute an update statement. The number of rows affected will be returned.</span><br><span class="hljs-comment">   * 更新记录 返回的是受影响的行数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute a delete statement. The number of rows affected will be returned.</span><br><span class="hljs-comment">   * 删除记录 返回的是受影响的行数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String statement)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Execute a delete statement. The number of rows affected will be returned.</span><br><span class="hljs-comment">   * 删除记录 返回的是受影响的行数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String statement, Object parameter)</span>;<br><br>  <span class="hljs-comment">//以下是事务控制方法,commit,rollback</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> force)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(<span class="hljs-type">boolean</span> force)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Flushes batch statements.</span><br><span class="hljs-comment">   * 刷新批处理语句,返回批处理结果</span><br><span class="hljs-comment">   */</span><br>  List&lt;BatchResult&gt; <span class="hljs-title function_">flushStatements</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Closes the session</span><br><span class="hljs-comment">   * 关闭Session</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Clears local session cache</span><br><span class="hljs-comment">   * 清理Session缓存</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearCache</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieves current configuration</span><br><span class="hljs-comment">   * 得到配置</span><br><span class="hljs-comment">   */</span><br>  Configuration <span class="hljs-title function_">getConfiguration</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieves a mapper.</span><br><span class="hljs-comment">   * 得到映射器</span><br><span class="hljs-comment">   * 这个巧妙的使用了泛型，使得类型安全</span><br><span class="hljs-comment">   * 到了MyBatis 3，还可以用注解,这样xml都不用写了</span><br><span class="hljs-comment">   */</span><br>  &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieves inner database connection</span><br><span class="hljs-comment">   * 得到数据库连接</span><br><span class="hljs-comment">   */</span><br>  Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>​	<strong>数据库会话，使用<code>外观模式</code>提供操作数据库的方法，具体实现底层调用<code>Executor</code>，设计这一层的目的是对,外屏蔽Executor底层调用的复杂性,DefaultSqlSession中包含Executor对象</strong></p><p><strong>功能</strong></p><ul><li>数据库操作 RURD</li><li>事务管理 提交回滚事务</li><li>获取连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sqlSessionTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(ExecutorType.SIMPLE);<br>        List&lt;Object&gt; admin = sqlSession.selectList(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.queryByUserName&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>        admin = sqlSession.selectList(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.queryByUserName&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>        System.out.println(admin);<br>    &#125;<br></code></pre></td></tr></table></figure><br><br><h3 id="executor-执行器"><a class="markdownIt-Anchor" href="#executor-执行器"></a> Executor 执行器</h3><p><img src="/2022/04/07/Mybatis/executor_uml.jpg" srcset="/img/loading.gif" lazyload alt></p><p>Executor是MyBatis执行者接口，执行器的功能包括：</p><ul><li>基本功能：改、查，没有增删的原因是，所有的增删操作在JDBC都可以归结到改</li><li>缓存维护：这里的缓存主要是为一级缓存服务，功能包括创建缓存Key、清理缓存、判断缓存是否存在</li><li>事务管理：提交、回滚、关闭</li><li>批处理刷新</li></ul><p>单元测试公共代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Autowired</span><br>    SqlSessionFactory sqlSessionFactory;<br><br>    Configuration configuration;<br><br>    Connection connection;<br><br>    JdbcTransaction jdbcTransaction;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        connection = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&quot;</span><br>                , <span class="hljs-string">&quot;root&quot;</span><br>                , <span class="hljs-string">&quot;root&quot;</span>);<br><br>        configuration = sqlSessionFactory.getConfiguration();<br>        jdbcTransaction = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTransaction</span>(connection);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="baseexecutor"><a class="markdownIt-Anchor" href="#baseexecutor"></a> BaseExecutor</h4><p>​	<strong>将Executor的共性抽取出一个公共的父类</strong></p><p>​	基础执行器主要是用于维护缓存和事务。事务是通过会话中调用commit、rollback进行管理。重点在于缓存这块它是如何处理的? (<strong>这里的缓存是指一级缓存</strong>）,它实现了Executor中的<code>query</code>与<code>update</code>方法。会话中SQL请求，正是调用的这两个方法。<code>query</code>方法中处理一级缓存逻辑，即根据SQL及参数判断缓存中是否存在数据，有就走缓存。否则就会调用子类的<code>doQuery()</code> 方法去查询数据库,然后在设置缓存。在<code>doUpdate()</code> 中主要是用于清空缓存</p><br><p><strong>共性</strong></p><ul><li>一级缓存</li><li>事务管理 获取、提交、回滚、关闭</li><li>数据库基本操作 query,update (除了查询为的操作可归并为update)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 两条相同的sql只执行一次查询，原因是第二次直接从BaseExecutor中获取数据  BaseExecutor.query方法存在一级缓存逻辑</span><br><span class="hljs-comment">     * 执行逻辑，调用BaseExecutor.query 是否一级缓存命中，以及缓存又命中则再调用子类的doQuery进行数据库查询</span><br><span class="hljs-comment">     * c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt;  Preparing: select * from sys_user where username = ?</span><br><span class="hljs-comment">     * c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt; Parameters: admin(String)</span><br><span class="hljs-comment">     * c.w.m.s.dao.SysUserDao.queryByUserName   : &lt;==      Total: 1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">baseExecutor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">SimpleExecutor</span> <span class="hljs-variable">simpleExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>(configuration, jdbcTransaction);<br>        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.queryByUserName&quot;</span>);<br>        <span class="hljs-comment">// 相同的sql 会执两次</span><br>        List&lt;Object&gt; objects = simpleExecutor.query(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);<br>        objects = simpleExecutor.query(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER);<br>        System.out.println(objects);<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><br><h4 id="simpleexecutor"><a class="markdownIt-Anchor" href="#simpleexecutor"></a> SimpleExecutor</h4><p><strong>SimpleExecutor是默认执行器</strong>，它的行为是每处理一次会话当中的SQl请求都会通过对应的StatementHandler 构建一个新个Statement，这就会导致即使是相同SQL语句也无法重用Statement,所以就有了（ReuseExecutor）可重用执行器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleExecutor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">SimpleExecutor</span> <span class="hljs-variable">simpleExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>(configuration, jdbcTransaction);<br>        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.queryByUserName&quot;</span>);<br>        List&lt;Object&gt; objects = simpleExecutor.doQuery(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, mappedStatement.getBoundSql(<span class="hljs-string">&quot;admin&quot;</span>));<br>        objects = simpleExecutor.doQuery(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, mappedStatement.getBoundSql(<span class="hljs-string">&quot;admin&quot;</span>));<br>        System.out.println(objects);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志中预编译了2次sql, 输出两次Preparing</span><br><span class="hljs-comment">     * 2022-04-03 14:52:31.416 DEBUG 15120 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt;  Preparing: select * from sys_user where username = ?</span><br><span class="hljs-comment">     * 2022-04-03 14:52:31.416 DEBUG 15120 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt; Parameters: admin(String)</span><br><span class="hljs-comment">     * 2022-04-03 14:52:31.431 DEBUG 15120 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : &lt;==      Total: 1</span><br><span class="hljs-comment">     * 2022-04-03 14:52:31.431 DEBUG 15120 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt;  Preparing: select * from sys_user where username = ?</span><br><span class="hljs-comment">     * 2022-04-03 14:52:31.431 DEBUG 15120 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt; Parameters: admin(String)</span><br><span class="hljs-comment">     * 2022-04-03 14:52:31.431 DEBUG 15120 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : &lt;==      Total: 1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     */</span><br></code></pre></td></tr></table></figure><br><h4 id="reuseexecutor"><a class="markdownIt-Anchor" href="#reuseexecutor"></a> ReuseExecutor</h4><p>​	<strong>重用的是 PreparedStatemen对象，减少预编译sql次数</strong></p><p>​	ReuseExecutor 区别在于他会将在<strong>会话期间内的Statement进行缓存</strong>，并使用SQL语句作为Key。所以当执行下一请求的时候，不在重复构建Statement，而是从缓存中取出并设置参数，然后执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reuseExecutor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">ReuseExecutor</span> <span class="hljs-variable">reuseExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReuseExecutor</span>(configuration, jdbcTransaction);<br>        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.queryByUserName&quot;</span>);<br>        <span class="hljs-comment">// 相同的sql 会执两次,但是sql预编译只执行一次</span><br>        List&lt;Object&gt; objects = reuseExecutor.doQuery(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, ReuseExecutor.NO_RESULT_HANDLER, mappedStatement.getBoundSql(<span class="hljs-string">&quot;admin&quot;</span>));<br>        objects = reuseExecutor.doQuery(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, SimpleExecutor.NO_RESULT_HANDLER, mappedStatement.getBoundSql(<span class="hljs-string">&quot;admin&quot;</span>));<br>        System.out.println(objects);<br>    &#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从日志看出只有一次预编译 Preparing</span><br><span class="hljs-comment">     * 2022-04-03 13:10:40.042 DEBUG 18364 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt;  Preparing: select * from sys_user where username = ?</span><br><span class="hljs-comment">     * 2022-04-03 13:10:40.042 DEBUG 18364 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt; Parameters: admin(String)</span><br><span class="hljs-comment">     * 2022-04-03 13:10:40.042 DEBUG 18364 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : &lt;==      Total: 1</span><br><span class="hljs-comment">     * 2022-04-03 13:10:40.042 DEBUG 18364 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt; Parameters: admin(String)</span><br><span class="hljs-comment">     * 2022-04-03 13:10:40.058 DEBUG 18364 --- [           main] c.w.m.s.dao.SysUserDao.queryByUserName   : &lt;==      Total: 1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     */</span><br></code></pre></td></tr></table></figure><br><h4 id="batchexecutor"><a class="markdownIt-Anchor" href="#batchexecutor"></a> BatchExecutor</h4><p>​	<strong>sql语句相同，顺序连贯(为保证sql执行的准确性)，才能合并</strong></p><p>​	BatchExecutor 顾名思议，它就是用来作批处理的。但会将所 有SQL请求集中起来，最后调用Executor.flushStatements() 方法时一次性将所有请求发送至数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * sql 只编译了一次，参数合并起来了。并不是所有相同的sql都合并的，必须满足sql一样和sql语句的顺序连贯才能合并</span><br><span class="hljs-comment"> *  c.w.m.sys.dao.SysUserDao.updateNameById  : ==&gt;  Preparing: update sys_user set username = ? where user_id = ?</span><br><span class="hljs-comment"> *  c.w.m.sys.dao.SysUserDao.updateNameById  : ==&gt; Parameters: admin(String), 1(Integer)</span><br><span class="hljs-comment"> *  c.w.m.sys.dao.SysUserDao.updateNameById  : ==&gt; Parameters: admin(String), 1(Integer)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchExecutor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">BatchExecutor</span> <span class="hljs-variable">reuseExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchExecutor</span>(configuration, jdbcTransaction);<br>    <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.updateNameById&quot;</span>);<br><br>    Map&lt;String, Object&gt; param = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    param.put(<span class="hljs-string">&quot;arg0&quot;</span>, <span class="hljs-number">1</span>);<br>    param.put(<span class="hljs-string">&quot;arg1&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br><br>    reuseExecutor.doUpdate(mappedStatement, param);<br>    reuseExecutor.doUpdate(mappedStatement, param);<br>    reuseExecutor.flushStatements();    <span class="hljs-comment">//刷新声明才会批量执行</span><br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="cachingexecutor"><a class="markdownIt-Anchor" href="#cachingexecutor"></a> CachingExecutor</h4><p>​	查看Executor 的子类还有一个CachingExecutor,这是用于处理二级缓存的。为什么不把它和一级缓存一起处理呢？因为二级缓存和一级缓存相对独立的逻辑，而且二级缓存可以通过参数控制关闭，而一级缓存是不可以的。综上原因把二级缓存单独抽出来处理。抽取的方式采用了装饰者设计模式，即在CachingExecutor 对原有的执行器进行包装，处理完二级缓存逻辑之后，把SQL执行相关的逻辑交给实至的Executor处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 缓存执行器</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 第一次查询二级缓存命中率为 0</span><br><span class="hljs-comment">     * com.wgf.modules.sys.dao.SysUserDao       : Cache Hit Ratio [com.wgf.modules.sys.dao.SysUserDao]: 0.0</span><br><span class="hljs-comment">     * c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt;  Preparing: select * from sys_user where username = ?</span><br><span class="hljs-comment">     * c.w.m.s.dao.SysUserDao.queryByUserName   : ==&gt; Parameters: admin(String)</span><br><span class="hljs-comment">     * c.w.m.s.dao.SysUserDao.queryByUserName   : &lt;==      Total: 1</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 第二次查询二级缓存命中率为 0.5 说明使用了缓存</span><br><span class="hljs-comment">     * com.wgf.modules.sys.dao.SysUserDao       : Cache Hit Ratio [com.wgf.modules.sys.dao.SysUserDao]: 0.5</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> SQLException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cachingExecutor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">SimpleExecutor</span> <span class="hljs-variable">simpleExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>(configuration, jdbcTransaction);<br>        <span class="hljs-comment">// 装饰者模式，传入包装的Executor</span><br>        <span class="hljs-type">CachingExecutor</span> <span class="hljs-variable">cachingExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingExecutor</span>(simpleExecutor);<br><br>        <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(<span class="hljs-string">&quot;com.wgf.modules.sys.dao.SysUserDao.queryByUserName&quot;</span>);<br>        <span class="hljs-comment">// 相同的sql 会执两次</span><br>        List&lt;Object&gt; objects = cachingExecutor.query(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);<br>        <span class="hljs-comment">// 一级缓存和二级缓存不同，二级缓存是线程共享的，必须是事务提交后才刷新到缓存中去</span><br>        <span class="hljs-comment">// 执行顺序 二级缓存 &gt; 一级缓存</span><br>        cachingExecutor.commit(<span class="hljs-literal">true</span>);<br>        objects = cachingExecutor.query(mappedStatement, <span class="hljs-string">&quot;admin&quot;</span>, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER);<br>        System.out.println(objects);<br>    &#125;<br></code></pre></td></tr></table></figure><br><h4 id="mybatis-开启二级缓存"><a class="markdownIt-Anchor" href="#mybatis-开启二级缓存"></a> mybatis 开启二级缓存</h4><ol><li>配置文件 <code>mybatis-config.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--显示的开启全局缓存 (默认开启二级缓存)--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><br><ol start="2"><li><p>在 Mapper.xml 文件中添加cache标签</p><p>在要使用二级缓存的Mapper.xml文件中添加cache标签</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>eviction：清除策略为FIFO缓存，先进先出原则，默认的清除策略是 LRU<br>flushInterval：属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量<br>size：最多可以存储结果对象或列表的引用数<br>readOnly：只读属性，可以被设置为 true 或 false。<br></code></pre></td></tr></table></figure><br><br><h3 id="mappedstatement"><a class="markdownIt-Anchor" href="#mappedstatement"></a> MappedStatement</h3><p>​	<img src="/2022/04/07/Mybatis/MappedStatement.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 表示一个 SQL 节点（SELECT \ UPDATE \ DELETE \ INSERT）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MappedStatement</span> &#123;<br><br>  <span class="hljs-keyword">private</span> String resource;<br>  <span class="hljs-keyword">private</span> Configuration configuration;<br>  <span class="hljs-comment">//节点中的id属性加要命名空间</span><br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> Integer fetchSize;<br>  <span class="hljs-comment">//SQL超时时间</span><br>  <span class="hljs-keyword">private</span> Integer timeout;<br>  <span class="hljs-comment">// Statement的类型，STATEMENT/PREPARE/CALLABLE-对应SQL执行的几种方式</span><br>  <span class="hljs-keyword">private</span> StatementType statementType;<br>  <span class="hljs-comment">// 结果集类型， 是一个枚举类型</span><br>  <span class="hljs-keyword">private</span> ResultSetType resultSetType;<br>  <span class="hljs-comment">// SqlSource 对象， 对应一条 SQL</span><br>  <span class="hljs-keyword">private</span> SqlSource sqlSource;<br>  <span class="hljs-comment">// 缓存</span><br>  <span class="hljs-keyword">private</span> Cache cache;<br>  <span class="hljs-comment">// 参数</span><br>  <span class="hljs-keyword">private</span> ParameterMap parameterMap;<br>  <span class="hljs-comment">// 结果集</span><br>  <span class="hljs-keyword">private</span> List&lt;ResultMap&gt; resultMaps;<br>  <span class="hljs-comment">// 刷新缓存</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flushCacheRequired;<br>  <span class="hljs-comment">// 是否使用缓存</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> useCache;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> resultOrdered;<br>  <span class="hljs-keyword">private</span> SqlCommandType sqlCommandType;<br>  <span class="hljs-comment">//和SELECTKEY标签有关</span><br>  <span class="hljs-keyword">private</span> KeyGenerator keyGenerator;<br>  <span class="hljs-keyword">private</span> String[] keyProperties;<br>  <span class="hljs-keyword">private</span> String[] keyColumns;<br><br>  <span class="hljs-comment">// 是否有嵌套的结果集</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> hasNestedResultMaps;<br>  <span class="hljs-keyword">private</span> String databaseId;<br>  <span class="hljs-keyword">private</span> Log statementLog;<br>  <span class="hljs-keyword">private</span> LanguageDriver lang;<br>  <span class="hljs-keyword">private</span> String[] resultSets;<br><br>  MappedStatement() &#123;<br>    <span class="hljs-comment">// constructor disabled</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 静态内部类， 又是建造者模式</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappedStatement</span>();<br> ...<br></code></pre></td></tr></table></figure><p><strong>MappedStatement维护了一条&lt;select|update|delete|insert&gt;节点的封装，也就是说一个Mapper类的方法会产生一个MappedStatement对象，它存储在<code>Configuration</code>的<code>mappedStatements</code>map存储，key为 <code>Mapper全类名.方法名</code></strong></p><br><br><h3 id="statementhandler"><a class="markdownIt-Anchor" href="#statementhandler"></a> StatementHandler</h3><p><img src="/2022/04/07/Mybatis/StatementHandler_uml.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/07/Mybatis/StatementHandler.jpg" srcset="/img/loading.gif" lazyload alt></p><p>​	<strong>对JDBC的<code>Statement</code>进行封装,负责操作 Statement 对象与数据库进行交流，在工作时还会使用 <code>ParameterHandler</code> 和 <code>ResultSetHandler</code> 对参数进行映射，对结果进行实体类的绑定</strong></p><p>​	<strong>Mapper XML 配置文件中可以手动指定StatementHandler</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;page&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;voMap&quot;</span> <span class="hljs-attr">statementType</span>=<span class="hljs-string">&quot;PREPARED&quot;</span>&gt;</span><br>    取值 STATEMENT,PREPARED,CALLABLE<br></code></pre></td></tr></table></figure><br><h4 id="basestatementhandler"><a class="markdownIt-Anchor" href="#basestatementhandler"></a> BaseStatementHandler</h4><p><img src="/2022/04/07/Mybatis/BaseStatementHandler.jpg" srcset="/img/loading.gif" lazyload alt></p><br><h4 id="simplestatementhandler"><a class="markdownIt-Anchor" href="#simplestatementhandler"></a> SimpleStatementHandler</h4><p><img src="/2022/04/07/Mybatis/SimpleStatementHandler.jpg" srcset="/img/loading.gif" lazyload alt></p><p>​	<strong>对JDBC的<code>StatementImpl</code>进行封装,添加返回结果映射到java实体,不支持SQL预编译</strong></p><br><h4 id="preparedstatementhandler"><a class="markdownIt-Anchor" href="#preparedstatementhandler"></a> PreparedStatementHandler</h4><p><img src="/2022/04/07/Mybatis/PreparedStatementHandler.png" srcset="/img/loading.gif" lazyload alt></p><p>​	<strong>支持通过占位符实现SQL预编译的处理器,可以防止SQL注入,默认使用这个处理器</strong></p><br><h4 id="callablestatementhandler"><a class="markdownIt-Anchor" href="#callablestatementhandler"></a> CallableStatementHandler</h4><p>​	<strong>支持执行存储过程的StatementHandler</strong></p><br><br><h3 id="parameterhandler"><a class="markdownIt-Anchor" href="#parameterhandler"></a> ParameterHandler</h3><h3 id="resultsethandler"><a class="markdownIt-Anchor" href="#resultsethandler"></a> ResultSetHandler</h3><h3 id="typehandler"><a class="markdownIt-Anchor" href="#typehandler"></a> TypeHandler</h3><h3 id="sqlsource"><a class="markdownIt-Anchor" href="#sqlsource"></a> SqlSource</h3><h3 id="boundsql"><a class="markdownIt-Anchor" href="#boundsql"></a> BoundSql</h3><br><br><h2 id="缓存体系"><a class="markdownIt-Anchor" href="#缓存体系"></a> 缓存体系</h2><p>mybatis的缓存体系是框架内部实现的，和数据库没有任何关系，myBatis中存在两个缓存，一级缓存和二级缓存</p><ul><li><p>一级缓存</p><p>​ 也叫做会话级缓存，生命周期仅存在于当前会话，不可以直接关关闭。但可以通过flushCache和是 localCacheScope对其做相应控制，BaseExecutore 实现了一级缓存，一级缓存是sqlSession级别的缓存，线程不共享，默认开启，会话关闭一级缓存失效</p></li><li><p>二级缓存</p><p>CachingExecutor实现了二级缓存，二级缓存是sqlSessionFactory级别的缓存，线程共享</p></li></ul><br><p><strong>如果开启了二级缓存，执行顺序<code>二级缓存 &gt; 一级缓存 &gt; 数据库获取</code></strong></p><br><h3 id="一级缓存"><a class="markdownIt-Anchor" href="#一级缓存"></a> 一级缓存</h3><p>由 BaseExecutore 内部的 PerpetualCache 对象存储，PerpetualCache 内部使用map存储 缓存key -&gt; 数据的映射关系</p><br><p><img src="/2022/04/07/Mybatis/cacheKey.jpg" srcset="/img/loading.gif" lazyload alt></p><br><h4 id="缓存命中参数"><a class="markdownIt-Anchor" href="#缓存命中参数"></a> 缓存命中参数</h4><ul><li>SQL语句与参数相同</li><li>同一个会话 (sqlSession)</li><li>相同的MapperStatement ID</li><li>RowBounds行范围相同 (分页对象)</li></ul><br><h4 id="触发清空缓存"><a class="markdownIt-Anchor" href="#触发清空缓存"></a> 触发清空缓存</h4><p><img src="/2022/04/07/Mybatis/clear1.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/07/Mybatis/clear2.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/07/Mybatis/clear3.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/04/07/Mybatis/clear4.jpg" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>手动调用clearCache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSession.clearCache();<br></code></pre></td></tr></table></figure></li><li><p>执行事务 提交回滚</p></li><li><p>执行update (update标签里面是select语句也会)</p></li><li><p>配置flushCache=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Options(flushCache = Options.FlushCachePolicy.TRUE)</span><br></code></pre></td></tr></table></figure></li><li><p>修改缓存作用域为Statement</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STATEMENT&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><br><h4 id="一级缓存失效"><a class="markdownIt-Anchor" href="#一级缓存失效"></a> 一级缓存失效</h4><p>在使用Mybatis生成的Mapper代理类执行相关的sql操作时，如果多个sql操作不在同一个事务内部，则无法使用一级缓存（缓存失效），<strong>原因是不在一个事务内，每次调用Mapper代理类操作数据库都会获取新的会话</strong></p><br><p>缓存失效代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Mapper 缓存失效， 走两次查询</span><br><span class="hljs-comment"> * c.w.m.sys.dao.SysUserDao.selectById      : ==&gt;  Preparing: SELECT user_id,username,password,salt,email,mobile,status,create_user_id,create_time FROM sys_user WHERE user_id=?</span><br><span class="hljs-comment"> * c.w.m.sys.dao.SysUserDao.selectById      : ==&gt; Parameters: 1(Integer)</span><br><span class="hljs-comment"> * c.w.m.sys.dao.SysUserDao.selectById      : &lt;==      Total: 0</span><br><span class="hljs-comment"> * c.w.m.sys.dao.SysUserDao.selectById      : ==&gt;  Preparing: SELECT user_id,username,password,salt,email,mobile,status,create_user_id,create_time FROM sys_user WHERE user_id=?</span><br><span class="hljs-comment"> * c.w.m.sys.dao.SysUserDao.selectById      : ==&gt; Parameters: 1(Integer)</span><br><span class="hljs-comment"> * c.w.m.sys.dao.SysUserDao.selectById      : &lt;==      Total: 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invalidCache</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// sysUserDao 自动注入获得</span><br>    <br>    <span class="hljs-comment">// 调用获取新的SqlSession</span><br>    sysUserDao.selectById(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">// 调用获取新的SqlSession</span><br>    sysUserDao.selectById(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><p>缓存生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 使用事务后一级缓存生效</span><br><span class="hljs-comment">    * o.s.t.c.transaction.TransactionContext   : Began transaction (1) for test context [DefaultTestContext@142269f2 testClass = ExecutorTest, testInstance = com.wgf.ExecutorTest@248e31a1, testMethod = tran@ExecutorTest, testException = [null], merge</span><br><span class="hljs-comment">    * c.w.m.sys.dao.SysUserDao.selectById      : ==&gt;  Preparing: SELECT user_id,username,password,salt,email,mobile,status,create_user_id,create_time FROM sys_user WHERE user_id=?</span><br><span class="hljs-comment">    * c.w.m.sys.dao.SysUserDao.selectById      : ==&gt; Parameters: 1(Integer)</span><br><span class="hljs-comment">    * c.w.m.sys.dao.SysUserDao.selectById      : &lt;==      Total: 0</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-meta">@Transactional(readOnly = true)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tran</span><span class="hljs-params">()</span> &#123;<br>       sysUserDao.selectById(<span class="hljs-number">1</span>);<br>       sysUserDao.selectById(<span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><br><h5 id="缓存失效原因"><a class="markdownIt-Anchor" href="#缓存失效原因"></a> 缓存失效原因</h5><p><img src="/2022/04/07/Mybatis/SqlSession%E4%BA%8B%E5%8A%A1%E6%95%B4%E5%90%88.png" srcset="/img/loading.gif" lazyload alt></p><p>为了对事务的支持，Mybatis的Spring模块对SqlSession进行了封装，通过SqlSessionTemplae ，<strong>使得如果不在一个事务内调用Mapper</strong>，<strong>每次都会重新构建一个SqlSession</strong>，具体参见SqlSessionInterceptor ，解决的方法是让多个操作在一个事务内部就可以共享同一个SqlSession，这样就能使用一级缓存</p><br><h3 id="二级缓存"><a class="markdownIt-Anchor" href="#二级缓存"></a> 二级缓存</h3><p><img src="/2022/04/07/Mybatis/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BD%93%E7%B3%BB.jpg" srcset="/img/loading.gif" lazyload alt></p><p>​	<strong>经典的<code>装饰器加责任链模式</code></strong></p><br><p>这样设计有以下优点：</p><ol><li>职责单一：各个节点只负责自己的逻辑，不需要关心其它节点。</li><li>扩展性强：可根据需要扩展节点、删除节点，还可以调换顺序保证灵活性。</li><li>松耦合：各节点之间不没强制依赖其它节点。而是通过顶层的Cache接口进行间接依赖。</li></ol><br><h4 id="二级缓存的使用"><a class="markdownIt-Anchor" href="#二级缓存的使用"></a> 二级缓存的使用</h4><p>启用</p><ul><li><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">类上使用<br><span class="hljs-meta">@CacheNamespace</span>  Mapper开启二级缓存<br><span class="hljs-meta">@CacheNamespaceRef</span>  引入其他Mapper的二级缓存<br><br>方法上使用的<br><span class="hljs-meta">@Options</span> 设置缓存大小，过期时间等<br></code></pre></td></tr></table></figure></li></ul><p><strong>XML配置的二级缓存和java注解配置的缓存不能同时存在</strong></p><br><p><strong>二级缓存的作用范围： NameSpace</strong></p><p><strong>使用代码</strong></p><p>先开启二级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-meta">@CacheNamespace</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SysUserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;SysUserEntity&gt; &#123;<br>	<br>	<span class="hljs-meta">@Select(&quot;select * from sys_user where username = #&#123;arg0&#125;&#125;&quot;)</span><br>	<span class="hljs-keyword">public</span> SysUserEntity <span class="hljs-title function_">selectUsername</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="二级缓存为什么要提交才生效"><a class="markdownIt-Anchor" href="#二级缓存为什么要提交才生效"></a> 二级缓存为什么要提交才生效</h4><p>​	二级缓存体系中存在一个<code>事务缓存管理器 TransactionalCacheManager</code>和<code>事务缓存 TransactionalCach</code>，缓存暂存区的意义在于当前事务执行了update但是还没提交事务（事务可能回滚），此时由缓存区先存着，等事务真正提交再把缓存区数据刷进二级缓存能够防止二级缓存的脏读</p><p><strong>二级缓存生效场景</strong></p><ul><li>提交事务</li><li>关闭SqlSession</li></ul><br><h4 id="二级缓存流程"><a class="markdownIt-Anchor" href="#二级缓存流程"></a> <a target="_blank" rel="noopener" href="http://coderead.cn/p/mybatis/html/img/image-20200609152830260.png">二级缓存流程</a></h4><br><h2 id="sqlsessionfactorybean"><a class="markdownIt-Anchor" href="#sqlsessionfactorybean"></a> SqlSessionFactoryBean</h2><p>Mybatis和Spring融合</p><br><h2 id="其他问题"><a class="markdownIt-Anchor" href="#其他问题"></a> 其他问题</h2><h3 id="什么是mybatis"><a class="markdownIt-Anchor" href="#什么是mybatis"></a> 什么是Mybatis</h3><blockquote><ul><li>Mybatis是一个半自动ORM（对象关系映射）框架，它内部封装了JDBC，面向Sql开发，不需要花费精力去处理<strong>加载驱动、创建连接、创建statement等繁杂的过程</strong></li><li>MyBatis 可以使用 XML 或注解来配置和映射实体和表的映射关系，避免JDBC手动设置参数和获取结果的复杂性</li><li>提供XML和注解的方式将Sql和业务代码剥离，提供访问数据的DAO层</li></ul><p><strong>总结</strong>：<code>半自动ORM</code>，<code>面向Sql开发</code>，<code>对JDBC二次封装</code>，<code>屏蔽JDBC复杂性减少代码量</code>，<code>提供动态Sql标签</code></p></blockquote><br><h3 id="mybaits的优点"><a class="markdownIt-Anchor" href="#mybaits的优点"></a> Mybaits的优点</h3><blockquote><ul><li>面向Sql编程，提供XML和注解方式将Sql和代码玻璃，Sql便于统一管理和复用</li><li>与JDBC相比，减少了获取连接，设置参数，获取结果等最少50%代码量</li><li>能很好兼容常见的关系型数据库</li><li>提供映射标签，支持对象与数据库的ORM映射</li><li>提供DAO层访问数据库</li><li>提供动态SQL标签，支持灵活实现SQL和SQL复用</li></ul><p><strong>总结</strong>：<code>面向SQL编程</code>，<code>与JDBC比较</code>，<code>数据库兼容性</code>，<code>提供DAO层</code>，<code>映射标签</code>，<code>动态SQL标签</code></p></blockquote><br><h3 id="mybatis的缺点"><a class="markdownIt-Anchor" href="#mybatis的缺点"></a> Mybatis的缺点</h3><blockquote><ul><li>半自动ORM框架，面向Sql开发，Sql开发量大</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><p><strong>总结：</strong><code>SQL开发量大</code>，<code>数据库可移植性差</code></p></blockquote><br><h3 id="mybatis框架适用场合"><a class="markdownIt-Anchor" href="#mybatis框架适用场合"></a> MyBatis框架适用场合</h3><blockquote><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案</li><li>对性能要求高，并且业务数据复杂的系统，比如互联网，ERP等</li></ul><p><strong>总结：</strong><code>灵活的DAO层解决方案</code>，<code>性能高</code></p></blockquote><br><h3 id="mybatis与hibernate有哪些不同"><a class="markdownIt-Anchor" href="#mybatis与hibernate有哪些不同"></a> MyBatis与Hibernate有哪些不同</h3><blockquote><p>相同点</p><ul><li>都是对JDBC进行二次封装，提供DAO层解决方案</li></ul><p>不同点</p><ul><li>mybatis是一个半自动化的ORM框架，<strong>配置的是java对象与SQL语句执行结果的映射</strong>，多表关联配置简单</li><li>Hibernate是个全自动化的ORM框架，配置Java对象与数据库表的对应关系 ，多表关联配置复杂</li><li>Hibernate可以使用<strong>HQL</strong>面向对象编程</li><li>Hibernate对比MySQL数据库可移植性更强，底层采用HQL屏蔽数据库差异性</li></ul><p><strong>总结：</strong><code>半自动/自动ORM</code>，<code>HQL</code>，<code>数据库移植性</code></p></blockquote><br><h3 id="orm是什么"><a class="markdownIt-Anchor" href="#orm是什么"></a> ORM是什么</h3><blockquote><ul><li>ORM（Object Relational Mapping） ,对象关系映射 。<strong>ORM是用于描述对象与数据库之间的映射元数据，将程序中的对自动的持久化到关系型数据库中</strong></li></ul><p><strong>总结：</strong><code>对象与数据库的映射</code>，<code>对象持久化到数据库</code></p></blockquote><br><h3 id="mybatis为什么不是全自动orm"><a class="markdownIt-Anchor" href="#mybatis为什么不是全自动orm"></a> Mybatis为什么不是全自动ORM</h3><blockquote><ul><li>全自动ORM是将对象属性与数据库表字段进行一一对应，并将表的关联关系具体体现在实体关系中</li><li>Mybatsi使用映射标签将对象字段与SQL执行结果映射而不是和表映射，需要自己配置映射关系</li></ul><p><strong>总结：</strong><code>参数全自动ORM</code>，<code>SQL执行结果映射</code></p></blockquote><br><h3 id="传统jdbc开发存在什么问题"><a class="markdownIt-Anchor" href="#传统jdbc开发存在什么问题"></a> 传统JDBC开发存在什么问题</h3><blockquote><ul><li>频繁创建数据量连接对象，自己管理事务，代码量大，影响系统性能</li><li>SQL语句定义，参数填充，结果获取存在硬编码，代码不够灵活</li><li>结果集处理存在重复代码，可维护性差</li></ul><p><strong>总结：</strong><code>连接难维护</code>，<code>SQL硬编码</code>，<code>参数设置死板</code>，<code>处理结果集代码冗余</code></p></blockquote><br><h3 id="mybatis是如何解决jdbc不足之处"><a class="markdownIt-Anchor" href="#mybatis是如何解决jdbc不足之处"></a> MyBatis是如何解决JDBC不足之处</h3><blockquote><ul><li>数据库链接创建 ,Mybatis允许配置连接池来管理数据库连接</li><li>SQL语句剥离，使用XML和注解将SQL语句和代码剥离，统一管理</li><li>动态SQL，提供动态标签解决JDBC参数设置不灵活缺点</li><li>结果映射，通过灵活配置将结果集映射到实体上</li><li>对JDBC进行封装，屏蔽底层复杂性</li></ul><p><strong>总结：</strong><code>支持连接池管理连接</code>，<code>SQL统一管理</code>，<code>动态SQL标签</code>，<code>结果映射</code>，<code>屏蔽JDBC复杂性</code></p></blockquote><br><h3 id="mybatis编程步骤"><a class="markdownIt-Anchor" href="#mybatis编程步骤"></a> MyBatis编程步骤</h3><blockquote><ul><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过sqlsession执行数据库操作</li><li>调用session.commit()提交事务</li><li>调用session.close()关闭会话</li></ul><p>**总结：**Mybatis通过门面设计模式封装了SqlSession会话层，对外屏蔽了Executor调用的复杂性</p></blockquote><br><h3 id="请说说mybatis的工作原理"><a class="markdownIt-Anchor" href="#请说说mybatis的工作原理"></a> 请说说MyBatis的工作原理</h3><p><img src="https://uploadfiles.nowcoder.com/files/20211231/687814481_1640937671381/v2-e2dbc8a0c9ecf0586d0cadfb7ba9d777_720w.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息</li><li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表</li><li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory</li><li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法</li><li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护</li><li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息</li><li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程</li><li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程</li></ul></blockquote><br><h3 id="mybatis的功能架构"><a class="markdownIt-Anchor" href="#mybatis的功能架构"></a> MyBatis的功能架构</h3><blockquote><ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑</li></ul></blockquote><br><h3 id="为什么需要预编译"><a class="markdownIt-Anchor" href="#为什么需要预编译"></a> 为什么需要预编译</h3><blockquote><p>**定义：**SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给数据库之前对 SQL 语句进行编译，这样 数据库执行 SQL 时，就不需要重新编译</p><p><strong>为什么</strong></p><ul><li>防止SQL注入</li><li>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，数据库不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用 ****</li></ul><p><strong>总结：</strong><code>防止SQL注入</code>，<code>减少数据库编译工作</code></p></blockquote><br><h3 id="和的区别是什么"><a class="markdownIt-Anchor" href="#和的区别是什么"></a> #{}和${}的区别是什么</h3><ul><li>#{}是预编译处理</li><li>${}是字符串替换</li></ul><br><h3 id="体类中的属性名和表中的字段名不一样怎么办"><a class="markdownIt-Anchor" href="#体类中的属性名和表中的字段名不一样怎么办"></a> 体类中的属性名和表中的字段名不一样怎么办</h3><blockquote><ul><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</li><li>通过 <resultmap>来映射字段名和实体类属性名的一一对应的关系</resultmap></li></ul><p><strong>总结：</strong><code>SQL字段起别名</code>，<code>&lt;resultMap&gt;br&gt;添加映射</code></p></blockquote><br><h3 id="模糊查询like语句该怎么写"><a class="markdownIt-Anchor" href="#模糊查询like语句该怎么写"></a> 模糊查询like语句该怎么写</h3><blockquote><ul><li><p>在代码中添加通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;%wgf%&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>在sql语句中拼接通配符，会引起sql注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">select * from foo where bar like &#x27;%$&#123;bar&#125;%&#x27;<br></code></pre></td></tr></table></figure></li><li><p>使用 concat 函数，推荐</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">select * from where name like concat(&#x27;%&#x27;, #&#123;name&#125;)<br></code></pre></td></tr></table></figure></li></ul><p><strong>总结：</strong><code>java字符串拼接</code>，<code>$字符串拼接</code>，<code>concat函数</code></p></blockquote><br><h3 id="mybatis都有哪些executor执行器"><a class="markdownIt-Anchor" href="#mybatis都有哪些executor执行器"></a> Mybatis都有哪些Executor执行器</h3><blockquote><ul><li><strong>BaseExecutor</strong>: 将Executor共性抽取出一个父类，提供<strong>一级缓存，事务，数据库基本操作</strong></li><li><strong>CachingExecutor</strong>: 提供二级缓存功能</li><li><strong>SimpleExecutor</strong>: 默认执行器，每次执行query或update都创建一个新的Statement对象，用完立即关闭Statement对象</li><li><strong>ReuseExecutor</strong>: 使用Sql作为Key,将Statement对象缓存起来，重复使用Statement减少SQL预编译次数（SqlSession范围重用）</li><li><strong>BatchExecutor</strong>: 执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），会合并sql语句</li></ul></blockquote><br><h3 id="mybatis中如何指定使用哪一种executor"><a class="markdownIt-Anchor" href="#mybatis中如何指定使用哪一种executor"></a> Mybatis中如何指定使用哪一种Executor</h3><blockquote><ul><li><p>在Mybatis配置文件中，在设置（settings）可以指定默认的<strong>ExecutorType</strong>执行器类型</p></li><li><p>在yml文件中配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">executor-type:</span> <span class="hljs-string">batch</span><br></code></pre></td></tr></table></figure></li><li><p>在调用DefaultSqlSessionFactory的openSession方法传入ExecutorType参数</p></li></ul><p><strong>总结：</strong><code>mybatis XML setting配置</code>，<code>yml 文件配置</code>， <code>DefaultSqlSessionFactory 参数传入</code></p></blockquote><br><h3 id="mapper接口里的方法能重载吗"><a class="markdownIt-Anchor" href="#mapper接口里的方法能重载吗"></a> Mapper接口里的方法能重载吗</h3><blockquote><ul><li><p>Mapper接口允许多个方法重载，但是映射只能有一个，否则报错</p></li><li><p>Mybatis源码Configuration类中获取MappedStatement信息是通过Mapper全类名加方法名作为key获取的，底层数据结构是一个Map，因此不能存在多个映射</p></li></ul><p><strong>总结</strong>：<code>允许重载，只能有一个映射</code></p></blockquote><br><h3 id="mybatis是如何进行分页的分页插件原理"><a class="markdownIt-Anchor" href="#mybatis是如何进行分页的分页插件原理"></a> Mybatis是如何进行分页的，分页插件原理</h3><blockquote><p><strong>分页</strong></p><p>​ Mybatis 使用 <strong>RowBounds</strong> 对象进行分页，也可以直接编写 sql 实现分页，也可以使用Mybatis 的分页插件</p><p><strong>插件原理</strong></p><p>​ 实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql</p><p><strong>总结：</strong> <code>RowBounds</code>，<code>编写SQL</code>，<code>使用分页插件</code>，<code>自定义插件</code>，<code>拦截sql且重写</code></p></blockquote><br><h3 id="mybatis是如何将sql执行结果封装为目标对象并返回的都有哪些映射形式"><a class="markdownIt-Anchor" href="#mybatis是如何将sql执行结果封装为目标对象并返回的都有哪些映射形式"></a> Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><blockquote><ul><li>第一种是使用 <resultmap>标签，逐一定义数据库列名和对象属性名之间的映射关系</resultmap></li><li>第二种是使用sql列的别名功能，将列的别名书写为对象属性名</li><li>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的</li></ul><p><strong>总结：</strong><code> &lt;resultMap&gt;</code>，<code>sql别名和字段名对应</code>，<code>反射创建对象并赋值</code></p></blockquote><br><h3 id="如何获取自动生成的主键值"><a class="markdownIt-Anchor" href="#如何获取自动生成的主键值"></a> 如何获取自动生成的(主)键值</h3><blockquote><ul><li>insert 方法总是返回一个int值 ，这个值代表的是插入的行数</li><li>update 方法返回一个int值，是受影响行数</li><li>xml中设置 useGeneratedKeys=“true” keyProperty=“id”</li></ul><p><strong>总结：</strong><code>useGeneratedKeys</code>，<code>keyProperty</code></p></blockquote><br><h3 id="在mapper中如何传递多个参数"><a class="markdownIt-Anchor" href="#在mapper中如何传递多个参数"></a> 在mapper中如何传递多个参数</h3><blockquote><ul><li>下表占位符 #{arg0}, #{arg1}</li><li>@Param注解</li><li>使用Map传参</li><li>使用实体传参</li></ul><p><strong>总结</strong>：<code>#&#123;arg0&#125;</code>，<code>@Param</code></p></blockquote><br><h3 id="mybatis是否支持延迟加载原理是什么"><a class="markdownIt-Anchor" href="#mybatis是否支持延迟加载原理是什么"></a> Mybatis是否支持延迟加载？原理是什么</h3><blockquote><ul><li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载 ,association指的就是一对一，collection指的就是一对多查询,可以配置是否启用延迟加载lazyLoadingEnabled=true|false</li><li>原理：它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理</li></ul><p><strong>总结</strong>：<code>关联关系允许懒加载</code></p></blockquote><br><h3 id="mybatis动态sql有什么用"><a class="markdownIt-Anchor" href="#mybatis动态sql有什么用"></a> Mybatis动态sql有什么用</h3><blockquote><ul><li>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，<strong>执行原理是根据表达式的值完成逻辑判断并动态拼接sql的功能</strong></li><li>通过动态sql标签灵活装配SQL</li><li>Mybatis提供了9种动态sql标签： trim| where| set| foreach| if|choose| when| otherwise| bind</li></ul></blockquote><br><h3 id="mybatis的xml映射文件中不同的xml映射文件id是否可以重复"><a class="markdownIt-Anchor" href="#mybatis的xml映射文件中不同的xml映射文件id是否可以重复"></a> Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复</h3><blockquote><ul><li>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复</li><li>原因是Mybatis的配置中MapperStatement是根据 namespace+id 作为作为Map &lt;String,MapperStatement&gt;的key使用的 ，保证namespace+id不重复就行</li></ul><p><strong>总结</strong>：<code>MapperStatement -&gt; namespace + id</code></p></blockquote><br><h3 id="一对一-一对多的关联查询"><a class="markdownIt-Anchor" href="#一对一-一对多的关联查询"></a> 一对一、一对多的关联查询</h3><blockquote><ul><li>一对一使用associate，一个类根据关联字段对应着一个类，实体类里声明另一个实体类</li><li>一对多使用collection，一个类根据关联字段对应着多个类，实体类里声明另一个实体类的List</li><li>多对一使用associate，多个类根据关联字段对应着一个类，实体类里声明另一个实体类</li></ul><p>总结：<code>associate</code>，<code>collection</code></p></blockquote><br><h3 id="mybatis的一级-二级缓存"><a class="markdownIt-Anchor" href="#mybatis的一级-二级缓存"></a> Mybatis的一级、二级缓存</h3><blockquote><ul><li>基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源</li></ul><p><strong>总结</strong>：<code>一级缓存会话独享，二级缓存会话共享</code>，<code>一级缓存是SqlSession级别缓存，二级缓存是SqlSessionFactory级别缓存</code></p></blockquote><br><h3 id="开发一个mybatis插件"><a class="markdownIt-Anchor" href="#开发一个mybatis插件"></a> 开发一个Mybatis插件</h3><blockquote><ul><li><p>实现 Mybatis 的 Interceptor 接口并复写 intercept()方法，然后在给插件编写注解，指定</p><p>要拦截哪一个接口的哪些方法即可，在配置文件中配置插件</p></li></ul><p><strong>总结</strong>：<code>实现 Interceptor接口</code>，<code>重写 intercept方法</code>，<code>注解配置拦截方法</code>，<code>配置文件配置插件</code></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>Mybatis</div><div>https://wugengfeng.cn/2022/04/07/Mybatis/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年4月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/04/13/java%E6%BA%90%E7%A0%81/" title="java源码"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">java源码</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/03/29/jvm/" title="jvm"><span class="hidden-mobile">jvm</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>