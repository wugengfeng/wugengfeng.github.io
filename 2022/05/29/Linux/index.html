<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="零拷贝 零拷贝 是一种技术，它允许数据在内存中的移动或操作，而无需进行应用程序和内核之间的数据拷贝，也就是零次多余的拷贝。  什么是零拷贝 零拷贝字面上的意思包括两个，“零” 和 “拷贝”：  拷贝：指的是数据从一个存储位置移至另一个存储位置的过程。 零 ：在此上下文中，代表零次多余的拷贝。  零拷贝 是在执行I&#x2F;O操作时，避免CPU从一个存储区域向另一个存储区域复制数据的技术(应用程序和内核)"><meta property="og:type" content="article"><meta property="og:title" content="Linux"><meta property="og:url" content="https://wugengfeng.cn/2022/05/29/Linux/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="零拷贝 零拷贝 是一种技术，它允许数据在内存中的移动或操作，而无需进行应用程序和内核之间的数据拷贝，也就是零次多余的拷贝。  什么是零拷贝 零拷贝字面上的意思包括两个，“零” 和 “拷贝”：  拷贝：指的是数据从一个存储位置移至另一个存储位置的过程。 零 ：在此上下文中，代表零次多余的拷贝。  零拷贝 是在执行I&#x2F;O操作时，避免CPU从一个存储区域向另一个存储区域复制数据的技术(应用程序和内核)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/linux.png"><meta property="article:published_time" content="2022-05-29T15:57:33.000Z"><meta property="article:modified_time" content="2023-11-01T09:35:49.534Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/linux.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>Linux - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Linux"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-29 23:57" pubdate>2022年5月29日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 36 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Linux</h1><div class="markdown-body"><h1 id="零拷贝"><a class="markdownIt-Anchor" href="#零拷贝"></a> 零拷贝</h1><p><code>零拷贝</code> 是一种技术，它允许数据在内存中的移动或操作，而无需进行应用程序和内核之间的数据拷贝，也就是零次多余的拷贝。</p><h2 id="什么是零拷贝"><a class="markdownIt-Anchor" href="#什么是零拷贝"></a> 什么是零拷贝</h2><p>零拷贝字面上的意思包括两个，“零” 和 “拷贝”：</p><ul><li><code>拷贝</code>：指的是数据从一个存储位置移至另一个存储位置的过程。</li><li><code>零</code> ：在此上下文中，代表零次多余的拷贝。</li></ul><p><code>零拷贝</code> 是在执行I/O操作时，避免CPU从一个存储区域向另一个存储区域复制数据的技术(应用程序和内核)。这样做可以降低系统的上下文切换次数，减少CPU的负载，并避免不必要的内存使用，从而提高I/O性能。</p><h2 id="传统的io执行流程"><a class="markdownIt-Anchor" href="#传统的io执行流程"></a> 传统的IO执行流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>((n = read(diskfd, buf, BUF_SIZE)) &gt; <span class="hljs-number">0</span>)<br>    write(sockfd, buf , n);<br></code></pre></td></tr></table></figure><ol><li><strong><code>文件描述符</code></strong>:<ul><li><code>diskfd</code> 是一个文件描述符，指代在文件系统上的一个文件。</li><li><code>sockfd</code> 是一个文件描述符，指代一个已连接的socket。</li></ul></li><li><strong><code>read系统调用</code></strong>:<ul><li>在用户空间:<ul><li>当应用程序执行<code>read</code>函数时，它会通过系统调用请求OS执行数据读取的操作。</li></ul></li><li>在内核空间:<ol><li><strong>从磁盘读取数据到内核缓冲区</strong>：这个操作是在内核空间中进行的。内核负责管理硬件资源，所以从磁盘读取数据的实际操作是在内核空间完成的。</li><li><strong>从内核缓冲区拷贝到用户缓冲区</strong>：这也是在内核空间中完成的。系统需要将内核缓冲区中的数据拷贝到用户空间的缓冲区。</li></ol></li></ul></li><li><strong><code>write系统调用</code></strong>:<ul><li>在用户空间:<ul><li>当应用程序执行<code>write</code>函数时，它会通过系统调用请求OS执行数据写入的操作。</li></ul></li><li>在内核空间:<ol><li><strong>从用户缓冲区拷贝到内核的socket缓冲区</strong>：这个操作是在内核空间完成的。系统需要将用户缓冲区中的数据拷贝到内核空间的socket缓冲区。</li><li><strong>从socket缓冲区写入到网卡设备</strong>：这也是在内核空间完成的。内核通过网络协议栈处理数据，然后将数据发送到网卡。</li></ol></li></ul></li><li><strong><code>注意事项</code></strong>:<ul><li>该方法是<strong>阻塞的</strong>：这意味着，如果 <code>read</code> 或 <code>write</code> 系统调用不能立即完成（例如，磁盘很慢或网络有延迟），那么整个进程会被阻塞，直到操作完成。</li><li>在现实场景中，为了提高性能和响应时间，通常会使用非阻塞IO、多线程或异步IO。</li></ul></li></ol><p><img src="/2022/05/29/Linux/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD.png" srcset="/img/loading.gif" lazyload alt></p><ol><li>用户应用进程调用read函数，向操作系统发起IO调用(系统调用)，<strong>上下文从用户态转为内核态（切换1）</strong>。</li><li>DMA控制器把数据从磁盘读取到内核缓冲区。</li><li>CPU把内核缓冲区数据拷贝到用户应用缓冲区，<strong>上下文从内核态转为用户态（切换2）</strong>，read函数返回。</li><li>用户应用进程通过write函数发起IO调用(系统调用)，<strong>上下文从用户态转为内核态（切换3）</strong>。</li><li>CPU将用户缓冲区中的数据拷贝到socket缓冲区。</li><li>DMA控制器将数据从socket缓冲区传输到网卡设备，<strong>上下文从内核态切换回用户态（切换4）</strong>，write函数返回。</li></ol><p><strong>总结</strong>：传统的IO流程确实会经历<strong>四次上下文切换和四次数据拷贝</strong>。</p><h2 id="cpu上下文切换"><a class="markdownIt-Anchor" href="#cpu上下文切换"></a> CPU上下文切换</h2><p>一般我们说的上下文切换，是指操作系统在 CPU 上切换进程或线程的状态，包括用户态和内核态之间的转换，以及内核态下不同进程或线程之间的切换。进程从用户态切换到内核态，通常是通过系统调用来完成的。在系统调用的过程中，会涉及到 CPU 上下文的切换。这个过程包括保存当前进程或线程的 CPU 寄存器状态，然后加载新的进程或线程的 CPU 寄存器状态，以便新的进程或线程可以接着之前的状态继续运行。具体来说，CPU 寄存器里原来的用户态指令位置需要被保存起来，然后 CPU 寄存器需要更新为内核态指令的新位置，最后 CPU 才能跳转到内核态运行 <code>内核任务</code>。</p><br><h2 id="用户空间和内核空间"><a class="markdownIt-Anchor" href="#用户空间和内核空间"></a> <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1739264">用户空间和内核空间</a></h2><p><img src="/2022/05/29/Linux/IO%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/81883894"><strong>什么是系统内核</strong></a><ul><li>内核是操作系统的核心组成部分，它作为应用程序和硬件之间的桥梁，负责管理系统的进程、内存、设备驱动程序、文件系统和网络功能等。内核的设计和性能直接影响整个系统的性能和稳定性。</li></ul></li><li><strong>内核空间</strong>：系统内核运行的空间</li><li><strong>用户空间</strong>：应用程序运行的空间</li><li><strong>为什么要区分内核空间和用户空间</strong>：<ul><li>为了确保操作系统的稳定性和可用性，应用程序被限制在用户空间运行，而不能直接访问硬件或执行某些关键的系统操作。这些底层的任务，如读写磁盘文件、分配和回收内存或从网络接口读写数据，都必须通过内核提供的接口来完成。</li></ul></li><li><strong>具体实现</strong>：比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3<ul><li>当进程运行在 Ring3 级别时被称为运行在<strong>用户态</strong></li><li>而运行在 Ring0 级别时被称为运行在<strong>内核态</strong></li></ul></li></ul><h2 id="dma拷贝"><a class="markdownIt-Anchor" href="#dma拷贝"></a> DMA拷贝</h2><ul><li><strong>DMA</strong>，全称为<strong>Direct Memory Access</strong>，即<strong>直接内存访问</strong>。DMA是一种硬件级的数据传输技术，通常由主板上的独立DMA控制器芯片实现。它允许外设设备和内存存储器之间直接进行IO数据传输，而不需要CPU的参与。<ul><li><strong>DMA的主要任务是协助CPU处理IO请求和数据拷贝</strong>。</li><li><strong>DMA使硬件设备能够直接与内存存储器进行数据IO传输，提高了数据传输的效率</strong>。</li></ul></li></ul><h2 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h2><p><img src="/2022/05/29/Linux/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>现代操作系统使用虚拟内存技术，其中系统为应用程序提供虚拟地址，而不是直接的物理地址。使用虚拟内存有以下好处：</p><ul><li><strong>虚拟内存空间通常远大于物理内存空间</strong>。这是因为虚拟内存不仅仅是物理内存，还包括使用磁盘上的一部分作为&quot;交换空间&quot;或&quot;页面文件&quot;。</li><li><strong>多个虚拟地址可以映射到同一个物理地址</strong>。这使得多个进程或线程可以共享同一物理内存地址，从而实现内存共享。</li></ul><p>正是因为多个虚拟地址可以映射到同一个物理地址，内核空间和用户空间的虚拟地址可以映射到同一个物理地址。这种方式可以减少在数据传输时的数据拷贝次数。</p><ul><li>虚拟地址到物理地址的转换过程称为<strong>地址翻译</strong>。</li><li>通过多个虚拟地址共同指向同一个物理地址，可以在内核空间与用户空间或应用程序之间实现<strong>内存共享</strong>，从而减少数据复制。</li></ul></li></ul><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>零拷贝的核心是减少无用的数据复制次数，优化IO。其实现是通过系统调用(调用系统内核函数)</p><h3 id="mmap"><a class="markdownIt-Anchor" href="#mmap"></a> mmap</h3><p><img src="/2022/05/29/Linux/mmap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload alt></p><p>使用 <code>mmap</code> 方法代替传统的IO方式，核心是利用虚拟内存的映射特性。这使得用户空间和内核空间可以共享相同的<code>Read Buffer</code>，因此数据不再需要从内核空间复制到用户空间，从而避免了一次数据复制。</p><p><strong><code>数据移动次数</code></strong>：三次</p><p><strong><code>上下文切换次数</code></strong>：四次</p><ol><li>用户进程通过<code>mmap</code>方法向操作系统内核发起IO调用，此时上下文从用户态切换为内核态。</li><li>利用DMA控制器，数据从硬盘被传输到内核缓冲区。</li><li>上下文从内核态切换回用户态，<code>mmap</code>方法返回。</li><li>用户进程通过<code>write</code>方法向操作系统内核发起IO调用，此时上下文从用户态切换为内核态。</li><li>数据在内核缓冲区中被准备好并通过DMA直接从socket缓冲区传输到网卡。</li><li>上下文从内核态切换回用户态，<code>write</code>调用返回。</li></ol><p><strong><code>优点</code></strong>：操作文件的速度与操作内存相当，特别适合处理较大的文件，如在<code>NIO</code>和<code>RocketMQ</code>中的应用。</p><p><strong><code>缺点</code></strong>：</p><ul><li>对于非常小的文件（例如小于4KB），可能会浪费内存，因为内存页面的最小单位通常为4KB。</li><li>如果系统频繁使用<code>mmap</code>操作，且每次映射的大小都不同，可能导致内存碎片化，从而缺乏连续的内存空间。</li></ul><p><code>适用场景</code></p><p>对数据读取后需要进行加工处理的，比如<code>NIO</code>,<code>RocketMQ</code></p><h3 id="sendfile"><a class="markdownIt-Anchor" href="#sendfile"></a> sendfile</h3><p><strong>sendfile是Linux2.1内核版本后引入的一个系统调用函数，API如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>out_fd:为待写入内容的文件描述符，一个socket描述符。，</li><li>in_fd:为待读出内容的文件描述符，必须是真实的文件，不能是socket和管道。</li><li>offset：指定从读入文件的哪个位置开始读，如果为NULL，表示文件的默认起始位置。</li><li>count：指定在fdout和fdin之间传输的字节数。</li></ul><p><code>sendfile</code> 是一种专门用于在两个文件描述符之间传输数据的系统调用。它直接在内核中进行数据传输，避免了数据在内核空间与用户空间之间的中间拷贝，从而实现真正的零拷贝传输。这种优化减少了不必要的上下文切换和数据复制，从而提高了文件传输的效率。</p><p><strong>sendfile实现的零拷贝流程如下：</strong></p><p><img src="/2022/05/29/Linux/2.1sendfile.png" srcset="/img/loading.gif" lazyload alt></p><p>数据移动次数：<strong>三次</strong></p><p>上下文切换次数：<strong>两次，使用sendfile()系统调用替换Read和Write系统调用</strong></p><ol><li>用户进程发起sendfile系统调用，此时上下文从用户态切换到内核态。</li><li>通过DMA控制器，数据从硬盘直接拷贝到内核的页缓存。</li><li>数据从页缓存被转移到目标socket的内核缓冲区。</li><li>通过DMA控制器，数据从内核的socket缓冲区传输到网卡。</li><li>上下文从内核态切换回用户态，sendfile调用返回。</li></ol><p><strong>Linux 2.4内核优化<code>SG-DMA拷贝</code></strong></p><p><img src="/2022/05/29/Linux/2.4sendfile.png" srcset="/img/loading.gif" lazyload alt></p><p>使用<code>scatter/gather DMA</code>技术，允许数据直接从硬盘拷贝到网卡，无需中间内存间拷贝。</p><p>数据移动次数：<strong>两次</strong> （都是DMA拷贝）</p><p>上下文切换次数：<strong>两次</strong></p><p><strong><code>优点</code></strong>：</p><ul><li>2次上下文切换，0次CPU拷贝，2次DMA拷贝 — 实现了真正意义上的零拷贝。</li><li>非常适合大文件传输。</li></ul><p><strong><code>缺点</code></strong>：</p><ul><li>需要硬件支持DMA技术。</li><li>不能进行数据的中间处理或修改。</li></ul><p><strong><code>适用场景</code></strong>：</p><ul><li>对于应用层不需要对数据进行处理的场景，例如，直接将硬盘上的文件发送到网卡。如<code>kafka</code>的高吞吐量实现。</li><li>需要注意的是，sendfile存在限制。特别是在某些版本的Linux内核中，数据源不能是socket，而数据的目标必须是socket。这意味着sendfile主要用于文件到网络的传输，限制了其使用范围</li></ul><h3 id="splice"><a class="markdownIt-Anchor" href="#splice"></a> splice</h3><p>鉴于 Sendfile 的缺点，在 Linux2.6.17 中引入了 Splice，它在读缓冲区和网络操作缓冲区之间建立管道避免 CPU 拷贝：<strong>先将文件读入到内核缓冲区，然后再与内核网络缓冲区建立管道</strong>。它的函数原型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ssize_t <span class="hljs-title function_">splice</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, loff_t *off_in, <span class="hljs-type">int</span> fd_out, loff_t *off_out, size_t len, unsigned <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/29/Linux/splice.jpg" srcset="/img/loading.gif" lazyload alt></p><ol><li>用户进程调用 <code>splice()</code>，此时从用户态切换到内核态。</li><li>如果源是一个普通文件，DMA（Direct Memory Access）将文件数据从存储设备读入内核缓冲区。</li><li><code>splice()</code> 将数据从源文件描述符直接移动到目标文件描述符，避免了数据复制到用户空间的额外步骤。</li><li>如果目标是网络套接字，数据会被传输到相关的网络缓冲区（通过修改数据的指针），并最终通过 DMA 被发送到网络接口。</li></ol><p><strong>管道设备</strong></p><p>管道设备文件，也称为 FIFO (First-In, First-Out) 文件，数据流入一端并从另一端流出。虽然通常用于进程间通信，管道也能够配合 <code>splice</code> 等系统调用，实现高效的数据传输。</p><p><strong>局限性</strong></p><p>splice也有一些局限，它的两个文件描述符参数中有一个必须是管道设备</p><h3 id="tee"><a class="markdownIt-Anchor" href="#tee"></a> tee</h3><p><strong>tee类似splice但是两个fd都必须是管道，而且tee不消耗输入fd的数据</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>Linux</div><div>https://wugengfeng.cn/2022/05/29/Linux/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年5月29日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/06/15/netty%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" title="netty核心原理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">netty核心原理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/05/25/netty/" title="netty"><span class="hidden-mobile">netty</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>