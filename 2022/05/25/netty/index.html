<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="IO模型  什么是IO？ I&#x2F;O（Input&#x2F;Outpu） 即输入／输出   BIO  什么是BIO？ Blocking I&#x2F;O，属于同步阻塞 IO 模型 ​	同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销  ​	同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，"><meta property="og:type" content="article"><meta property="og:title" content="netty"><meta property="og:url" content="https://wugengfeng.cn/2022/05/25/netty/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="IO模型  什么是IO？ I&#x2F;O（Input&#x2F;Outpu） 即输入／输出   BIO  什么是BIO？ Blocking I&#x2F;O，属于同步阻塞 IO 模型 ​	同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销  ​	同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/netty.png"><meta property="article:published_time" content="2022-05-25T03:48:28.000Z"><meta property="article:modified_time" content="2023-07-14T06:49:16.905Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/netty.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>netty - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="netty"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-25 11:48" pubdate>2022年5月25日 中午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 165k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 1375 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">netty</h1><div class="markdown-body"><h2 id="io模型"><a class="markdownIt-Anchor" href="#io模型"></a> IO模型</h2><blockquote><p><strong>什么是IO？</strong></p><p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong></p></blockquote><h3 id="bio"><a class="markdownIt-Anchor" href="#bio"></a> BIO</h3><blockquote><p><strong>什么是BIO？</strong></p><p>Blocking I/O，<strong>属于同步阻塞 IO 模型</strong></p><p>​	同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</p><p><img src="/2022/05/25/netty/BIO%E6%A8%A1%E5%9E%8B2.png" srcset="/img/loading.gif" lazyload alt></p><p>​	同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间</p><p><img src="/2022/05/25/netty/BIO%E6%A8%A1%E5%9E%8B.jpg" srcset="/img/loading.gif" lazyload alt></p><p><strong>缺点</strong>：</p><ul><li>如果客户端很多就必须创建更多的工作线程服务于客户端，线程的创建会消耗服务器资源，影响效率</li><li>Client和Server建立连接后，不一定会一直进行读写操作，有可能什么都不干，但是还是占用一个工作线程，浪费资源</li><li>BIO一个服务端的工作线程对应一个客户端请求无法满足高并发场景</li></ul><p><font color="red">适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解</font></p></blockquote><br><h3 id="nio"><a class="markdownIt-Anchor" href="#nio"></a> NIO</h3><blockquote><p><strong>背景</strong>：<code>在客户端连接数量不高的情况下，使用BIO是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量</code></p><p><strong>NIO</strong>：</p><p>​	Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO</p><ul><li>Non-blocking I/O （同步非阻塞IO）</li><li>同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理</li></ul><p><img src="/2022/05/25/netty/NIO.png" srcset="/img/loading.gif" lazyload alt="NIO.png"></p><p><strong>同步非阻塞</strong></p><ul><li><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p></li><li><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p></li><li><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p></li><li><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了</p></li></ul><p><img src="/2022/05/25/netty/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E.png" srcset="/img/loading.gif" lazyload alt></p><br><p><strong>IO多路复用</strong></p><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务</p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的</p><ul><li><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持</p></li><li><p><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持</p></li><li><p><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率</p></li></ul><p><img src="/2022/05/25/netty/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012129558/article/details/82878994"><strong>内核空间与用户空间</strong></a></p><ul><li>户空间的程序不能直接去磁盘空间(网卡)中读取数据，必须由经由内核空间通过DMA来获取</li><li>一般用户空间的内存分页与磁盘空间不会对齐，因此需要由内核空间在中间做一层处理</li></ul><p><font color="red">适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持</font></p></blockquote><br><h3 id="aio"><a class="markdownIt-Anchor" href="#aio"></a> AIO</h3><blockquote><p><strong>Asynchronous I/O 异步非阻塞IO</strong></p><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作</p><p><img src="/2022/05/25/netty/AIO.png" srcset="/img/loading.gif" lazyload alt></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升</p><p><font color="red">使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持</font></p></blockquote><br><h3 id="nio-2"><a class="markdownIt-Anchor" href="#nio-2"></a> NIO</h3><p><img src="/2022/05/25/netty/NIO%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D" srcset="/img/loading.gif" lazyload alt></p><h2 id="nio的基本介绍"><a class="markdownIt-Anchor" href="#nio的基本介绍"></a> NIO的基本介绍</h2><blockquote><ul><li>Java NIO 全称 <strong>java non-blocking IO</strong>，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出 的新特性，被统称为 NIO(即 New IO)，是<strong>同步非阻塞</strong>的</li><li>NIO 相关类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写</li><li>NIO 有三大核心部分：<strong>Channel(通道)，Buffer(缓冲区), Selector(选择器)</strong></li><li>NIO是<strong>面向缓冲区 ，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区(Buffer)，需要时可在缓冲区中前后移动，这就 增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</li><li>Java NIO的<strong>非阻塞模式</strong>，<strong>使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情</strong></li><li>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来, 根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个</li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903984524705800">HTTP2.0</a>使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求 的数量比HTTP1.1大了好几个数量级</li></ul></blockquote><br><h2 id="nio三大核心"><a class="markdownIt-Anchor" href="#nio三大核心"></a> NIO三大核心</h2><h3 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h3><p>java.nio 定义了以下几个 Buffer 的实现</p><p><img src="/2022/05/25/netty/Buffer.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>一个 Buffer本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据</strong></p><p>其实核心是最后的 <strong>ByteBuffer</strong>，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 <strong>ByteBuffer</strong></p><p>我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等</p><p><strong>MappedByteBuffer</strong> 用于实现内存映射文件</p><p>操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法</p><p><strong>position、limit、capacity</strong></p><p><code>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity</code></p><p><img src="/2022/05/25/netty/Buffer.jpg" srcset="/img/loading.gif" lazyload alt></p><ul><li><p><strong>capacity</strong>：<strong>它代表这个缓冲区的容量，一旦设定就不可以更改</strong>。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值</p><br></li><li><p><strong>position</strong>：<strong>它代表这个缓冲区的数据定位，从写操作模式到读操作模式切换的时候（flip），position 都会归零，这样就可以从头开始读写了</strong></p><ul><li>写模式：每往 Buffer 中写入一个值，position 就自动加 1，<strong>代表下一次的写入位置</strong></li><li>读模式：每读一个值，position 就自动加 1，<strong>指向下一次要读取的位置</strong></li></ul><br></li><li><p><strong>limit</strong>：<strong>它代表这个缓冲区的数据限制</strong></p><ul><li>写模式：<strong>limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity</strong></li><li>读模式：<strong>此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满</strong></li></ul></li></ul><p><img src="/2022/05/25/netty/Buffer%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" lazyload alt></p></blockquote><h4 id="初始化buffer"><a class="markdownIt-Anchor" href="#初始化buffer"></a> 初始化Buffer</h4><blockquote><p>每个 Buffer 实现类都提供了一个静态方法 <code>allocate(int capacity)</code> 帮助我们快速实例化一个 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuf</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">1024</span>);<br><span class="hljs-type">LongBuffer</span> <span class="hljs-variable">longBuf</span> <span class="hljs-operator">=</span> LongBuffer.allocate(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><p>另外，我们经常使用 wrap 方法来初始化一个 Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>]);<br><span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1024</span>]);<br><span class="hljs-type">LongBuffer</span> <span class="hljs-variable">longBuffer</span> <span class="hljs-operator">=</span> LongBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">1024</span>]);<br></code></pre></td></tr></table></figure></blockquote><h4 id="填充buffer-写操作"><a class="markdownIt-Anchor" href="#填充buffer-写操作"></a> 填充Buffer (写操作)</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 填充一个 byte 值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span> b)</span>;<br><br><span class="hljs-comment">// 在指定位置填充一个 byte 值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">byte</span> b)</span>;<br><br><span class="hljs-comment">// 将一个数组中的值填充进去</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] src)</span>;<br><br><span class="hljs-comment">// 截取数组中的一部分填充进去</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] src, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferTest</span> &#123;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bufferExample</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 分配一个长度为5的IntBuffer</span><br>     <span class="hljs-comment">//IntBuffer buffer = IntBuffer.allocate(5);</span><br>     <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> IntBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>]);<br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buffer.capacity(); i++) &#123;<br>        buffer.put(i);<br>     &#125;<br><br>     <span class="hljs-comment">// 转换，如果当前是写模式则转换为读模式</span><br>     buffer.flip();<br><br>     <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>         <span class="hljs-comment">// get 有指针会向前移动</span><br>         System.out.println(buffer.get());<br>     &#125;<br> &#125;<br><br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br>     <span class="hljs-comment">// HeapIntBuffer 底层pos自动 + 1， flip 后 lim=pos， pos=1</span><br>     intBuffer.put(<span class="hljs-number">1</span>);<br><br>     intBuffer.flip();<br><br>     <span class="hljs-comment">// 输出 1</span><br>     <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>         System.out.println(intBuffer.get());<br>     &#125;<br> &#125;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put2</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br>     <span class="hljs-comment">// 这里put底层，pos不会自动加1,导致flip后 lim = pos = 0</span><br>     intBuffer.put(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>     intBuffer.flip();<br>     <span class="hljs-comment">// 重新设置限制，默认lim为0</span><br>     intBuffer.limit(<span class="hljs-number">2</span>);<br><br>     <span class="hljs-comment">// lim和pos都为0</span><br>     <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>         System.out.println(intBuffer.get());<br>     &#125;<br><br>     <span class="hljs-comment">// [0, 2, 0, 0, 0]</span><br>     System.out.println(Arrays.toString(intBuffer.array()));<br><br>     <span class="hljs-comment">// 不设置intBuffer.limit(2) 则数组下标越界（lim为0）</span><br>     System.out.println(intBuffer.get(<span class="hljs-number">1</span>));<br> &#125;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put3</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br>     <span class="hljs-type">int</span>[] bytes = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>     intBuffer.put(bytes);<br><br>     intBuffer.flip();<br><br>     <span class="hljs-comment">// 输出 1，2，3，4，5</span><br>     <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>         System.out.println(intBuffer.get());<br>     &#125;<br> &#125;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put4</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">10</span>);<br>     <span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br>     <span class="hljs-comment">// 第二个参数offse指的是数组的偏移量。第三个参数length 指的是取偏移量后几位</span><br>     intBuffer.put(array, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>     intBuffer.flip();<br><br>     <span class="hljs-comment">// 输出 2，3</span><br>     <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>         System.out.println(intBuffer.get());<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red">上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 java.nio.BufferOverflowException异常</font></p><br><p><strong>读操作</strong>：对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为<strong>读操作</strong>，因为数据是从外部（文件或网络等）读到内存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure><p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小</p></blockquote><h4 id="提取-buffer-中的值-读操作"><a class="markdownIt-Anchor" href="#提取-buffer-中的值-读操作"></a> 提取 Buffer 中的值 （读操作）</h4><blockquote><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）</p><p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个</p><p>调用 Buffer 的 <strong>flip()</strong> 方法，可以从<strong>写入模式切换到读取模式</strong>。其实这个方法也就是设置了一下 <code>position</code> 和<code>limit</code> 值罢了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">flip</span><span class="hljs-params">()</span> &#123;<br> limit = position; <span class="hljs-comment">// 将 limit 设置为实际写入的数据数量</span><br> position = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置 position 为 0</span><br> mark = -<span class="hljs-number">1</span>; <span class="hljs-comment">// mark 之后再说</span><br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据 position 来获取数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 获取指定位置的数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><span class="hljs-comment">// 将 Buffer 中的数据写入到数组中</span><br><span class="hljs-keyword">public</span> ByteBuffer <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] dst)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">int</span>[] bytes = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    intBuffer.put(bytes);<br><br>    intBuffer.flip();<br><br>    <span class="hljs-comment">// 1,2,3,4,5</span><br>    <span class="hljs-keyword">while</span> (intBuffer.hasRemaining()) &#123;<br>        <span class="hljs-comment">// 根据 position 来获取数据, 每读取一次 position + 1</span><br>        System.out.println(intBuffer.get());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">int</span>[] bytes = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    intBuffer.put(bytes);<br><br>    intBuffer.flip();<br><br>    <span class="hljs-comment">// 3</span><br>    System.out.println(intBuffer.get(<span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">get3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">IntBuffer</span> <span class="hljs-variable">intBuffer</span> <span class="hljs-operator">=</span> IntBuffer.allocate(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">int</span>[] bytes = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    intBuffer.put(bytes);<br><br>    intBuffer.flip();<br><br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 将Buffer中的数据写入到数组中</span><br>    intBuffer.get(arr);<br><br>    <span class="hljs-comment">// 1,2,3</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<code>ByteBuffer</code>经常使用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array()).trim();<br></code></pre></td></tr></table></figure><p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是将我们写入的数据传输到 Channel 中，如通过 <strong>FileChannel</strong> 将数据写入到文件中，通过 <strong>SocketChannel</strong> 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为<strong>写操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="mark-reset"><a class="markdownIt-Anchor" href="#mark-reset"></a> mark() &amp; reset()</h4><blockquote><p><strong>mark</strong>: <strong>用于临时保存 position 的值</strong>，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用</p><p><strong>reset</strong>: <strong>把position设置成mark的值</strong>，相当于之前做过一个标记，<strong>现在要退回到之前标记(mark)的地方</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">mark</span><span class="hljs-params">()</span> &#123;<br> mark = position;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mark;<br> <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>)<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidMarkException</span>();<br> position = m;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="rewind-clear-compact"><a class="markdownIt-Anchor" href="#rewind-clear-compact"></a> rewind() &amp; clear() &amp; compact()</h4><blockquote><p><strong>rewind</strong>：<strong>会重置 position 为 0，通常用于重新从头读写 Buffer</strong>,类似磁带倒带</p><p><strong>场景</strong>：在写模式下重写数据到缓冲区</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">0</span>;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><blockquote><p><strong>clear</strong>：有点重置 Buffer 的意思，相当于重新实例化了一样</p><p><strong>场景</strong>：<code>写 -&gt; 读 -&gt; clear -&gt; 继续写</code>。通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">0</span>;<br>    limit = capacity;<br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><blockquote><p><strong>compact</strong>: 和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用，相当于压缩</p><p><strong>场景</strong>：Buffer数据还没完全读完就要继续写，那么就将未读取的数据重新压缩到Buffer头部方便下次去读</p><ul><li><p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p></li><li><p>而 compact() 方法有点不一样，<strong>调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边</strong></p></li></ul></blockquote><br><h4 id="类型化的buffer"><a class="markdownIt-Anchor" href="#类型化的buffer"></a> 类型化的Buffer</h4><blockquote><p><strong>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型， get就应该使用相应的数据类型来取出， 否则可能有 BufferUnderflowException 异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">64</span>);<br>    <span class="hljs-comment">//类型化方式放入数据</span><br>    buffer.putInt(<span class="hljs-number">100</span>);<br>    buffer.putLong(<span class="hljs-number">9</span>);<br>    buffer.putChar(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    buffer.putShort((<span class="hljs-type">short</span>) <span class="hljs-number">4</span>);<br><br>    buffer.flip();<br>    <br>    <span class="hljs-comment">// 如果取出的数据类型不匹配，则可能会抛出异常， 比如最后一行调用 buffer.getShort() 缓冲会溢出</span><br>    <span class="hljs-comment">// 如果取出的顺序不一致，则读取的数据会错乱</span><br>    System.out.println(buffer.getInt());<br>    System.out.println(buffer.getLong());<br>    System.out.println(buffer.getChar());<br>    System.out.println(buffer.getShort());<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="只读buffer"><a class="markdownIt-Anchor" href="#只读buffer"></a> 只读Buffer</h4><blockquote><p><strong>可以将一个普通Buffer 转成只读Buffer,如果对 readOnlyBuffer进行 put 操作就会抛出异常</strong></p><p><img src="/2022/05/25/netty/%E5%8F%AA%E8%AF%BBbuffer.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//创建一个buffer</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        buffer.put((<span class="hljs-type">byte</span>)i);<br>    &#125;<br><br>    <span class="hljs-comment">//准备读取</span><br>    buffer.flip();<br><br>    <span class="hljs-comment">//得到一个只读的Buffer HeapByteBufferR</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">readOnlyBuffer</span> <span class="hljs-operator">=</span> buffer.asReadOnlyBuffer();<br>    System.out.println(readOnlyBuffer.getClass());<br><br>    <span class="hljs-keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;<br>        System.out.println(readOnlyBuffer.get());<br>    &#125;<br><br>    <span class="hljs-comment">//ReadOnlyBufferException</span><br>    readOnlyBuffer.put((<span class="hljs-type">byte</span>)<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="mappedbytebuffer"><a class="markdownIt-Anchor" href="#mappedbytebuffer"></a> MappedByteBuffer</h4><blockquote><p><strong>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存） 中进行修改， 而如何同步到文件由NIO 来完成</strong></p><p>这里底层其实就是使用到了<a href="/2022/05/29/Linux/#mmap">零拷贝的 MMAP 技术</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mappedByteBufferTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;/Volumes/app/test.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>    <span class="hljs-comment">//获取对应的通道</span><br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> randomAccessFile.getChannel();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 这里使用内存映射文件，可以提高内存的读写效率.实际上就是使用零拷贝的 MMAP</span><br><span class="hljs-comment">        * 参数1: FileChannel.MapMode.READ_WRITE 使用的读写模式</span><br><span class="hljs-comment">        * 参数2： 0 ： 可以直接修改的起始位置</span><br><span class="hljs-comment">        * 参数3:  5: 是映射到内存的大小(不是索引位置) ,即将 test.txt 的多少个字节映射到内存</span><br><span class="hljs-comment">        * 可以直接修改的范围就是 0-5</span><br><span class="hljs-comment">        * 实际类型 DirectByteBuffer</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">mappedByteBuffer</span> <span class="hljs-operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>       <span class="hljs-comment">// MMAP 映射到内存的数据是可以直接修改的, 可以直接修改的范围是 0-5 数据在内核空间映射到用户空间</span><br>       mappedByteBuffer.put(<span class="hljs-number">0</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;H&#x27;</span>);<br>       mappedByteBuffer.put(<span class="hljs-number">3</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;9&#x27;</span>);<br>       mappedByteBuffer.put(<span class="hljs-number">4</span>, (<span class="hljs-type">byte</span>) <span class="hljs-string">&#x27;Y&#x27;</span>);<br>       <span class="hljs-comment">// mappedByteBuffer.put(5, (byte) &#x27;Z&#x27;); //IndexOutOfBoundsException</span><br><br>       randomAccessFile.close();<br>       System.out.println(<span class="hljs-string">&quot;修改成功~~&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>这里的5是映射到内存的大小，不是索引位置，如果在操作第5个位置就会抛出异常</strong></p></blockquote><br><h4 id="buffer的分散和聚集"><a class="markdownIt-Anchor" href="#buffer的分散和聚集"></a> Buffer的分散和聚集</h4><blockquote><p><strong>前面我们讲的读写操作， 都是通过一个Buffer 完成的， NIO 还支持</strong> <strong>通过多个Buffer (即 Buffer 数组)</strong> <strong>完成读写操作， 即 Scattering 和 Gathering</strong></p><p>Buffer 的分散和聚集</p><ul><li><p><strong>Scattering</strong>：将数据写入到buffer时，可以采用buffer数组，依次写入 [分散]</p><p><img src="/2022/05/25/netty/Scatter.png" srcset="/img/loading.gif" lazyload alt></p><p>将Channel中的数据读取到多个Buffer</p><p>分离读取的时候，Channel写入buffer的数据是按顺序的，<strong>Scatter操作并不适合动态长度的数据传输，也就意味着传输数据的每一部分都是固定长度时，Scatter才能发挥它的作用</strong></p><br></li><li><p><strong>Gathering</strong>: 从buffer读取数据时，可以采用buffer数组，依次读 [聚集]</p><p><img src="/2022/05/25/netty/Gather.png" srcset="/img/loading.gif" lazyload alt></p><p>Gather操作将多个buffer的数据写入到同一个Channel</p><p>channel的write()方法可以接受buffer数据作为参数，write()方法会按照顺序将多个buffer中的数据依次写入channel。<strong>需要注意的是，write()操作只会写入buffer中已写入的数据，即position到limit之间的数据；例如一个buffer的容量为128字节，但buffer中只写入了28字节的数据，只有这28个字节会写入channel中，因此Gather操作非常适合动态长度数据写入</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 客户端使用名称 telnet localhost 8080</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>       <span class="hljs-comment">// 监听 8080 端口</span><br>       serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>       <span class="hljs-comment">//创建buffer数组</span><br>       ByteBuffer[] byteBuffers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[<span class="hljs-number">2</span>];<br>       byteBuffers[<span class="hljs-number">0</span>] = ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>       byteBuffers[<span class="hljs-number">1</span>] = ByteBuffer.allocate(<span class="hljs-number">3</span>);<br><br>       <span class="hljs-comment">//等待客户端连接（telnet）</span><br>       <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br><br>       <span class="hljs-comment">//假定从客户端接受8个字节</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">messageLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><br>       <span class="hljs-comment">//循环的读取</span><br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><br>           <span class="hljs-type">int</span> <span class="hljs-variable">byteRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>           <span class="hljs-keyword">while</span> (byteRead &lt; messageLength) &#123;<br>               <span class="hljs-comment">// 使用scattering方式读取 将数据读取到buffer数组中</span><br>               <span class="hljs-type">long</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffers);<br>               System.out.println(<span class="hljs-string">&quot;r = &quot;</span> + r);<br>               <span class="hljs-comment">//累计读取的字节数</span><br>               byteRead += <span class="hljs-number">1</span>;<br>               System.out.println(<span class="hljs-string">&quot;byteRead = &quot;</span> + byteRead);<br>               <span class="hljs-comment">//使用流打印, 看看当前的这个buffer的position 和 limit</span><br>               Arrays.asList(byteBuffers)<br>                       .stream()<br>                       .map(byteBuffer -&gt; <span class="hljs-string">&quot;position=&quot;</span> + byteBuffer.position() + <span class="hljs-string">&quot;, limit=&quot;</span> + byteBuffer.limit())<br>                       .forEach(System.out::println);<br>           &#125;<br><br>           <span class="hljs-comment">//将所有的buffer进行flip</span><br>           Arrays.asList(byteBuffers).forEach(byteBuffer -&gt; byteBuffer.flip());<br><br>           <span class="hljs-comment">//将数据读出显示到客户端</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">byteWrite</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (byteWrite &lt; messageLength) &#123;<br>               <span class="hljs-comment">// 使用gathering方式读取 将buffer数组中的数据写出到客户端</span><br>               <span class="hljs-type">long</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> socketChannel.write(byteBuffers);<br>               byteWrite += <span class="hljs-number">1</span>;<br>               System.out.println(<span class="hljs-string">&quot;byteWrite = &quot;</span> + byteWrite);<br>           &#125;<br><br>           <span class="hljs-comment">//将所有的buffer 进行clear</span><br>           Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;<br>               buffer.clear();<br>           &#125;);<br><br>           System.out.println(<span class="hljs-string">&quot;byteRead:=&quot;</span> + byteRead + <span class="hljs-string">&quot; byteWrite=&quot;</span> + byteWrite + <span class="hljs-string">&quot;, messagelength=&quot;</span> + messageLength);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></blockquote><br><br><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><p><strong>重要属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Capacity</td><td>容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变</td></tr><tr><td>Limit</td><td>表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的</td></tr><tr><td>Position</td><td>位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备</td></tr><tr><td>Mark</td><td>标记，调用mark()来设置mark=position，再调用reset()可以让position恢复到标记的位置</td></tr></tbody></table><p><strong>实例化</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>allocate(int capacity)</td><td>从堆空间中分配一个容量大小为capacity的byte数组作为缓冲区的byte数据存储器</td></tr><tr><td>allocateDirect(int capacity)</td><td>是不使用JVM堆栈而是通过操作系统来创建内存块用作缓冲区，它与当前操作系统能够更好的耦合，因此能进一步提高I/O操作速度。但是分配直接缓冲区的系统开销很大，因此只有在缓冲区较大并长期存在，或者需要经常重用时，才使用这种缓冲区</td></tr><tr><td>wrap(byte[] array)</td><td>这个缓冲区的数据会存放在byte数组中，bytes数组或buff缓冲区任何一方中数据的改动都会影响另一方。其实ByteBuffer底层本来就有一个bytes数组负责来保存buffer缓冲区中的数据，通过allocate方法系统会帮你构造一个byte数组</td></tr><tr><td>wrap(byte[] array, int offset, int length)</td><td>在上一个方法的基础上可以指定偏移量和长度，这个offset也就是包装后byteBuffer的position，而length呢就是limit-position的大小，从而我们可以得到limit的位置为length+position(offset)</td></tr></tbody></table><p><strong>重要方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>limit(), limit(10)等</td><td>其中读取和设置这4个属性的方法的命名和jQuery中的val(),val(10)类似，一个负责get，一个负责set</td></tr><tr><td>reset()</td><td>把position设置成mark的值，相当于之前做过一个标记，现在要退回到之前标记的地方</td></tr><tr><td>clear()</td><td>position = 0;limit = capacity;mark = -1; 有点初始化的味道，但是并不影响底层byte数组的内容</td></tr><tr><td>flip()</td><td>limit = position;position = 0;mark = -1; 翻转，也就是让flip之后的position到limit这块区域变成之前的0到position这块，翻转就是将一个处于存数据状态的缓冲区变为一个处于准备取数据的状态</td></tr><tr><td>rewind()</td><td>把position设为0，mark设为-1，不改变limit的值</td></tr><tr><td>remaining()</td><td>return limit - position;返回limit和position之间相对位置差</td></tr><tr><td>hasRemaining()</td><td>return position &lt; limit返回是否还有未读内容</td></tr><tr><td>compact()</td><td>把从position到limit中的内容移到0到limit-position的区域内，position和limit的取值也分别变成limit-position、capacity。如果先将positon设置到limit，再compact，那么相当于clear()</td></tr><tr><td>get()</td><td>相对读，从position位置读取一个byte，并将position+1，为下次读写作准备</td></tr><tr><td>get(int index)</td><td>绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position</td></tr><tr><td>get(byte[]）</td><td>将 Buffer 中的数据写入到数组中</td></tr><tr><td>get(byte[] dst, int offset, int length)</td><td>从position位置开始相对读，读length个byte，并写入dst下标从offset到offset+length的区域</td></tr><tr><td>put(byte b)</td><td>相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备</td></tr><tr><td>put(int index, byte b)</td><td>绝对写，向byteBuffer底层的bytes中下标为index的位置插入byte b，不改变position</td></tr><tr><td>put(ByteBuffer src)</td><td>用相对写，把src中可读的部分（也就是position到limit）写入此byteBuffer</td></tr><tr><td>put(byte[] src, int offset, int length)</td><td>从src数组中的offset到offset+length区域读取数据并使用相对写写入此byteBuffer</td></tr></tbody></table><blockquote><p><strong>相对读</strong>：position+1</p><p><strong>绝对读</strong>：不改变position</p><p><strong>相对写</strong>：postion+1</p><p><strong>绝对写</strong>：不改变position</p></blockquote><blockquote><p><strong>非直接缓冲区</strong>（直接在堆内存中开辟空间，也就是数组）：</p><p><img src="/2022/05/25/netty/%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" srcset="/img/loading.gif" lazyload alt></p><p>竖左边的是操作系统（OS），右边是Java虚拟机(JVM),<strong>应用程序无论是读操作还是写操作都必须在OS和JVM之间进行复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">通过allocate()方法分配缓冲区，将缓冲区建立在JVM的内存中<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1020</span>);<br></code></pre></td></tr></table></figure><p><strong>直接缓冲区</strong></p><p><img src="/2022/05/25/netty/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" srcset="/img/loading.gif" lazyload alt></p><p>解释：<strong>在NIO中，直接开辟物理内存映射文件，应用程序直接操作物理内存映射文件，这样就少了中间的copy过程，可以极大得提高读写效率。虽然直接缓冲可以进行高效的I/O操作，但它使用的内存是操作系统分配的，绕过了JVM堆栈，建立和销毁比堆栈上的缓冲区要更大的开销</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">分配直接缓冲区<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1020</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">直接缓冲区</td><td style="text-align:left">在虚拟机内存外，开辟的内存，IO操作直接进行,没有再次复制</td><td style="text-align:left">创建和销毁开销大</td></tr><tr><td style="text-align:left">非直接缓冲区</td><td style="text-align:left">在虚拟机内存中创建，易回收</td><td style="text-align:left">但占用虚拟机内存开销，处理中有复制过程。</td></tr></tbody></table><br><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1283.html"><strong>内存映射文件MMAP</strong></a></p><p>多个进程可以允许并发地内存映射同一文件，以便允许数据共享。任何一个进程的写入会修改<strong>虚拟内存</strong>的数据，并且其他映射同一文件部分的进程都可看到</p><p>内存映射的共享是实现：每个共享进程的<strong>虚拟内存映射指向物理内存的同一页面，而该页面有磁盘块的复制</strong></p><p><img src="/2022/05/25/netty/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6.jpg" srcset="/img/loading.gif" lazyload alt></p><p><strong>总而言之，内存映射就是将每个磁盘块映射到内存中，一个进程或多个进程把对磁盘块的访问转化为对内存页的访问</strong></p><p><font color="red">内存映射文件的目的是实现内存共享，MMAP是零拷贝的一种实现</font></p><p>很多时候，共享内存实际上是通过内存映射来实现的。在这种情况下，进程可以通过共享内存来通信，而共享内存是通过映射同样文件到通信进程的虚拟地址空间来实现的。内存映射文件充当通信进程之间的共享内存区域</p><p><img src="/2022/05/25/netty/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg" srcset="/img/loading.gif" lazyload alt></p><br><p><strong>虚拟内存</strong></p><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上物理内存通常被分隔成多个内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。此外，虚拟内存技术可以使多个进程共享同一个运行库，并通过分割不同进程的内存空间来提高系统的安全性</p><br><p><strong>相关知识理论</strong></p><ul><li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/81883894"><strong>什么是系统内核</strong></a></p><ul><li>内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。<strong>是连接应用程序和硬件的桥梁</strong></li></ul></li><li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1739264"><strong>内核空间和用户空间</strong></a></p><ul><li>原因：<ul><li><strong>保证系统运行的稳定性及可用性</strong></li><li><strong>应用程序无法直接完成读写磁盘文件，分配回收内存，从网络接口读写数据等底层硬件操作，必须由内核提供统一的接口完成</strong></li></ul></li><li>具体实现：比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3<ul><li>当进程运行在 Ring3 级别时被称为运行在<strong>用户态</strong></li><li>而运行在 Ring0 级别时被称为运行在<strong>内核态</strong></li></ul></li></ul></li><li><p><a href="/2022/05/29/Linux/#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><strong>零拷贝技术</strong></a></p></li></ul></blockquote><br><br><h3 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h3><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel</p><p><img src="/2022/05/25/netty/Channel.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li>FileChannel：文件通道，用于文件的读和写</li><li>DatagramChannel：用于 UDP 连接的接收和发送</li><li>SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li><li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li></ul></blockquote><p><strong>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中</strong></p><p><img src="/2022/05/25/netty/channel%E8%AF%BB%E6%93%8D%E4%BD%9C.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/channel%E5%86%99%E6%93%8D%E4%BD%9C.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>NIO的通道类似于流，但有些区别如下：</strong></p><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲</li></ul></blockquote><h4 id="filechannel"><a class="markdownIt-Anchor" href="#filechannel"></a> FileChannel</h4><p>文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，<strong>FileChannel 是不支持非阻塞的</strong></p><blockquote><p>FileChannel主要用来对本地文件进行 IO 操作，常见的方法有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(ByteBuffer dst)</span> ，从通道读取数据并放到缓冲区中<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ByteBuffer src)</span> ，把缓冲区的数据写到通道中<br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferFrom</span><span class="hljs-params">(ReadableByteChannel src, <span class="hljs-type">long</span> position, <span class="hljs-type">long</span> count)</span>，从目标通道 中复制数据到当前通道<br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> count, WritableByteChannel target)</span>，把数据从当 前通道复制给目标通道<br></code></pre></td></tr></table></figure></blockquote><br><blockquote><p><strong>流只能读或者写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 流只能读或者只能写</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 写入数据 输出流</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/Volumes/app/data.txt&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">18</span>);<br>        byteBuffer.put(<span class="hljs-string">&quot;写入测试数据&quot;</span>.getBytes());<br><br>        <span class="hljs-comment">// 切换读模式</span><br>        byteBuffer.flip();<br>        fileChannel.write(byteBuffer);<br><br>        <span class="hljs-comment">// 读取数据</span><br>        byteBuffer.clear();<br><br>        <span class="hljs-comment">// 读取数据 输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/Volumes/app/data.txt&quot;</span>);<br>        fileChannel = fileInputStream.getChannel();<br>        fileChannel.read(byteBuffer);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()));<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>通道可以从缓冲读数据，也可以写数据到缓冲</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;/Volumes/app/data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> randomAccessFile.getChannel();<br><br><span class="hljs-comment">// 写入数据， utf-8 一个汉字三个字节</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">18</span>);<br>byteBuffer.put(<span class="hljs-string">&quot;写入测试数据&quot;</span>.getBytes());<br><br><span class="hljs-comment">// 切换读模式</span><br>byteBuffer.flip();<br><br><span class="hljs-comment">// 读取Buffer的数据到channel</span><br><span class="hljs-keyword">while</span> (byteBuffer.hasRemaining()) &#123;<br> fileChannel.write(byteBuffer);<br>&#125;<br><br>byteBuffer.clear();<br>fileChannel.read(byteBuffer);<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array()));<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>实现文件复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/Volumes/app/data.txt&quot;</span>);<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> inputStream.getChannel();<br><br>     <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/Volumes/app/data2.txt&quot;</span>);<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> outputStream.getChannel();<br><br>     <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br><br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 这里一定要清理buffer.否则limit 和 position相等会读取不到数据 num一直等于0（buffer刚被读完状态）</span><br>         buffer.clear();<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> inChannel.read(buffer);<br>         <span class="hljs-keyword">if</span> (num == -<span class="hljs-number">1</span>) &#123;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br><br>         buffer.flip();<br>         outChannel.write(buffer);<br>     &#125;<br><br>     outChannel.close();<br>     inChannel.close();<br>     outputStream.close();<br>     inputStream.close();<br> &#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>sendFile 零拷贝</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件拷贝使用sendFile实现零拷贝</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferFrom</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//创建相关流</span><br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;/Volumes/app/data.txt&quot;</span>);<br>    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;/Volumes/app/data2.txt&quot;</span>);<br><br>    <span class="hljs-comment">//获取各个流对应的filechannel</span><br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">sourceCh</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">destCh</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel();<br><br>    <span class="hljs-comment">//使用transferForm完成拷贝</span><br>    destCh.transferFrom(sourceCh, <span class="hljs-number">0</span>,sourceCh.size());<br><br>    <span class="hljs-comment">//关闭资源</span><br>    sourceCh.close();<br>    sourceCh.close();<br>    fileInputStream.close();<br>    fileOutputStream.close();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 网络传输文件实现零拷贝</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transferTo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Volumes/app/data.txt&quot;</span>);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> file.length();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1.将test.txt文件内容读取到arr中</span><br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(file, <span class="hljs-string">&quot;rwd&quot;</span>);<br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> raFile.getChannel();<br><br>        <span class="hljs-comment">// 2.提供对外服务</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span><br>                    serverSocketChannel.accept();<br><br>            <span class="hljs-keyword">if</span>(socketChannel != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">// 3.使用transferTo方法将文件数据传输到客户端</span><br>                channel.transferTo(<span class="hljs-number">0</span>, size, socketChannel);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="serversocketchannel"><a class="markdownIt-Anchor" href="#serversocketchannel"></a> ServerSocketChannel</h4><blockquote><p>SocketChannel可以看作是 TCP 客户端，那么 ServerSocketChannel 就是对应的服务端</p><p><img src="/2022/05/25/netty/ServerSocketChannel.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">// 实例化</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">// 监听 8080 端口</span><br>serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br> <span class="hljs-comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span><br> <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里我们可以看到 SocketChannel 的另一个实例化方式</strong></p><p>SocketChannel 它不仅仅是 TCP 客户端，它代表的是一个网络通道，可读可写</p><p><strong>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接</strong></p></blockquote><br><h4 id="socketchannel"><a class="markdownIt-Anchor" href="#socketchannel"></a> SocketChannel</h4><blockquote><p>可以将 SocketChannel 理解成一个 TCP 客户端或者一个可读可写的网络通道</p><p><strong>NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类 似Socket</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">// 打开一个通道</span><br><span class="hljs-comment">// SocketChannel socketChannel = SocketChannel.open();</span><br><span class="hljs-comment">// 发起连接</span><br><span class="hljs-comment">// socketChannel.connect(new InetSocketAddress(&quot;http://localhost&quot;, 8080));</span><br><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取数据</span><br>socketChannel.read(buffer);<br><br><span class="hljs-comment">// 写入数据到网络连接中</span><br><span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>socketChannel.write(buffer);   <br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="datagramchannel"><a class="markdownIt-Anchor" href="#datagramchannel"></a> DatagramChannel</h4><blockquote><p>UDP 和 TCP 不一样，<strong>DatagramChannel 一个类处理了服务端和客户端</strong></p><p><strong>UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-comment">// 服务端</span><br>  <span class="hljs-type">DatagramChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> DatagramChannel.open();<br>  server.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>  <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">35</span>);<br><br>  <span class="hljs-comment">// 客户端发送数据</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">newData</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;datagramChannel test  &quot;</span><br>                + System.currentTimeMillis();<br><br>        buf.put(newData.getBytes());<br>        buf.flip();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bytesSent</span> <span class="hljs-operator">=</span> server.send(buf, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br><br>        <span class="hljs-comment">// 服务端监听</span><br>        server.receive(buf);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf.array()));<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><ul><li>通道类似于流，但是通道可以进行<strong>读和写</strong></li><li>读和写<ul><li>通道的<code>read</code>操作是将通道中的数据写到缓冲的过程</li><li>通道的<code>writer</code>操作是将缓冲的数据写到通道的过程</li></ul></li><li><strong>一个通道可以对应多个缓冲</strong>，能够对多个缓冲进行读写</li></ul><br><br><h3 id="selector"><a class="markdownIt-Anchor" href="#selector"></a> Selector</h3><blockquote><p><strong>介绍</strong></p><ul><li>Java 的 NIO，用非阻塞的 IO 方式。<strong>可以用一个线程，处理多个的客户端连接</strong>，就会使用到Selector(选择器或叫多路复用器)</li><li>Selector 能够检测多个注册的通道上是否有事件发生<font color="red">(注意:多个Channel以事件的方式可以注册到同一个Selector)</font>，<strong>如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</strong></li><li>只有在 通道(连接) <strong>真正有读写事件发生时，才会进行读写</strong>，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><p><img src="/2022/05/25/netty/Channel%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>说明</strong></p><ul><li>Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器， 也叫多路复用器)，可以同时并发处理成百上千个客户端连接</li><li>当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务</li><li>线程通常将非阻塞 IO 的空闲时间用于在其他通道上 执行 IO 操作，所以单独的线程可以管理多个输入和 输出通道</li><li>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起（BIO数据没就绪就会阻塞线程）</li><li>一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，<strong>这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到 了极大的提升</strong></li></ul></blockquote><br><h4 id="selector常用方法"><a class="markdownIt-Anchor" href="#selector常用方法"></a> Selector常用方法</h4><blockquote><p>Selector是一个<strong>抽象类</strong></p><p><strong>源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Selector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123; <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Selector <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<span class="hljs-comment">//得到一个选择器对象 </span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span>;<span class="hljs-comment">//监控所有注册的通道，当其中有 IO 操作可以进行时，将对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间 </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="hljs-title function_">keys</span><span class="hljs-params">()</span>;<span class="hljs-comment">//获取当前channel注册在Selector上所有的key</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="hljs-title function_">selectedKeys</span><span class="hljs-params">()</span>;<span class="hljs-comment">//从内部集合中得到所有的 SelectionKey </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<span class="hljs-comment">//不阻塞，立马返还</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span><span class="hljs-keyword">throws</span> IOException;<span class="hljs-comment">//阻塞1000毫秒，在1000毫秒后返回</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<span class="hljs-comment">//阻塞,监控所有注册的通,至少有一个已注册的Channel发生了事件才返回</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Selector <span class="hljs-title function_">wakeup</span><span class="hljs-params">()</span>;<span class="hljs-comment">//唤醒</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<span class="hljs-comment">//关闭</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="selectionkey"><a class="markdownIt-Anchor" href="#selectionkey"></a> SelectionKey</h4><blockquote><p><strong>SelectionKey，表示 Selector 和Channel的注册关系</strong></p><p>当我们调用**<code>channel.register(selector, SelectionKey.OP_READ, buffer);</code><strong>方法时，会将</strong>通道channel注册到选择器selector上并监听指定事件，同时会返回一个SelectionKey选择键对象，这个键对象标识了通道和选择器之间的注册关系。选择键会记住您关心的通道。它们也会追踪对应的通道是否已经就绪**。当您调用一个选择器对象的select( )方法时，相关的键建会被更新，用来检查所有被注册到该选择器的通道。您可以获取一个就绪键的集合，从而找到当时已经就绪的通道。通过遍历这些键，您可以选择出每个从上次您调用select( )开始直到现在，已经就绪的通道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionKey</span> &#123;<br>	<span class="hljs-comment">//以下四个常量是定义的通道的四种操作</span><br> <span class="hljs-comment">// 代表读操作</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_READ</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br> <span class="hljs-comment">// 代表写操作</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_WRITE</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br> <span class="hljs-comment">// 代表连接已经建立</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_CONNECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br> <span class="hljs-comment">//有新的网络连接可以 accept</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OP_ACCEPT</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br> <br>	<span class="hljs-comment">//可以针对指定的通道附加一个对象 </span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Object</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<span class="hljs-comment">// 获得通道对象</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SelectableChannel <span class="hljs-title function_">channel</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">// 获得通道所注册的选择器</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Selector <span class="hljs-title function_">selector</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">// 验证通道和选择器之间的注册关系是否还生效</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//将通道放入选择器的已注销集合中</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//获得该通道所感兴趣的操作</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">interestOps</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//设置通道感兴趣的操作</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> SelectionKey <span class="hljs-title function_">interestOps</span><span class="hljs-params">(<span class="hljs-type">int</span> paramInt)</span>;<br>	<span class="hljs-comment">//获得通道已准备好的操作</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readyOps</span><span class="hljs-params">()</span>;<br> <br> <span class="hljs-comment">//是否可以读 </span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadable</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> ((readyOps() &amp; <span class="hljs-number">0x1</span>) != <span class="hljs-number">0</span>);<br>	&#125;<br> <br> <span class="hljs-comment">//是否可以写 </span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isWritable</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> ((readyOps() &amp; <span class="hljs-number">0x4</span>) != <span class="hljs-number">0</span>);<br>	&#125;<br> <br> <span class="hljs-comment">// 是否可以 accept</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnectable</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> ((readyOps() &amp; <span class="hljs-number">0x8</span>) != <span class="hljs-number">0</span>);<br>	&#125;<br> <br> <span class="hljs-comment">//是否可以 accept</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAcceptable</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> ((readyOps() &amp; <span class="hljs-number">0x10</span>) != <span class="hljs-number">0</span>);<br>	&#125;<br> <br> <span class="hljs-comment">//为SelectionKey绑定附加对象</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">attach</span><span class="hljs-params">(Object paramObject)</span> &#123;<br>		<span class="hljs-type">Object</span> <span class="hljs-variable">localObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.attachment;<br>		<span class="hljs-built_in">this</span>.attachment = paramObject;<br>		<span class="hljs-keyword">return</span> localObject;<br>	&#125;<br> <br> <span class="hljs-comment">//绑定之后，可通过对应的SelectionKey取出该对象</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">attachment</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.attachment;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/Selector.jpg" srcset="/img/loading.gif" lazyload alt></p><ul><li>当客户端连接时，会通过ServletSocketChannel得到对应的StoketChannel</li><li>Selector进行事件监听（select方法），返回有事件发生的通道个数</li><li>将SocketChannel注册到Selector上，一个Selector可以注册多个Channel（比如：<strong>SelectableChannel:register(Selector sel, int ops) 其中ops为事件类型</strong>）</li><li>注册后返回一个SelectionKey,会和该Selector关联（Selector维护一个集合）</li><li>进一步得到SelectionKey(有事件发生)</li><li>通过SelectionKey反向获得SocketChannel(比如：<strong>SelectionKey:channel()</strong>)</li><li>通过得到的Channel配合Buffer完成读写操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">server</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1.打开一个服务端通道</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-comment">// 2.绑定端口号</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 3.通道默认是阻塞的,设置为非阻塞</span><br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 4.创建一个选择器</span><br>        <span class="hljs-comment">// 真实类型</span><br>        <span class="hljs-comment">// Windows平台: WindowsSelectorImpl</span><br>        <span class="hljs-comment">// Linux平台: EpollSelectorImpl</span><br>        <span class="hljs-comment">// Mac平台: KQueueSelectorImpl</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br>        <span class="hljs-comment">// 5.将通道注册到选择器上, 并且指定监听事件 OP_ACCEPT</span><br>        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br>        <span class="hljs-comment">// 6.轮询式的获取选择器上已经准备就绪的事件</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 7.轮询获取已经就绪的事件</span><br>            <span class="hljs-keyword">if</span> (selector.select(<span class="hljs-number">1000</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 8.如果3秒钟内没有获取到已经就绪的事件, 则打印一个警告信息</span><br>                System.out.println(<span class="hljs-string">&quot;没有获取到已经就绪的事件&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 8.获取已经就绪的事件(可能有多个就绪的事件,所以是集合)</span><br>            Set&lt;SelectionKey&gt;      selectionKeys = selector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; iterator      = selectionKeys.iterator();<br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> iterator.next();<br><br>                <span class="hljs-comment">// 9.判断就绪时间类型, 如果是OP_ACCEPT, 则表示有新的客户端连接到来</span><br>                <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                    <span class="hljs-comment">// 10.获取到客户端通道</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                    <span class="hljs-comment">// 11.设置为非阻塞</span><br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 12.将客户端通道注册到选择器上, 并且指定监听事件 OP_READ, 再添加一个绑定对象</span><br>                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="hljs-number">1024</span>));<br>                &#125;<br><br>                <span class="hljs-comment">// 13.如果是OP_READ, 则表示有客户端数据发送过来</span><br>                <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                    <span class="hljs-comment">// 14.通过selectionKey获取到客户端通道</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) selectionKey.channel();<br>                    <span class="hljs-comment">// 15. 获取绑定对象</span><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> (ByteBuffer) selectionKey.attachment();<br>                    <span class="hljs-comment">// 16.读取数据</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), <span class="hljs-number">0</span>, read, StandardCharsets.UTF_8));<br><br>                    <span class="hljs-comment">// 17.向客户端发送数据</span><br>                    socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;hello client&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>                    <span class="hljs-comment">// 通道一旦关闭就不能被再次打开</span><br>                    socketChannel.close();<br>                &#125;<br>                <span class="hljs-comment">// 18.清空已处理的事件</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">client</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// 1.打开一个客户端通道</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <span class="hljs-comment">// 2.设置为非阻塞</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 3.发送数据</span><br>        socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;hello server&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">// 4.客户端读取服务端发送过来的数据</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-type">int</span>        <span class="hljs-variable">read</span>       <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), <span class="hljs-number">0</span>, read, StandardCharsets.UTF_8));<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure></blockquote><h4 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h4><ul><li>Channel注册到Selector中必须设置需要关注的<strong>事件</strong></li><li>Channel注册到Selector会返回一个SelectionKey,<strong>可以通过这个Key反向获取到和客户端连接的Channel</strong></li><li>一个Selector可以注册多个Channel</li><li>当触发了注册的事件后,数据准备就绪就会将SelectionKey放到<code>Selector的selectedKeys</code>中,可以遍历这个Set去处理就绪事件</li><li>NIO的非阻塞特性需要手动设置<code>SelectableChannel.configureBlocking(false)</code></li></ul><br><br><h3 id="nio-网络编程"><a class="markdownIt-Anchor" href="#nio-网络编程"></a> NIO 网络编程</h3><blockquote><p><strong>要求</strong></p><ul><li></li></ul></blockquote><h2 id="内核角度看nio"><a class="markdownIt-Anchor" href="#内核角度看nio"></a> 内核角度看NIO</h2><p><a target="_blank" rel="noopener" href="https://developer.51cto.com/article/703026.html">聊聊Netty那些事儿之从内核角度看IO模型</a></p><br><br><h2 id="reactor线程模型"><a class="markdownIt-Anchor" href="#reactor线程模型"></a> Reactor线程模型</h2><p>Reactor模式 是一种「<strong>事件驱动</strong>」模式</p><p>「Reactor线程模型」就是通过单个线程使用Java NIO包中的Selector的select()方法，进行监听。当获取到事件(如accept、read等)后，就会分配(dispatch)事件进行相应的事件处理(handle)</p><p>如果要给 Reactor线程模型 下一个更明确的定义，应该是</p><blockquote><p>Reactor线程模式 = Reactor(I/O多路复用)+ 线程池</p></blockquote><p><strong>其中Reactor负责监听和分配事件，线程池负责处理事件</strong></p><br><h3 id="单reactor单线程"><a class="markdownIt-Anchor" href="#单reactor单线程"></a> 单Reactor单线程</h3><p><img src="/2022/05/25/netty/%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>说明</strong>:</p><ul><li>Select 是前面 I/O 复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求(IO多路复用)</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 accept 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li><li>Handler 会完成 <code>Read→业务处理→Send</code> 的完整业务流程.<strong>服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写 等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑</strong></li></ul></blockquote><blockquote><p><strong>优点</strong>:</p><ul><li><strong>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</strong></li></ul></blockquote><blockquote><p><strong>缺点</strong>:</p><ul><li><strong>性能问题</strong>，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某 个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li><strong>可靠性问题</strong>，线程意外终止，或者进入死循环，会导致整个系统通信模块不 可用，不能接收和处理外部消息，造成节点故障</li></ul></blockquote><blockquote><p><strong>使用场景</strong>:</p><ul><li><strong>客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复 杂度 O(1) 的情况</strong></li></ul></blockquote><br><h3 id="单reactor多线程"><a class="markdownIt-Anchor" href="#单reactor多线程"></a> 单Reactor多线程</h3><p><img src="/2022/05/25/netty/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>说明</strong>:</p><ul><li><strong>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发</strong></li><li><strong>如果建立连接请求, 则由 Acceptor 通过 accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件</strong></li><li><strong>如果不是连接请求，则由 Reactor 分发调用连接对 应的Handler 来处理</strong></li><li><strong>Handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 Worker 线程池的某个线程处理业务</strong></li><li><strong>Worker 线程池会分配独立线程完成真正的业务， 并将结果返回给 Handler</strong></li><li><strong>Handler 收到响应后，通过 send 将结果返回给 Client</strong></li></ul></blockquote><blockquote><p><strong>优点</strong>:</p><ul><li><strong>可以充分的利用多核cpu 的处理能力</strong></li></ul></blockquote><blockquote><p><strong>缺点</strong>:</p><ul><li>多线程数据共享和访问比较复杂,<strong>单 Reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈</strong></li></ul></blockquote><br><h3 id="主从reactor多线程"><a class="markdownIt-Anchor" href="#主从reactor多线程"></a> 主从Reactor多线程</h3><p><img src="/2022/05/25/netty/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>说明</strong>:</p><ul><li><strong>Reactor 主线程 MainReactor 对象通过 select 监听连接事件, 收到事件后，通过 Acceptor 处理连接事件(主 Reactor 只处理连接事件)</strong></li><li><strong><font color="red">当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor</font></strong></li><li><strong>SubReactor 将连接加入到连接队列进行监听,并创建 Handler 进行各种事件处理</strong></li><li><strong>当有新事件发生时， SubReactor 就会调用对应的 Handler处理，Handler 通过 read 读取数据，分发给后面的 （Worker 线程池）处理</strong></li><li><strong>（Worker 线程池）分配独立的 （Worker 线程）进行业务处理，并返 回结果</strong></li><li><strong>Handler 收到响应的结果后，再通过 send 将结果返回给 Client</strong></li><li><strong>一个 MainReactor 可以关联多个 SubReactor</strong></li></ul></blockquote><blockquote><p><strong>优点</strong>:</p><ul><li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li><li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据</li></ul></blockquote><blockquote><p><strong>缺点</strong>:</p><ul><li>编程复杂度较高</li></ul></blockquote><blockquote><p><strong>结合实例</strong>:</p><ul><li>这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 Reactor 多进程模型， <code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ul></blockquote><br><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><blockquote><ul><li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</li><li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 Reactor 多线程，多个前台接待员，多个服务员</li></ul></blockquote><blockquote><p><strong>Reactor 模式具有如下的优点：</strong></p><ul><li>响应快，不必为单个同步事件所阻塞，虽然 Reactor 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程 的切换开销</li><li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li><li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ul></blockquote><br><br><h2 id="netty模型"><a class="markdownIt-Anchor" href="#netty模型"></a> Netty模型</h2><h3 id="简单版"><a class="markdownIt-Anchor" href="#简单版"></a> 简单版</h3><p><img src="/2022/05/25/netty/netty%E7%AE%80%E5%8D%95%E7%89%88.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li><strong>BossGroup线程维护Selector, 只关注Accecpt（只处理连接事件）</strong></li><li><strong>当接收到Accept事件，获取到对应的 SocketChannel, 封装成 NIOScoketChannel并注册到 Worker 线程(事件循环), 并进行维护</strong></li><li><strong>当Worker线程监听到 Selector 中通道发生自己感兴趣的事件后（监听事件），就进行处理(就由 Handler 处理)， 注意 Handler 已经加入到通道</strong></li></ul></blockquote><h3 id="进阶版"><a class="markdownIt-Anchor" href="#进阶版"></a> 进阶版</h3><p><img src="/2022/05/25/netty/netty%E8%BF%9B%E9%98%B6%E7%89%88.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li>Netty主要基于<strong>主从Reactor多线程模型</strong>做了一定的改进，其中主从Reactor多线程模型有多个Reactor</li><li>每个Reactor都可以看作是一个<strong>NIOEventLoop</strong></li></ul></blockquote><h3 id="最终版"><a class="markdownIt-Anchor" href="#最终版"></a> 最终版</h3><p><img src="/2022/05/25/netty/NettyReactor%E5%B7%A5%E4%BD%9C%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li><strong>Netty 抽象出两组线程池 ，BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写</strong></li><li><strong>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup (NIO事件循环组)</strong></li><li><strong>NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 NioEventLoop</strong></li><li><strong>NioEventLoop 表示一个不断循环的执行处理任务的线程(selector监听绑定事件是否发生，因为是非阻塞的所以需要不断循环)，每个 NioEventLoop 都有一个 Selector，用于监听绑定在其上的 socket 的网络通讯，比如NioServerSocketChannel绑定在服务器boosgroup的NioEventLoop的selector上，NioSocketChannel绑定在客户端的NioEventLoop的selector上，然后各自的selector就不断循环监听相关事件</strong></li><li><strong>NioEventLoopGroup 可以有多个线程，即可以含有多个 NioEventLoop</strong></li><li><strong>每个 BossGroup下面的NioEventLoop 循环执行的步骤有 3 步</strong><ul><li>轮询 accept 事件</li><li>处理 accept 事件，与 client 建立连接，生成 NioScocketChannel，并将其注册到某个 workerGroup NIOEventLoop 上的 Selector</li><li>继续处理任务队列的任务，即 runAllTasks（同一时间可能会有多个连接，就绪的任务就放在TaskQueue中）</li></ul></li><li><strong>每个 WorkerGroup NIOEventLoop 循环执行的步骤</strong><ul><li>轮询 read，write 事件</li><li>处理 I/O 事件，即 read，write 事件，在对应 NioScocketChannel 处理</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li><li><strong>每个 Worker NIOEventLoop 处理业务时，会使用 <code>pipeline（管道）</code>，pipeline 中包含了 channel（通道），即通过 pipeline 可以获取到对应通道，管道中维护了很多的Handler</strong></li><li><strong><font color="red">NioEventLoop 内部采用串行化设计，从消息的 读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由 IO 线程 NioEventLoop 负责</font></strong></li><li><strong>NioEventLoopGroup 下包含多个 NioEventLoop</strong><ul><li>每个 NioEventLoop 中包含有一个 <strong>Selector</strong>，一个 <strong>taskQueue</strong></li><li>每个 NioEventLoop 的 Selector 上可以注册监听<strong>多个</strong> NioChannel</li><li><strong>每个 NioChannel 只会绑定在唯一的 NioEventLoop 上</strong></li><li>每个 NioChannel 都绑定有一个自己的 ChannelPipeline</li><li>NioChannel可以获取对应的ChannelPipeline，ChannelPipeline也可以获取对应的NioChannel</li></ul></li></ul></blockquote><blockquote><p><strong>ChannelPipeline 管道</strong>：比如水管，水管是由多个组件组成的，比如，弯头，开关，变径等。这些组件就好比是Handler, 当水（NioChannel）流过管道（ChannelPipeline）就会经过经过管道的组件，水就会被管道组件（Handler）所处理</p></blockquote><br><h3 id="netty-tcp服务例子"><a class="markdownIt-Anchor" href="#netty-tcp服务例子"></a> Netty TCP服务例子</h3><blockquote><p>使用Netty开发，当客户端连接上服务端后发送消息，服务端接收消息后相应客户端</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Netty 服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建BossGroup 和 WorkerGroup</span><br>        <span class="hljs-comment">//说明</span><br>        <span class="hljs-comment">//1. 创建两个线程组 bossGroup 和 workerGroup</span><br>        <span class="hljs-comment">//2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成</span><br>        <span class="hljs-comment">//3. 两个都是无限循环</span><br>        <span class="hljs-comment">//4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数</span><br>        <span class="hljs-comment">//   默认实际 cpu核数 * 2</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-comment">//ServerBootstrap作为一个启动辅助类，通过他可以很方便的创建一个Netty服务端。从EchoServer可以看出，实现一个Server大概分为这样几个步骤：</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//1.设置bossGroup和workGroup。这里可以先理解为两个线程池，bossGroup设置一个线程，用于处理连接请求和建立连接，</span><br>        <span class="hljs-comment">// 而workGroup线程池大小默认值2*CPU核数，在连接建立之后处理IO请求。</span><br>        <span class="hljs-comment">// EventLoopGroup体现了Netty对线程模型的抽象设计</span><br>        <span class="hljs-comment">//2.指定使用NioServerSocketChannel来处理连接请求。</span><br>        <span class="hljs-comment">// channel(NioServerSocketChannel.class)这段代码实际上在设置channelFactory，而ServerBootstrap会通过channelFactory.newChannel来生产channel。</span><br>        <span class="hljs-comment">// 这里channelFactory是一个ReflectiveChannelFactory，顾名思义这个工厂类以反射的方式来构建channel实例，而实例的类型就是我们指定的NioServerSocketChannel。</span><br>        <span class="hljs-comment">//        3.配置TCP参数。</span><br>        <span class="hljs-comment">//        4.配置handler和childHandler，数据处理器。</span><br>        <span class="hljs-comment">//        5.ServerBootstrap启动服务器。</span><br>        <span class="hljs-comment">//        真正的启动过程由ChannelFuture f = b.bind(PORT).sync();开始触发。调用链路：ServerBootstrap.bind → AbstractBootstrap.bind → AbstractBootstrap.doBind</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建服务器端的启动对象，配置参数</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            <span class="hljs-comment">//配置</span><br>            <span class="hljs-comment">//使用链式编程来进行设置</span><br>            bootstrap.group(bossGroup, workerGroup) <span class="hljs-comment">// 设置两个线程组</span><br>            .channel(NioServerSocketChannel.class) <span class="hljs-comment">//使用NioServerSocketChannel 作为服务器的通道实现</span><br>            .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>) <span class="hljs-comment">// 设置线程taskQueue的长度</span><br>            .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 设置保持活动连接状态</span><br>             <span class="hljs-comment">//.handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup</span><br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span><br><br>                <span class="hljs-comment">//给pipeline 设置处理器</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    System.out.println(<span class="hljs-string">&quot;client socketChannel hashCode = &quot;</span> + socketChannel.hashCode());<br>                    socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                &#125;<br>            &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;server is ready&quot;</span>);<br><br>            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个 ChannelFuture 对象</span><br>            <span class="hljs-comment">//启动服务器(并绑定端口)</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>            <span class="hljs-comment">//给channelFuture 注册监听器，监控我们关心的事件</span><br>            channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-keyword">if</span>(future.isSuccess()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口 6666 成功&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口 6666 失败&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 优雅停机</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">说明</span><br><span class="hljs-comment">1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范)</span><br><span class="hljs-comment">2. 这时我们自定义一个Handler , 才能称为一个handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><br><span class="hljs-comment">    2. Object msg: 就是客户端发送的数据 默认Object</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());<br>        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);<br>        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span><br><br>        <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span><br>        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">// 数据读取完毕</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//writeAndFlush 是 write + flush</span><br>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span><br>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello client !!!&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Netty客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 客户端需要一个时间循环组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建客户端启动对象</span><br>            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>            bootstrap.group(eventLoopGroup)<br>                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span><br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//给pipeline 设置处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">// 对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 优雅停机</span><br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端处理类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">// 当通道准备就绪就会触发该方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 发送消息给服务端</span><br>        System.out.println(<span class="hljs-string">&quot;client &quot;</span> + ctx);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello server !!&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">// 当通道就就绪的读取时间时，会触发</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;服务端回复的消息是：&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;服务器地址是：&quot;</span> +  ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">// 异常处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="自定义任务"><a class="markdownIt-Anchor" href="#自定义任务"></a> 自定义任务</h4><blockquote><ul><li><strong>当需要执行比较耗时的任务时，为了避免长时间阻塞<code>EventLoop</code>,可以将任务提交给<code>taskQueue</code>,由任务队列异步执行</strong></li></ul><p>用户自定义普通任务，修改<code>NettyServerHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数据读取完毕</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 添加耗时长的自定义任务， 异步执行10秒, 如果添加多个则串行执行</span><br>        ctx.channel().eventLoop().execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 假设任务需要执行10</span><br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            System.out.println(Thread.currentThread().getName());<br>            ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;自定义任务响应&quot;</span>, CharsetUtil.UTF_8));<br>        &#125;);<br><br><br>        <span class="hljs-comment">//writeAndFlush 是 write + flush</span><br>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span><br>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span><br>        System.out.println(Thread.currentThread().getName());<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello client !!!&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br><br>启动服务端和客户端后<br><br>服务端输出：<br>客户端发送消息是:hello server !!<br>客户端地址:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">57026</span><br>nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span><br>nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span><br>    <br>客户端输出：<br>服务端回复的消息是：hello client !!!<br>服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br>服务端回复的消息是：自定义任务响应<br>服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><p><strong>由此可见，用户自定义的任务不会阻塞正常的流程，并且<code>taskQueue</code>执行的线程是<code>EventLoop</code>这个线程</strong></p><p><img src="/2022/05/25/netty/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1.png" srcset="/img/loading.gif" lazyload alt></p></blockquote><br><h4 id="定时任务"><a class="markdownIt-Anchor" href="#定时任务"></a> 定时任务</h4><blockquote><p><strong>定时任务，按照指定时间间隔触发，异步执行。任务是提交到<code>scheduledTaskQueue</code></strong></p><p>用户定义定时任务，修改<code>NettyServerHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">// 数据读取完毕</span><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-comment">// 添加耗时长的自定义任务， 异步执行</span><br>     ctx.channel().eventLoop().execute(() -&gt; &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>             e.printStackTrace();<br>         &#125;<br><br>         log.info(Thread.currentThread().getName());<br>         ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;自定义任务响应&quot;</span>, CharsetUtil.UTF_8));<br>     &#125;);<br><br>     <span class="hljs-comment">// 添加定时任务, 10秒执行一次</span><br>     ctx.channel().eventLoop().schedule(() -&gt; &#123;<br>         log.info(Thread.currentThread().getName());<br>         ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;定时任务响应&quot;</span>, CharsetUtil.UTF_8));<br>     &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br><br><br>     <span class="hljs-comment">//writeAndFlush 是 write + flush</span><br>     <span class="hljs-comment">//将数据写入到缓存，并刷新</span><br>     <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span><br>     log.info(Thread.currentThread().getName());<br>     ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello client !!!&quot;</span>, CharsetUtil.UTF_8));<br> &#125;<br><br>启动服务端和客户端后<br><br>服务端输出：<br>客户端发送消息是:hello server !!<br>客户端地址:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">58964</span><br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">19.889</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyServerHandler - nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span><br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">29.912</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyServerHandler - nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span><br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">29.912</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyServerHandler - nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span><br> <br>客户端输出：<br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">19.905</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务端回复的消息是：hello client !!!<br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">19.905</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">29.912</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务端回复的消息是：自定义任务响应<br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">29.912</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">29.912</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务端回复的消息是：定时任务响应<br><span class="hljs-number">19</span>:<span class="hljs-number">17</span>:<span class="hljs-number">29.912</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" srcset="/img/loading.gif" lazyload alt></p><p><strong><code>scheduledTaskQueue</code>的执行线程是<code>EventLoop</code>这个线程</strong></p></blockquote><br><h4 id="非reachor线程调用channel"><a class="markdownIt-Anchor" href="#非reachor线程调用channel"></a> 非Reachor线程调用Channel</h4><blockquote><p>例如在<strong>推送系统</strong>的业务线程里面，根据用户的标识，找到对应用户的<strong>Channel引用</strong>，然后调用Channel的writer方法向用户推送消息</p><p>用户定义定时任务，修改<code>NettyServerHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br> <span class="hljs-comment">// channel 用户列表</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Set&lt;Channel&gt; channelSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br> <span class="hljs-comment">// 构造器执行定时任务</span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">NettyServerHandler</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 模拟推送业务</span><br>     pushMsg();<br> &#125;<br><br> <span class="hljs-comment">//读取数据实际(这里我们可以读取客户端发送的消息)</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址</span><br><span class="hljs-comment">    2. Object msg: 就是客户端发送的数据 默认Object</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; channle =&quot;</span> + ctx.channel());<br>        System.out.println(<span class="hljs-string">&quot;server ctx =&quot;</span> + ctx);<br>        System.out.println(<span class="hljs-string">&quot;看看channel 和 pipeline的关系&quot;</span>);<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ctx.pipeline(); <span class="hljs-comment">//本质是一个双向链接, 出站入站</span><br><br>        <span class="hljs-comment">//将 msg 转成一个 ByteBuf</span><br>        <span class="hljs-comment">//ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">// 数据读取完毕</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        channelSet.add(ctx.channel());<br>        <span class="hljs-comment">//writeAndFlush 是 write + flush</span><br>        <span class="hljs-comment">//将数据写入到缓存，并刷新</span><br>        <span class="hljs-comment">//一般讲，我们对这个发送的数据进行编码</span><br>        log.info(Thread.currentThread().getName());<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello client !!!&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-comment">// 定时向客户端推送在线人数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 非Reactor线程</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br>        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> channelSet.size();<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                Iterator&lt;Channel&gt; iterator = channelSet.iterator();<br><br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-type">Channel</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>                    <span class="hljs-keyword">if</span> (!next.isActive()) &#123;<br>                        iterator.remove();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        next.pipeline().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;当前人数：&quot;</span> + count, CharsetUtil.UTF_8));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">//处理异常, 一般是需要关闭通道</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.close();<br>    &#125;<br>&#125;<br><br>客户端输出：<br><span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">46.322</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务端回复的消息是：hello client !!!<br><span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">46.322</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br><span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">51.287</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务端回复的消息是：当前人数：<span class="hljs-number">1</span><br><span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">51.287</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br><span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">56.275</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务端回复的消息是：当前人数：<span class="hljs-number">1</span><br><span class="hljs-number">19</span>:<span class="hljs-number">49</span>:<span class="hljs-number">56.275</span> [nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] INFO com.wgf.tcp.NettyClientHandler - 服务器地址是：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure></blockquote><br><br><h2 id="netty源码剖析"><a class="markdownIt-Anchor" href="#netty源码剖析"></a> Netty源码剖析</h2><h3 id="客户端bootstrap启动过程"><a class="markdownIt-Anchor" href="#客户端bootstrap启动过程"></a> 客户端Bootstrap启动过程</h3><blockquote><p>Netty 中 Bootstrap 类是客户端程序的启动引导类</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/example/src/main/java/io/netty/example/echo/EchoClient.java">使用官方Example EchoClient</a>, 下面的源码剖析都根据这个Example进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoClient</span> &#123;<br><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">SSL</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-literal">null</span>;<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HOST</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;host&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-string">&quot;256&quot;</span>));<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-comment">// Configure SSL.git</span><br>     <span class="hljs-keyword">final</span> SslContext sslCtx;<br>     <span class="hljs-keyword">if</span> (SSL) &#123;<br>         sslCtx = SslContextBuilder.forClient()<br>             .trustManager(InsecureTrustManagerFactory.INSTANCE).build();<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         sslCtx = <span class="hljs-literal">null</span>;<br>     &#125;<br><br>     <span class="hljs-comment">// Configure the client.</span><br>     <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>         b.group(group)<br>          .channel(NioSocketChannel.class)<br>          .option(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br>          .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                  <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                  <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>                      p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));<br>                  &#125;<br>                  <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>                  p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoClientHandler</span>());<br>              &#125;<br>          &#125;);<br><br>         <span class="hljs-comment">// Start the client.</span><br>         <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.connect(HOST, PORT).sync();<br><br>         <span class="hljs-comment">// Wait until the connection is closed.</span><br>         f.channel().closeFuture().sync();<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-comment">// Shut down the event loop to terminate all threads.</span><br>         group.shutdownGracefully();<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/example/src/main/java/io/netty/example/echo/EchoClientHandler.java">使用官方Example EchoClientHandler</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ByteBuf firstMessage;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a client-side handler.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EchoClientHandler</span><span class="hljs-params">()</span> &#123;<br>        firstMessage = Unpooled.buffer(EchoClient.SIZE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; firstMessage.capacity(); i ++) &#123;<br>            firstMessage.writeByte((<span class="hljs-type">byte</span>) i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        ctx.writeAndFlush(firstMessage);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>        ctx.write(msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>       ctx.flush();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        <span class="hljs-comment">// Close the connection when an exception is raised.</span><br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><p>Bootstrap启动流程</p><p><img src="/2022/05/25/netty/Bootstrap%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><br><h3 id="eventloopgroup的初始化"><a class="markdownIt-Anchor" href="#eventloopgroup的初始化"></a> EventLoopGroup的初始化</h3><blockquote><p>客户端源码在一开始就实例化了 一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup</a> 对象因此就从它的构造器中追踪 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> 的初始化过程。首先来看 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup</a> 的类继承层次结构</p><p><img src="/2022/05/25/netty/NioEventLoopGroup%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup</a> 有几个重载的构造器，不过内容都没有太大的区别，最终都调用父类 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java">MultithreadEventLoopGroup</a> 的构造器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>    <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参数<code>nThreads</code>就是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup</a> 线程数量，其实就是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> 的数量，如果传入的参数为0则额外特殊处理, 在静态代码块中获取当前机器的<code>CPU核心数量 * 2</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Netty首先从系统属性中获取“io.netty.eventLoopThreads”的 值，如果我们没有设置，就返回默认值，即CPU核数×2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> &#123;<br>    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>            <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>​	<span style="border-bottom:2px dashed green">Netty首先从系统属性中获取“io.netty.eventLoopThreads”的值，如果我们没有设置，就返回默认值，即<code>CPU核数 × 2</code></span>。回到 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java">MultithreadEventLoopGroup</a> 构造器中会继续调用父类<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java">MultithreadEventExecutorGroup</a> 的构造器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java">    。。。<br>	<span class="hljs-comment">// 这个就是 EventLoop 的容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] children;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最终的创建实例调用的构造器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nThreads       该实例将使用的线程数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> executor       将要使用的executor, 默认为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chooserFactory 将要使用的EventExecutorChooserFactory</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args           arguments which will passed to each &#123;<span class="hljs-doctag">@link</span> #newChild(Executor, Object...)&#125; call</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br>        <span class="hljs-comment">// 校验线程数量的合法性</span><br>        checkPositive(nThreads, <span class="hljs-string">&quot;nThreads&quot;</span>);<br><br>        <span class="hljs-comment">// executor校验非空, 如果为空就创建ThreadPerTaskExecutor, 该类实现了 Executor接口(JUC)</span><br>        <span class="hljs-comment">// 题外说明：Executor接口的execute方法在JUC线程池中是用于提交异步任务的</span><br>        <span class="hljs-comment">// 这个executor 是用来执行线程池中的所有的线程，也就是所有的NioEventLoop，其实从</span><br>        <span class="hljs-comment">// NioEventLoop构造器中也可以知道，NioEventLoop构造器中都传入了executor这个参数</span><br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>        &#125;<br><br>        <span class="hljs-comment">// 这里的children数组， 其实就是线程池的核心实现，线程池中就是通过指定的线程数组来实现线程池；</span><br>        <span class="hljs-comment">// 数组中每个元素其实就是一个NioEventLoop</span><br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br>        <span class="hljs-comment">// for循环实例化children数组，NioEventLoop对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// newChild 这个抽象方法在 NioEventLoopGroup类 被实现，就是返回 NioEventLoop</span><br>                children[i] = newChild(executor, args);<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 如果创建失败就释放资源</span><br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                        children[j].shutdownGracefully();<br>                    &#125;<br><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                            <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                            Thread.currentThread().interrupt();<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// chooserFactory类型是 DefaultEventExecutorChooserFactory</span><br>        <span class="hljs-comment">// chooser类型是 DefaultEventExecutorChooserFactory的两个内部类之一，选择器的作用就是当BossGroup创建连接后注册到WorkerGroup的EventLoop时</span><br>        <span class="hljs-comment">// 需要使用来选择数组中的EventLoop, 底层算法是通过 executors[(int) Math.abs(idx.getAndIncrement() % executors.length)] 实现的轮询算法</span><br>        chooser = chooserFactory.newChooser(children);<br><br>        <span class="hljs-comment">// 为每个EventLoop线程添加 线程终止监听器</span><br>        <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-comment">// 异常终止数量自增</span><br>                <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>                    terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (EventExecutor e : children) &#123;<br>            e.terminationFuture().addListener(terminationListener);<br>        &#125;<br><br>        <span class="hljs-comment">// 将children 添加到对应的set集合中去重， 表示只可读</span><br>        Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>        Collections.addAll(childrenSet, children);<br>        readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>    &#125;<br></code></pre></td></tr></table></figure><br><h4 id="eventloop的创建过程"><a class="markdownIt-Anchor" href="#eventloop的创建过程"></a> EventLoop的创建过程</h4><blockquote><p><span style="border-bottom:2px dashed green"><code>newChild(executor, args)</code> 这是一个抽象方法，在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java">MultithreadEventLoopGroup</a> 的构造函数中被调用，通过循环来创建<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> ，它的任务是实例化 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> 对象</span>。我们跟踪一下它的代码，可以发现，这个方法在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup </a>类中有实现</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-comment">// 创建 并返回 NioEventLoop 对象</span><br><span class="hljs-keyword">protected</span> EventLoop <span class="hljs-title function_">newChild</span><span class="hljs-params">(Executor executor, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 就 是 在 NioEventLoopGroup 构 造 器 中 ， 调 用</span><br>    <span class="hljs-comment">//SelectorProvider.provider()方法获取的SelectorProvider对象</span><br>    <span class="hljs-type">SelectorProvider</span> <span class="hljs-variable">selectorProvider</span> <span class="hljs-operator">=</span> (SelectorProvider) args[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">SelectStrategyFactory</span> <span class="hljs-variable">selectStrategyFactory</span> <span class="hljs-operator">=</span> (SelectStrategyFactory) args[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拒绝策略，实际上调用了RejectedExecutionHandlers.reject(), 拒绝策略是抛出异常        </span><br>    <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">rejectedExecutionHandler</span> <span class="hljs-operator">=</span> (RejectedExecutionHandler) args[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">EventLoopTaskQueueFactory</span> <span class="hljs-variable">taskQueueFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">EventLoopTaskQueueFactory</span> <span class="hljs-variable">tailTaskQueueFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">argsLength</span> <span class="hljs-operator">=</span> args.length;<br>    <span class="hljs-keyword">if</span> (argsLength &gt; <span class="hljs-number">3</span>) &#123;<br>        taskQueueFactory = (EventLoopTaskQueueFactory) args[<span class="hljs-number">3</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (argsLength &gt; <span class="hljs-number">4</span>) &#123;<br>        tailTaskQueueFactory = (EventLoopTaskQueueFactory) args[<span class="hljs-number">4</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoop</span>(<span class="hljs-built_in">this</span>, executor, selectorProvider,<br>            selectStrategyFactory.newSelectStrategy(),<br>            rejectedExecutionHandler, taskQueueFactory, tailTaskQueueFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java">NioEventLoop</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,<br>             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,<br>             EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) &#123;<br>    <span class="hljs-comment">// newTaskQueue 创建任务队列，底层使用JCTools第三方非阻塞线程安全的队列        </span><br>    <span class="hljs-built_in">super</span>(parent, executor, <span class="hljs-literal">false</span>, newTaskQueue(taskQueueFactory), newTaskQueue(tailTaskQueueFactory),<br>            rejectedExecutionHandler);<br>    <span class="hljs-comment">// 就 是 在 NioEventLoopGroup 构 造 器 中 ， 调 用SelectorProvider.provider()方法获取的SelectorProvider对象</span><br>    <span class="hljs-comment">// SelectorProvider 使用java spi, 不同平台又不同实现</span><br>    <span class="hljs-built_in">this</span>.provider = ObjectUtil.checkNotNull(selectorProvider, <span class="hljs-string">&quot;selectorProvider&quot;</span>);<br>    <span class="hljs-built_in">this</span>.selectStrategy = ObjectUtil.checkNotNull(strategy, <span class="hljs-string">&quot;selectStrategy&quot;</span>);<br>    <span class="hljs-comment">// 获取原生 Selector， netty 默认对 Selector 有优化，将keys属性由Set改为数组，这样add操作的时间复杂度为O(1)        </span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> openSelector();<br>    <span class="hljs-comment">// provider.openSelector() 获取selector方法</span><br>    <span class="hljs-built_in">this</span>.selector = selectorTuple.selector;<br>    <span class="hljs-built_in">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="eventexecutorchooser的创建过程"><a class="markdownIt-Anchor" href="#eventexecutorchooser的创建过程"></a> EventExecutorChooser的创建过程</h4><blockquote><p>事件执行器选择器，用于在Channel注册时提供选择 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> 功能<code>chooserFactory.newChooser(children);</code> 在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java">MultithreadEventLoopGroup</a> 的构造函数中被调用</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java">DefaultEventExecutorChooserFactory</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnstableApi</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultEventExecutorChooserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooserFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DefaultEventExecutorChooserFactory</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventExecutorChooserFactory</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DefaultEventExecutorChooserFactory</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">return</span> (val &amp; -val) == val;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果nThreads是2的平方，则使用 PowerOfTwoEventExecutorChooser</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;<br>            <span class="hljs-built_in">this</span>.executors = executors;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 轮询算法，如果时2的幂次方，使用&amp;比使用%效率高，极限优化</span><br>            <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果nThreads不是2的平方，则使用 GenericEventExecutorChooser</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericEventExecutorChooser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooser</span> &#123;<br>        <span class="hljs-comment">// Use a &#x27;long&#x27; counter to avoid non-round-robin behaviour at the 32-bit overflow boundary.</span><br>        <span class="hljs-comment">// The 64-bit long solves this by placing the overflow so far into the future, that no system</span><br>        <span class="hljs-comment">// will encounter this in practice.</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br>        GenericEventExecutorChooser(EventExecutor[] executors) &#123;<br>            <span class="hljs-built_in">this</span>.executors = executors;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 自增序列向长度取模就是轮询算法</span><br>            <span class="hljs-keyword">return</span> executors[(<span class="hljs-type">int</span>) Math.abs(idx.getAndIncrement() % executors.length)];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果nThreads是2的平方，则使用 <strong>PowerOfTwoEventExecutorChooser</strong> ， 否则使用<strong>GenericEventExecutorChooser</strong>。这两个Chooser都重写next()方法。<strong>next()</strong> 方法的主要功能就是将数组索引循环位移，如下图所示</p></blockquote><p><img src="/2022/05/25/netty/EventLoop%E9%80%89%E6%8B%A9%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>当索引移动到最后一个位置时，再调用next()方法就会将索引位 置重新指向0，如下图所示</p></blockquote><p><img src="/2022/05/25/netty/EventLoop%E9%80%89%E6%8B%A9%E5%99%A82.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>选择器之所有两个内部类，是因为计算机底层的 &amp; 运算比 % 运算效率高，Netty会根据nThread是否为2次幂动态选择，属于一个优化手段，最终实现的都是一个 <strong>轮询算法</strong></p></blockquote><br><h4 id="总结-4"><a class="markdownIt-Anchor" href="#总结-4"></a> 总结</h4><blockquote><ul><li><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup </a>底层其实是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java">MultithreadEventExecutorGroup</a> 内部维护好了一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/common/src/main/java/io/netty/util/concurrent/EventExecutor.java">EventExecutor</a> 的children数组 ,其大小是nThreads，这样就构成了一 个线程池</li><li>实例化 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup </a>时，如果指定线程池大小，则nThreads就是指定的值，反之是CPU核数×2</li><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java">MultithreadEventExecutorGroup </a>中调用 <strong>newChild()</strong> 象方法来初始化children数组</li><li><strong>newChild()</strong> 方法是在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup </a>中实现的，它返回一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java">NioEventLoop</a> 实例</li><li>初始化NioEventLoop对象并给属性赋值，具体赋值的属性如下<ul><li>provider ： 就是在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java">NioEventLoopGroup </a>构造器中 ， 调用 **SelectorProvider.provider()**方法获取的 SelectorProvider (java spi) 对象</li><li><span style="border-bottom:2px dashed green">selector ： 就是在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java">NioEventLoop</a> 构造器中 ， 调用 <strong>provider.openSelector()</strong> (java nio) 方法获取的 <code>Selector</code> 对象</span></li></ul></li></ul></blockquote><pre class="mermaid">sequenceDiagram
	EventLoopGroup ->>	MultithreadEventLoopGroup : 构造函数调用，nThreads取值：参数指定，构造函数指定，或cpu核心数 * 2
	MultithreadEventLoopGroup ->>  MultithreadEventExecutorGroup : 构造函数调用，确认EventLoop数量
    MultithreadEventExecutorGroup ->> NioEventLoopGroup : 循环调用 newChild() 创建EventLoo
    NioEventLoopGroup ->> NioEventLoop : 构造函数 -> JCTolls 创建任务队列,openSelector()，默认创建优化的Selector
    MultithreadEventExecutorGroup ->> DefaultEventExecutorChooserFactory : newChooser(), 创建EventLoop选择器
	MultithreadEventExecutorGroup ->> MultithreadEventExecutorGroup : 添加EventLoop终止监听
	MultithreadEventExecutorGroup ->> MultithreadEventExecutorGroup : 将EventLoop数组转为只读Set</pre><br><h3 id="channel-2"><a class="markdownIt-Anchor" href="#channel-2"></a> Channel</h3><blockquote><ul><li><p>在Netty中，<strong>Channel相当于一个Socket的抽象，它为用户提供了关于Socket状态（是连接还是断开）及对Socket的读、写等操作。每当Netty建立了一个连接，都创建一个与其对应的Channel实例</strong></p></li><li><p>除了TCP，<strong>Netty还支持很多其他的连接协议，并且每种协议还有NIO（非阻塞I/O）和OIO（Old-I/O，即传统的阻塞I/O）版本的区别</strong>，不同协议不同阻塞类型的连接都有不同的Channel类型与之对应</p></li></ul><table><thead><tr><th>通道类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>NioSocketChannel</strong></td><td><strong>异步的客户端 TCP Socket 连接</strong></td></tr><tr><td><strong>NioServerSocketChannel</strong></td><td><strong>异步的服务器端 TCP Socket 连接</strong></td></tr><tr><td><strong>NioDatagramChannel</strong></td><td><strong>异步的 UDP 连接</strong></td></tr><tr><td><strong>NioSctpChannel</strong></td><td><strong>异步的客户端 Sctp 连接</strong></td></tr><tr><td><strong>NioSctpServerChannel</strong></td><td><strong>异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO</strong></td></tr><tr><td><strong>OioSocketChannel</strong></td><td><strong>同步的客户端 TCP Socket 连接</strong></td></tr><tr><td><strong>OioServerSocketChannel</strong></td><td><strong>同步的服务器端 TCP Socket 连接</strong></td></tr><tr><td><strong>OioDatagramChannel</strong></td><td><strong>同步的 UDP 连接</strong></td></tr><tr><td><strong>OioSctpChannel</strong></td><td><strong>同步的 Sctp 服务器端连接</strong></td></tr><tr><td><strong>OioSctpServerChannel</strong></td><td><strong>同步的客户端 TCP Socket 连接</strong></td></tr></tbody></table><p><img src="/2022/05/25/netty/channel%E5%85%B3%E7%B3%BB%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p></blockquote><br><h4 id="channel的创建过程"><a class="markdownIt-Anchor" href="#channel的创建过程"></a> Channel的创建过程</h4><blockquote><p><strong>客户端连接代码的初始化Bootstrap中，该方法调用了一个channel()方法</strong>，传入的参数是NioSocketChannel.class，在这个方法中其实就是初始化了一ReflectiveChannelFactory的对象，代码实现如下 ：</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置服务端Channel类型，返回ReflectiveChannelFactory 它是一个反射工厂， 通过反射创建Channel对象</span><br><span class="hljs-comment">    * The &#123;<span class="hljs-doctag">@link</span> Class&#125; which is used to create &#123;<span class="hljs-doctag">@link</span> Channel&#125; instances from.</span><br><span class="hljs-comment">    * You either use this or &#123;<span class="hljs-doctag">@link</span> #channelFactory(io.netty.channel.ChannelFactory)&#125; if your</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> Channel&#125; implementation has no no-args constructor.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> B <span class="hljs-title function_">channel</span><span class="hljs-params">(Class&lt;? extends C&gt; channelClass)</span> &#123;<br>       <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;C&gt;(<br>               ObjectUtil.checkNotNull(channelClass, <span class="hljs-string">&quot;channelClass&quot;</span>)<br>       ));<br>   &#125;<br></code></pre></td></tr></table></figure><p>而 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java">ReflectiveChannelFactory</a> 实现了 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelFactory.java">ChannelFactory</a> 接口，它提供了唯一的方法，即newChannel()方法。顾名思义，<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelFactory.java">ChannelFactory</a> 就是创建 Channel 的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反射Channel工厂</span><br><span class="hljs-comment"> * A &#123;<span class="hljs-doctag">@link</span> ChannelFactory&#125; that instantiates a new &#123;<span class="hljs-doctag">@link</span> Channel&#125; by invoking its default constructor reflectively.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelFactory</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">// Channel 的构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; constructor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，根据传递进来的Channel类型获取其无参构造函数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReflectiveChannelFactory</span><span class="hljs-params">(Class&lt;? extends T&gt; clazz)</span> &#123;<br>        ObjectUtil.checkNotNull(clazz, <span class="hljs-string">&quot;clazz&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.constructor = clazz.getConstructor();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) +<br>                    <span class="hljs-string">&quot; does not have a public non-arg constructor&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过无参构造函数调用Java反射Api生成一个新的Channel,在有客户端建立新的连接时使用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> constructor.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;        <br></code></pre></td></tr></table></figure><p><strong>结论:</strong></p><ul><li><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 中的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelFactory.java">ChannelFactory</a> 实现类是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java">ReflectiveChannelFactory</a></li><li>通过 channel() 方法创建的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a> 具体类型是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a></li><li><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a> 的实例化过程其实就是调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelFactory.java">ChannelFactory</a> 的newChannel() 方 法 ， 而实例化的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a> 具体类型又和初始化Bootstrap时传入的channel()方法的参数相关。因此对于客户端的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 而言，创建的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a> 实例就是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a></li></ul></blockquote><pre class="mermaid">sequenceDiagram
	AbstractBootstrap ->> AbstractBootstrap : channel() -> channelFactory() 创建ChannelFactory
	AbstractBootstrap ->> ReflectiveChannelFactory : 创建一个通过反射创建Channel的ChannelFactory</pre><br><h4 id="niosocketchannel的创建"><a class="markdownIt-Anchor" href="#niosocketchannel的创建"></a> NioSocketChannel的创建</h4><blockquote><p><img src="/2022/05/25/netty/%E5%88%9B%E5%BB%BAChannel.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/example/src/main/java/io/netty/example/echo/EchoClient.java">EchoClient</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>    <span class="hljs-comment">// 指定Channel类型</span><br>    .channel(NioSocketChannel.class) <br>    ...<br>   <span class="hljs-comment">// Start the client.</span><br>   <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.connect(HOST, PORT).sync();<br>...<br></code></pre></td></tr></table></figure><ul><li>分析 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 类的 connect() 方法调用链路图可知，当客户端发起连接操作的时候在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a> 的 initAndRegister() 方 法 中 ， <span style="border-bottom:2px dashed green">调用<br><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelFactory.java">ChannelFactory</a> 的 <code>newChannel()</code> 方法来创建一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 的实例</span></li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">...    <br>	<span class="hljs-comment">// 初始化和注册Channel</span><br>    <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过工厂生成Channel, 工厂在配置引导类调用 .channel(channelClass) 方法时被初始化</span><br>            channel = channelFactory.newChannel();<br>            <span class="hljs-comment">// 本类的抽象方法，客户端由 Bootstrap 类实现，服务端由 ServerBootStrap 类实现</span><br>            init(channel);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 异常强制关闭 channel, Netty里，channel就是对Socket的抽象封装</span><br>                <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>                channel.unsafe().closeForcibly();<br>                <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>            &#125;<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br><br>        <span class="hljs-comment">// 异步地向EventLoopGroup 注册当前的channel</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>        <span class="hljs-comment">// 处理重复注册和异常</span><br>        <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>                channel.close();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channel.unsafe().closeForcibly();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="客户端channel的初始化"><a class="markdownIt-Anchor" href="#客户端channel的初始化"></a> 客户端Channel的初始化</h4><p>NioSocketChannel体系</p><p><img src="/2022/05/25/netty/NioSocketChannel%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java">ReflectiveChannelFactory. newChannel()</a> 方法中，利用反射机制调用类对象的 <code>newInstance()</code> 方法来创建一个新的Channel实例，相当于调用NioSocketChannel的默认构造器 <em>(参考 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java">ReflectiveChannelFactory</a> 工厂的实现)</em></li><li>利用反射机制调用类对象的 <code>newInstance()</code> 方法来创建一个新的Channel实例，相当于调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 的默认构造器。NioSocketChannel的默认构造器代码</li></ul><p><img src="/2022/05/25/netty/Channel%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioSocketChannel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractNioByteChannel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">io</span>.netty.channel.socket.SocketChannel &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InternalLogger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> InternalLoggerFactory.getInstance(NioSocketChannel.class);<br>    <span class="hljs-comment">// JDK的 Selector提供者，JDK NIO 模块的 SPI机制, 主要兼容不同的平台 mac, win, linux</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorProvider</span> <span class="hljs-variable">DEFAULT_SELECTOR_PROVIDER</span> <span class="hljs-operator">=</span> SelectorProvider.provider();<br><br>    <span class="hljs-comment">// 通过java SPI 机制获取不同平台上打开Socket的实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Method</span> <span class="hljs-variable">OPEN_SOCKET_CHANNEL_WITH_FAMILY</span> <span class="hljs-operator">=</span><br>            SelectorProviderUtil.findOpenMethod(<span class="hljs-string">&quot;openSocketChannel&quot;</span>);<br><br>    <span class="hljs-comment">// java nio Channel的相关配置，NioSocketChannel 持有 java nio Channel的相关配置这点可以体现Netty 对 java nio Channel 的高度封装</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannelConfig config;<br><br>    <span class="hljs-comment">// 2.创建一个新的Channel, 构造函数会调用这个方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SocketChannel <span class="hljs-title function_">newChannel</span><span class="hljs-params">(SelectorProvider provider, InternetProtocolFamily family)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 通过反射调用 不同平台实现的 openSocketChannel 方法获取一个 SocketChannel            </span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> SelectorProviderUtil.newChannel(OPEN_SOCKET_CHANNEL_WITH_FAMILY, provider, family);<br>            <span class="hljs-comment">// 根据 SPI 打开一个新的 java Nio Channel</span><br>            <span class="hljs-keyword">return</span> channel == <span class="hljs-literal">null</span> ? provider.openSocketChannel() : channel;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Failed to open a socket.&quot;</span>, e);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无参构造函数</span><br><span class="hljs-comment">     * ReflectiveChannelFactory 工厂使用这个反射生成Channel</span><br><span class="hljs-comment">     * Create a new instance</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NioSocketChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 支持自定义 Selector提供者</span><br><span class="hljs-comment">     * Create a new instance using the given &#123;<span class="hljs-doctag">@link</span> SelectorProvider&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NioSocketChannel</span><span class="hljs-params">(SelectorProvider provider)</span> &#123;<br>        <span class="hljs-built_in">this</span>(provider, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造器</span><br><span class="hljs-comment">     * Create a new instance using the given &#123;<span class="hljs-doctag">@link</span> SelectorProvider&#125; and protocol family (supported only since JDK 15).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NioSocketChannel</span><span class="hljs-params">(SelectorProvider provider, InternetProtocolFamily family)</span> &#123;<br>        <span class="hljs-built_in">this</span>(newChannel(provider, family));<br>    &#125;<br></code></pre></td></tr></table></figure><br><ul><li>在这个构造器中首先会调用 newSocket() 方法来打开一个新的Java NIO的 <strong>SocketChannel</strong> 对象 <em>(步骤 2)</em></li></ul><p><a href>AbstractNioByteChannel</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 构造函数，第一个channel 暂时为空，第二个ch 为 java nio SocketChannel</span><br><span class="hljs-comment"> * Create a new instance</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parent            the parent &#123;<span class="hljs-doctag">@link</span> Channel&#125; by which this instance was created. May be &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> ch                the underlying &#123;<span class="hljs-doctag">@link</span> SelectableChannel&#125; on which it operates</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioByteChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch)</span> &#123;<br>     <span class="hljs-comment">// 调用父类 AbstractNioChannel 的构造器，并传入一个读操作标识</span><br>     <span class="hljs-built_in">super</span>(parent, ch, SelectionKey.OP_READ);<br> &#125;<br></code></pre></td></tr></table></figure><br><ul><li><p>最后会调用其父类的构造器，即AbstractNioByteChannel的构造器 <em>（步骤 4）</em>，传入参数，parent的值默认为null，ch为之前调用</p><p>newSocket()方法创建的Java NIO 的 <strong>SocketChannel</strong> 对象，<strong>因此新创建的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 对象中的parent暂时是null</strong></p></li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java">AbstractNioByteChannel</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Create a new instance</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> parent            the parent &#123;<span class="hljs-doctag">@link</span> Channel&#125; by which this instance was created. May be &#123;<span class="hljs-doctag">@code</span> null&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ch                the underlying &#123;<span class="hljs-doctag">@link</span> SelectableChannel&#125; on which it operates</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> readInterestOp    the ops to set to receive data from the &#123;<span class="hljs-doctag">@link</span> SelectableChannel&#125;</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch, <span class="hljs-type">int</span> readInterestOp)</span> &#123;<br>     <span class="hljs-comment">// AbstractChannel 父类的构造函数</span><br>     <span class="hljs-built_in">super</span>(parent);<br>     <span class="hljs-built_in">this</span>.ch = ch;<br>     <span class="hljs-built_in">this</span>.readInterestOp = readInterestOp;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// 设置 java nio channel 为非阻塞的</span><br>         ch.configureBlocking(<span class="hljs-literal">false</span>);<br>     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             ch.close();<br>         &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;<br>             logger.warn(<br>                         <span class="hljs-string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);<br>         &#125;<br><br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br><ul><li>接着会调用父类AbstractNioChannel的构造器，并传入实际参数readInterestOp=SelectionKey.OP_READ</li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java">AbstractNioChannel</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractNioChannel</span><span class="hljs-params">(Channel parent, SelectableChannel ch, <span class="hljs-type">int</span> readInterestOp)</span> &#123;<br>     <span class="hljs-comment">// AbstractChannel 父类的构造函数</span><br>    <span class="hljs-built_in">super</span>(parent);<br>     <span class="hljs-built_in">this</span>.ch = ch;<br>    <span class="hljs-built_in">this</span>.readInterestOp = readInterestOp;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// 设置 java nio channel 为非阻塞的</span><br>         ch.configureBlocking(<span class="hljs-literal">false</span>);<br>     &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             ch.close();<br>         &#125; <span class="hljs-keyword">catch</span> (IOException e2) &#123;<br>             logger.warn(<br>                         <span class="hljs-string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);<br>         &#125;<br><br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><br><ul><li>最后会调用父类 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 的构造器</li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelId.java">DefaultChannelId</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel$Unsafe</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> &#123;<br>     <span class="hljs-built_in">this</span>.parent = parent;<br>    <span class="hljs-comment">// 创建一个 DefaultChannelId，为Channel 绑定一个 ShortId 不唯一的值, 只有LongId才不会重复，通过mac 地址等基础数据计算</span><br>     id = newId();<br>    <span class="hljs-comment">// Unsafe 是 Channel 的内部类，只允许IO线程调用，真正用于数据传输操作</span><br>     unsafe = newUnsafe();<br>     <span class="hljs-comment">// 为当前的 Channel 创建一个 DefaultChannelPipeline 管道，所以 Channel 和 Pipeline 是一对一关系</span><br>     pipeline = newChannelPipeline();<br> &#125;<br></code></pre></td></tr></table></figure><p>至此，NioSocketChannel就完成了初始化, 注意：创建了一个Nio 的 Channel, 此时上面的parent 还是 null</p><br><p><strong>总结</strong>：</p><ol><li><p><span style="border-bottom:2px dashed green">调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel.newSocket(DEFAULT_SELECTOR_PROVIDER)</a> -&gt; <code>SelectorProvider.openSocketChannel()</code> 打开一个新的<code>Java Nio SocketChannel</code></span></p></li><li><p>向上不断调用其父类的构造函数直到初始化 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel(Channel parent)</a> 对象并给属性赋值，具体赋值的属性如下</p></li></ol><ul><li>id：每个Channel都会被分配一个id</li><li>parent：属性值默认为null</li><li>unsafe：通过调用newUnsafe()方法实例化一个Unsafe对象，它的类型是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java">AbstractNioByteChannel.NioByteUnsafe</a>内部类，负责真正的I/O读写</li><li>pipeline：是通过调用new DefaultChannelPipeline(this)新创建的实例</li></ul><ol start="3"><li><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java">AbstractNioByteChannel</a> 中被赋值的属性如下<ul><li>ch：被赋值为Java原生SocketChannel，即NioSocketChannel的newSocket()方法返回的Java NIO SocketChannel</li><li>readInterestOp：被赋值为SelectionKey.OP_READ</li><li>ch：被配置为非阻塞，即调用 <strong>ch.configureBlocking(false)</strong> 方法</li><li><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 中被赋值的属性 ： config = newNioSocketChannelConfig(this，socket.socket())</li></ul></li></ol></blockquote><pre class="mermaid">sequenceDiagram
	Bootstrap ->> Bootstrap : connect() -> doResolveAndConnect() 客户端连接
	Bootstrap ->> AbstractBootstrap : initAndRegister() 初始化和注册Channel
	AbstractBootstrap ->> ReflectiveChannelFactory : .newChannel() 通过工厂创建Channel
	ReflectiveChannelFactory ->> NioSocketChannel : 反射创建 NioSocketChannel
	NioSocketChannel ->> SelectorProvider : SPI机制调用 openSocketChannel
	SelectorProvider ->>  SocketChannel : 获得nio原生Channel
	NioSocketChannel ->> AbstractNioChannel : Channel设置非阻塞
	AbstractNioChannel ->> AbstractChannel : newId()  newUnsafe()  newChannelPipeline()</pre><br><h4 id="unsafe内部类"><a class="markdownIt-Anchor" href="#unsafe内部类"></a> Unsafe内部类</h4><blockquote><p><strong>注意</strong>：这里的 <code>Unsafe</code> 并不是我们常说的Java自带的 <code>sun.misc.Unsafe</code>，而是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">io.netty.channel.Channel#Unsafe</a>。按源码注释上说法是 “Unsafe函数不允许被用户代码使用，这些函数是真正用于数据传输操作，必须被IO线程调用” ，也就是说<strong>真正依赖于底层协议/方案的实现是通过Unsafe包装出去的</strong></p><p>​	在实例化 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 的 过 程 中 ， <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Unsafe</a>就特别关键 。 <strong><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Unsafe</a> 其实是对Java底层Socket操作的封装，因此，它实际上是沟通 Netty上层和Java底层的重要桥梁</strong>。下面我们看一下Unsafe接口所提供的方法</p><p>​	<span style="border-bottom:2px dashed green"><code>Unsafe</code> 的初始化时机在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 的构造函数中调用了 <code>newUnsafe()</code></span></p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Unsafe</a></p><p><img src="/2022/05/25/netty/Unsafe%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Unsafe</span> &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Return the assigned &#123;<span class="hljs-doctag">@link</span> RecvByteBufAllocator.Handle&#125; which will be used to allocate &#123;<span class="hljs-doctag">@link</span> ByteBuf&#125;&#x27;s when</span><br><span class="hljs-comment">         * receiving data.</span><br><span class="hljs-comment">         */</span><br>        RecvByteBufAllocator.Handle <span class="hljs-title function_">recvBufAllocHandle</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回本地绑定的Socket地址</span><br><span class="hljs-comment">         * Return the &#123;<span class="hljs-doctag">@link</span> SocketAddress&#125; to which is bound local or</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@code</span> null&#125; if none.</span><br><span class="hljs-comment">         */</span><br>        SocketAddress <span class="hljs-title function_">localAddress</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回通信对端的Socket地址</span><br><span class="hljs-comment">         * Return the &#123;<span class="hljs-doctag">@link</span> SocketAddress&#125; to which is bound remote or</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@code</span> null&#125; if none is bound yet.</span><br><span class="hljs-comment">         */</span><br>        SocketAddress <span class="hljs-title function_">remoteAddress</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 注册Channel到多路复用器上,一旦注册操作完成,通知ChannelFuture</span><br><span class="hljs-comment">         * Register the &#123;<span class="hljs-doctag">@link</span> Channel&#125; of the &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; and notify</span><br><span class="hljs-comment">         * the &#123;<span class="hljs-doctag">@link</span> ChannelFuture&#125; once the registration was complete.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 绑定指定的localAddress到当前的Channel上,完成后通知ChannelFuture</span><br><span class="hljs-comment">         * Bind the &#123;<span class="hljs-doctag">@link</span> SocketAddress&#125; to the &#123;<span class="hljs-doctag">@link</span> Channel&#125; of the &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; and notify</span><br><span class="hljs-comment">         * it once its done.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress, ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 	绑定完成之后,连接服务器,操作完成之后通知ChannelFuture</span><br><span class="hljs-comment">         * Connect the &#123;<span class="hljs-doctag">@link</span> Channel&#125; of the given &#123;<span class="hljs-doctag">@link</span> ChannelFuture&#125; with the given remote &#123;<span class="hljs-doctag">@link</span> SocketAddress&#125;.</span><br><span class="hljs-comment">         * If a specific local &#123;<span class="hljs-doctag">@link</span> SocketAddress&#125; should be used it need to be given as argument. Otherwise just</span><br><span class="hljs-comment">         * pass &#123;<span class="hljs-doctag">@code</span> null&#125; to it.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * The &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; will get notified once the connect operation was complete.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 断开连接,完成后通知ChannelFuture</span><br><span class="hljs-comment">         * Disconnect the &#123;<span class="hljs-doctag">@link</span> Channel&#125; of the &#123;<span class="hljs-doctag">@link</span> ChannelFuture&#125; and notify the &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; once the</span><br><span class="hljs-comment">         * operation was complete.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">disconnect</span><span class="hljs-params">(ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 关闭Channel连接,完成后通知</span><br><span class="hljs-comment">         * Close the &#123;<span class="hljs-doctag">@link</span> Channel&#125; of the &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; and notify the &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; once the</span><br><span class="hljs-comment">         * operation was complete.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 强制关闭连接</span><br><span class="hljs-comment">         * Closes the &#123;<span class="hljs-doctag">@link</span> Channel&#125; immediately without firing any events.  Probably only useful</span><br><span class="hljs-comment">         * when registration attempt failed.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeForcibly</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 取消此Channel在多路复用器上的注册</span><br><span class="hljs-comment">         * Deregister the &#123;<span class="hljs-doctag">@link</span> Channel&#125; of the &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; from &#123;<span class="hljs-doctag">@link</span> EventLoop&#125; and notify the</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; once the operation was complete.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">deregister</span><span class="hljs-params">(ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 设置网络操作位为用于读取消息</span><br><span class="hljs-comment">         * Schedules a read operation that fills the inbound buffer of the first &#123;<span class="hljs-doctag">@link</span> ChannelInboundHandler&#125; in the</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@link</span> ChannelPipeline&#125;.  If there&#x27;s already a pending read operation, this method does nothing.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginRead</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 发送消息,完成之后通知ChannelFuture</span><br><span class="hljs-comment">         * Schedules a write operation.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, ChannelPromise promise)</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 将发送缓冲数组中的消息写入到Channel中</span><br><span class="hljs-comment">         * Flush out all write operations scheduled via &#123;<span class="hljs-doctag">@link</span> #write(Object, ChannelPromise)&#125;.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回一个特殊的可重用和传递的ChannelPromise,它不用于操作成功或失败的通知器,仅仅作为容器使用</span><br><span class="hljs-comment">         * Return a special ChannelPromise which can be reused and passed to the operations in &#123;<span class="hljs-doctag">@link</span> Unsafe&#125;.</span><br><span class="hljs-comment">         * It will never be notified of a success or error and so is only a placeholder for operations</span><br><span class="hljs-comment">         * that take a &#123;<span class="hljs-doctag">@link</span> ChannelPromise&#125; as argument but for which you not want to get notified.</span><br><span class="hljs-comment">         */</span><br>        ChannelPromise <span class="hljs-title function_">voidPromise</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回消息发送缓冲区</span><br><span class="hljs-comment">         * Returns the &#123;<span class="hljs-doctag">@link</span> ChannelOutboundBuffer&#125; of the &#123;<span class="hljs-doctag">@link</span> Channel&#125; where the pending write requests are stored.</span><br><span class="hljs-comment">         */</span><br>        ChannelOutboundBuffer <span class="hljs-title function_">outboundBuffer</span><span class="hljs-params">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>从上述源码中可以看出，这些方法其实都是与Java底层的相关Socket的操作相对应的</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel$AbstractUnsafe</a> 基本抽象实现</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 的构造方法中 ， 在这里调用了 newUnsafe()方法获取一个新的Unsafe对象，而newUnsafe()方法在 NioSocketChannel中被重写了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> &#123;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    <span class="hljs-comment">// 创建一个 DefaultChannelId，为Channel 绑定一个 ShortId 不唯一的值, 只有LongId才不会重复，通过mac 地址等基础数据计算</span><br>    id = newId();<br>    <span class="hljs-comment">// Unsafe 是 Channel 的内部类，只允许IO线程调用，真正用于数据传输操作</span><br>    unsafe = newUnsafe();<br>    <span class="hljs-comment">// 为当前的 Channel 创建一个 DefaultChannelPipeline 管道，所以 Channel 和 Pipeline 是一对一关系</span><br>    pipeline = newChannelPipeline();<br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重写 newUnsafe， 因为 NioSocketChannel 自己实现了Unsafe</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> AbstractNioUnsafe <span class="hljs-title function_">newUnsafe</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioSocketChannelUnsafe</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioSocketChannelUnsafe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NioByteUnsafe</span> &#123;<br>    ...<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 的 newUnsafe() 方 法 会 返 回 一 个 <strong>NioSocketChannelUnsafe</strong>实例。从这里我们就可以确定，在实例化的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a>中的 Unsafe 属性其实是一 个 NioSocketChannelUnsafe的实例</p><br><h4 id="channelpipeline的初始化"><a class="markdownIt-Anchor" href="#channelpipeline的初始化"></a> ChannelPipeline的初始化</h4><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractChannel</span><span class="hljs-params">(Channel parent)</span> &#123;<br>    <span class="hljs-built_in">this</span>.parent = parent;<br>    <span class="hljs-comment">// 创建一个 DefaultChannelId，为Channel 绑定一个 ShortId 不唯一的值, 只有LongId才不会重复，通过mac 地址等基础数据计算</span><br>    id = newId();<br>    <span class="hljs-comment">// Unsafe 是 Channel 的内部类，只允许IO线程调用，真正用于数据传输操作</span><br>    unsafe = newUnsafe();<br>    <span class="hljs-comment">// 为当前的 Channel 创建一个 DefaultChannelPipeline 管道，所以 Channel 和 Pipeline 是一对一关系</span><br>    pipeline = newChannelPipeline();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><img src="/2022/05/25/netty/ChannelPipeline%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><p><span style="border-bottom:2px dashed green">在创建完 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 构造函数中可以看到，在创建完 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Unsafe</a> 后紧接着又调用 <strong>newChannelPipeline()</strong> 创建 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a></span></p><p><span style="border-bottom:2px dashed green">在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> 的注释说明中写道  “Each channel has its own pipeline and it is created automatically when a new channel is created”  。我们知道，在实例化一个Channel时，必然都要实例化一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> </span>。而我们确实在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 的构造器中看到了<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> 属性被初始化为<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 的实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelPipeline 源码的注释<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A list of &#123;<span class="hljs-doctag">@link</span> ChannelHandler&#125;s which handles or intercepts inbound events and outbound operations of a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Channel&#125;.  &#123;<span class="hljs-doctag">@link</span> ChannelPipeline&#125; implements an advanced form of the</span><br><span class="hljs-comment"> * &lt;a href=&quot;https://www.oracle.com/technetwork/java/interceptingfilter-142169.html&quot;&gt;Intercepting Filter&lt;/a&gt; pattern</span><br><span class="hljs-comment"> * to give a user full control over how an event is handled and how the &#123;<span class="hljs-doctag">@link</span> ChannelHandler&#125;s in a pipeline</span><br><span class="hljs-comment"> * interact with each other.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;h3&gt;Creation of a pipeline&lt;/h3&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Each channel has its own pipeline and it is created automatically when a new channel is created.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> ...</span><br></code></pre></td></tr></table></figure><br><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel.newChannelPipeline()</a> 方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为 Channel 创建一个默认的管道</span><br><span class="hljs-comment"> * Returns a new &#123;<span class="hljs-doctag">@link</span> DefaultChannelPipeline&#125; instance.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> DefaultChannelPipeline <span class="hljs-title function_">newChannelPipeline</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPipeline</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br><h5 id="defaultchannelpipeline"><a class="markdownIt-Anchor" href="#defaultchannelpipeline"></a> <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// handlerContext 链表头指针</span><br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext head;<br>    <span class="hljs-comment">// handlerContext 链表尾指针</span><br>    <span class="hljs-keyword">final</span> AbstractChannelHandlerContext tail;<br>...<br>    <span class="hljs-comment">// 唯一的构造函数，创建 DefaultChannelPipeline 必穿一个 netty 的 Channel 对象</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DefaultChannelPipeline</span><span class="hljs-params">(Channel channel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="hljs-string">&quot;channel&quot;</span>);<br>        succeededFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SucceededChannelFuture</span>(channel, <span class="hljs-literal">null</span>);<br>        voidPromise =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoidChannelPromise</span>(channel, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// ChannelPipeline 维护了 ChannelHandler 的链表头部和尾部，在Pipeline里</span><br>        <span class="hljs-comment">// 用户配置的多个ChannelHandler 组成了一个双向链表</span><br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TailContext</span>(<span class="hljs-built_in">this</span>);<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeadContext</span>(<span class="hljs-built_in">this</span>);<br><br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 的构造器需要传入一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a>，而这个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a> 其实就是我们实例化的<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 对象，<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 会将这个<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java">NioSocketChannel</a> 对象保存在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/Channel.java">Channel</a> 属性中。<strong><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 中还有两个特殊的属性，即Head和Tail，这两个属性是双向链表的头和尾。其实在<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 中维护了一个以<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a>为节点元素的双向链表，这个链表是Netty实现Pipeline机制的关键</strong></p></blockquote><br><h5 id="handlercontext"><a class="markdownIt-Anchor" href="#handlercontext"></a> HandlerContext</h5><p>HeadContext 体系</p><p><img src="/2022/05/25/netty/HeadContext%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><p>TailContext 体系</p><p><img src="/2022/05/25/netty/TailContext%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelOutboundHandler</span>, ChannelInboundHandler &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><br>    HeadContext(DefaultChannelPipeline pipeline) &#123;<br>        <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, HEAD_NAME, HeadContext.class);<br>        unsafe = pipeline.channel().unsafe();<br>        setAddComplete();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TailContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelInboundHandler</span> &#123;<br><br>    TailContext(DefaultChannelPipeline pipeline) &#123;<br>        <span class="hljs-built_in">super</span>(pipeline, <span class="hljs-literal">null</span>, TAIL_NAME, TailContext.class);<br>        setAddComplete();<br>    &#125;<br></code></pre></td></tr></table></figure><br><blockquote><p><strong>获取出站和入站的HandleConetxt方法</strong></p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取处理入站的HandlerContext</span><br><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">findContextInbound</span><span class="hljs-params">(<span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">currentExecutor</span> <span class="hljs-operator">=</span> executor();<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.next;<br>    &#125; <span class="hljs-keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br><br><span class="hljs-comment">// 获取处理出站的HandlerContext</span><br><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">findContextOutbound</span><span class="hljs-params">(<span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">currentExecutor</span> <span class="hljs-operator">=</span> executor();<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.prev;<br>    &#125; <span class="hljs-keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br></code></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram
	AbstractChannel ->> AbstractChannel : 构造函数 -> newChannelPipeline()
	AbstractChannel ->> DefaultChannelPipeline : 创建默认的 ChannelPipeline, 传递Channel
	DefaultChannelPipeline ->> HeadContext : 创建Pipeline 链表头
	DefaultChannelPipeline ->> TailContext : 创建Pipeline 链表尾</pre><br><h3 id="将channel注册到selector"><a class="markdownIt-Anchor" href="#将channel注册到selector"></a> 将Channel注册到Selector</h3><blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 最后会调用 <code>connect(String inetHost, int inetPort)</code>方法连接服务端，最终会调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 的 <code>doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress)</code> 方法，Channel <em>（java nio Channel）</em> 会在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap </a>的 <code>initAndRegister()</code> 中进行初始化，但是这个方法还会将初始化好的 Channe <em>（java nio Channel）</em> 注册到 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java">NioEventLoop</a> 的 Selector 中</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 处理远程连接</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@see</span> #connect()</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doResolveAndConnect</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>      <span class="hljs-comment">// 初始化和注册Channel</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br><br>      <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>          <span class="hljs-keyword">if</span> (!regFuture.isSuccess()) &#123;<br>              <span class="hljs-keyword">return</span> regFuture;<br>          &#125;<br>          <span class="hljs-keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>          regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                  <span class="hljs-comment">// Directly obtain the cause and do a null check so we only need one volatile read in case of a</span><br>                  <span class="hljs-comment">// failure.</span><br>                  <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                  <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                      <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                      <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                      promise.setFailure(cause);<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                      <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                      <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                      promise.registered();<br>                      doResolveAndConnect0(channel, remoteAddress, localAddress, promise);<br>                  &#125;<br>              &#125;<br>          &#125;);<br>          <span class="hljs-keyword">return</span> promise;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化和注册Channel</span><br><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过工厂生成Channel, 工厂在配置引导类调用 .channel(channelClass) 方法时被初始化</span><br>        channel = channelFactory.newChannel();<br>        <span class="hljs-comment">// 本类的抽象方法，客户端由 Bootstrap 类实现，服务端由 ServerBootStrap 类实现</span><br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 异常强制关闭 channel, Netty里，channel就是对Socket的抽象封装</span><br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-comment">// 异步地向EventLoopGroup 注册当前的channel</span><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>    <span class="hljs-comment">// 处理重复注册和异常</span><br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><br><blockquote><p>当Channel初始化后，紧接着会调用 <code>config().group().register(channel)</code> 方法来向 Selector 注册 Channel</p><p>通过跟踪调用链 ， 我们最终发现在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a> 的 <code>initAndRegister()</code> 方法中调用的是 <code>Unsafe</code> 的 <code>register()</code> 方法，接下来看一下 <code>AbstractChannel$AbstractUnsafe.register()</code> 方法的具体实现代码</p></blockquote><pre class="mermaid">sequenceDiagram
		Bootstrap ->>	AbstractBootstrap : initAndRegister()
    AbstractBootstrap ->> MultithreadEventLoopGroup : register() 
    MultithreadEventLoopGroup ->> SingleThreadEventLoop : register()
    SingleThreadEventLoop ->> AbstractChannel$AbstractUnsafe : register()</pre><blockquote><p>通过跟踪调用链，我们最终发现在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a> 的 <code>initAndRegister()</code> 方法中调用的是Unsafe的register()方法，接下来看一下 <a href="%5BAbstractChannel%5D(https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java)">AbstractChannel$AbstractUnsafe.register()</a>方法的具体实现代码</p></blockquote><p><a href="%5BAbstractChannel%5D(https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java)">AbstractChannel$AbstractUnsafe</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册到事件循环</span><br><span class="hljs-comment"> * 注册方法其实就是判断是否当前线程就是IO线程，是的话就直接执行，不是就包装成一个任务提交给IO线程，这样就避免多线程的问题，始终是单线程操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> eventLoop</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> promise</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ObjectUtil.checkNotNull(eventLoop, <span class="hljs-string">&quot;eventLoop&quot;</span>);<br>    <span class="hljs-comment">// 是否已经注册到一个eventLoop</span><br>    <span class="hljs-keyword">if</span> (isRegistered()) &#123;<br>        promise.setFailure(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;registered to an event loop already&quot;</span>));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否是NioEventLoop类型</span><br>    <span class="hljs-keyword">if</span> (!isCompatible(eventLoop)) &#123;<br>        promise.setFailure(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 给外部类的 eventLoop 属性赋值，传递事件循环</span><br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br>    <span class="hljs-comment">// 当前线程是eventLoop的线程才可以注册，防止多线程并发问题，所以即使多线程来操作，也是安全的，会按照一定顺序提交到任务队列里</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//否则就当做任务提交给eventLoop的任务队列</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            logger.warn(<br>                    <span class="hljs-string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,<br>                    AbstractChannel.<span class="hljs-built_in">this</span>, t);<br>            closeForcibly();    <span class="hljs-comment">//强制关闭</span><br>            closeFuture.setClosed();    <span class="hljs-comment">//关闭回调</span><br>            safeSetFailure(promise, t); <span class="hljs-comment">//设置失败</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先，将 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> 赋值给 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 的 <code>eventLoop</code> 属性，我们知道 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/EventLoop.java">EventLoop</a> 对象其实是通过 <a href="#EventExecutorChooser%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-17">MultithreadEventLoopGroup的next()</a> 方法<br>获取的，根据前面的分析，<strong>可以确定next()方法返回的EventLoop对象是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java">NioEventLoop</a> 实例。register()方法接着调用了register0()方法，代码如下</strong></p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel$AbstractUnsafe</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册前的处理</span><br><span class="hljs-comment"> * 真正的注册逻辑在 doRegister 方法，其实就是将NIO Channel 注册到 Selector 上，然后进行处理器的待添加事件的处理,</span><br><span class="hljs-comment"> * 注册回调成功，管道传递注册事件，如果是第一次注册，管道传递通道激活事件，否则是设置自动读的话就注册读监听</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> promise</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 确保 Channel 当前是打开着的</span><br>        <span class="hljs-comment">// check if the channel is still open as it could be closed in the mean time when the register</span><br>        <span class="hljs-comment">// call was outside of the eventLoop</span><br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 设置注册标记</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRegistration</span> <span class="hljs-operator">=</span> neverRegistered;<br>        <span class="hljs-comment">// 真正的注册逻辑，参考 AbstractNioChannel，其实也就是拿到 java Nio Channel 往 EventLoop 注册</span><br>        <span class="hljs-comment">// EventLoop 的来源在上面 register(EventLoop eventLoop, final ChannelPromise promise) 方法中被赋值</span><br>        doRegister();<br>        <span class="hljs-comment">// 标记 Channel 已经注册</span><br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// AbstractChannel 外部类的注册标记，标记注册</span><br>        registered = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 如果在注册前有处理器添加，还没进行HandlerAdded回调，注册成功后要回调</span><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        <span class="hljs-comment">// 回调注册成功</span><br>        safeSetSuccess(promise);<br>        <span class="hljs-comment">// 通道注册事件传递</span><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span><br>        <span class="hljs-comment">// multiple channel actives if the channel is deregistered and re-registered.</span><br>        <span class="hljs-comment">// 判断当前通道是否激活，其实就是判断 java Nio Channel 当前是否打开和连接着</span><br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-comment">// 第一次注册要进行激活事件传递</span><br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                <span class="hljs-comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span><br>                <span class="hljs-comment">// again so that we process inbound data.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/4805</span><br>                <span class="hljs-comment">// 如果设置乐自动读，就继续监听读事件，这里也就是将 Channel 注册返回的 SelectionKey 感兴趣事件设置为 读</span><br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// Close the channel directly to avoid FD leak.</span><br>        closeForcibly();    <span class="hljs-comment">//强制关闭</span><br>        closeFuture.setClosed();    <span class="hljs-comment">//关闭回调</span><br>        safeSetFailure(promise, t); <span class="hljs-comment">//设置失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>register0()</code> 方法又调用了 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java">AbstractNioChannel的doRegister()方法</a>，代码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            <span class="hljs-keyword">if</span> (!selected) &#123;<br>                <span class="hljs-comment">// Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span><br>                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span><br>                eventLoop().selectNow();<br>                selected = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span><br>                <span class="hljs-comment">// for whatever reason. JDK bug ?</span><br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>看到 <code>javaChannel()</code> 这个方法，我们在前面已经知道了，它返回的是一个<strong>Java NIO的SocketChannel</strong>对象，这里我们将SocketChannel注册到与eventLoop关联的<code>Selector</code>上</p></blockquote><br><h4 id="总结-5"><a class="markdownIt-Anchor" href="#总结-5"></a> 总结</h4><blockquote><ol><li>在客户端引导类 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">Bootstrap</a> 的连接操作方法 <code>connect</code> 中，最终户i调用到 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a> 的initAndRegister()方法</li><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap</a> 的 <code>initAndRegister()</code> 方法中，通过group().register(channel) 调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java">MultithreadEventLoopGroup</a> 的<code>register()</code> 方法</li><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java">MultithreadEventLoopGroup</a> 的 <code>register()</code> 方法中，调用 <code>next()</code> <em>(<a href="#EventExecutorChooser%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-33">通过前面的 EventExecutorChooser 从EventloopGroup选择一个EventGroup</a>)</em> 方法获取一个可用的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java">SingleThreadEventLoop</a>，然后调用它的 <code>register()</code> 方法</li><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java">SingleThreadEventLoop</a> 的 register() 方法中 ， 调用 <code>channel.unsafe().register(this ， promise)</code> 方法获取 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractChannel</a> 的 unsafe() 底层操作对象，然后调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractUnsafe</a> 的register()方法</li><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractUnsafe</a> 的register()方法中，调用register0() 方法注册Channel对象</li><li>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractUnsafe</a> 的 register0() 方法中 ， 调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java">AbstractNioChannel</a> 的doRegister()方法</li><li><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java">AbstractNioChannel</a> 的 doRegister() 方法通过 javaChannel().register(eventLoop().selector ， 0 ， this) 将Channel 对应的 Java NIO 的 SocketChannel 注册到一个 EventLoop 的Selector中，并且将当前Channel作为Attachment与SocketChannel关联</li></ol><br><p>​	总的来说，Channel的注册过程所做的工作就是将Channel与对应的EventLoop进行关联。因此，在Netty中，每个Channel都会关联一个特定的EventLoop，并且这个Channel中的所有I/O操作都是在这个EventLoop中执行的；当关联好Channel和EventLoop后，会继续调用底层Java NIO的SocketChannel对象的register()方法，将底层Java NIO的SocketChannel注册到指定的Selector中。通过这两步，就完成了Netty对Channel的注册过程</p></blockquote><pre class="mermaid">sequenceDiagram
		Bootstrap ->>	Channel : 1.connetc() 通过Factory创建一个Channel
		Bootstrap ->> EventLoopGroup : 2.group() 通过配置得到 EventLoopGroup
		EventLoopGroup ->> EventLoop : 3.next() 得到EventLoop
		EventLoop ->> SingleThreadEventLoop : 4 register(Channel)
		SingleThreadEventLoop ->> AbstractNioUnsafe : 5. doRegister() 通过Channel获得Unsafe
		AbstractNioUnsafe --> AbstractNioUnsafe : 6. 获取EventLoop 对应的Selector
		AbstractNioUnsafe --> AbstractNioUnsafe : 7 javaChannel().register(selector)</pre><br><h3 id="handler的添加过程"><a class="markdownIt-Anchor" href="#handler的添加过程"></a> Handler的添加过程</h3><blockquote><p>​	<strong>Netty有一个强大和灵活之处就是基于Pipeline的自定义Handler机制。基于此，我们可以像添加插件一样自由组合各种各样的Handler来完成业务逻辑。</strong><span style="border-bottom:2px dashed green"> 例如我们需要处理 HTTP 数据 ， 那么就可以在Pipeline前添加一个针对HTTP编解码的Handler，然后添加我们自己的业务逻辑的Handler，这样网络上的数据流就像通过一个管道一样，从不同的Handler中流过并进行编解码，最终到达我们自定义的Handler中。</span></p><p>​	在Bootstrap引导类中就有关于Handler的配置，<code>handler(ChannelHandler handler)</code> 方法，可供用户自定义将 Handler 添加到 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> 中，<span style="border-bottom:2px dashed green"> <strong>调用时机在 Channel 被注册到 EventLoop 后添加 ChannelHandler</strong></span></p></blockquote><blockquote><p>调用时机</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannel.java">AbstractUnsafe</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ....<br>        <span class="hljs-comment">// 注册Channel到EventLoop</span><br>        doRegister();<br>        ....<br>        <span class="hljs-comment">// 如果在注册前有处理器添加，还没进行HandlerAdded回调，注册成功后要回调，这里会添加Bootstrap配置的ChannelHandler</span><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>初始化</p></blockquote><p><img src="/2022/05/25/netty/ChannelInitializerUML.png" srcset="/img/loading.gif" lazyload alt></p><p><a href="#ChannelPipeline%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">ChannelPipeline的初始化</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>        <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>            p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));<br>        &#125;<br>        <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>        p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoClientHandler</span>());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>这个代码片段就实现了Handler的添加功能。我们看到，Bootstrap的handler()方法接收一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelHandler.java">ChannelHandler</a>，而我们传入的参数是一个派生于抽象类 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a> 的匿名类，它也实现了 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelHandler.java">ChannelHandler</a> 接口。我们来看 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a> 类中到底有什么玄机，代码如下</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;C <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InternalLogger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> InternalLoggerFactory.getInstance(ChannelInitializer.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;ChannelHandlerContext&gt; initMap = Collections.newSetFromMap(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;ChannelHandlerContext, Boolean&gt;());<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(C ch)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Normally this method will never be called as handlerAdded(...) should call initChannel(...) and remove</span><br>        <span class="hljs-comment">// the handler.</span><br>        <span class="hljs-comment">// 调用下面的私有方法，私有方法再调用 initChannel 抽象方法     </span><br>        <span class="hljs-keyword">if</span> (initChannel(ctx)) &#123;<br>            <span class="hljs-comment">// we called initChannel(...) so we need to call now pipeline.fireChannelRegistered() to ensure we not</span><br>            <span class="hljs-comment">// miss an event.</span><br>            ctx.pipeline().fireChannelRegistered();<br><br>            <span class="hljs-comment">// We are done with init the Channel, removing all the state for the Channel now.</span><br>            removeState(ctx);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Called initChannel(...) before which is the expected behavior, so just forward the event.</span><br>            ctx.fireChannelRegistered();<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 初始化通道</span><br>    <span class="hljs-comment">// 上面的 channelRegistered 方法 和 AbstractChannel#register0() 中代码 pipeline.invokeHandlerAddedIfNeeded(); 会调用这里   </span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 抽象方法调用，调用子类实现的方法, 这里就是调用我们在Bootstrap配置ChannelHandler自定义的代码</span><br>                initChannel((C) ctx.channel());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>                <span class="hljs-comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span><br>                <span class="hljs-comment">// We do so to prevent multiple calls to initChannel(...).</span><br>                exceptionCaught(ctx, cause);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 作为配置类，将自身从管道 pipeline 中移除</span><br>                <span class="hljs-keyword">if</span> (!ctx.isRemoved()) &#123;<br>                    ctx.pipeline().remove(<span class="hljs-built_in">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;  <br></code></pre></td></tr></table></figure><blockquote><p>​	<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a> 是一个抽象类 ， 它有一个抽象的 <code>initChannel()</code> 方法，我们看到的匿名类正是实现了这个方法，并在这个方法中添加了自定义的Handler。那么 <code>initChannel()</code> 方法是在哪里被调用的呢？其实是在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a> 的 <code>channelRegistered()</code>方法中</p><p>​	接下来关注一下 <code>channelRegistered()</code> 方法。我们从上面的代码中可以看到，在 <code>channelRegistered()</code> 方法中，会调用 <code>initChannel()</code> 方法 ， 将自定 义的 <code>Handler</code> 添加到 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> 中 ， 然后调用 <code>ctx.pipeline().remove(this)</code> 方法将自己从 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> 中删除</p><p>​	一开始， <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelPipeline.java">ChannelPipeline</a> 中只有三个Handler，分别是Head、Tail和我们添加的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a></p></blockquote><p><img src="/2022/05/25/netty/ChannelHnadler%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/ChannelHnadler%E5%88%9D%E5%A7%8B%E5%8C%962.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>接着调用initChannel()方法，添加自定义的Handler，如下图所示</p></blockquote><p><img src="/2022/05/25/netty/ChannelHnadler%E5%88%9D%E5%A7%8B%E5%8C%963.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><p>最后将 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelInitializer.java">ChannelInitializer</a> 删掉，<span style="border-bottom:2px dashed green">它的作用只是在 Channel 进行注册的时候对自定义的 ChannelHandler 添加到 ChannelPipeline</span></p></blockquote><pre class="mermaid">sequenceDiagram
		AbstractUnsafe ->> AbstractUnsafe : register0() 注册Channel
		AbstractUnsafe ->> ChannelInitializer : pipeline.invokeHandlerAddedIfNeeded() 添加Handler ..-> handlerAdded()
		ChannelInitializer ->> 子类实现 : 调用 initChannel方法实现
		子类实现 ->> ChannelPipeline : 添加 Handler 
		ChannelInitializer ->> ChannelInitializer : removeState(ctx) 方法，将自身在ChannelPipeline中删除</pre><br><h3 id="客户端发起连接请求"><a class="markdownIt-Anchor" href="#客户端发起连接请求"></a> 客户端发起连接请求</h3><blockquote><p>客户端通过调用 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a> 的 <code>connect()</code> 方法进行连接 。 在 <code>connect()</code> 方法中进行一些参数检查，并调用 <code>doConnect()</code> 方法，其代码实现如下</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/Bootstrap.java">Bootstrap</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 连接最终调用的方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doConnect</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise connectPromise)</span> &#123;<br><br>    <span class="hljs-comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span><br>    <span class="hljs-comment">// the pipeline in its channelRegistered() implementation.</span><br>    <span class="hljs-comment">// Bootstrap 指定的Channel类型</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connectPromise.channel();<br>    <span class="hljs-comment">// 提交异步任务</span><br>    channel.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (localAddress == <span class="hljs-literal">null</span>) &#123;<br>                channel.connect(remoteAddress, connectPromise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channel.connect(remoteAddress, localAddress, connectPromise);<br>            &#125;<br>            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在 <code>doConnect()</code> 方法中 ， eventLoop 线程会调用 <code>Channel</code> 的 <code>connect()</code> 法 ， 而这个 Channel 的具体类型实际就是NioSocketChannel，前面已经分析过。继续跟踪 <code>channel.connect()</code> 方法，我们发现<span style="border-bottom:2px dashed green">它调用的是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 的 <code>connect()</code> 方法</span>，Pipeline的connect()方法的代码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">connect</span><span class="hljs-params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">return</span> tail.connect(remoteAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们已经分析过，<strong>Tail</strong> 是一个 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">TailContext</a> 的实例，而 TailContext 又是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a> 的子类，并且没有实现 <code>connect()</code> 方法，因此这里调用的其实是 <code>AbstractChannelHandlerContext的connect()</code>方法，我们看一下这个方法的实现代码</p></blockquote><hr><p><img src="/2022/05/25/netty/TailContext%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ObjectUtil.checkNotNull(remoteAddress, <span class="hljs-string">&quot;remoteAddress&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (isNotValidPromise(promise, <span class="hljs-literal">false</span>)) &#123;<br>        <span class="hljs-comment">// cancelled</span><br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 tail 开始向前找，找到第一个OutboundChannelHandler</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> findContextOutbound(MASK_CONNECT);<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        next.invokeConnect(remoteAddress, localAddress, promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        safeExecute(executor, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeConnect(remoteAddress, localAddress, promise);<br>            &#125;<br>        &#125;, promise, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码片段中有一句非常关键的代码，即 <span style="border-bottom:2px dashed green">final AbstractChannelHandlerContextnext=findContextOutbound()</span>，这里调用<code>findContextOutbound()</code>方法，从 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 内的双向链表的<strong>Tail</strong>开始，不断向前找到第一个处理Outbound的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a>，然后调用它的invokeConnect()方法，代码如下</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取处理出站的HandlerContext</span><br><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">findContextOutbound</span><span class="hljs-params">(<span class="hljs-type">int</span> mask)</span> &#123;<br>    <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">currentExecutor</span> <span class="hljs-operator">=</span> executor();<br>    <span class="hljs-keyword">do</span> &#123;<br>        ctx = ctx.prev;<br>    &#125; <span class="hljs-keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));<br>    <span class="hljs-keyword">return</span> ctx;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">skipContext</span><span class="hljs-params">(</span><br><span class="hljs-params">        AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="hljs-type">int</span> mask, <span class="hljs-type">int</span> onlyMask)</span> &#123;<br>    <span class="hljs-comment">// Ensure we correctly handle MASK_EXCEPTION_CAUGHT which is not included in the MASK_EXCEPTION_CAUGHT</span><br>    <span class="hljs-keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="hljs-number">0</span> ||<br>            <span class="hljs-comment">// We can only skip if the EventExecutor is the same as otherwise we need to ensure we offload</span><br>            <span class="hljs-comment">// everything to preserve ordering.</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/10067</span><br>            (ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行连接</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeConnect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这里能够强转是因为在调这个方法前已经调用 findContextOutbound 方法获取 ChannelOutboundHandler 了</span><br>            ((ChannelOutboundHandler) handler()).connect(<span class="hljs-built_in">this</span>, remoteAddress, localAddress, promise);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            notifyOutboundHandlerException(t, promise);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        connect(remoteAddress, localAddress, promise);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">DefaultChannelPipeline</a> 的构造器中，实例化了两个对象：<strong>Head</strong> 和 <strong>Tail</strong>，并形成了双向链表的头和尾。<strong>Head</strong> 是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">HeadContext</a> 的实例，它实现了<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java">ChannelOutboundHandler</a> 接口。<span style="border-bottom:2px dashed green">因此在 <code>findContextOutbound()</code> 方法中，找到的 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java">AbstractChannelHandlerContext</a> 对象其实就是<strong>Head</strong> ， 进而在<code>invokeConnect()</code> 方法中，我们向上转换为 <code>ChannelOutboundHandler</code> 就没问题了。而又因为 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">HeadContext</a> 重写了 <code>connect()方法</code>，所以实际上调用的是 <code>HeadContext 的 connect() 方法</code></span> 。 接着跟踪 <code>HeadContext 的connect()方法</code></p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">HeadContext</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Channel 连接操作</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">        ChannelHandlerContext ctx,</span><br><span class="hljs-params">        SocketAddress remoteAddress, SocketAddress localAddress,</span><br><span class="hljs-params">        ChannelPromise promise)</span> &#123;<br>    unsafe.connect(remoteAddress, localAddress, promise);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个 <code>connect()</code> 方法很简单，只是调用了Unsafe的connect()方法。回顾一下 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java">HeadContext</a> 的构造器，我们发现这个Unsafe其实就是<strong>pipeline.channel().unsafe()</strong> 返回的 <code>Channel</code> 的 <code>Unsafe</code> 属性。到这里为止，我们应该已经知道，其实是 <a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java">AbstractNioByteChannel.NioByteUnsafe</a> 内部类转了一大圈。最后，我们找到创建 <strong>Socket</strong> 连接的关键代码继续跟踪，其实调用的就是 <code>AbstractNioUnsafe的connect()方法</code></p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java">NioByteUnsafe</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Channel 连接</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Already a connect in process.</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionPendingException</span>();<br>            &#125;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">wasActive</span> <span class="hljs-operator">=</span> isActive();<br>            <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;<br>                fulfillConnectPromise(promise, wasActive);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                connectPromise = promise;<br>                requestedRemoteAddress = remoteAddress;<br><br>                <span class="hljs-comment">// Schedule connect timeout.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">connectTimeoutMillis</span> <span class="hljs-operator">=</span> config().getConnectTimeoutMillis();<br>                <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>                    connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                            <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">connectPromise</span> <span class="hljs-operator">=</span> AbstractNioChannel.<span class="hljs-built_in">this</span>.connectPromise;<br>                            <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span> &amp;&amp; !connectPromise.isDone()<br>                                    &amp;&amp; connectPromise.tryFailure(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectTimeoutException</span>(<br>                                            <span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress))) &#123;<br>                                close(voidPromise());<br>                            &#125;<br>                        &#125;<br>                    &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>                &#125;<br><br>                promise.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-keyword">if</span> (future.isCancelled()) &#123;<br>                            <span class="hljs-keyword">if</span> (connectTimeoutFuture != <span class="hljs-literal">null</span>) &#123;<br>                                connectTimeoutFuture.cancel(<span class="hljs-literal">false</span>);<br>                            &#125;<br>                            connectPromise = <span class="hljs-literal">null</span>;<br>                            close(voidPromise());<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            promise.tryFailure(annotateConnectException(t, remoteAddress));<br>            closeIfClosed();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个connect()方法中，又调用了doConnect()方法。注意：这个方法并不是AbstractNioUnsafe的方法，而是AbstractNioChannel的抽象方法。doConnect()方法是在NioSocketChannel中实现的，因此进入NioSocketChannel的doConnect()方法，代码如下</p></blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java">AbstractNioUnsafe</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doConnect</span><span class="hljs-params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (localAddress != <span class="hljs-literal">null</span>) &#123;<br>        doBind0(localAddress);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">connected</span> <span class="hljs-operator">=</span> SocketUtils.connect(javaChannel(), remoteAddress);<br>        <span class="hljs-keyword">if</span> (!connected) &#123;<br>            selectionKey().interestOps(SelectionKey.OP_CONNECT);<br>        &#125;<br>        success = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> connected;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            doClose();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面代码的功能是，首先获取Java NIO的SocketChannel，然后获取NioSocketChannel的newSocket()方法返回的SocketChannel对象；再调SocketChannel的 connect() 方法完成Java NIO底层的Socket连接</p></blockquote><br><br><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><h3 id="bossgroup和workergroup"><a class="markdownIt-Anchor" href="#bossgroup和workergroup"></a> BossGroup和WorkerGroup</h3><p><img src="/2022/05/25/netty/BossGroup.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/NioEventLoopGroup.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li><strong>Netty中的<code>BossGroup</code>和<code>WorkerGroup</code>的实际类型是<code>NioEventLoopGroup</code>,通过类图能够发现是通过JUC线程池接口扩展而来的</strong></li><li><strong>线程池线程的个数（NioEventLoop个数）如果在构造函数不指定的话，默认是CPU核心数的2倍</strong></li><li><strong>NioEventLoopGroup 就是 NioEventLoop 组，负责管理 NioEventLoop，当有 Channel 需要注册的时候，NioEventLoopGroup 会轮询找到下一个 NioEventLoop 注册上去。在NioEventLoopGroup 上作出的配置最终都会作用到 NioEventLoop 上</strong></li></ul></blockquote><br><h4 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h4><blockquote><p><a target="_blank" rel="noopener" href="https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example/echo">官方 Netty Example 源码</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServer</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">SSL</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;ssl&quot;</span>) != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> Integer.parseInt(System.getProperty(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8007&quot;</span>));<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// Configure SSL.</span><br>        <span class="hljs-keyword">final</span> SslContext sslCtx;<br>        <span class="hljs-keyword">if</span> (SSL) &#123;<br>            <span class="hljs-type">SelfSignedCertificate</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfSignedCertificate</span>();<br>            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sslCtx = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Configure the server.</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">EchoServerHandler</span> <span class="hljs-variable">serverHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoServerHandler</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            b.group(bossGroup, workerGroup)<br>             .channel(NioServerSocketChannel.class)<br>             .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>             .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>             .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                     <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                     <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>                         p.addLast(sslCtx.newHandler(ch.alloc()));<br>                     &#125;<br>                     <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>                     p.addLast(serverHandler);<br>                 &#125;<br>             &#125;);<br><br>            <span class="hljs-comment">// Start the server.</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.bind(PORT).sync();<br><br>            <span class="hljs-comment">// Wait until the server socket is closed.</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><p>先看启动类：main 方法中，首先创建了关于 SSL 的配置类</p></li><li><p>重点分析下 创建了两个 EventLoopGroup 对象：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br></code></pre></td></tr></table></figure><ul><li>这两个对象是整个 Netty 的核心对象，可以说，整个 Netty 的运作都依赖于他们。bossGroup 用于接受Tcp 请求，他会将请求交给 workerGroup ，workerGroup 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作</li></ul><br><ul><li><strong>EventLoopGroup 是事件循环组（线程组） 含有多个 EventLoop，可以注册 channel ,用于在事件循环中去进行选择（和选择器相关）</strong></li></ul><p><img src="/2022/05/25/netty/EventLoopGroup%E6%BA%90%E7%A0%811.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/EventLoopGroup%E6%BA%90%E7%A0%812.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>在<code>NioEventLoopGroup</code>的父类<code>MultithreadEventExecutorGroup</code>类中包含属性<code>private final EventExecutor[] children</code>,<code>NioEventLoop</code>类是接口<code>EventExecutor</code>的实现类之一</strong></p><br><ul><li><strong>new NioEventLoopGroup(1); 这个 1 表示 bossGroup 事件组有 1 个线程你可以指定，如果 new NioEventLoopGroup() 会含有默认个线程 cpu 核数 * 2, 即可以充分的利用多核的优势</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultithreadEventLoopGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MultithreadEventExecutorGroup</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventLoopGroup</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InternalLogger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> InternalLoggerFactory.getInstance(MultithreadEventLoopGroup.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_EVENT_LOOP_THREADS;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * NettyRuntime.availableProcessors() 会拿到当前计算机的Cpu的核心数</span><br><span class="hljs-comment">     * 最终结果是 Cpu核心数 * 2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>                <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 跟踪 new NioEventLoopGroup() 源码</span><br><span class="hljs-comment">     * 在类 MultithreadEventLoopGroup 源码的构造方法中，如果传入的 nThreads 为0 （new EventLoopGroup() 构造函数传入）</span><br><span class="hljs-comment">     * 则使用默认值 DEFAULT_EVENT_LOOP_THREADS</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, Executor, Object...)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>        <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>    &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><br><ul><li><strong>NioEventLoopGroup初始化过程</strong></li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java">MultithreadEventExecutorGroup 源码</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultithreadEventExecutorGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractEventExecutorGroup</span> &#123;<br><br>    <span class="hljs-comment">// 这个就是 EventLoop 的容器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] children;<br>    <span class="hljs-comment">// http://gitbook.net/java/util/collections_unmodifiableset.html</span><br>    <span class="hljs-comment">// 只读的 EventLoop 集合，当children初始化完成就会拷贝过来，底层类是 UnmodifiableSet，只读的Set, 添加会抛异常</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;EventExecutor&gt; readonlyChildren;<br>    <span class="hljs-comment">// 终止的 EventLoop 数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">terminatedChildren</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-comment">// Promise 在 Future(JUC) 接口的基础上扩展了，可写的接口，DefaultPromise 是通过 CAS 来进行更新执行的结果 result 字段的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Promise&lt;?&gt; terminationFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPromise</span>(GlobalEventExecutor.INSTANCE);<br>    <span class="hljs-comment">// EventLoop 选择器，Channel 注册到 EventLoop 时使用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser;<br><br>  ...<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最终的创建实例调用的构造器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nThreads       该实例将使用的线程数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> executor       将要使用的executor, 默认为null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> chooserFactory 将要使用的EventExecutorChooserFactory</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args           arguments which will passed to each &#123;<span class="hljs-doctag">@link</span> #newChild(Executor, Object...)&#125; call</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">                                            EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br>        <span class="hljs-comment">// 校验线程数量的合法性</span><br>        checkPositive(nThreads, <span class="hljs-string">&quot;nThreads&quot;</span>);<br><br><br>        <span class="hljs-comment">// executor校验非空, 如果为空就创建ThreadPerTaskExecutor, 该类实现了 Executor接口(JUC)</span><br>        <span class="hljs-comment">// 题外说明：Executor接口的execute方法在JUC线程池中是用于提交异步任务的</span><br>        <span class="hljs-comment">// 这个executor 是用来执行线程池中的所有的线程，也就是所有的NioEventLoop，其实从</span><br>        <span class="hljs-comment">// NioEventLoop构造器中也可以知道，NioEventLoop构造器中都传入了executor这个参数</span><br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>        &#125;<br><br>        <span class="hljs-comment">// 这里的children数组， 其实就是线程池的核心实现，线程池中就是通过指定的线程数组来实现线程池；</span><br>        <span class="hljs-comment">// 数组中每个元素其实就是一个NioEventLoop</span><br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br><br>        <span class="hljs-comment">// for循环实例化children数组，NioEventLoop对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                <span class="hljs-comment">// newChild 这个抽象方法在 NioEventLoopGroup类 被实现，就是返回 NioEventLoop</span><br>                children[i] = newChild(executor, args);<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 如果创建失败就释放资源</span><br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                        children[j].shutdownGracefully();<br>                    &#125;<br><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                            <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                            Thread.currentThread().interrupt();<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// chooserFactory类型是 DefaultEventExecutorChooserFactory</span><br>        <span class="hljs-comment">// chooser类型是 DefaultEventExecutorChooserFactory的两个内部类之一，选择器的作用就是当BossGroup创建连接后注册到WorkerGroup的EventLoop时</span><br>        <span class="hljs-comment">// 需要使用来选择数组中的EventLoop, 底层算法是通过 executors[(int) Math.abs(idx.getAndIncrement() % executors.length)] 实现的轮询算法</span><br>        chooser = chooserFactory.newChooser(children);<br><br>        <span class="hljs-comment">// 为每个EventLoop线程添加 线程终止监听器</span><br>        <span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-comment">// 异常终止数量自增</span><br>                <span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>                    terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (EventExecutor e : children) &#123;<br>            e.terminationFuture().addListener(terminationListener);<br>        &#125;<br><br>        <span class="hljs-comment">// 将children 添加到对应的set集合中去重， 表示只可读</span><br>        Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>        Collections.addAll(childrenSet, children);<br>        readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>    &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="serverbootstrap"><a class="markdownIt-Anchor" href="#serverbootstrap"></a> ServerBootstrap</h3><blockquote><p><strong>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始 ，主要作用是配置整个 Netty 程序，串联各个组件, ServerBootstrap是服务端启动引导类</strong></p><p><strong>常见的方法有：</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</strong></td><td><strong>该方法用于服务器端，用来设置两个 EventLoopGroup</strong></td></tr><tr><td><strong>public B channel(Class&lt;? extends C&gt; channelClass)</strong></td><td><strong>该方法用来设置一个服务器端的通道实现</strong></td></tr><tr><td><strong>public ChannelFuture bind(int inetPort)</strong></td><td><strong>该方法用于服务器端，用来设置占用的端口号</strong></td></tr><tr><td><strong>public B option(ChannelOption option, T value)</strong></td><td><strong>用来给 ServerChannel 添加配置</strong></td></tr><tr><td><strong>public B handler(ChannelHandler handler)</strong></td><td><strong>用于给bossGroup设置业务处理类</strong></td></tr><tr><td><strong>public B group(EventLoopGroup group)</strong></td><td><strong>该方法用于客户端，用来设置一个 EventLoopGroup</strong></td></tr><tr><td><strong>public ChannelFuture connect(String inetHost, int inetPort)</strong></td><td><strong>该方法用于客户端，用来连接服务器端</strong></td></tr><tr><td><strong>public ServerBootstrap childOption(ChannelOption childOption, T value)</strong></td><td><strong>用来给接收到的通道添加配置</strong></td></tr><tr><td><strong>public ServerBootstrap childHandler(ChannelHandler childHandler)</strong></td><td><strong>该方法用来设置业务处理类 （workerGroup 自定义的 handler）</strong></td></tr></tbody></table></blockquote><br><p><img src="/2022/05/25/netty/ServerBootstrap%E8%BF%90%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/ServerSocketChannel%E8%BF%90%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/ServerBootstrap.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li><strong>服务端的启动类，扩展于NIO的<code>Channel</code>接口</strong></li><li><strong>用于Netty的启动配置，如通道类型，Handler等配置</strong></li><li><strong><code>BossGroup</code>的配置在<code>ServerBootstrap</code>实例中，<code>WorkerGroup</code>的配置信息在<code>AbstractBootstrap</code>中</strong></li></ul></blockquote><br><h4 id="源码解析-2"><a class="markdownIt-Anchor" href="#源码解析-2"></a> 源码解析</h4><blockquote><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/example/src/main/java/io/netty/example/echo/EchoServer.java">源码地址</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Configure the server.</span><br>  <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">5</span>);<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">EchoServerHandler</span> <span class="hljs-variable">serverHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EchoServerHandler</span>();<br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>      b.group(bossGroup, workerGroup)<br>        <span class="hljs-comment">// 指定channel类型，通过反射创建</span><br>       .channel(NioServerSocketChannel.class)<br>       .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">100</span>)<br>       .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>       .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>               <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ch.pipeline();<br>               <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-literal">null</span>) &#123;<br>                   p.addLast(sslCtx.newHandler(ch.alloc()));<br>               &#125;<br>               <span class="hljs-comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span><br>               p.addLast(serverHandler);<br>           &#125;<br>       &#125;);<br><br>      <span class="hljs-comment">// Start the server.</span><br>      <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> b.bind(PORT).sync();<br><br>      <span class="hljs-comment">// Wait until the server socket is closed.</span><br>      f.channel().closeFuture().sync();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// Shut down all event loops to terminate all threads.</span><br>      bossGroup.shutdownGracefully();<br>      workerGroup.shutdownGracefully();<br>  &#125;<br></code></pre></td></tr></table></figure><br><ul><li><strong>变量 b 调用了 group 方法将两个 group 放入了自己的字段中，用于后期引导使用</strong></li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java">ServerBootstrap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerBootstrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">InternalLogger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> InternalLoggerFactory.getInstance(ServerBootstrap.class);<br><br>    <span class="hljs-comment">// The order in which child ChannelOptions are applied is important they may depend on each other for validation</span><br>    <span class="hljs-comment">// purposes.</span><br>    <span class="hljs-comment">// Channel 的配置属性项</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;ChannelOption&lt;?&gt;, Object&gt;();<br>    <span class="hljs-comment">// AttributeMap 的key, AttributeMap 是 Channel 接口的顶级接口，每个Channel 必定是个 AttributeMap</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;AttributeKey&lt;?&gt;, Object&gt;();<br>    <span class="hljs-comment">// ServerBootstrap 配置类，主要提供获取 BossGroup 和 WorkerGroup配置能力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ServerBootstrapConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapConfig</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">// WorkerGroup</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> EventLoopGroup childGroup;<br>    <span class="hljs-comment">// WorkerGroup 对应的handler, 用于处理 initChannel 事件。当Channel在注册WorkerGroup时触发</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ChannelHandler childHandler;<br>  <br>  ...<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置BossGroup 和 WorkerGroup</span><br><span class="hljs-comment">     * Set the &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125; for the parent (acceptor) and the child (client). These</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;<span class="hljs-doctag">@link</span> ServerChannel&#125; and</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Channel&#125;&#x27;s.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-title function_">group</span><span class="hljs-params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;<br>        <span class="hljs-comment">//调用父类方法 BossGroup 的相关属性都放在父类 AbstractBootstrap里</span><br>        <span class="hljs-built_in">super</span>.group(parentGroup);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.childGroup != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;childGroup set already&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将WorkerGroup赋值到当前对象 WorkerGroup相关配置都在 ServerBootstrap</span><br>        <span class="hljs-built_in">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="hljs-string">&quot;childGroup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br> ... <br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>.channel(NioServerSocketChannel.class) 用于指定所使用的Channel类型，并会创建一个Channel工厂用于反射生成Channel</strong></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置服务端Channel类型，返回ReflectiveChannelFactory 它是一个反射工厂， 通过反射创建Channel对象</span><br><span class="hljs-comment"> * The &#123;<span class="hljs-doctag">@link</span> Class&#125; which is used to create &#123;<span class="hljs-doctag">@link</span> Channel&#125; instances from.</span><br><span class="hljs-comment"> * You either use this or &#123;<span class="hljs-doctag">@link</span> #channelFactory(io.netty.channel.ChannelFactory)&#125; if your</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Channel&#125; implementation has no no-args constructor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> B <span class="hljs-title function_">channel</span><span class="hljs-params">(Class&lt;? extends C&gt; channelClass)</span> &#123;<br>    <span class="hljs-keyword">return</span> channelFactory(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;C&gt;(<br>            ObjectUtil.checkNotNull(channelClass, <span class="hljs-string">&quot;channelClass&quot;</span>)<br>    ));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置Channel工厂</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@deprecated</span> Use &#123;<span class="hljs-doctag">@link</span> #channelFactory(io.netty.channel.ChannelFactory)&#125; instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-keyword">public</span> B <span class="hljs-title function_">channelFactory</span><span class="hljs-params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;<br>    ObjectUtil.checkNotNull(channelFactory, <span class="hljs-string">&quot;channelFactory&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.channelFactory != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;channelFactory set already&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.channelFactory = channelFactory;<br>    <span class="hljs-keyword">return</span> self();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ReflectiveChannelFactory 是如何通过反射创建Channel的</strong></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java">ReflectiveChannelFactory.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反射Channel工厂</span><br><span class="hljs-comment"> * A &#123;<span class="hljs-doctag">@link</span> ChannelFactory&#125; that instantiates a new &#123;<span class="hljs-doctag">@link</span> Channel&#125; by invoking its default constructor reflectively.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelFactory</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">// Channel 的构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; constructor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，根据传递进来的Channel类型获取其无参构造函数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReflectiveChannelFactory</span><span class="hljs-params">(Class&lt;? extends T&gt; clazz)</span> &#123;<br>        ObjectUtil.checkNotNull(clazz, <span class="hljs-string">&quot;clazz&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.constructor = clazz.getConstructor();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) +<br>                    <span class="hljs-string">&quot; does not have a public non-arg constructor&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过无参构造函数调用Java反射Api生成一个新的Channel,在有客户端建立新的连接时使用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> constructor.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>        &#125;<br>    &#125;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><br><ul><li><strong>.option(ChannelOption.SO_BACKLOG, 100) 设置BossGroup配置属性项</strong></li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置BossGroup 的配置属性项</span><br><span class="hljs-comment"> * Allow to specify a &#123;<span class="hljs-doctag">@link</span> ChannelOption&#125; which is used for the &#123;<span class="hljs-doctag">@link</span> Channel&#125; instances once they got</span><br><span class="hljs-comment"> * created. Use a value of &#123;<span class="hljs-doctag">@code</span> null&#125; to remove a previous set &#123;<span class="hljs-doctag">@link</span> ChannelOption&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; B <span class="hljs-title function_">option</span><span class="hljs-params">(ChannelOption&lt;T&gt; option, T value)</span> &#123;<br>    ObjectUtil.checkNotNull(option, <span class="hljs-string">&quot;option&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (options) &#123;<br>      	<span class="hljs-comment">// options 是个map</span><br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>            options.remove(option);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            options.put(option, value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> self();<br>&#125;<br></code></pre></td></tr></table></figure><br><ul><li><strong>.handler(…) .childHandler(…)</strong></li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java">ServerBootstrap.java</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/netty/edit/master/-/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java">AbstractBootstrap.java</a></p><p><strong>分别为AbstractBootstrap#handler 和 ServerBootstrap#childHandler 赋值</strong></p></blockquote><blockquote><p><img src="/2022/05/25/netty/Bootstrap%E5%88%9D%E5%A7%8B%E5%8C%961.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/Bootstrap%E5%88%9D%E5%A7%8B%E5%8C%962.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/Bootstrap3%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/Bootstrap4%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong>ServerBootstrap的bind是最终启动服务的方法</strong><ul><li>它首先会通过反射创建一个指定类型的<code>ServerSocketChannel</code></li><li>然后根据ServerBootStrap设置的配置去初始化<code>ServerSocketChannel</code></li><li>通过<code>ServerSocketChannel</code>获得<code>DefaultChannelPipeline</code>，<font color="red">在图中能看到<code>Channel</code> 和<code>Pipeline</code>是相互包含关系,在创建Channel的同时就会创建Pipeline</font></li><li>获取ServerBootStrap设置相关的child配置（WorkerGroup的配置）</li><li>创建一个异步任务，为<code>Pipeline</code>添加一个handler<code>ServerBootstrapAcceptor</code></li><li><code>ServerBootstrapAcceptor</code>处理客户端连接的<code>Accect</code>事件，获得<code>SocketChannel</code>后就会获取child配置初始化到Channel,然后注册到<code>WorkerGroup</code></li><li><code>SocketChannel</code>注册到<code>WorkerGroup</code>的<code>EventLoop</code>中，默认采用的是轮询算法进行注册，注册完成之后就监听读事件，等待客户端请求</li></ul></li></ul></blockquote><br><br><h3 id="nioeventloop"><a class="markdownIt-Anchor" href="#nioeventloop"></a> NioEventLoop</h3><p><img src="/2022/05/25/netty/NioEventLoop.png" srcset="/img/loading.gif" lazyload alt></p><blockquote><ul><li><strong>NioEventLoop 就是一个事件循环类，几乎所有事件处理都会经过这个类</strong></li><li><strong>和NioEventLoopGroup一样都是扩展于JUC包下的线程池接口，不同的是事件循环是一个单线程的线程池</strong></li><li><strong>根据类图可知每个子线程都有自己的Selector (NioEventLoop#selector) 和TaskQueue (SingleThreadEventExecutor#taskQueue)</strong></li></ul></blockquote><br><h4 id="源码剖析"><a class="markdownIt-Anchor" href="#源码剖析"></a> 源码剖析</h4><blockquote></blockquote><br><h3 id="channel-3"><a class="markdownIt-Anchor" href="#channel-3"></a> Channel</h3><blockquote><ul><li><strong>每个NioChannel只会绑定一个EventLoop</strong></li><li>Netty 网络通信的组件，能够用于执行网络 I/O 操作</li><li>通过Channel 可获得当前网络连接的通道的状态</li><li>通过Channel 可获得网络连接的配置参数 （例如接收缓冲区大小 ）</li><li>Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成</li><li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方 支持关联 I/O 操作与对应的处理程序</li><li>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应</li></ul><p><strong>常用的 Channel 类型</strong></p><table><thead><tr><th>通道类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>NioSocketChannel</strong></td><td><strong>异步的客户端 TCP Socket 连接</strong></td></tr><tr><td><strong>NioServerSocketChannel</strong></td><td><strong>异步的服务器端 TCP Socket 连接</strong></td></tr><tr><td><strong>NioDatagramChannel</strong></td><td><strong>异步的 UDP 连接</strong></td></tr><tr><td><strong>NioSctpChannel</strong></td><td><strong>异步的客户端 Sctp 连接</strong></td></tr><tr><td><strong>NioSctpServerChannel</strong></td><td><strong>异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO</strong></td></tr><tr><td><strong>OioSocketChannel</strong></td><td><strong>同步的客户端 TCP Socket 连接</strong></td></tr><tr><td><strong>OioServerSocketChannel</strong></td><td><strong>同步的服务器端 TCP Socket 连接</strong></td></tr><tr><td><strong>OioDatagramChannel</strong></td><td><strong>同步的 UDP 连接</strong></td></tr><tr><td><strong>OioSctpChannel</strong></td><td><strong>同步的 Sctp 服务器端连接</strong></td></tr><tr><td><strong>OioSctpServerChannel</strong></td><td><strong>同步的客户端 TCP Socket 连接</strong></td></tr></tbody></table></blockquote><br><h4 id="channeloption"><a class="markdownIt-Anchor" href="#channeloption"></a> ChannelOption</h4><br><h3 id="异步模型"><a class="markdownIt-Anchor" href="#异步模型"></a> 异步模型</h3><blockquote><ul><li>异步的概念和同步是相对的。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态，通知和回调来通知调用者</li><li>Netty中的 I/O 操作是异步的，包括 Bind, Write, Connect等操作会简单地返回一个ChannelFuture</li><li>调用者并不能立即获得结果，而是通过 <strong>Future-Listener 机制</strong>，用户可以方便主动获取或通过通知机制获得 I/O 操作结果</li><li>Netty的异步模型是建立在 Future和Callback之上的（JUC的异步任务）。Callback就是回调。重点说 Future,它的核心思想是：假设一个方法 fun, 计算过程可能非常耗时，等待fun返回显然不太合适。那么可以在调用fun的时候，立马返回一个 Future, 后续可以通过Future去监控方法fun的处理过程（Future-Listener机制）</li></ul></blockquote><br><h4 id="future-listener-机制"><a class="markdownIt-Anchor" href="#future-listener-机制"></a> Future-Listener 机制</h4><blockquote><p><img src="/2022/05/25/netty/java/blog/source/_posts/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>Future 表示异步的执行结果，可以通过它提供的方法来检测执行是否完成，比如检索计算等等</li></ul><p><img src="/2022/05/25/netty/java/blog/source/_posts/%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>在使用Netty进行编程时，拦截操作和转换出入站数据只需要提供 callback 或利用 future 即可，这使得<strong>链式操作</strong>简单，高效，并有利编写可重用的，通用的代码</li><li>Netty框架的目标就是让你的业务代码逻辑从网络编程中分离出来，解脱出来</li></ul></blockquote><br><h4 id="channelfuture"><a class="markdownIt-Anchor" href="#channelfuture"></a> ChannelFuture</h4><blockquote><ul><li><strong>ChannelFuture是一个接口，我们可以添加监听器，当监听的事件发生时，就会通知到监听器</strong></li></ul><p><strong>常用方法：</strong></p><ul><li><strong>Channel channel()，返回当前正在进行 IO 操作的通道</strong></li><li><strong>ChannelFuture sync()，等待异步操作执行完毕</strong></li><li><strong>ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; var1) 注册监听器</strong></li></ul><p><img src alt></p><ul><li><strong>顶层的<code>Future</code>是<code>JUC</code>的接口，第二个是Netty包下的接口</strong></li></ul><p><img src="/2022/05/25/netty/java/blog/source/_posts/ChannelFuture%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" srcset="/img/loading.gif" lazyload alt></p><br><ul><li>Future-Listener 机制当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作</li><li>常见有如下操作<ul><li>通过 <strong>isDone</strong> 方法来判断当前操作是否完成</li><li>通过 <strong>isSuccess</strong> 方法来判断已完成的当前操作是否成功；</li><li>通过 <strong>getCause</strong> 方法来获取已完成的当前操作失败的原因；</li><li>通过 <strong>isCancelled</strong> 方法来判断已完成的当前操作是否被取消；</li><li>通过 <strong>addListener</strong> 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器</li></ul></li></ul><p><strong>给一个 ChannelFuture 注册监听器，来监控我们关心的事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//启动服务器(并绑定端口),bind是一个异步操作</span><br>  <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>  <span class="hljs-comment">//给channelFuture 注册监听器，监控我们关心的事件</span><br>  channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>          <span class="hljs-keyword">if</span>(future.isSuccess()) &#123;<br>              System.out.println(<span class="hljs-string">&quot;监听端口 6666 成功&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              System.out.println(<span class="hljs-string">&quot;监听端口 6666 失败&quot;</span>);<br>          &#125;<br>      &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure></blockquote><br><h3 id="selector-2"><a class="markdownIt-Anchor" href="#selector-2"></a> Selector</h3><blockquote><ul><li><a href="#selector">参考 NIO Selector</a></li><li>Netty 基于 Selector 对象实现 <strong>I/O 多路复用</strong>，通过 Selector 一个线程可以监听多个连接的 Channel 事件</li><li><strong>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询 (Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接 完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel</strong></li></ul></blockquote><br><h3 id="channelhandler"><a class="markdownIt-Anchor" href="#channelhandler"></a> ChannelHandler</h3><blockquote><p><img src="/2022/05/25/netty/ChannelHandler%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>ChannelHandler是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到ChannelPipeline（业务处理链）中的下一个处理程序, <strong>Handler是Netty业务处理的重要体系</strong></li><li>ChannelHandler本身并没有提供很多方法，因为这个接口有许多方法需要实现，方便使用期间，可以继承它的子类</li><li>ChannelInboundHandler 用于处理入站 I/O 事件</li><li>ChannelOutboundHandler用于处理出站 I/O 事件</li><li>适配器<ul><li>ChannelInboundHandlerAdapter 用于处理入站 I/O 事件</li><li>ChannelOutboundHandlerAdapter 用于处理出站 I/O 事件</li><li>ChannelDuplexHandler 用于处理出站和入站事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServerInitialize</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 向管道加入处理器</span><br><br>        <span class="hljs-comment">// 得到管道</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br><br>        <span class="hljs-comment">// 加入一个Netty提供的 HttpServerCodec (http协议编解码器) codec =&gt; decoder</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br><br>        <span class="hljs-comment">// 增加一个针对http协议的handler</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerHandler</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Handler常用的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Channel注册到EventLoop的时候，调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Channel从EventLoop注销的时候，调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Channel活跃的时候，调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Channel不活跃的时候，调用，此时生命周期马上结束</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Channel读取到消息的时候调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 抛出异常时调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  发生IO出站事件的时候，方法会得到通知调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called once a bind operation is made.</span><br><span class="hljs-comment">     * 绑定操作被执行的时候调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called once a connect operation is made.</span><br><span class="hljs-comment">     * 连接操作执行的时候调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span><br><span class="hljs-params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called once a disconnect operation is made.</span><br><span class="hljs-comment">     * 断开连接的时候调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">disconnect</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called once a close operation is made.</span><br><span class="hljs-comment">     * 关闭的时候调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called once a deregister operation is made from the current registered &#123;<span class="hljs-doctag">@link</span> EventLoop&#125;.</span><br><span class="hljs-comment">     * 注销的时候调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deregister</span><span class="hljs-params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Intercepts &#123;<span class="hljs-doctag">@link</span> ChannelHandlerContext#read()&#125;.</span><br><span class="hljs-comment">     * 拦截ChannelHandlerContext#read()方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Called once a write operation is made. The write operation will write the messages through the</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> ChannelPipeline&#125;. Those are then ready to be flushed to the actual &#123;<span class="hljs-doctag">@link</span> Channel&#125; once</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Channel#flush()&#125; is called</span><br><span class="hljs-comment">     * 写操作时候调用，写的消息会经过ChannelPipeline，调用Channel#flush()的时候，消息会被flush到Channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called once a flush operation is made. The flush operation will try to flush out all previous written messages that are pending.</span><br><span class="hljs-comment">     * flush会将前面前部pending的消息flush到Channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>适配器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>    <span class="hljs-type">boolean</span> added;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChannelHandlerAdapter</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureNotSharable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isSharable()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;ChannelHandler &quot;</span> + <span class="hljs-built_in">this</span>.getClass().getName() + <span class="hljs-string">&quot; is not allowed to be shared&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断当前hanlder是否是可共享(在多个pipeline中）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSharable</span><span class="hljs-params">()</span> &#123;<br>        Class&lt;?&gt; clazz = <span class="hljs-built_in">this</span>.getClass();<br>        Map&lt;Class&lt;?&gt;, Boolean&gt; cache = InternalThreadLocalMap.get().handlerSharableCache();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">sharable</span> <span class="hljs-operator">=</span> (Boolean)cache.get(clazz);<br>        <span class="hljs-keyword">if</span> (sharable == <span class="hljs-literal">null</span>) &#123;<br>            sharable = clazz.isAnnotationPresent(Sharable.class);<br>            cache.put(clazz, sharable);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sharable;<br>    &#125;<br><br>    <span class="hljs-comment">// 在ChannelHandler被添加到实际上下文中并准备好处理事件后调</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 在ChannelHandler从实际上下文中移除后调用，表明它不再处理事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 在抛出Throwable类后调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireExceptionCaught(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelInboundHandler</span> &#123;<br>    <span class="hljs-comment">// 通道注册事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRegistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireChannelRegistered();<br>    &#125;<br><br>    <span class="hljs-comment">// 通道注销事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelUnregistered</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireChannelUnregistered();<br>    &#125;<br><br>    <span class="hljs-comment">// 通道就绪事件 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireChannelActive();<br>    &#125;<br><br>    <span class="hljs-comment">// 通道读取数据事件 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireChannelRead(msg);<br>    &#125;<br><br>    <span class="hljs-comment">// 通道读取数据完毕事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireChannelReadComplete();<br>    &#125;<br><br>    <span class="hljs-comment">// 通道发生异常事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.fireExceptionCaught(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelOutboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(ChannelHandlerContext var1, SocketAddress var2, ChannelPromise var3)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当NioServerSocketChannel创建、初始化、注册到EventLoopGroup完成后，接下来就进行绑定，与本地</span><br><span class="hljs-comment">     * 端口进行绑定以便接收数据,绑定的工作通过代码分析发现最后调用的是 AbstractBootstrap#doBind0方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(ChannelHandlerContext var1, SocketAddress var2, SocketAddress var3, ChannelPromise var4)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>   <span class="hljs-comment">// 当请求将 Channel 连接到远程节点时被调用</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">disconnect</span><span class="hljs-params">(ChannelHandlerContext var1, ChannelPromise var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">// 当请求关闭 Channel 时被调用</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ChannelHandlerContext var1, ChannelPromise var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">// 当请求将 Channel 从远程节点断开时被调用</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deregister</span><span class="hljs-params">(ChannelHandlerContext var1, ChannelPromise var2)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">// 当请求从 Channel 读取更多的数据时被调用</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">// 当请求通过 Channel 将数据写到远程节点时被调用</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext var1, Object var2, ChannelPromise var3)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-comment">// 当请求通过 Channel 将入队数据冲刷到远程节点时被调</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(ChannelHandlerContext var1)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="出站和入站机制"><a class="markdownIt-Anchor" href="#出站和入站机制"></a> 出站和入站机制</h4><br><h3 id="channelpipeline"><a class="markdownIt-Anchor" href="#channelpipeline"></a> ChannelPipeline</h3><blockquote><p><img src="/2022/05/25/netty/ChannelPipeline.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/ChannelPipeline%E8%BF%90%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span><br><br>             <span class="hljs-comment">//给pipeline 设置处理器,可以设置多个，是个双向链表</span><br>             <span class="hljs-meta">@Override</span><br>             <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                 System.out.println(<span class="hljs-string">&quot;client socketChannel hashCode = &quot;</span> + socketChannel.hashCode());<br>                 socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>             &#125;<br>         &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>ChannelPipeline 是一个 Handler 的集合（双向链表）</strong>，它负责处理和拦截 inbound（入站） 或者 outbound（出栈） 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解： ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站 和出站 事件 / 操作)</li><li>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互</li><li>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应它们的组成关系如下</li></ul><p><img src="/2022/05/25/netty/%E5%85%A5%E7%AB%99%E5%92%8C%E5%87%BA%E7%AB%992.png" srcset="/img/loading.gif" lazyload alt></p><br><p><strong>入站和出站</strong></p><p><img src="/2022/05/25/netty/%E5%85%A5%E7%AB%99%E5%92%8C%E5%87%BA%E7%AB%99.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong>入站</strong>：从<code>ChannelHandlerContext</code>链表的<code>head</code>调用到<code>tail</code></li><li><strong>出站</strong>：从<code>ChannelHandlerContext</code>链表的<code>tail</code>调用到<code>head</code></li></ul><p>说明：</p><ul><li><strong>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler</strong></li><li><strong>入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler， 出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</strong></li></ul></blockquote><br><h3 id="channelhandlercontext"><a class="markdownIt-Anchor" href="#channelhandlercontext"></a> ChannelHandlerContext</h3><blockquote><p><img src="/2022/05/25/netty/ChannelHandlerContext.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/ChannelHandlerContext%E8%BF%90%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>数据结构：<strong>双向链表, <code>AbstractChannelHandlerContext</code> 包含 <code>next</code> <code>prev</code></strong></li><li><strong>包含</strong><ul><li>Channel</li><li>ChannelHandler：<strong>ChannelHandlerContext和ChannelHandler是一一对应关系</strong></li><li>ChannelPipeline</li></ul></li></ul><p><img src="/2022/05/25/netty/%E5%85%A5%E7%AB%99%E5%92%8C%E5%87%BA%E7%AB%99.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong>入站</strong>：从<code>ChannelHandlerContext</code>链表的<code>head</code>调用到<code>tail</code></li><li><strong>出站</strong>：从<code>ChannelHandlerContext</code>链表的<code>tail</code>调用到<code>head</code></li></ul></blockquote><br><h3 id="buf"><a class="markdownIt-Anchor" href="#buf"></a> Buf</h3><blockquote><p><img src="/2022/05/25/netty/AbstractByteBuf.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/buf.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong>Netty 重新实现了体系，实现了读写操作不再需要<code>flip</code>操作</strong></li><li><strong>实现了同时读写功能</strong><ul><li><strong>capacity: buf容量</strong></li><li><strong>readerIndex：readerIndex -&gt; writerIndex 之间是可读性范围</strong></li><li><strong>writerIndex： writerIndex -&gt; capacity 之间是可写范围</strong></li></ul></li><li>Buf实现了<strong>自动扩容</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 非池化的Buf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">// 能够自动扩容</span><br>            buf.writeByte(i);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, buf.readByte());<br>        &#125;<br><br>        log.info(<span class="hljs-string">&quot;类型：&#123;&#125;&quot;</span>, buf.getClass());<br>        log.info(<span class="hljs-string">&quot;capacity = &#123;&#125;&quot;</span>, buf.capacity());<br>        log.info(<span class="hljs-string">&quot;readIndex = &#123;&#125;&quot;</span>, buf.readerIndex());<br>        log.info(<span class="hljs-string">&quot;writeIndex = &#123;&#125;&quot;</span>, buf.writerIndex());<br>        log.info(<span class="hljs-string">&quot;可读取的 = &#123;&#125;&quot;</span>, buf.readableBytes());<br>        <span class="hljs-comment">// 读取一部分 buf.getCharSequence(6, 2, Charset.forName(&quot;utf-8&quot;));</span><br>    &#125;<br>&#125;<br><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.787</span> [main] INFO com.wgf.netty.BufTest - <span class="hljs-number">0</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.790</span> [main] INFO com.wgf.netty.BufTest - <span class="hljs-number">1</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - <span class="hljs-number">2</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - <span class="hljs-number">3</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - <span class="hljs-number">4</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - 类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf<br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - capacity = <span class="hljs-number">128</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - readIndex = <span class="hljs-number">5</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - writeIndex = <span class="hljs-number">100</span><br><span class="hljs-number">02</span>:<span class="hljs-number">51</span>:<span class="hljs-number">58.791</span> [main] INFO com.wgf.netty.BufTest - 可读取的 = <span class="hljs-number">95</span><br></code></pre></td></tr></table></figure></blockquote><br><h4 id="bytebuf分类"><a class="markdownIt-Anchor" href="#bytebuf分类"></a> ByteBuf分类</h4><p>Netty使用ByteBuf对象作为数据容器，进行I/O读写操作，Netty的内存管理也是围绕着<strong>ByteBuf对象高效地分配和释放</strong></p><p>当讨论ByteBuf对象管理，主要从以下方面进行分类</p><br><h5 id="pooled-和-unpooled"><a class="markdownIt-Anchor" href="#pooled-和-unpooled"></a> Pooled 和 Unpooled</h5><ul><li>池化内存分配时基于预分配的一整块大内存，取其中的部分封装成ByteBuf提供使用，用完后回收到内存池中</li><li>非池化内存每次分配时直接调用系统 API 向操作系统申请ByteBuf需要的同样大小内存，用完后通过系统调用进行释放Pooled</li><li><strong>Netty4默认使用Pooled的方式，可通过参数-Dio.netty.allocator.type=unpooled或pooled进行设置</strong></li></ul><br><h5 id="heap-和-direct"><a class="markdownIt-Anchor" href="#heap-和-direct"></a> Heap 和 Direct</h5><ul><li>Heap，指ByteBuf关联的内存JVM堆内分配，分配的内存受GC 管理</li><li>Direct，指ByteBuf关联的内存在JVM堆外分配，分配的内存不受GC管理，需要通过系统调用实现申请和释放，底层基于Java NIO的DirectByteBuffer对象</li></ul><br><h2 id="http服务"><a class="markdownIt-Anchor" href="#http服务"></a> HTTP服务</h2><blockquote><ul><li><p><strong>使用Netty实现Http协议编解码，支持浏览器访问</strong></p></li><li><p><strong>熟悉Netty Http开发</strong></p></li><li><p>服务端</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                    .group(bossGroup, workGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerInitialize</span>());  <span class="hljs-comment">// 自定义 handler</span><br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>HttpServerInitialize</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServerInitialize</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 向管道加入处理器</span><br><br>        <span class="hljs-comment">// 得到管道</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br><br>        <span class="hljs-comment">// 加入一个Netty提供的 HttpServerCodec (http协议编解码器) codec =&gt; decoder</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerCodec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br><br>        <span class="hljs-comment">// 增加一个针对http协议的handler</span><br>        pipeline.addLast(<span class="hljs-string">&quot;MyHttpServerHandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerHandler</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>HttpServerHandler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter 的子类</span><br><span class="hljs-comment"> * 2. HttpObject 客户端和服务端相互通讯的数据对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 判断 msg 是否为 http 请求</span><br>        <span class="hljs-keyword">if</span> (httpObject <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;<br>            log.info(<span class="hljs-string">&quot;httpObject 类型：&#123;&#125;&quot;</span>, httpObject.getClass());<br>            log.info(<span class="hljs-string">&quot;客户端地址：&#123;&#125;&quot;</span>, channelHandlerContext.channel().remoteAddress());<br><br>            <span class="hljs-comment">// 回复客户端消息， 封装 httpResponse</span><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<span class="hljs-string">&quot;我是服务器&quot;</span>, CharsetUtil.UTF_8);<br>            <span class="hljs-type">FullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf);<br><br>            <span class="hljs-comment">// 设置响应头</span><br>            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;application/json&quot;</span>)<br>                    .set(HttpHeaderNames.CONTENT_LENGTH, byteBuf.readableBytes());<br><br>            <span class="hljs-comment">// 将构建好的response 返回</span><br>            channelHandlerContext.channel().writeAndFlush(response);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">浏览器访问 http:<span class="hljs-comment">//localhost:8080/</span><br>服务端输出：<br>09:<span class="hljs-number">10</span>:<span class="hljs-number">11.402</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - httpObject 类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.handler.codec.http.DefaultHttpRequest<br>09:<span class="hljs-number">10</span>:<span class="hljs-number">11.402</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - 客户端地址：/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">49999</span><br>09:<span class="hljs-number">10</span>:<span class="hljs-number">11.419</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - httpObject 类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.handler.codec.http.DefaultHttpRequest<br>09:<span class="hljs-number">10</span>:<span class="hljs-number">11.419</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - 客户端地址：/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">49999</span><br></code></pre></td></tr></table></figure><br><p><strong>可以看到服务端连续输出两次有BUG, 打印请求信息，优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, HttpObject httpObject)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 判断 msg 是否为 http 请求</span><br>        <span class="hljs-keyword">if</span> (httpObject <span class="hljs-keyword">instanceof</span> HttpRequest) &#123;<br>            log.info(<span class="hljs-string">&quot;httpObject 类型：&#123;&#125;&quot;</span>, httpObject.getClass());<br>            log.info(<span class="hljs-string">&quot;客户端地址：&#123;&#125;&quot;</span>, channelHandlerContext.channel().remoteAddress());<br><br>            <span class="hljs-comment">// 打印请求链接</span><br>            <span class="hljs-comment">// /</span><br>            <span class="hljs-comment">// /favicon.ico 请求网络图标</span><br>            <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> (HttpRequest) httpObject;<br>            <span class="hljs-type">URI</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(httpRequest.uri());<br>            log.info(uri.getPath());<br><br>            <span class="hljs-comment">// 过滤http请求</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;<br>                log.info(<span class="hljs-string">&quot;过滤图标请求&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 打印每次请求信息</span><br>            <span class="hljs-comment">// http 属于短链接，浏览器每次刷新都会创建一个新的 channel -&gt; pipeline -&gt; handler,</span><br>            <span class="hljs-comment">// 所以 channel -&gt; pipeline -&gt; handler 三者是连接独享关系</span><br>            log.info(<span class="hljs-string">&quot;channel class: &#123;&#125;, hashCode: &#123;&#125;&quot;</span>, channelHandlerContext.channel().getClass(),<br>                    channelHandlerContext.channel().hashCode());<br>            log.info(<span class="hljs-string">&quot;pipeline class: &#123;&#125;, pipeline: &#123;&#125;&quot;</span>, channelHandlerContext.pipeline().getClass(),<br>                    channelHandlerContext.pipeline().hashCode());<br>            log.info(<span class="hljs-string">&quot;handler class: &#123;&#125;, handler: &#123;&#125;&quot;</span>, channelHandlerContext.handler().getClass(),<br>                    channelHandlerContext.handler().hashCode());<br><br>            <span class="hljs-comment">// 回复客户端消息， 封装 httpResponse</span><br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<span class="hljs-string">&quot;我是服务器&quot;</span>, CharsetUtil.UTF_8);<br>            <span class="hljs-type">FullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf);<br><br>            <span class="hljs-comment">// 设置响应头</span><br>            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;application/json&quot;</span>)<br>                    .set(HttpHeaderNames.CONTENT_LENGTH, byteBuf.readableBytes());<br><br>            <span class="hljs-comment">// 将构建好的response 返回</span><br>            channelHandlerContext.channel().writeAndFlush(response);<br>        &#125;<br>    &#125;<br>&#125;<br><br>刷新两次浏览器<br>服务端输出：<br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.346</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - 客户端地址：/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">65232</span><br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.346</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - /<br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.347</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - channel class: <span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.channel.socket.nio.NioSocketChannel, hashCode: -<span class="hljs-number">817620801</span><br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.347</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - pipeline class: <span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.channel.DefaultChannelPipeline, pipeline: <span class="hljs-number">930529060</span><br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.347</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - handler class: <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.wgf.http.HttpServerHandler, handler: <span class="hljs-number">1652365183</span><br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.366</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - httpObject 类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.handler.codec.http.DefaultHttpRequest<br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.366</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - 客户端地址：/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">65232</span><br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.366</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - /favicon.ico<br><span class="hljs-number">10</span>:<span class="hljs-number">59</span>:<span class="hljs-number">53.366</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] INFO com.wgf.http.HttpServerHandler - 过滤图标请求<br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.945</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - httpObject 类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.handler.codec.http.DefaultHttpRequest<br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.945</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - 客户端地址：/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">65276</span><br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.945</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - /<br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.945</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - channel class: <span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.channel.socket.nio.NioSocketChannel, hashCode: <span class="hljs-number">1632808762</span><br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.945</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - pipeline class: <span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.channel.DefaultChannelPipeline, pipeline: <span class="hljs-number">958372783</span><br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.945</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - handler class: <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.wgf.http.HttpServerHandler, handler: <span class="hljs-number">2082276072</span><br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.962</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - httpObject 类型：<span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.handler.codec.http.DefaultHttpRequest<br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.962</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - 客户端地址：/<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">65276</span><br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.962</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - /favicon.ico<br><span class="hljs-number">11</span>:<span class="hljs-number">00</span>:<span class="hljs-number">38.962</span> [nioEventLoopGroup-<span class="hljs-number">3</span>-<span class="hljs-number">2</span>] INFO com.wgf.http.HttpServerHandler - 过滤图标请求<br></code></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><ul><li><p><strong>两次请求是因为有个图标请求<code>/favicon.ico</code></strong></p></li><li><p><strong>http属于段连接，每次刷新都会建立一个新的连接</strong></p></li><li><p><strong><code>channel</code> , <code>pipeline</code> , <code>handler</code> 三者都是连接独享，非共享的对象</strong></p></li></ul></blockquote></blockquote><br><h2 id="多人聊天室"><a class="markdownIt-Anchor" href="#多人聊天室"></a> 多人聊天室</h2><blockquote><ul><li><strong>熟悉 ChannelHandler API使用</strong></li><li><strong>熟悉 ChannelGroup 使用</strong></li><li><strong>了解 Netty 心跳机制 IdleStateHandler(空闲状态处理器)</strong></li></ul><p><strong>服务端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChatServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建bossGroup,workGroup</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">8</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建启动器</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.group(bossGroup, workGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO)) <span class="hljs-comment">// 添加日志打印</span><br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHandler</span>());<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(port).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 优雅停机</span><br>            bossGroup.shutdownGracefully();<br>            workGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatServer</span>(<span class="hljs-number">9999</span>).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 加入编解码器</span><br>        ch.pipeline().addLast(<span class="hljs-string">&quot;decode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>())<br>                .addLast(<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>())<br>                .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerChatHandler</span>());          <span class="hljs-comment">// 加入业务处理Handler</span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 说明：</span><br><span class="hljs-comment">         *   1. IdleStateHandler 是 Netty 提供的 空闲状态处理器</span><br><span class="hljs-comment">         *   2. 四个参数：</span><br><span class="hljs-comment">         *      readerIdleTime : 表示多久没有 读 事件后，就会发送一个心跳检测包，检测是否还是连接状态</span><br><span class="hljs-comment">         *      writerIdleTime : 表示多久没有 写 事件后，就会发送一个心跳检测包，检测是否还是连接状态</span><br><span class="hljs-comment">         *      allIdleTime : 表示多久时间既没读也没写 后，就会发送一个心跳检测包，检测是否还是连接状态</span><br><span class="hljs-comment">         *      TimeUnit : 时间单位</span><br><span class="hljs-comment">         *   3. 当 Channel 一段时间内没有执行 读 / 写 / 读写 事件后，就会触发一个 IdleStateEvent 空闲状态事件</span><br><span class="hljs-comment">         *   4. 当 IdleStateEvent 触发后，就会传递给 Pipeline 中的下一个 Handler 去处理，通过回调下一个 Handler 的 userEventTriggered 方法，在该方法中处理 IdleStateEvent</span><br><span class="hljs-comment">         */</span><br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>, TimeUnit.SECONDS))<br>                .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHeartbeatHandler</span>()); <span class="hljs-comment">// 添加一个Handler 处理空闲状态事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息处理</span><br><span class="hljs-comment"> * SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter的子类</span><br><span class="hljs-comment"> * 配合编码解码器，可以范型消息类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerChatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义一个 Channel 线程组，管理所有的 Channel, channel断开连接会自动删除, 参数 执行器</span><br><span class="hljs-comment">     * GlobalEventExecutor =&gt; 全局事件执行器</span><br><span class="hljs-comment">     * INSTANCE =&gt; 表示是单例的</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelGroup</span> <span class="hljs-variable">channelGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);<br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-comment">// 在ChannelHandler被添加到实际上下文中并准备好处理事件后调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 提示聊天室所有人有新用户上线</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        <span class="hljs-comment">// 向整个ChannelGroup发送消息</span><br>        channelGroup.writeAndFlush(String.format(<span class="hljs-string">&quot;%s [channel %s] 加入聊天&quot;</span>, simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), channel.remoteAddress()));<br>        channelGroup.add(channel);<br>    &#125;<br><br>    <span class="hljs-comment">// 在ChannelHandler从实际上下文中移除后调用，表明它不再处理事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        channelGroup.writeAndFlush(String.format(<span class="hljs-string">&quot;%s [channel %s] 离开聊天&quot;</span>, simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), channel.remoteAddress()));<br>        <span class="hljs-comment">// channelGroup.remove(channel); 不需要，handlerRemoved（）直接删除了channel</span><br>    &#125;<br><br>    <span class="hljs-comment">// Channel不活跃的时候，调用，此时生命周期马上结束</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; [channel &#123;&#125;] 下线了&quot;</span>, simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">// Channel活跃的时候，调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; [channel &#123;&#125;] 上线了&quot;</span>, simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-comment">// 读取事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br>        <span class="hljs-comment">// 读取客户端发送的数据，发送给其他人包括自己</span><br>        channelGroup.forEach(ch -&gt; &#123;<br>            <span class="hljs-comment">// 判断是否为自己</span><br>            <span class="hljs-keyword">if</span> (ch.equals(channel)) &#123;<br>                ch.writeAndFlush(String.format(<span class="hljs-string">&quot;%s [自己]: %s\n&quot;</span>, date, msg));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ch.writeAndFlush(String.format(<span class="hljs-string">&quot;%s [%s]: %s\n&quot;</span>, date, channel.remoteAddress(), msg));<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerHeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">// 用户事件触发，处理IdleStateHandler触发的用户事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 判断是否空闲状态事件</span><br>        <span class="hljs-keyword">if</span> (!(evt <span class="hljs-keyword">instanceof</span> IdleStateEvent)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">idleStateEvent</span> <span class="hljs-operator">=</span> (IdleStateEvent) evt;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">evtType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (idleStateEvent.state()) &#123;<br>            <span class="hljs-keyword">case</span> READER_IDLE:<br>                evtType = <span class="hljs-string">&quot;读空闲&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> WRITER_IDLE:<br>                evtType = <span class="hljs-string">&quot;写空闲&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ALL_IDLE:<br>                evtType = <span class="hljs-string">&quot;读写空闲&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> ctx.channel();<br><br>        log.info(<span class="hljs-string">&quot;[channel: &#123;&#125; &#123;&#125;]&quot;</span>, channel.remoteAddress(), evtType);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatClient</span> &#123;<br>    <span class="hljs-keyword">private</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChatClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">nioEventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.group(nioEventLoopGroup)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientHandler</span>());<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(host, port).sync();<br><br>            <span class="hljs-comment">// 得到当前建立的Channel</span><br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>            <span class="hljs-comment">// 扫描用户输入</span><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>                channel.writeAndFlush(msg);<br>            &#125;<br><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            nioEventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatClient</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ch.pipeline().addLast(<span class="hljs-string">&quot;decode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDecoder</span>())<br>                .addLast(<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>())<br>                .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientChatHandler</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientChatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 直接输入服务端返回的消息</span><br>        log.info(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h3 id="channelgroup"><a class="markdownIt-Anchor" href="#channelgroup"></a> ChannelGroup</h3><blockquote><ul><li>Netty提供了<code>ChannelGroup</code>来用于保存<code>Channel组</code>，<code>ChannelGroup</code>是一个线程安全的<code>Channel</code>集合，<strong>它提供一些对<code>Channel</code>的批量操作。当一个TCP连接关闭后，对应的Channel会自动从ChannelGroup移除，所以不需要手动去移除关闭的Channel</strong></li><li>当有新的客户端连接到服务器，将对应的<code>Channel</code>加入到一个<code>ChannelGroup</code>中，当发布者发布消息时，服务器可以将消息通过<code>ChannelGroup</code>写入到所有客户端</li></ul></blockquote><br><h3 id="心跳机制"><a class="markdownIt-Anchor" href="#心跳机制"></a> 心跳机制</h3><blockquote><p><strong>什么是 IdleStateHandler ?</strong></p><p>​	当连接的空闲时间（读或者写）太长时，将会触发一个 IdleStateEvent 事件。然后，你可以通过你的 ChannelInboundHandler 中重写 userEventTrigged 方法来处理该事件</p><br><p><strong>如何使用？</strong></p><ul><li><p>IdleStateHandler 既是出站处理器也是入站处理器，继承了 ChannelDuplexHandler 。通常在 initChannel 方法中将 IdleStateHandler 添加到 pipeline 中。然后在自己的 handler 中重写 userEventTriggered 方法，当发生空闲事件（读或者写），就会触发这个方法，并传入具体事件</p></li><li><p>这时，你可以通过 Context 对象尝试向目标 Socekt 写入数据，并设置一个 监听器，如果发送失败就关闭 Socket （Netty 准备了一个 <code>ChannelFutureListener.CLOSE_ON_FAILURE</code> 监听器用来实现关闭 Socket 逻辑）</p></li></ul><br><p><strong>说明：</strong></p><ul><li><p>IdleStateHandler 是 Netty 提供的 空闲状态处理器</p></li><li><p>四个参数：</p><ul><li>readerIdleTime : 表示多久没有 读 事件后，就会发送一个心跳检测包，检测是否还是连接状态</li><li>writerIdleTime : 表示多久没有 写 事件后，就会发送一个心跳检测包，检测是否还是连接状态</li><li>allIdleTime : 表示多久时间既没读也没写 后，就会发送一个心跳检测包，检测是否还是连接状态</li><li>TimeUnit : 时间单位</li></ul></li><li><p>当 Channel 一段时间内没有执行 读 / 写 / 读写 事件后，就会触发一个 IdleStateEvent 空闲状态事件</p></li><li><p>当 IdleStateEvent 触发后，就会传递给 Pipeline 中的下一个 Handler 去处理，通过回调下一个 Handler 的 userEventTriggered 方法，在该方法中处理 IdleStateEvent</p></li></ul></blockquote><br><br><h2 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h2><blockquote><ul><li><p>实现基于webSocket的长连接 的全双工的交互</p></li><li><p>改变Http协议多次请求的约束，实现长连接了， 服务器可以发送消息 给浏览器</p></li><li><p>客户端浏览器和服务器端会相互感 知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</p></li></ul><br><p><strong>服务端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//创建bossGroup,workGroup</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建启动器</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">//循环事件组</span><br>            serverBootstrap.group(bossGroup, workGroup)<span class="hljs-comment">//线程组</span><br>                    .channel(NioServerSocketChannel.class)<span class="hljs-comment">//通道类型</span><br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHandler</span>());<br>            System.out.println(<span class="hljs-string">&quot;server is ok&quot;</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>        <span class="hljs-comment">//基于http协议使用http的编码和解码器</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 添加块处理器</span><br><span class="hljs-comment">         * 在需要将数据从文件系统复制到用户内存中时，可以使用 ChunkedWriteHandler，</span><br><span class="hljs-comment">         * 它支持异步写大型数据流，而又不会导致大量的内存消耗</span><br><span class="hljs-comment">         * 每次只生成固定大小的数据块，防止客户端因为网速接收慢而导致服务端无限将数据写入内存</span><br><span class="hljs-comment">         */</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChunkedWriteHandler</span>());<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            说明：</span><br><span class="hljs-comment">            1. 因为 HTTP 数据传输时是分段的，HttpObjectAggregator 可以将多个端聚合</span><br><span class="hljs-comment">            2. 这就是为什么浏览器发送大量数据时，就会发出多次 HTTP 请求</span><br><span class="hljs-comment">         */</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpObjectAggregator</span>(<span class="hljs-number">8192</span>));<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            说明：</span><br><span class="hljs-comment">            1. 对于 WebSocket 是以 帧(frame) 的形式传递的</span><br><span class="hljs-comment">            2. 后面的参数表示 ：请求的 URL</span><br><span class="hljs-comment">            3. WebSocketServerProtocolHandler 将 HTTP 协议升级为 WebSocket 协议，即保持长连接</span><br><span class="hljs-comment">            4. 切换协议通过一个状态码101</span><br><span class="hljs-comment">         */</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServerProtocolHandler</span>(<span class="hljs-string">&quot;/hello&quot;</span>));<br>        <span class="hljs-comment">// 自定义的 Handler</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWebSocketFrameHandler</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> msg.text();<br>        log.info(<span class="hljs-string">&quot;服务器收到消息：&#123;&#125;&quot;</span>, message);<br><br>        <span class="hljs-comment">// 回复消息</span><br>        ctx.channel().writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWebSocketFrame</span>(String.format(<span class="hljs-string">&quot;%s 服务器收到消息：%s&quot;</span>, LocalDateTime.now(), message)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 客户端连接后，触发方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// longText 保证全局唯一</span><br>        log.info(<span class="hljs-string">&quot;handlerAdded 被调用：&#123;&#125;&quot;</span>, ctx.channel().id().asLongText());<br><br>        <span class="hljs-comment">// shortText 不保证全局唯一</span><br>        log.info(<span class="hljs-string">&quot;handlerAdded 被调用：&#123;&#125;&quot;</span>, ctx.channel().id().asShortText());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// longText 保证全局唯一</span><br>        log.info(<span class="hljs-string">&quot;handlerRemoved 被调用：&#123;&#125;&quot;</span>, ctx.channel().id().asLongText());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.error(<span class="hljs-string">&quot;发生异常&quot;</span>, cause);<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>客户端</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;发送消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;responseText&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;清空内容&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> socket;</span><br><span class="language-javascript">    <span class="hljs-comment">// 判断当前浏览器是否支持 WebSocket</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">WebSocket</span>)&#123;</span><br><span class="language-javascript">        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080/hello&quot;</span>);</span><br><span class="language-javascript">        <span class="hljs-comment">// 相当于 channelRead0 方法，ev 收到服务器端回送的消息</span></span><br><span class="language-javascript">        socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> rt = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;responseText&quot;</span>);</span><br><span class="language-javascript">            rt.<span class="hljs-property">value</span> = rt.<span class="hljs-property">value</span> + <span class="hljs-string">&quot;\n&quot;</span> + ev.<span class="hljs-property">data</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// 相当于连接开启，感知到连接开启</span></span><br><span class="language-javascript">        socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> rt = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;responseText&quot;</span>);</span><br><span class="language-javascript">            rt.<span class="hljs-property">value</span> = rt.<span class="hljs-property">value</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;连接开启……&quot;</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// 感知连接关闭</span></span><br><span class="language-javascript">        socket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> rt = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;responseText&quot;</span>);</span><br><span class="language-javascript">            rt.<span class="hljs-property">value</span> = rt.<span class="hljs-property">value</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;连接关闭……&quot;</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;不支持 WebSocket&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 发送消息到服务器</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">message</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 判断 WebSocket 是否创建好了</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">socket</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> ;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// 判断 WebSocket 是否开启</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (socket.<span class="hljs-property">readyState</span> == <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 通过 Socket 发送消息</span></span><br><span class="language-javascript">            socket.<span class="hljs-title function_">send</span>(message);</span><br><span class="language-javascript">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;连接未开启&quot;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure></blockquote><br><br><h2 id="编码和解码"><a class="markdownIt-Anchor" href="#编码和解码"></a> 编码和解码</h2><blockquote><p><img src="/2022/05/25/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>编码和解码的基本介绍</strong></p><ul><li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码</li><li>codec（编码器）的组成部分有两个：decoder（解码器）和encoder（编码器）。encoder负责把业务数据缓存字节码数据，decoder负责把字节码数据转换成业务数据</li></ul><br><p><strong>Netty本身的编码解码的机制和问题分析</strong></p><ul><li><strong>Netty提供的编码器</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelHandlerAdapter (io.netty.channel)<br>    ChannelOutboundHandlerAdapter (io.netty.channel)<br>        MessageToMessageEncoder (io.netty.handler.codec)<br>            ByteArrayEncoder (io.netty.handler.codec.bytes)<br>            DatagramDnsQueryEncoder (io.netty.handler.codec.dns)<br>            WebSocket08FrameEncoder (io.netty.handler.codec.http.websocketx)<br>                WebSocket07FrameEncoder (io.netty.handler.codec.http.websocketx)<br>                WebSocket13FrameEncoder (io.netty.handler.codec.http.websocketx)<br>            DatagramDnsResponseEncoder (io.netty.handler.codec.dns)<br>            SctpOutboundByteStreamHandler (io.netty.handler.codec.sctp)<br>            SpdyHttpEncoder (io.netty.handler.codec.spdy)<br>            WebSocketExtensionEncoder (io.netty.handler.codec.http.websocketx.extensions)<br>                DeflateEncoder (io.netty.handler.codec.http.websocketx.extensions.compression)<br>            RedisEncoder (io.netty.handler.codec.redis)<br>            LineEncoder (io.netty.handler.codec.string)<br>            ProtobufEncoderNano (io.netty.handler.codec.protobuf)<br>            StringEncoder (io.netty.handler.codec.string)<br>            SmtpRequestEncoder (io.netty.handler.codec.smtp)<br>            WebSocket00FrameEncoder (io.netty.handler.codec.http.websocketx)<br>            ProtobufEncoder (io.netty.handler.codec.protobuf)<br>            MqttEncoder (io.netty.handler.codec.mqtt)<br>            HttpObjectEncoder (io.netty.handler.codec.http)<br>                HttpRequestEncoder (io.netty.handler.codec.http)<br>                    Encoder in <span class="hljs-title function_">HttpClientCodec</span> <span class="hljs-params">(io.netty.handler.codec.http)</span><br>                HttpResponseEncoder (io.netty.handler.codec.http)<br>                    HttpServerResponseEncoder in <span class="hljs-title function_">HttpServerCodec</span> <span class="hljs-params">(io.netty.handler.codec.http)</span><br>                RtspObjectEncoder (io.netty.handler.codec.rtsp)<br>                RtspEncoder (io.netty.handler.codec.rtsp)<br>                    RtspRequestEncoder (io.netty.handler.codec.rtsp)<br>                    RtspResponseEncoder (io.netty.handler.codec.rtsp)<br>            DatagramPacketEncoder (io.netty.handler.codec)<br>            AbstractMemcacheObjectEncoder (io.netty.handler.codec.memcache)<br>                AbstractBinaryMemcacheEncoder (io.netty.handler.codec.memcache.binary)<br>            StompSubframeEncoder (io.netty.handler.codec.stomp)<br>            LengthFieldPrepender (io.netty.handler.codec)<br>            Base64Encoder (io.netty.handler.codec.base64)<br>            ...<br></code></pre></td></tr></table></figure><ul><li><strong>Netty提供的解码器</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">ChannelHandlerAdapter (io.netty.channel)<br>    ChannelInboundHandlerAdapter (io.netty.channel)<br>        MessageToMessageDecoder (io.netty.handler.codec)<br>            SctpInboundByteStreamHandler (io.netty.handler.codec.sctp)<br>            SctpMessageCompletionHandler (io.netty.handler.codec.sctp)<br>            Base64Decoder (io.netty.handler.codec.base64)<br>            DatagramDnsQueryDecoder (io.netty.handler.codec.dns)<br>            WebSocketExtensionDecoder (io.netty.handler.codec.http.websocketx.extensions)<br>                DeflateDecoder (io.netty.handler.codec.http.websocketx.extensions.compression)<br>            RedisArrayAggregator (io.netty.handler.codec.redis)<br>            SpdyHttpDecoder (io.netty.handler.codec.spdy)<br>            ProtobufDecoder (io.netty.handler.codec.protobuf)<br>            HttpContentDecoder (io.netty.handler.codec.http)<br>                HttpContentDecompressor (io.netty.handler.codec.http)<br>            DatagramPacketDecoder (io.netty.handler.codec)<br>            SctpMessageToMessageDecoder (io.netty.handler.codec.sctp)<br>            StringDecoder (io.netty.handler.codec.string)<br>            WebSocketProtocolHandler (io.netty.handler.codec.http.websocketx)<br>                WebSocketClientProtocolHandler (io.netty.handler.codec.http.websocketx)<br>                WebSocketServerProtocolHandler (io.netty.handler.codec.http.websocketx)<br>            DatagramDnsResponseDecoder (io.netty.handler.codec.dns)<br>            ByteArrayDecoder (io.netty.handler.codec.bytes)<br>            MessageAggregator (io.netty.handler.codec)<br>                WebSocketFrameAggregator (io.netty.handler.codec.http.websocketx)<br>                AbstractMemcacheObjectAggregator (io.netty.handler.codec.memcache)<br>                StompSubframeAggregator (io.netty.handler.codec.stomp)<br>                RedisBulkStringAggregator (io.netty.handler.codec.redis)<br>                HttpObjectAggregator (io.netty.handler.codec.http)<br>            ProtobufDecoderNano (io.netty.handler.codec.protobuf)<br>            ...<br></code></pre></td></tr></table></figure><br><ul><li>Netty本身自带的ObjectDecoder和ObjectEncoder可以用实现POJO对象或业务对象的编码和解码，底层使用的仍然是Java序列化技术，而Java序列化技术本身效率就不高，存在如下问题:<ul><li>无法跨语言</li><li>序列化后体积太大，是二进制编码的5倍多</li><li>序列化后传输效率太低</li><li>序列化性能太低</li></ul></li><li><strong>解决方案：</strong><code>Google ProtoBuf</code></li></ul></blockquote><br><h3 id="protobuf"><a class="markdownIt-Anchor" href="#protobuf"></a> ProtoBuf</h3><blockquote><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/javatutorial">官方文档</a></p><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">数据类型</a></p><p><strong>1.ProtoBuf 简介</strong></p><p>​	<code>protobuf</code> (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，<strong>用于通讯协议、数据存储等领域的<code>语言无关</code>、<code>平台无关</code>、<code>可扩展</code>的序列化结构数据格式</strong></p><br><p><strong>2.为什么使用protobuf</strong></p><p>​	我们知道数据在网络传输中是以二进制进行的，一般我们使用字节byte来表示， 一个byte是8bits，如果要在网络上中传输对象，一般需要将对象序列化，序列化的目的就是将对象转换成byte数组在网络中传输，当接收方接收到byte数组之后，再对byte数组进行反序列化，最终转换成java中的对象</p><p><strong>java对象序列化 常见的方式</strong></p><ul><li>使用JDK自带的对象序列化，但是JDK自带的序列化本身存在一些问题，并且这种序列化手段只适合在java程序之间进行传输，如果是非java程序，比如PHP或者GO，那么序列化就不通用了</li><li>你还可以自定义序列化协议，这种方式的灵活程度比较高，但是不够通用，并且实现起来也比较复杂，很可能出现意想不到的问题</li><li>将数据转换成为XML或者JSON进行传输。XML和JSON的好处在于他们都有可以区分对象的起始符号，通过判断这些符号的位置就可以读取到完整的对象。但是不管是XML还是JSON的缺点都是转换成的数据比较大。在反序列化的时候对资源的消耗也比较多</li></ul><p>所以我们需要一种新的序列化的方法，这就是protobuf，它是一种灵活、高效、自动化的解决方案</p><p>​	通过编写一个.proto的数据结构定义文件，然后调用protobuf的编译器，就会生成对应的类，该类以高效的二进制格式实现protobuf数据的自动编码和解析。 生成的类为定义文件中的数据字段提供了getter和setter方法，并提供了读写的处理细节。 重要的是，protobuf可以向前兼容，也就是说老的二进制代码也可以使用最新的协议进行读取</p></blockquote><br><h4 id="message-介绍"><a class="markdownIt-Anchor" href="#message-介绍"></a> message 介绍</h4><blockquote><p><code>message</code>：<code>protobuf</code>中定义一个消息类型是通过关键字<code>message</code>字段指定的，这个关键字类似于C++/Java中的class关键字。使用protobuf编译器将<code>proto</code>编译成Java代码之后，每个<code>message</code>都会生成一个名字与之对应的Java类，该类公开继承自<code>com.google.protobuf.Message</code></p></blockquote><br><h4 id="message-消息定义"><a class="markdownIt-Anchor" href="#message-消息定义"></a> <strong>message 消息定义</strong></h4><blockquote><p><strong>Msg.proto 文件</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>; <span class="hljs-comment">// 协议版本</span><br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;NettyMsg&quot;</span>; <span class="hljs-comment">// 生成的外部类名，同时也是文件名</span><br><br><span class="hljs-comment">// proto 使用 message 管理数据， 会在 NettyMsg 下生成一个内部类</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Msg</span> &#123;<br><span class="hljs-type">int32</span> id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 类似java对象定义属性，1 表示的是属性的序号，不是属性的值</span><br><span class="hljs-type">string</span> msg = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><br><h4 id="example"><a class="markdownIt-Anchor" href="#example"></a> example</h4><blockquote><ul><li><p>添加 Maven 坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.21.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">下载Protobuf3</a></p></li><li><p>将<code>Msg.proto</code>文件拷贝到 Protobuf3 bin 目录下</p></li><li><p>执行命令 <code>protoc.exe --java_out=. Msg.proto</code> 生成 <a href="NettyMsg.java">NettyMsg.java</a></p></li></ul><br><p><strong>服务端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            bootstrap.group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>            .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span><br><br>                <span class="hljs-comment">//给pipeline 设置处理器</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br><br>                    <span class="hljs-comment">// 添加ProtoBuf解码器, 指定对哪种对象进行节码</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufDecoder</span>(NettyMsg.Msg.getDefaultInstance()));<br><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                &#125;<br>            &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;server is ready&quot;</span>);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;NettyMsg.Msg&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, NettyMsg.Msg msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;消息id：&#123;&#125;&quot;</span>, msg.getId());<br>        log.info(<span class="hljs-string">&quot;消息：&#123;&#125;&quot;</span>, msg.getMsg());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>客户端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 客户端需要一个时间循环组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建客户端启动对象</span><br>            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>            bootstrap.group(eventLoopGroup)<br>                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span><br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>                            <span class="hljs-comment">// 设置ProtoBuf编码器</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufEncoder</span>());<br>                            <span class="hljs-comment">// 给pipeline 设置处理器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">// 对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 优雅停机</span><br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">// 当通道准备就绪就会触发该方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 发送一个Msg对象到服务端</span><br>        <span class="hljs-keyword">final</span> NettyMsg.<span class="hljs-type">Msg</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> NettyMsg.Msg.newBuilder().setId(<span class="hljs-number">1</span>).setMsg(<span class="hljs-string">&quot;hi! 服务端~&quot;</span>).build();<br>        ctx.writeAndFlush(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/protobuf.png" srcset="/img/loading.gif" lazyload alt></p></blockquote><br><h4 id="protobuf-传输多种类型"><a class="markdownIt-Anchor" href="#protobuf-传输多种类型"></a> ProtoBuf 传输多种类型</h4><blockquote><p><strong>核心：</strong></p><ul><li><strong>枚举DataType的定义</strong></li><li><strong>oneof的使用</strong></li><li><strong>通过一个<code>message</code>管理多个<code>message</code></strong></li></ul><br><p><strong>MultiMsg.proto</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;  <span class="hljs-comment">// 指定协议版本</span><br><span class="hljs-keyword">option</span> optimize_for = SPEED;  <span class="hljs-comment">// 加快解析</span><br><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.wgf.protobuf&quot;</span>; <span class="hljs-comment">// 指定生成在哪个包下</span><br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;MultiMsg&quot;</span>; <span class="hljs-comment">// 外部类名</span><br><br><span class="hljs-comment">// ProtoBuf 可以使用 message 管理其他的message</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">MsgType</span> &#123;<br><br>  <span class="hljs-comment">// 定义一个枚举</span><br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">DataType</span> &#123;<br>      commonMsgType = <span class="hljs-number">0</span>; <span class="hljs-comment">// 在 ProtoBuf 要求Enum的编号从0开始</span><br>      customerMsgType = <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 定义一个属性来标识传的是哪一个枚举类型</span><br>  DataType data_type = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 表示枚举类型最多只能出现其中的一个，节省空间</span><br>  <span class="hljs-keyword">oneof</span> dataBody &#123;<br>      CommonMsg commonMsg = <span class="hljs-number">2</span>;<br>      CustomerMsg customerMsg = <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">CommonMsg</span> &#123;<br>  <span class="hljs-type">string</span> msg = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">CustomerMsg</span> &#123;<br>  <span class="hljs-type">string</span> msg = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> customerAddress = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>服务端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            bootstrap.group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>            .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span><br><br>                <span class="hljs-comment">//给pipeline 设置处理器</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> socketChannel.pipeline();<br><br>                    <span class="hljs-comment">// 添加ProtoBuf解码器, 指定对哪种对象进行节码， 多种类型使用一个message管理多个message</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufDecoder</span>(MultiMsg.MsgType.getDefaultInstance()));<br><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                &#125;<br>            &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;server is ready&quot;</span>);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;MultiMsg.MsgType&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, MultiMsg.MsgType msgType)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        MultiMsg.MsgType.<span class="hljs-type">DataType</span> <span class="hljs-variable">dataType</span> <span class="hljs-operator">=</span> msgType.getDataType();<br><br>        <span class="hljs-comment">// 判断接收的对象类型</span><br>        <span class="hljs-keyword">if</span> (MultiMsg.MsgType.DataType.commonMsgType == dataType) &#123;<br>            MultiMsg.<span class="hljs-type">CommonMsg</span> <span class="hljs-variable">commonMsg</span> <span class="hljs-operator">=</span> msgType.getCommonMsg();<br>            log.info(commonMsg.getMsg());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MultiMsg.MsgType.DataType.customerMsgType == dataType) &#123;<br>            MultiMsg.<span class="hljs-type">CustomerMsg</span> <span class="hljs-variable">customerMsg</span> <span class="hljs-operator">=</span> msgType.getCustomerMsg();<br>            log.info(customerMsg.getCustomerAddress());<br>            log.info(customerMsg.getMsg());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>客户端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 客户端需要一个时间循环组</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建客户端启动对象</span><br>            <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>            bootstrap.group(eventLoopGroup)<br>                    .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span><br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>                            <span class="hljs-comment">// 设置ProtoBuf编码器</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;encode&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtobufEncoder</span>());<br>                            <span class="hljs-comment">// 给pipeline 设置处理器</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">// 对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 优雅停机</span><br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-comment">// 当通道准备就绪就会触发该方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 发送一个Msg对象到服务端</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">final</span> MultiMsg.<span class="hljs-type">MsgType</span> <span class="hljs-variable">common</span> <span class="hljs-operator">=</span> MultiMsg.MsgType.newBuilder()<br>                    .setDataType(MultiMsg.MsgType.DataType.commonMsgType)<br>                    .setCommonMsg(MultiMsg.CommonMsg.newBuilder().setMsg(<span class="hljs-string">&quot;commonMsg ~~&quot;</span>).build())<br>                    .build();<br>            ctx.writeAndFlush(common);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">final</span> MultiMsg.<span class="hljs-type">MsgType</span> <span class="hljs-variable">custome</span> <span class="hljs-operator">=</span> MultiMsg.MsgType.newBuilder()<br>                    .setDataType(MultiMsg.MsgType.DataType.customerMsgType)<br>                    .setCustomerMsg(MultiMsg.CustomerMsg.newBuilder().setMsg(<span class="hljs-string">&quot;customer ~~&quot;</span>)<br>                            .setCustomerAddress(ctx.channel().remoteAddress().toString()).build())<br>                    .build();<br>            ctx.writeAndFlush(custome);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="maven-插件使用"><a class="markdownIt-Anchor" href="#maven-插件使用"></a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/icefox_zhaoyt/article/details/122459972">maven 插件使用</a></h4><br><h3 id="自定义编解码器"><a class="markdownIt-Anchor" href="#自定义编解码器"></a> 自定义编解码器</h3><blockquote><p><img src="/2022/05/25/netty/encoder.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/decoder.png" srcset="/img/loading.gif" lazyload alt></p><p>从类图上可知，编码和节码其实就是建立在入站和出站的Handler中的</p><p><strong>解码</strong>：入站时，数据是以二进制形式传递的，解码器就是在入站的Handler中将二进制数据转换为特定的数据格式</p><p><strong>编码</strong>：出站时，将特定的数据格式转换成二进制字节流后传输到网络间</p><br><p><img src="/2022/05/25/netty/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E8%B0%83%E7%94%A8.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>  <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>      bootstrap.group(bossGroup, workerGroup)<br>              .channel(NioServerSocketChannel.class)<br>              .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>              .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>              .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerHandler</span>());<br><br>      System.out.println(<span class="hljs-string">&quot;server is ready&quot;</span>);<br><br>      <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>      channelFuture.channel().closeFuture().sync();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>      bossGroup.shutdownGracefully();<br>      workerGroup.shutdownGracefully();<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br><br>  <span class="hljs-comment">// 加入自定义解码器</span><br>  pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyByteToLongDecoder</span>());<br><br>  <span class="hljs-comment">// 加入自定义编码器</span><br>  pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLongToByteEncoder</span>());<br><br>  <span class="hljs-comment">// 业务逻辑处理</span><br>  pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBusinessHandler</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerBusinessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;Long&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  log.info(<span class="hljs-string">&quot;读取客户端数据：&#123;&#125;&quot;</span>, msg);<br><br>  <span class="hljs-comment">// 回复客户端</span><br>  ctx.writeAndFlush(<span class="hljs-number">987654L</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>编解码器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLongToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span>&lt;Long&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  log.info(<span class="hljs-string">&quot;MyLongToByteEncoder encoder 被调用&quot;</span>);<br>  log.info(<span class="hljs-string">&quot;msg = &#123;&#125;&quot;</span>, msg);<br>  out.writeLong(msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyByteToLongDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteToMessageDecoder</span> &#123;<br><br><span class="hljs-comment">//上下文channelHandlerContext</span><br><span class="hljs-comment">//入站的ByteBuf</span><br><span class="hljs-comment">//List集合，将解码后的数据传给下一个handler</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  log.info(<span class="hljs-string">&quot;MyByteToLongDecoder被调用&quot;</span>);<br>  <span class="hljs-comment">//因为long8字节,8个字节，才能读取一个long</span><br>  <span class="hljs-keyword">if</span> (byteBuf.readableBytes() &gt;= <span class="hljs-number">8</span>) &#123;<br>      list.add(byteBuf.readLong());<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 客户端需要一个时间循环组</span><br>  <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>  <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//创建客户端启动对象</span><br>      <span class="hljs-comment">//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>      <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>      bootstrap.group(eventLoopGroup)<br>              .channel(NioSocketChannel.class) <span class="hljs-comment">// 设置客户端通道的实现类(反射)</span><br>              .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientHandler</span>());<br><br>      <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>      <span class="hljs-comment">// 对关闭通道进行监听</span><br>      channelFuture.channel().closeFuture().sync();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// 优雅停机</span><br>      eventLoopGroup.shutdownGracefully();<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>  <span class="hljs-comment">// 添加自定义解码器</span><br>  pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyByteToLongDecoder</span>());<br>  <span class="hljs-comment">// 添加自定义编码器</span><br>  pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLongToByteEncoder</span>());<br><br>  <span class="hljs-comment">// 业务逻辑处理</span><br>  pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientBusinessHandler</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientBusinessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;Long&gt; &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  log.info(<span class="hljs-string">&quot;服务端回复: &#123;&#125;&quot;</span>, msg);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  ctx.writeAndFlush(<span class="hljs-number">123456L</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/%E7%BC%96%E7%A0%81%E6%9C%8D%E5%8A%A1%E7%AB%AF.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/%E7%BC%96%E7%A0%81%E5%AE%A2%E6%88%B7%E7%AB%AF.png" srcset="/img/loading.gif" lazyload alt></p></blockquote><br><h4 id="问题1"><a class="markdownIt-Anchor" href="#问题1"></a> 问题1</h4><blockquote><p><strong>如果客户端自定义的<code>handler</code>发送的是下面这个代码，数据是16个字节，那么服务端的入解码器的<code>decode</code>方法会被调用几次?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-comment">// ctx.writeAndFlush(123456L);</span><br>    <span class="hljs-comment">// 一次性发送16字节，服务端规定每次大于等于8字节才读取</span><br>    ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;1234567890123456&quot;</span>, CharsetUtil.UTF_8));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/%E6%8B%86%E5%8C%85%E4%BC%A0%E8%BE%93.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>由图可见，一个16字节的消息被自定义解码器<code>MyByteToLongDecoder</code>进行两次读取，原因在于服务器只知道每次要大于8个字节才去读取数据，但是一条完整的数据有多长，不得而知，这就是<a href="#%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85">拆包现象</a></strong></p><ul><li>对于<code>decode</code>方法会根据接收到的数据，被调用多次，直到确定没有新的元素被添加到<code>list</code>或者是<code>ByteBuf</code>没有更多的可读字节为止</li><li><strong>如果<code>list</code>不为空，就会将<code>list</code>内容传递给下一个<code>ChannelInboundhandler</code>处理，该处理器的方法也会被调用多次</strong></li><li>这里&quot;<code>1234567890123456</code>&quot;是16个字节，所以服务端解码的时候<code>decode</code>会被调两次，每次解码出来的数据放到<code>list</code>里面，<code>list</code>的里数据传给自定义的<code>handler</code>进行处理</li></ul></blockquote><br><h4 id="问题2"><a class="markdownIt-Anchor" href="#问题2"></a> 问题2</h4><blockquote><p><img src="/2022/05/25/netty/%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%982.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>使用问题1的代码片段后，发现，客户端的出站编码<code>handler-》MyLongToByteEncoder</code>，没有被调用，怎么回事呢？</strong></p><ul><li>对于客户端的自定义<code>handler</code>的前一个<code>handler</code>是<code>MyLongToByteEncoder</code>，<code>MyLongToByteEncoder</code>父类<code>MessageToByteEncoder</code>有一个<code>write</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//判断数据是不是应该处理的类型，是的话调用encode方法，进行编码，不是，就不编码，直接write,然后交给前一个handler</span><br>        <span class="hljs-keyword">if</span> (acceptOutboundMessage(msg)) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">I</span> <span class="hljs-variable">cast</span> <span class="hljs-operator">=</span> (I) msg;<br>            buf = allocateBuffer(ctx, cast, preferDirect);<br>            <span class="hljs-keyword">try</span> &#123;<br>            	<span class="hljs-comment">//我们写子类的时候，重写了该方法</span><br>                encode(ctx, cast, buf);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ReferenceCountUtil.release(cast);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (buf.isReadable()) &#123;<br>                ctx.write(buf, promise);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                buf.release();<br>                ctx.write(Unpooled.EMPTY_BUFFER, promise);<br>            &#125;<br>            buf = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.write(msg, promise);<br>        &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%982%E8%BF%90%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>因此，我们编写的<code>Encoder</code>是要注意传入的数据类型和处理的数据类型一致</li></ul></blockquote><br><h4 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h4><blockquote><ul><li><strong>不论解码器handler 还是 编码器handler 即接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行</strong></li><li><strong>在解码器进行数据解码时，需要判断缓存区(ByteBuf)的数据是否足够 ，否则接收到的结果会期望结果可能不一致</strong></li></ul></blockquote><br><h4 id="其他常见的编解码器"><a class="markdownIt-Anchor" href="#其他常见的编解码器"></a> 其他常见的编解码器</h4><h5 id="replayingdecoder"><a class="markdownIt-Anchor" href="#replayingdecoder"></a> ReplayingDecoder</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;S&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteToMessageDecoder</span><br></code></pre></td></tr></table></figure><ul><li><code>ReplayingDecoder</code>扩展了<code>ByteToMessageDecoder</code>类，使用这个类，我们不必调用<code>readableBytes</code>()方法。参数<code>S</code>指定了用户状态管理的类型，其中<code>Void</code>代表不需要状态管理</li><li>应用实例：使用<code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyByteToLongDecoder2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;MyByteToLongDecoder2被调用&quot;</span>);<br>        <span class="hljs-comment">// 在ReplayingDecoder不需要判断数据是否足够读取，内部会进行处理判断</span><br>        list.add(byteBuf.readLong());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/ReplayingDecoder.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>测试</strong>：使用<code>MyByteToLongDecoder2</code> 替代之前的<code>MyByteToLongDecoder</code>，结果和之前的一样</p><br><p><strong>它有一些局限性:</strong></p><ul><li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个<code>UnsupportedOperationException</code></li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于<code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul><br><p><strong>其他解码器</strong></p><ul><li><strong>LineBasedFrameDecoder</strong>：这个类在Netty内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据</li><li><strong>DelimiterBasedFrameDecoder</strong>：使用自定义的特殊字符作为消息的分隔符</li><li><strong>HttpObjectDecoder</strong>：一个HTTP数据的解码器</li><li><strong>LengthFieldBasedFrameDecoder</strong>：通过指定长度来标识整包消息，这样就可以自动的处理粘包和拆包消息</li></ul></blockquote><br><h2 id="粘包和拆包"><a class="markdownIt-Anchor" href="#粘包和拆包"></a> 粘包和拆包</h2><blockquote><p><strong>什么是粘包和拆包？</strong></p><p>​	TCP是个<code>流</code>的协议，所谓<code>流</code>就是没有界限的一串数据，大家可以想想河里的水，他们是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分。所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也可能会把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包/拆包问题</p><p>​	由于TCP无消息保护边界，需要在接收端处理消息边界问题，也就是我们所说的粘包，拆包问题</p><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数不是确定的，故可能存在四种情况：</strong></p><ol><li>服务端分两次读取到两个独立的包，分别是<strong>D1</strong>和<strong>D2</strong>，没有粘包和拆包</li><li>服务端一次接受到两个数据包，<strong>D1</strong>和<strong>D1</strong>粘合在一起，被称为TCP粘包</li><li>服务端分两次接收到了两个数据包，第一次读取到了完成的<strong>D1</strong>包和<strong>D2</strong>包的部分内容，第二次读取到了<strong>D2</strong>包的剩余内容，这被称为TCP的拆包</li><li>服务端分两次接受到了两个数据包，第一次读取到了<strong>D1</strong>包的部分内容<strong>D1-1</strong>，第二次读取到了<strong>D1</strong>包的剩余内容<strong>D1-2</strong>和<strong>D2</strong>包的整包</li></ol></blockquote><br><h3 id="粘包例子"><a class="markdownIt-Anchor" href="#粘包例子"></a> 粘包例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            bootstrap.group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>            .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123; <span class="hljs-comment">//创建一个通道初始化对象(匿名对象)</span><br><br>                <span class="hljs-comment">//给pipeline 设置处理器</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">// 异常处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[msg.readableBytes()];<br>        msg.readBytes(buffer);<br><br>        <span class="hljs-comment">// 将buffer转成字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer, CharsetUtil.UTF_8);<br>        log.info(<span class="hljs-string">&quot;服务端接收到数据： &#123;&#125;&quot;</span>, message);<br>        log.info(<span class="hljs-string">&quot;服务端接收到数据的次数：&#123;&#125;&quot;</span>, ++count);<br><br>        <span class="hljs-comment">// 回复客户端</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="hljs-string">&quot;\r\n&quot;</span>, CharsetUtil.UTF_8);<br>        ctx.writeAndFlush(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>            bootstrap.group(eventLoopGroup)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> Unpooled.copiedBuffer(<span class="hljs-string">&quot;hello server &quot;</span> + i + <span class="hljs-string">&quot;    &quot;</span>, CharsetUtil.UTF_8);<br>            ctx.writeAndFlush(buf);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[msg.readableBytes()];<br>        msg.readBytes(bytes);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, CharsetUtil.UTF_8);<br>        log.info(<span class="hljs-string">&quot;客户端接收到消息：&#123;&#125;&quot;</span>, message);<br>        log.info(<span class="hljs-string">&quot;客户端接收消息次数：&#123;&#125;&quot;</span>, ++count);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>第一次启动客户端</strong></p><p>服务端输出</p><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E6%9C%8D%E5%8A%A1%E7%AB%AF1.png" srcset="/img/loading.gif" lazyload alt></p><p>客户端输出</p><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E5%AE%A2%E6%88%B7%E7%AB%AF1.png" srcset="/img/loading.gif" lazyload alt></p><br><p><strong>第二次启动客户端</strong></p><p>服务端输出</p><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E6%9C%8D%E5%8A%A1%E7%AB%AF2.png" srcset="/img/loading.gif" lazyload alt></p><p>客户端输出</p><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E5%AE%A2%E6%88%B7%E7%AB%AF2.png" srcset="/img/loading.gif" lazyload alt></p></blockquote><br><h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h3><blockquote><p><strong>原因</strong>：<strong>服务端或客户端并不知道每个请求（write操作）消息的长度是多少</strong>，<strong>服务器有可能多读或少读数据</strong>。所以每次读取数据的时候就有可能遇到<code>粘包</code>和<code>拆包</code>的情况</p><br><p><strong>解决方案：</strong></p><ul><li>使用<strong>自定义协议</strong> + <strong>编解码器</strong> 来解决</li><li>关键就是要解决 服务器端每次读取数据长度的问题，这个问题解决就不会出现服务器多读或者少读数据的问题，从而避免TCP的<code>粘包</code>和<code>拆包</code></li></ul><br><p><strong>具体实现：</strong></p><ul><li>自定义一个协议实体<ul><li><strong>msg字段</strong>：需要发送的消息</li><li><strong>length:</strong> 消息长度，用于告诉接收端本次消息应该读取的长度是多少，避免多读和少读</li></ul></li><li>自定义一个编解码器来将实体转成byte，自定义一个解码器将byte转成实体</li></ul><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E6%96%B9%E6%A1%88.png" srcset="/img/loading.gif" lazyload alt></p><br><p><strong>自定义协议</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgProtocol</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] msg;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>自定义编码器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span>&lt;MsgProtocol&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MsgProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 将对象转成字节流</span><br>        log.info(<span class="hljs-string">&quot;自定义编码器被调用&quot;</span>);<br>        out.writeInt(msg.getLength());<br>        out.writeBytes(msg.getMsg());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>自定义解码器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;ByteBuf&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;自定义解码器被调用&quot;</span>);<br>        <span class="hljs-comment">// 将二进制字节流转换成对象</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.readInt();<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>        msg.readBytes(bytes);<br><br>        <span class="hljs-comment">// 封装成 MsgEncoder 对象加入 List, 传递给下一个Handler处理</span><br>        <span class="hljs-type">MsgProtocol</span> <span class="hljs-variable">msgEncoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgProtocol</span>(length, bytes);<br>        out.add(msgEncoder);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>服务端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">6666</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br><br>            bootstrap.group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>            .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>            .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                <span class="hljs-comment">//给pipeline 设置处理器</span><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-comment">// 加入自定义编码器</span><br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgEncoder</span>());<br>                    <span class="hljs-comment">// 加入自定义解码器</span><br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgDecoder</span>());<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(PORT).sync();<br><br>            channelFuture.channel().closeFuture().sync();<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;MsgProtocol&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">// 异常处理</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MsgProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 接收对象并处理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.getLength();<br>        <span class="hljs-type">byte</span>[] bytes = msg.getMsg();<br><br>        log.info(<span class="hljs-string">&quot;服务端接收到消息长度：&#123;&#125;&quot;</span>, length);<br>        log.info(<span class="hljs-string">&quot;服务端接收到的消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, CharsetUtil.UTF_8));<br>        log.info(<span class="hljs-string">&quot;服务端接收到数据包的次数：&#123;&#125;&quot;</span>, ++count);<br><br>        <span class="hljs-comment">// 回复消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s=%s&quot;</span>, <span class="hljs-string">&quot;服务端回复消息&quot;</span>, UUID.randomUUID().toString());<br>        <span class="hljs-type">byte</span>[] responseBytes = response.getBytes(CharsetUtil.UTF_8);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">responseLength</span> <span class="hljs-operator">=</span> responseBytes.length;<br>        <span class="hljs-type">MsgProtocol</span> <span class="hljs-variable">responseMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgProtocol</span>(responseLength, responseBytes);<br>        ctx.writeAndFlush(responseMsg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>客户端源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventLoopGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br><br>            bootstrap.group(eventLoopGroup)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 加入自定义编码器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgEncoder</span>());<br>                            <span class="hljs-comment">// 加入自定义解码器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgDecoder</span>());<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;MsgProtocol&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 发送10条数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s=%s&quot;</span>,  j + <span class="hljs-number">1</span>, UUID.randomUUID().toString());<br>            <span class="hljs-type">byte</span>[] bytes = msg.getBytes(CharsetUtil.UTF_8);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> bytes.length;<br>            <span class="hljs-type">MsgProtocol</span> <span class="hljs-variable">msgProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MsgProtocol</span>(length, bytes);<br>            ctx.writeAndFlush(msgProtocol);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MsgProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.getLength();<br>        <span class="hljs-type">byte</span>[] bytes = msg.getMsg();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, CharsetUtil.UTF_8);<br><br>        log.info(<span class="hljs-string">&quot;客户端收到服务端消息长度：&#123;&#125;&quot;</span>, length);<br>        log.info(<span class="hljs-string">&quot;客户端收到服务端消息：&#123;&#125;&quot;</span>, message);<br>        log.info(<span class="hljs-string">&quot;客户端接收消息次数：&#123;&#125;&quot;</span>, ++count);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BE%93%E5%87%BA.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/05/25/netty/%E7%B2%98%E5%8C%85%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BE%93%E5%87%BA.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>由输出的消息可知，当告知接收方数据包的大小后，数据就避免了多读和少读问题，从而避免了<code>粘包</code>和<code>拆包</code>的产生</strong></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>netty</div><div>https://wugengfeng.cn/2022/05/25/netty/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年5月25日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/05/29/Linux/" title="Linux"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Linux</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/05/01/elasticsearch/" title="Elasticsearch"><span class="hidden-mobile">Elasticsearch</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>