<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="思维导图   选型的一些思考 在进行技术选型时，当考虑使用ZooKeeper作为分布式协调服务的解决方案时，首先需要明确ZooKeeper是否能够满足特定的应用场景需求。ZooKeeper作为一种分布式系统中的协调工具，虽然功能强大且通用，但它并不一定适合所有场景。在分布式协调服务的细分领域中，存在多种替代方案。这些方案针对不同的需求和约束条件，可能提供更优的性能、更高的可扩展性或更简单的使用方式"><meta property="og:type" content="article"><meta property="og:title" content="zookeeper"><meta property="og:url" content="https://wugengfeng.cn/2022/08/18/zookeeper/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="思维导图   选型的一些思考 在进行技术选型时，当考虑使用ZooKeeper作为分布式协调服务的解决方案时，首先需要明确ZooKeeper是否能够满足特定的应用场景需求。ZooKeeper作为一种分布式系统中的协调工具，虽然功能强大且通用，但它并不一定适合所有场景。在分布式协调服务的细分领域中，存在多种替代方案。这些方案针对不同的需求和约束条件，可能提供更优的性能、更高的可扩展性或更简单的使用方式"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/zookeeper.png"><meta property="article:published_time" content="2022-08-18T02:46:56.000Z"><meta property="article:modified_time" content="2023-11-13T07:48:24.021Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/zookeeper.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>zookeeper - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="zookeeper"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-08-18 10:46" pubdate>2022年8月18日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 27k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 227 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">zookeeper</h1><div class="markdown-body"><p><a target="_blank" rel="noopener" href="https://mubu.com/doc/4vWgWe6Oxgy#m">思维导图</a></p><p><img src="/2022/08/18/zookeeper/zookeeper%E6%95%B4%E4%BD%93%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><h2 id="选型的一些思考"><a class="markdownIt-Anchor" href="#选型的一些思考"></a> 选型的一些思考</h2><p>在进行技术选型时，当考虑使用ZooKeeper作为分布式协调服务的解决方案时，首先需要明确ZooKeeper是否能够满足特定的应用场景需求。ZooKeeper作为一种分布式系统中的协调工具，虽然功能强大且通用，但它并不一定适合所有场景。在分布式协调服务的细分领域中，存在多种替代方案。这些方案针对不同的需求和约束条件，可能提供更优的性能、更高的可扩展性或更简单的使用方式。因此，在最终决定采用ZooKeeper之前，应该对其功能特性进行全面评估，并与其他可用的替代方案进行比较，以确保选择最适合当前业务需求的解决方案。</p><div class="note note-primary"><p><strong><code>服务发现</code></strong></p><p>早期，Dubbo选择ZooKeeper作为其服务发现组件，这在一定程度上受到当时的技术环境影响。当时，微服务架构并未像现在这样广泛流行，服务发现的解决方案相对有限。重要的是要注意，ZooKeeper主要遵循CP（一致性和分区容错性）模型。然而，对于服务发现组件而言，是否真的需要强调一致性？个人认为，对于服务发现组件来说，最重要的应该是高可用性。在微服务架构中，服务发现组件的任何故障都不应导致整个系统的服务瘫痪，这种情况是不可接受的。理想情况下，服务发现组件应始终保持可用，即使数据不一致导致服务不可用也应通过负载均衡策略或服务降级等方案来确保系统的正常运行。</p><p>随着技术的发展，现在已经出现了一些更适合微服务架构的服务发现组件，它们主要遵循AP（可用性和分区容错性）模型，以确保在网络分区和其他故障情况下的高可用性。例如，Eureka（Spring Cloud 1.x）和Nacos，它们提供了更灵活和健壮的服务发现机制，更适合于微服务架构的服务发现需求。</p></div><div class="note note-primary"><p><strong><code>配置中心</code></strong></p><p>在对配置中心进行技术选型时，ZooKeeper的CP（一致性和分区容错性）模型确实非常适合用元数据配置服务。ZooKeeper的节点监听功能可以方便地实现配置的动态更新，这对于基本的元数据配置服务来说是一个不错的选择，早期的Kafka等相关服务也采用其作为解决方案。它的一致性保证了配置信息的准确性和可靠性。</p><p>然而，如果将ZooKeeper作为一个功能更全面的配置中心，也存在一些局限性。首先，它缺乏一个灵活且易于使用的配置UI界面，这对于管理和维护大量配置项可能会带来一定的挑战。其次，ZooKeeper本身并不提供数据解析逻辑，这意味着用户需要自行实现配置数据的解析和处理逻辑，这增加了使用的复杂性。</p><p>鉴于这些局限性，不如使用针对性更强的服务，如Apollo或Nacos。这些工具不仅提供了更友好的配置界面和数据管理功能，还内置了数据解析和处理逻辑，减少了开发者的工作量。此外，它们还可能提供更多高级功能，如配置版本管理、环境隔离、权限控制等，这些都是在复杂的应用环境中不可或缺的特性。</p></div><div class="note note-primary"><p><strong><code>分布式锁</code></strong></p><p>ZooKeeper构建的分布式锁不是一个适用于所有场景的通用解决方案。这主要是由于ZooKeeper底层的ZAB（ZooKeeper Atomic Broadcast）协议的工作机制。在ZAB协议中，事务的提交需要集群中大多数节点的同意，这意味着随着集群节点数量的增加，达成共识所需的时间会增加，从而导致事务操作的延迟性增高。因此，如果考虑使用ZooKeeper实现分布式锁，特别是在分布式事务场景中，就需要考量业务是否能够容忍这种写操作的性能瓶颈。</p><p>如果业务场景中对分布式锁的要求是高可用性，并且需要在服务异常时锁具有自动恢复的能力，那么ZooKeeper是一个非常合适的选择。可以使用临时节点，服务异常时自动释放锁。</p><p>然而，如果分布式锁应用于高并发的场景，ZooKeeper就不是一个理想的选择。在高并发场景下，ZooKeeper的性能瓶颈会严重影响业务，导致锁操作的响应时间变长，从而影响整体系统的性能。在这种情况下，可以考虑其他专门为高并发设计的分布式锁解决方案，例如基于Redis的RedLock算法等，这些方案能够提供更快的响应时间和更好的扩展性，更适合于高并发环境。</p></div><div class="note note-primary"><p><strong><code>Leader选举</code></strong></p><p>分布式服务中的Leader选举可以通过ZooKeeper来实现，优点是减少了开发工作量，因为ZooKeeper提供了一套现成的、可靠的机制来处理选举的复杂性。在整个方案中，各个服务节点尝试在ZooKeeper中创建同一个zNode（节点）。由于ZooKeeper保证同一个节点名下只能成功创建一个临时zNode，因此第一个成功创建该zNode的服务节点将成为Leader。</p><p>这个临时zNode的特性是关键：它确保了当Leader节点宕机或失去与ZooKeeper集群的连接时，该zNode会被自动删除。其他的服务节点（Follower）在ZooKeeper上对这个zNode进行监听。当它们检测到这个zNode被删除的事件时，意味着原Leader已不再可用，随即开始新一轮的Leader选举。</p><p>这种选举方案适合在Leader选举时，没有额外业务逻辑处理的选举场景。</p></div><h2 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/">文章涉及源码</a></p><p><span class="green-line">Apache ZooKeeper是一个开源的分布式协调服务</span>，主要用于构建分布式应用程序。它为分布式应用程序提供一套简单、可靠的协调和管理功能，帮助应用程序处理分布式环境中的各种服务，如 <code>配置管理</code>、<code>同步</code> 和 <code>服务发现</code> 等。</p><p class="note note-primary">工作机制</p><p><img src="/2022/08/18/zookeeper/%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt></p><p>ZooKeeper, 从设计模式的角度来看，可以被认为是一个实现了 <code>观察者模式</code> 的分布式协调服务框架。它主要负责存储和管理分布式系统中重要的配置信息和命名数据。<span class="green-line">当这些数据状态发生变化时，ZooKeeper会通知已经向其注册的观察者，从而使这些观察者能够做出相应的反应。</span></p><p><strong><code>Zookeeper</code> = 文件系统 + 通知机制</strong></p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><p><a href="/2022/10/10/分布式算法理论/#cap定理">CAP定理</a></p><p><img src="/2022/08/18/zookeeper/%E7%89%B9%E7%82%B9.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><p><code>可靠性</code>：即使部分节点发生故障，整个系统仍将继续运行。</p></li><li><p><code>顺序一致性</code>：Zookeeper 数据操作按照请求的先后顺序排队进行。集群可能存在短暂的数据不一致窗口，但ZooKeeper保证最终一致性。</p></li><li><p><code>原子性</code>：数据更新操作是原子的，要么完全成功，要么完全失败，不会有中间或部分完成的状态。</p></li><li><p><code>可扩展性</code>：集群架构支持节点水平扩展。</p></li><li><p><code>监视和通知</code>：可以在 znode 上设置监视。此机制允许客户端接收有关特定 znode 更改的通知，而无需轮询更新。</p></li></ol><div class="note note-warning"><p><code>广义上满足CP定理</code></p><p>ZK是一个满足CP理论的分布式应用程序协调服务，A（可用性）不满足是因为ZK集群Leader宕机恢复选举过程中，整个集群处于不可用状态，<a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#zab%E5%8D%8F%E8%AE%AE"><code>Zab协议</code></a>保证了集群间数据的最终一致性。</p></div><h3 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h3><p><img src="/2022/08/18/zookeeper/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p><span style="border-bottom:2px dashed green"><code>ZooKeeper</code> 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 <code>ZNode</code>。每一个 <code>ZNode</code> 默认能够存储 <code>1MB</code> 的数据，每个ZNode都有一个与之关联的路径，这个路径为其在ZooKeeper中提供了唯一的标识。</span></p><h4 id="节点类型"><a class="markdownIt-Anchor" href="#节点类型"></a> 节点类型</h4><p class="note note-primary">持久性</p><ul><li><code>持久节点（Persistent）</code>：无论客户端与服务端的会话是否失效，该节点都会持续存在，除非被显式删除。</li><li><code>临时 （Ephemeral）</code>：当客户端与服务端的会话失效时，该节点会自动被删除。</li></ul><p class="note note-primary">顺序性</p><ul><li><code>普通节点</code>：节点的名称与创建时客户端指定的名称完全相同。</li><li><code>顺序节点</code>：在节点的名称后会自动附加一个唯一的递增序列号。</li></ul><table><thead><tr><th style="text-align:left">节点类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">持久节点</td><td style="text-align:left">在Zookeeper中，持久节点会持续存在，直到被显式删除。</td></tr><tr><td style="text-align:left">持久顺序节点</td><td style="text-align:left">与持久节点特性相同，但每次创建时，节点名称后会自动添加由其父节点维护的递增整型数字。</td></tr><tr><td style="text-align:left">临时节点</td><td style="text-align:left">临时节点与客户端会话相关联。客户端会话失效时，其创建的所有临时节点都会被删除。</td></tr><tr><td style="text-align:left">临时顺序节点</td><td style="text-align:left">与临时节点特性相同，但在节点名称后会自动添加由其父节点维护的递增整型数字。</td></tr></tbody></table><p class="note note-primary">临时节点</p><p><img src="/2022/08/18/zookeeper/%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9.png" srcset="/img/loading.gif" lazyload alt></p><div class="note note-warning"><p>注意：临时节点不能添加子节点</p><p>节点元数据 <code>ephemeralOwner</code> 就是临时节点客户端的 session id</p></div><p>使用场景</p><ul><li><a href="#%E6%9C%8D%E5%8A%A1%E4%B8%8A%E4%B8%8B%E7%BA%BF">服务注册与发现</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">分布式锁（临时顺序节点）</a></li></ul><p class="note note-primary">Container节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create -c /test<br></code></pre></td></tr></table></figure><p><code>Container</code> 节点是ZooKeeper 3.5.0及其以后版本中引入的一种特殊类型的znode。</p><ol><li><strong><code>自动清理</code></strong>：<ul><li>当 <code>Container</code> 节点下的所有子节点都被删除后，<code>Container</code> 节点会在将来某个时间点被ZooKeeper自动删除。</li><li>这个特性使得 <code>Container</code> 节点很适合用于那些只需要短暂地作为容器存在的场景。</li></ul></li><li><strong><code>无法直接删除</code></strong>：<ul><li>如果你尝试直接删除一个还包含子节点的 <code>Container</code> 节点，这个操作会失败。只有当其下没有子节点时，<code>Container</code> 节点才会被自动删除。</li></ul></li></ol><p class="note note-primary">TTL节点</p><p>3.5.3版本新增，需要配置系统变量<code>zookeeper.extendedTypesEnabled=true</code>，3.6.3版本后默认启用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create -t 10 /test<br></code></pre></td></tr></table></figure><p>十秒后自动删除</p><ol><li><strong><code>自动删除</code></strong>：一旦TTL时间过去，节点将被自动删除。</li><li><strong><code>递归删除</code></strong>：如果一个TTL节点是一个父节点，当其到期被删除时，其子节点也会被删除。</li><li><strong><code>不可更改的TTL</code></strong>：一旦设置了TTL值，该值是不可以被修改的。</li><li><strong><code>TTL的时间单位</code></strong>：在ZooKeeper中，TTL的单位是毫秒。</li></ol><h4 id="节点数据信息"><a class="markdownIt-Anchor" href="#节点数据信息"></a> 节点数据信息</h4><p><span style="border-bottom:2px dashed green">zookeeper 中的所有存储的数据是由 znode 组成的，节点也称为 znode，并以 key/value 形式存储数据</span></p><table><thead><tr><th>说明</th><th>描述</th></tr></thead><tbody><tr><td>data</td><td>存储在znode中的数据。</td></tr><tr><td>acl</td><td>定义了用户的权限以及他们能够对znode执行的操作。<br><code>c</code>: 允许创建子节点<br><code>w</code>: 允许更新节点数据<br><code>r</code>: 允许读取节点数据和获取子节点列表<br><code>d</code>: 允许删除子节点<br><code>a</code>: 允许设置节点的acl权限</td></tr><tr><td>stat</td><td>包含znode的元数据，如创建和修改的时间戳、版本信息、大小等。</td></tr><tr><td>child</td><td>列出当前znode的直接子节点。</td></tr></tbody></table><p class="note note-primary">节点元数据</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">czxid</td><td style="text-align:left">创建节点时的事务ID。事务ID（zxid）表示ZooKeeper状态的每次修改。每个zxid都是唯一的，且按修改的顺序连续生成。如果zxid1小于zxid2，则zxid1在zxid2之前发生。</td></tr><tr><td style="text-align:left">mzxid</td><td style="text-align:left">节点最后修改时的事务ID。</td></tr><tr><td style="text-align:left">pZxid</td><td style="text-align:left">当前节点的子节点列表最后一次修改的事务ID。只有当子节点列表变动（例如，添加或删除子节点）时，此ID才会变更。修改子节点的数据内容不会影响此ID。</td></tr><tr><td style="text-align:left">ctime</td><td style="text-align:left">创建节点时的时间戳（毫秒为单位，从1970年1月1日开始）。</td></tr><tr><td style="text-align:left">mtime</td><td style="text-align:left">节点最后修改的时间戳（毫秒为单位，从1970年1月1日开始）。</td></tr><tr><td style="text-align:left">cversion</td><td style="text-align:left">子节点版本号。每当子节点列表变动时，此版本号递增。</td></tr><tr><td style="text-align:left">dataversion</td><td style="text-align:left">数据版本号。每当节点数据变动时，此版本号递增。</td></tr><tr><td style="text-align:left">aclVersion</td><td style="text-align:left">ACL（访问控制列表）版本号。每当节点的ACL变动时，此版本号递增。</td></tr><tr><td style="text-align:left">ephemeralOwner</td><td style="text-align:left">如果是临时节点，此字段表示znode拥有者的session id。如果是持久节点，则此字段为0。</td></tr><tr><td style="text-align:left">dataLength</td><td style="text-align:left">节点数据的长度（以字节为单位）。</td></tr><tr><td style="text-align:left">numChildren</td><td style="text-align:left">当前节点的直接子节点数量。</td></tr></tbody></table><h3 id="集群角色"><a class="markdownIt-Anchor" href="#集群角色"></a> 集群角色</h3><p><img src="/2022/08/18/zookeeper/%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><p><strong><code>事务请求</code></strong>：</p><ul><li>在ZooKeeper的集群（称为ensemble）中，为了保持数据一致性，修改操作都被视为事务请求。</li><li>客户端发起的事务请求首先到达Leader。</li><li>Leader创建提议并发起投票，请求Follower节点的意见。</li><li>Follower根据其状态回应投票结果。</li><li>若过半数Follower同意，Leader确认并执行事务。</li><li>由于需过半同意，集群大小确实对写性能有所影响：节点越多，达到多数的延迟越高。</li></ul></li><li><p><strong><code>事务请求转发</code></strong>：</p><ul><li>Follower收到客户端写请求后，会转发给Leader，因为仅Leader可提议更改。</li><li>Leader提议更改并等待Follower的回应。</li><li>一旦得到过半Follower的确认，Leader提交更改，并同步确保所有Follower与其状态一致。</li></ul><p><span class="green-line">写请求需要所有活跃的节点参与进来保证数据的一致性，因此它们被视为事务请求。</span></p><table><thead><tr><th style="text-align:left">角色</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">leader</td><td style="text-align:left">负责发起投票和做出决策，更新系统状态，以及处理事务请求。</td></tr><tr><td style="text-align:left">follower (跟随者)</td><td style="text-align:left">参与投票，接收并处理客户端的非事务请求并返回结果，同时将事务请求转发给leader进行处理。</td></tr><tr><td style="text-align:left">observer (观察者)</td><td style="text-align:left">虽然不参与投票，但同步leader的状态来扩展系统并提高读取性能。它还可以接收客户端请求，处理非事务请求并返回结果，同时将事务请求转发给leader。</td></tr></tbody></table></li></ol><p class="note note-primary">observer 观察者</p><ul><li>在 <code>Leader</code> 选举过程中，我们通常不讨论 <code>Observer</code>，这是因为 <code>Observer</code> 不具备投票权。尽管如此，<code>Observer</code> 与 <code>Follower</code> 在功能上极为相似，主要区别是其不参与投票和过半机制。<code>Observer</code> 可以接受客户端连接，并能够从 <code>Leader</code> 同步数据。</li><li><code>Observer</code> 的设计目的之一是为了支持扩容。它可以帮助实现数据的动态迁移和扩容。最重要的是，<span class="green-line"><code>Observer</code>在不影响集群写性能的前提下增强了读取性能</span>，使其成为异地数据中心数据同步的理想选择。</li></ul><h2 id="集群搭建"><a class="markdownIt-Anchor" href="#集群搭建"></a> 集群搭建</h2><p><a target="_blank" rel="noopener" href="https://archive.apache.org/dist/zookeeper/zookeeper-3.5.6/">zookeeper 下载</a></p><p class="note note-primary">创建节点文件夹（伪集群）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /data/zookeeper/zk1<br>mkdir /data/zookeeper/zk1/data<br>mkdir /data/zookeeper/zk1/logs<br>echo 1 &gt; /data/zookeeper/zk1/data/myid<br><br>mkdir /data/zookeeper/zk2<br>mkdir /data/zookeeper/zk2/data<br>mkdir /data/zookeeper/zk2/logs<br>echo 2 &gt; /data/zookeeper/zk2/data/myid<br><br>mkdir /data/zookeeper/zk3<br>mkdir /data/zookeeper/zk3/data<br>mkdir /data/zookeeper/zk3/logs<br>echo 3 &gt; /data/zookeeper/zk3/data/myid<br></code></pre></td></tr></table></figure><p>将下载好的zk分别解压到创建的三个zk目录中</p><p class="note note-primary">在zookeeper conf目录下分别添加zoo.cfg</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26462567/article/details/121747991">zookeeper 完整配置详解</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">心跳时间2秒</span> <br>tickTime=2000<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Follower跟随者服务器与Leader领导者服务器之间初始化连接时能容忍的最多心跳数10*tickTime</span> <br>initLimit=10<br><span class="hljs-meta prompt_">#</span><span class="language-bash">集群中Leader与Follower之间的最大响应时间单位5*tickTime</span> <br>syncLimit=5<br><span class="hljs-meta prompt_">#</span><span class="language-bash">存储快照文件 snapshot 的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能</span><br>dataDir=/data/zookeeper/zk1/data<br><span class="hljs-meta prompt_">#</span><span class="language-bash">事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升ZK性能</span><br>dataLogDir=/data/zookeeper/zk1/logs<br><span class="hljs-meta prompt_">#</span><span class="language-bash">zookeeper端口</span>  <br>clientPort=2181<br><span class="hljs-meta prompt_">#</span><span class="language-bash">单个客户端与单台服务器之间的连接数的限制，是ip级别的，默认是60，如果设置为0，那么表明不作任何限制</span><br>maxClientCnxns=60<br><span class="hljs-meta prompt_">#</span><span class="language-bash">server.1代表一台服务器的编号，第一个端口为集群通讯端口，第二个端口代表Leader选举的端口</span> <br>server.1=127.0.0.1:2881:3881<br>server.2=127.0.0.1:2882:3882<br>server.3=127.0.0.1:2883:3883<br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定观察者</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">server.3=127.0.0.1:2883:3883:observer</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">心跳时间2秒</span> <br>tickTime=2000<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Follower跟随者服务器与Leader领导者服务器之间初始化连接时能容忍的最多心跳数10*tickTime</span> <br>initLimit=10<br><span class="hljs-meta prompt_">#</span><span class="language-bash">集群中Leader与Follower之间的最大响应时间单位5*tickTime</span> <br>syncLimit=5<br><span class="hljs-meta prompt_">#</span><span class="language-bash">存储快照文件 snapshot 的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能</span><br>dataDir=/data/zookeeper/zk2/data<br><span class="hljs-meta prompt_">#</span><span class="language-bash">事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升ZK性能</span><br>dataLogDir=/data/zookeeper/zk2/logs<br><span class="hljs-meta prompt_">#</span><span class="language-bash">zookeeper端口</span>  <br>clientPort=2182<br><span class="hljs-meta prompt_">#</span><span class="language-bash">单个客户端与单台服务器之间的连接数的限制，是ip级别的，默认是60，如果设置为0，那么表明不作任何限制</span><br>maxClientCnxns=60<br><span class="hljs-meta prompt_">#</span><span class="language-bash">server.1代表一台服务器的编号，第一个端口为集群通讯端口，第二个端口代表Leader选举的端口</span>  <br>server.1=127.0.0.1:2881:3881<br>server.2=127.0.0.1:2882:3882<br>server.3=127.0.0.1:2883:3883<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">心跳时间2秒</span> <br>tickTime=2000<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Follower跟随者服务器与Leader领导者服务器之间初始化连接时能容忍的最多心跳数10*tickTime</span> <br>initLimit=10<br><span class="hljs-meta prompt_">#</span><span class="language-bash">集群中Leader与Follower之间的最大响应时间单位5*tickTime</span> <br>syncLimit=5<br><span class="hljs-meta prompt_">#</span><span class="language-bash">存储快照文件 snapshot 的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能</span><br>dataDir=/data/zookeeper/zk3/data<br><span class="hljs-meta prompt_">#</span><span class="language-bash">事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升ZK性能</span><br>dataLogDir=/data/zookeeper/zk3/logs<br><span class="hljs-meta prompt_">#</span><span class="language-bash">zookeeper端口</span>  <br>clientPort=2183<br><span class="hljs-meta prompt_">#</span><span class="language-bash">单个客户端与单台服务器之间的连接数的限制，是ip级别的，默认是60，如果设置为0，那么表明不作任何限制</span><br>maxClientCnxns=60<br><span class="hljs-meta prompt_">#</span><span class="language-bash">server.1代表一台服务器的编号，第一个端口为集群通讯端口，第二个端口代表Leader选举的端口</span> <br>server.1=127.0.0.1:2881:3881<br>server.2=127.0.0.1:2882:3882<br>server.3=127.0.0.1:2883:3883<br></code></pre></td></tr></table></figure><p class="note note-primary">分别启动zk</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd bin目录<br>./bin/zkServer.sh start<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>./bin/zkServer.sh status<br></code></pre></td></tr></table></figure><h2 id="客户端命令行"><a class="markdownIt-Anchor" href="#客户端命令行"></a> 客户端命令行</h2><h3 id="命令行语法"><a class="markdownIt-Anchor" href="#命令行语法"></a> 命令行语法</h3><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>help</code></td><td>显示ZooKeeper支持的所有命令及其用法。</td></tr><tr><td><code>ls &lt;path&gt; [watch]</code></td><td>列出指定<code>path</code>下的子节点。可选参数<code>watch</code>设置监听指定节点的子节点变化。<br><code>-R</code>：递归列出所有子节点。</td></tr><tr><td><code>ls2 &lt;path&gt; [watch]</code></td><td>类似于<code>ls</code>，但同时显示节点的状态信息，如数据版本和ACLs。</td></tr><tr><td><code>create &lt;path&gt; [data] [acl]</code></td><td>在指定的路径创建一个新节点。<br><code>-s</code>：创建一个带序列号的节点。<br><code>-e</code>：创建一个临时节点，会话结束或超时后消失。<br><code>-c</code>：创建一个容器节点，会自动删除没有子节点的容器。<br><code>-t &lt;time&gt;</code>：创建一个具有TTL（存活时间）的节点，未修改且无子节点时将被自动删除。</td></tr><tr><td><code>get &lt;path&gt; [watch]</code></td><td>获取指定路径节点的数据内容。<code>watch</code>参数用于设置对节点数据变化的监听。</td></tr><tr><td><code>set &lt;path&gt; &lt;data&gt; [version]</code></td><td>更新指定路径节点的数据。<br><code>-w</code>：更新时设置对节点数据变化的监听。<br><code>-s</code>：更新数据同时设置附加信息。<br><code>-v &lt;version&gt;</code>：指定节点的版本进行乐观锁控制。</td></tr><tr><td><code>stat &lt;path&gt;</code></td><td>显示指定节点的元数据信息，如版本号和子节点数。</td></tr><tr><td><code>delete &lt;path&gt; [version]</code></td><td>删除指定路径的节点。<br><code>-v &lt;version&gt;</code>：用于乐观锁控制，只有版本匹配时才能删除。</td></tr><tr><td><code>deleteall &lt;path&gt;</code></td><td>递归删除指定路径及其所有子节点。</td></tr><tr><td><code>rmr &lt;path&gt;</code></td><td>递归删除节点，与<code>deleteall</code>功能相同，但<code>rmr</code>已被弃用。</td></tr></tbody></table><h3 id="操作节点"><a class="markdownIt-Anchor" href="#操作节点"></a> 操作节点</h3><p><strong>查看指定路径下的子节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /<br></code></pre></td></tr></table></figure><hr><p><strong>查看子节点和元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls2 /<br></code></pre></td></tr></table></figure><hr><p><strong>查看节点元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">stat /<br></code></pre></td></tr></table></figure><hr><p><strong>创建永久节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create /yongjiu 永久节点<br></code></pre></td></tr></table></figure><hr><p><strong>创建永久顺序节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create -s /yongjiu/shunxu 永久顺序节点<br></code></pre></td></tr></table></figure><p>创建成功后名称会发生变化 <code>shunxu0000000000</code> 后面会加上序列号</p><hr><p><strong>创建临时节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create -e /linshi 临时节点<br></code></pre></td></tr></table></figure><hr><p><strong>创建临时顺序节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">create -e -s /linshi 临时顺序节点<br></code></pre></td></tr></table></figure><p><span style="border-bottom:2px dashed green">临时顺序节点的父节点不能是临时节点</span></p><hr><p><strong>设置节点的值</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> /yongjiu 永久节点2<br></code></pre></td></tr></table></figure><hr><p><strong>获取节点的值</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> /yongjiu<br></code></pre></td></tr></table></figure><hr><p><strong>删除节点</strong></p><ul><li><p>普通删除</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">delete</span> /yongjiu<br></code></pre></td></tr></table></figure></li><li><p>乐观锁删除</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">delete</span> -v <span class="hljs-number">1</span> /youjin<br></code></pre></td></tr></table></figure></li></ul><hr><p><strong>递归删除节点，包括其子节点</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deleteall /yongjiu<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rmr /yongjiu<br></code></pre></td></tr></table></figure><p class="note note-primary">ACL权限操作</p><ul><li><p>注册当前会话的账号和密码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addauth </span><span class="hljs-keyword">digest </span>test:<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure></li><li><p>创建节点并设置权限（指定该节点的用户，以及用户所拥有的权限）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">create /test-node <span class="hljs-built_in">test</span> auth:<span class="hljs-built_in">test</span>:123456:cdwra<br></code></pre></td></tr></table></figure></li></ul><p>如果其他会话不注册当前会话的账号密码，则没有权限操作<code>/test-node</code>节点</p><p class="note note-primary">客户端操作</p><p>ZooKeeper原生Java API的不足之处：</p><ul><li>在连接zk超时的时候，不支持自动重连，需要手动操作</li><li>Watch注册一次就会失效，需要反复注册</li><li>不支持递归创建节点</li></ul><p>Apache curator</p><ul><li>解决Watch注册一次就会失效的问题</li><li>支持直接创建多级结点</li><li>提供的 API 更加简单易用</li><li>提供更多解决方案并且实现简单，例如：分布式锁</li><li>提供常用的ZooKeeper工具类</li><li>编程风格更舒服</li></ul><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/src/test/java/com/wgf/zookeeper/ZkNodeTest.java">zkClient 节点操作</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/src/test/java/com/wgf/curator/CuratorNodeTest.java">curator 节点操作</a></p><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1923153">Curator使用手册</a></p><h3 id="节点监听原理"><a class="markdownIt-Anchor" href="#节点监听原理"></a> 节点监听原理</h3><p>在ZooKeeper中，节点监听（watch）是一种机制，允许客户端在指定的znode上注册一个watch，以便在该节点上发生特定类型的事件时得到通知。<span class="green-line">ZooKeeper的watch机制是轻量级的，它被设计为一次性触发器，即一旦被触发就会被移除</span>，如果需要持续监听，则需要在每次接收到通知后重新设置watch。</p><p class="note note-primary">节点监听流程</p><p><img src="/2022/08/18/zookeeper/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><strong><code>客户端初始化</code>：</strong> 当主线程中创建一个ZooKeeper客户端实例时，客户端会初始化其内部组件和线程。</li><li><strong><code>线程启动</code>：</strong> 客户端启动两个关键的后台线程：<ul><li><code>发送线程（Send Thread）</code>： 负责与ZooKeeper集群建立和维持网络连接，发送请求和接收响应。</li><li><code>事件线程（Event Thread）</code>： 负责处理来自服务器的事件通知，并触发注册的Watcher回调。</li></ul></li><li><strong><code>监听器注册</code>：</strong> 客户端通过发送线程向ZooKeeper服务器注册Watcher，同时指定感兴趣的事件类型。</li><li><strong><code>服务器处理</code>：</strong> ZooKeeper服务器接收到Watcher注册信息后，会把Watcher对象与指定的节点关联起来，并保存在内部的监听器映射表中。</li><li><strong><code>事件触发</code>：</strong> 一旦监视的节点发生了客户端注册的事件类型变化，ZooKeeper服务器会将此变化封装为一个事件通知，并将其加入到待处理的事件队列中。</li><li><strong><code>事件通知</code>：</strong> 事件线程从队列中获取通知，并通知相关客户端的Watcher进行处理。</li><li><strong><code>监听器一次性特性</code>：</strong> 在ZooKeeper中，Watcher是一次性的，即一旦触发，就不再有效。如果客户端需要持续监听某个事件，它需要在每次处理完事件通知后再次注册相同的Watcher。</li></ol><p><strong>注意事项：</strong></p><ul><li>为了保证线程安全，事件处理逻辑应避免直接在<code>process()</code>方法中执行长时间运行的操作或网络调用。如果必须进行这些操作，应在<code>process()</code>方法中将任务委托给其他线程执行。</li><li>客户端的主线程通常用于发起ZooKeeper操作和Watcher注册，并不直接参与网络通信或事件处理。这些职责由发送线程和事件线程分别承担。</li></ul><p class="note note-primary">监听事件</p><table><thead><tr><th>事件</th><th>说明</th><th>触发条件</th></tr></thead><tbody><tr><td><strong>None</strong></td><td>连接状态事件</td><td>客户端的连接状态改变时，包括以下KeeperState事件：<br>- <code>Expired</code>：会话过期<br>- <code>Disconnected</code>：断开连接<br>- <code>SyncConnected</code>：同步连接已建立<br>- <code>AuthFailed</code>：认证失败</td></tr><tr><td><strong>NodeCreated</strong></td><td>节点创建事件</td><td>对特定节点设置<code>exists</code>监听后，该节点被成功创建时触发</td></tr><tr><td><strong>NodeDeleted</strong></td><td>节点删除事件</td><td>被监听的节点被删除时触发</td></tr><tr><td><strong>NodeDataChanged</strong></td><td>节点数据变化事件</td><td>被监听的节点的数据发生变化时触发</td></tr><tr><td><strong>NodeChildrenChanged</strong></td><td>子节点列表变化事件</td><td>被监听节点的直接子节点列表发生变化时触发，如子节点的添加或删除</td></tr></tbody></table><p class="note note-primary">客户端实现 Watch</p><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1015390">Curator事件监听</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/src/test/java/com/wgf/curator/CuratorWatchTest.java">Curator 实现Watch</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/src/test/java/com/wgf/zookeeper/ZkWatchTest.java">zkClient 实现Watch</a></p><p>Curator提供了五种监听方式</p><p>Curator框架为ZooKeeper客户端操作提供了强化的监听器功能，包括以下几种类型：</p><ol><li><strong><code>Watcher监听</code></strong>：类似于ZooKeeper原生API的Watcher，用于对节点的变更进行一次性监听。它与ZooKeeper的原生实现在使用上差别不大，但Curator提供了更易用的接口。</li><li><strong><code>CuratorListener监听</code></strong>：专门用于处理后台操作的通知，如使用<code>inBackground</code>方法提交的异步任务。这类监听关注的是任务执行的结果及错误通知，而非节点内容的改变。</li><li><strong><code>NodeCache监听</code></strong>：针对单个节点的监听器，它会监控节点本身的创建、更新和删除事件。一旦注册，无需再次设置监听器，Curator会自动管理监听的生命周期。</li><li><strong><code>PathChildrenCache监听</code></strong>：用于监听一个节点的所有子节点的状态变化，如子节点的增加、更新和删除。与NodeCache一样，它提供了自动再监听机制，简化了开发者的操作。</li><li><strong><code>TreeCache监听</code></strong>：结合了<code>NodeCache</code>和<code>PathChildrenCache</code>的特性，监听指定的起始节点及其所有子节点的变化。这意味着无论是节点本身还是其任意层次的子节点发生变化，TreeCache都能捕捉到事件，并自动重新注册监听，方便用户追踪整个树形结构的状态。</li></ol><h4 id="节点的值变化监听"><a class="markdownIt-Anchor" href="#节点的值变化监听"></a> 节点的值变化监听</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端1<br>get -w /yongjiu<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端2<br>set /yongjiu 永久节点2<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端1<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeDataChanged path:/yongjiu<br></code></pre></td></tr></table></figure><h4 id="节点的子节点变化监听"><a class="markdownIt-Anchor" href="#节点的子节点变化监听"></a> 节点的子节点变化监听</h4><p><code>只对一级子节点有效</code></p><p>当监听节点的子节点发生变化就会触发（新增和删除）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端1<br>ls -w /yongjiu<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端2<br>create -s /yongjiu/shunxu<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端1<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/yonjiu<br></code></pre></td></tr></table></figure><h4 id="节点的后辈节点变化监听"><a class="markdownIt-Anchor" href="#节点的后辈节点变化监听"></a> 节点的后辈节点变化监听</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端1<br>ls -R -w /test<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端2<br>create /test/test2/test3/test4<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">客户端1<br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/test/test2/test3<br></code></pre></td></tr></table></figure><h4 id="判断znode是否存在"><a class="markdownIt-Anchor" href="#判断znode是否存在"></a> 判断Znode是否存在</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exists /test<br></code></pre></td></tr></table></figure><p>存在则返回节点信息，不存在则返回null</p><h3 id="事务操作"><a class="markdownIt-Anchor" href="#事务操作"></a> 事务操作</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/src/test/java/com/wgf/zookeeper/ZkTransactionTest.java">zkClient 使用事务</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/zookeeper-example/edit/master/-/src/test/java/com/wgf/curator/CuratorTransactionTest.java">curator 使用事务</a></p><p>在分布式系统中，我们经常需要确保一组操作要么全部成功执行，要么全部不执行，以此来保持系统的一致性。这是事务的基本特性，也称为原子性。在多线程或者分布式环境中，操作原子性尤为重要，因为它可以避免由于操作部分完成而引起的数据不一致问题。</p><p>从版本3.4.0起，ZooKeeper引入了 <code>multi</code> 操作，它允许客户端原子性地执行一批操作。这意味着这批操作要么都成功，要么都不会对ZooKeeper的状态产生任何影响。在Java客户端中，这一特性被封装在 <code>Transaction</code> 类中，提供了一种便捷的方法来组合多个操作并一次性提交。如果事务中的任何操作失败，整个事务会回滚，保证数据的一致性。</p><h4 id="multiop"><a class="markdownIt-Anchor" href="#multiop"></a> multiop</h4><p>删除 <code>/a</code> <code>/b</code> <code>/c</code> 节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multiOpTest</span><span class="hljs-params">()</span> &#123;<br>    List&lt;OpResult&gt; results = zooKeeper.multi(Arrays.asList(<br>            Op.delete(<span class="hljs-string">&quot;/a&quot;</span>, -<span class="hljs-number">1</span>),<br>            Op.delete(<span class="hljs-string">&quot;/b&quot;</span>, -<span class="hljs-number">1</span>),<br>            Op.delete(<span class="hljs-string">&quot;/c&quot;</span>, -<span class="hljs-number">1</span>)<br>    ));<br><br>    <span class="hljs-keyword">for</span> (OpResult result : results) &#123;<br>        System.out.println(result.getType());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如只存在 <code>/a</code> <code>/b</code>，执行时会抛出 <code>NoNodeException</code> 因为不存在 <code>/c</code>，执行完之后发生 <code>/a</code> <code>/b</code> 还在</p><p><img src="/2022/08/18/zookeeper/%E4%BA%8B%E5%8A%A1%E5%A4%B1%E8%B4%A5.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">异步处理</p><p>跟 ZooKeeper 的其他节点操作一样，multiop也提供了异步的版本，通过返回码判断执行结果，不用去捕获处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * multi 事务异步操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncMultiOpTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 回调函数</span><br>    <span class="hljs-comment">// ctx 是multi 方法传入的</span><br>    AsyncCallback.<span class="hljs-type">MultiCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> (rc, path, ctx, opResults) -&gt; &#123;<br>        <span class="hljs-keyword">switch</span> (KeeperException.Code.get(rc)) &#123;<br>            <span class="hljs-keyword">case</span> OK:<br>                System.out.println(String.format(<span class="hljs-string">&quot;节点%s删除成功&quot;</span>, path));<br>            <span class="hljs-keyword">case</span> CONNECTIONLOSS:<br>                System.out.println(<span class="hljs-string">&quot;连接丢失&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> NONODE:<br>                System.out.println(<span class="hljs-string">&quot;NoNode Error!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;Error when trying to delete node: &quot;</span> + KeeperException.create(KeeperException.Code.get(rc), path));<br>        &#125;<br>    &#125;;<br><br>    zkClient.multi(Arrays.asList(<br>                    Op.delete(<span class="hljs-string">&quot;/a&quot;</span>, -<span class="hljs-number">1</span>),<br>                    Op.delete(<span class="hljs-string">&quot;/b&quot;</span>, -<span class="hljs-number">1</span>),<br>        		   Op.delete(<span class="hljs-string">&quot;/c&quot;</span>, -<span class="hljs-number">1</span>),<br>            ),<br>            callback,<br>            <span class="hljs-literal">null</span><br>    );<br><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="transaction"><a class="markdownIt-Anchor" href="#transaction"></a> Transaction</h4><p>ZooKeeper 的 Transaction 功能建立在 <code>multi</code> 操作之上，提供了一种灵活的方式来组织一组操作。在这个机制中，你可以在事务提交前随时添加新的操作到一个原子操作序列中。此外，你可以在不同的方法中构建事务，不受限于单一代码块。当准备好提交时，Transaction 支持同步（<code>commit</code>）和异步（<code>commitAsync</code>）两种提交方式，确保事务的一致性执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transactionTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> zooKeeper.transaction();<br>    t.create(<span class="hljs-string">&quot;/t1&quot;</span>, <span class="hljs-string">&quot;t1&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    t.create(<span class="hljs-string">&quot;/t2&quot;</span>, <span class="hljs-string">&quot;t2&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    t.create(<span class="hljs-string">&quot;/t3&quot;</span>, <span class="hljs-string">&quot;t3&quot;</span>.getBytes(StandardCharsets.UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    List&lt;OpResult&gt; results = t.commit();<br><br>    <span class="hljs-keyword">for</span> (OpResult result : results) &#123;<br>        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> OpResult.CreateResult) &#123;<br>            System.out.println(<span class="hljs-string">&quot;create success&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">异步处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTransactionTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 回调函数</span><br>    AsyncCallback.<span class="hljs-type">MultiCallback</span> <span class="hljs-variable">callback</span> <span class="hljs-operator">=</span> (rc, path, ctx, opResults) -&gt; &#123;<br>        <span class="hljs-keyword">switch</span> (KeeperException.Code.get(rc)) &#123;<br>            <span class="hljs-keyword">case</span> OK:<br>                System.out.println(<span class="hljs-string">&quot;事务执行成功&quot;</span>);<br>            <span class="hljs-keyword">case</span> CONNECTIONLOSS:<br>                System.out.println(<span class="hljs-string">&quot;连接丢失&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> NONODE:<br>                System.out.println(<span class="hljs-string">&quot;NoNode Error!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;Error when trying to delete node: &quot;</span> + KeeperException.create(KeeperException.Code.get(rc), path));<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> zooKeeper.transaction();<br>    t.delete(<span class="hljs-string">&quot;/t1&quot;</span>, -<span class="hljs-number">1</span>)<br>            .delete(<span class="hljs-string">&quot;/t2&quot;</span>, -<span class="hljs-number">1</span>)<br>            .delete(<span class="hljs-string">&quot;/t3&quot;</span>, -<span class="hljs-number">1</span>);<br><br>    t.commit(callback, <span class="hljs-literal">null</span>);<br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务上下线"><a class="markdownIt-Anchor" href="#服务上下线"></a> 服务上下线</h2><p><img src="/2022/08/18/zookeeper/%E6%9C%8D%E5%8A%A1%E4%B8%8A%E4%B8%8B%E7%BA%BF%E7%9B%91%E5%90%AC.png" srcset="/img/loading.gif" lazyload alt></p><p>在分布式系统中，一个服务的节点可以有多台（比如Dubbo），可以动态上下线，任意一台客户端都能实时感知到服务节点的上下线</p><p class="note note-primary">服务端实现</p><ul><li>首先建立一个服务的永久节点</li><li>当节点上线则在服务节点下创建一个<code>临时节点</code>，节点的值存储服务器连接信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderTest</span> &#123;<br> <span class="hljs-comment">// 集群地址</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/server&quot;</span>;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">connectString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br> <span class="hljs-keyword">private</span> ZooKeeper zkClient;<br><br> <span class="hljs-meta">@SneakyThrows</span><br> <span class="hljs-meta">@BeforeEach</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>     zkClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, <span class="hljs-number">2000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br><br>         &#125;<br>     &#125;);<br><br>     <span class="hljs-comment">// 创建 /server 节点</span><br>     <span class="hljs-type">Stat</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> zkClient.exists(ROOT, <span class="hljs-literal">false</span>);<br>     <span class="hljs-keyword">if</span> (exists == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             zkClient.create(ROOT, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-comment">// 启动注册服务</span><br>     <span class="hljs-built_in">this</span>.register(<span class="hljs-string">&quot;provider&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br> &#125;<br><br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> serverName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String serverName, String ip, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s/%s&quot;</span>, ROOT, serverName);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s:%s&quot;</span>, ip, port);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">create</span> <span class="hljs-operator">=</span> zkClient.create(path, value.getBytes(StandardCharsets.UTF_8),<br>                ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>                CreateMode.EPHEMERAL);<br><br>        log.info(<span class="hljs-string">&quot;server &#123;&#125; is online&quot;</span>, serverName);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        log.info(<span class="hljs-string">&quot;启动服务...&quot;</span>);<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">服务端实现</p><ul><li>获取服务节点下的所有临时节点，并保存到本地服务列表</li><li>监听服务节点子节点变化，当服务节点的子节点发生变化时刷新本地服务列表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerTest</span> &#123;<br>    <span class="hljs-comment">// 集群地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/server&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">connectString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br>    <span class="hljs-keyword">private</span> ZooKeeper zkClient;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; serverList = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        zkClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, <span class="hljs-number">2000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span> &#123;<br>                log.info(<span class="hljs-string">&quot;path: &#123;&#125;&quot;</span>, event.getPath());<br><br>                <span class="hljs-comment">// 服务变更再次获取服务列表</span><br>                getServerList();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 服务启动获取服务列表</span><br>        getServerList();<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取远程服务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getServerList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1 获取服务器子节点信息，并且对父节点进行监听</span><br>        List&lt;String&gt; children = zkClient.getChildren(ROOT, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 2 存储服务器信息列表</span><br>        serverList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;(children);<br><br>        log.info(<span class="hljs-string">&quot;serverList: &#123;&#125;&quot;</span>, serverList);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getServer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(serverList)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;没有可用的服务&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> serverList.size();<br>        <span class="hljs-keyword">return</span> serverList.get((<span class="hljs-type">int</span>) (sequence.getAndIncrement() % len));<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>                log.info(<span class="hljs-string">&quot;执行业务&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> getServer();<br>                log.info(<span class="hljs-string">&quot;跨服务调用：调用服务：&#123;&#125;&quot;</span>, server);<br>                log.info(<span class="hljs-string">&quot;服务调用结束...&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分布式锁实现"><a class="markdownIt-Anchor" href="#分布式锁实现"></a> 分布式锁实现</h2><p>ZooKeeper 利用其临时顺序节点实现分布式锁，这种机制的优势在于其高可靠性：一旦持锁的服务意外宕机，ZooKeeper会自动删除那些与会话关联的临时节点，因此锁会被迅速释放。相比之下，基于Redis的分布式锁通常依赖于键的过期时间（TTL）来释放锁，如果服务在锁未释放时宕机，则需要等待TTL到期，这可能导致锁被持有超过必要的时间。</p><p>然而，ZooKeeper并不总是适用于高并发场景下的分布式锁。因为ZooKeeper的写操作需要经过集群中唯一的领导者（Leader）进行处理和复制到其他跟随者（Follower）节点，这限制了其在高写负载条件下的性能。如果写请求过于频繁，可能会成为系统性能的瓶颈。</p><p class="note note-primary">分布式锁实现</p><p><img src="/2022/08/18/zookeeper/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><strong><code>创建根节点</code></strong>：在ZooKeeper中创建一个持久的根节点<code>/locks</code>，作为所有分布式锁的父节点。</li><li><strong><code>请求锁</code></strong>：当一个客户端希望获得锁时，它在<code>/locks</code>节点下创建一个临时顺序节点，例如<code>/locks/lock_</code>。</li><li><strong><code>节点排序</code></strong>：客户端获取<code>/locks</code>下所有子节点，并按照节点编号排序。</li><li><strong><code>检查排名</code></strong>：客户端检查自己创建的临时顺序节点在所有子节点中的排序位置：<ul><li>如果是最小的节点，那么客户端获得锁。</li><li>如果不是，客户端找到比自己小的最近的一个节点，并在这个节点上设置监听。</li></ul></li><li><strong><code>锁等待</code></strong>：如果没有获得锁，客户端等待监听的节点变更（例如被删除），在变更发生时重新进行排名判断。</li><li><strong><code>锁的释放</code></strong>：一旦客户端完成其业务逻辑，它会删除自己的临时顺序节点，从而释放锁。</li><li><strong><code>监听触发</code></strong>：其他客户端的监听器会在它们监听的节点被删除时收到通知，然后这些客户端将重复步骤4和5来尝试获取锁。</li></ol><h3 id="原生-zookeeper-实现"><a class="markdownIt-Anchor" href="#原生-zookeeper-实现"></a> 原生 Zookeeper 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分布式锁接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DistributedLock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZookeeperLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistributedLock</span> &#123;<br>    <span class="hljs-comment">// 根节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/lock&quot;</span>;<br><br>    <span class="hljs-comment">// 使用ThreadLocal绑定当前线程与其所创建的节点信息</span><br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;String&gt; nodeInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 连接地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">connectString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>;<br><br>    <span class="hljs-comment">// 过期事件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sessionTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br><br>    <span class="hljs-comment">// 当前线程锁的路径</span><br>    <span class="hljs-keyword">private</span> String lockPath;<br><br>    <span class="hljs-comment">// zk客户端独享</span><br>    <span class="hljs-keyword">private</span> ZooKeeper zkClient;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ZookeeperLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lockPath = String.format(<span class="hljs-string">&quot;%s/%s&quot;</span>, ROOT, lockName);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 用于同步等待zk客户端连接服务端</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">connectedSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            zkClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(connectString, sessionTimeout, (Watcher) watchedEvent -&gt; &#123;<br>                <span class="hljs-comment">// 连接事件</span><br>                <span class="hljs-keyword">if</span> (watchedEvent.getState() == Watcher.Event.KeeperState.SyncConnected) &#123;<br>                    connectedSignal.countDown();<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">// 确保连接建立</span><br>            connectedSignal.await();<br><br>            <span class="hljs-comment">// 是否需要创建根节点</span><br>            <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zkClient.exists(ROOT, <span class="hljs-literal">false</span>);<br><br>            <span class="hljs-keyword">if</span> (stat == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 创建持久节点</span><br>                zkClient.create(ROOT, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建临时顺序节点</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">nodeName</span> <span class="hljs-operator">=</span> zkClient.create(lockPath, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>                    CreateMode.EPHEMERAL_SEQUENTIAL);<br><br>            <span class="hljs-comment">// 取出所有子节点</span><br>            List&lt;String&gt; subNodeList = zkClient.getChildren(ROOT, <span class="hljs-literal">false</span>);<br><br>            TreeSet&lt;String&gt; subNodeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br><br>            subNodeList.forEach(node -&gt; subNodeSet.add(String.format(<span class="hljs-string">&quot;%s/%s&quot;</span>, ROOT, node)));<br><br>            <span class="hljs-comment">// 获取最小节点</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">smallNode</span> <span class="hljs-operator">=</span> subNodeSet.first();<br><br>            <span class="hljs-comment">// 获取当前节点的上一个节点</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> subNodeSet.lower(nodeName);<br><br>            <span class="hljs-comment">// 如果当前线程节点为最小节点，则表示获取锁</span><br>            <span class="hljs-keyword">if</span> (nodeName.equals(smallNode)) &#123;<br>                nodeInfo.set(nodeName);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">waitLockLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">// 注册当前节点的上个节点删除事件监听</span><br>            <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zkClient.exists(preNode, watchedEvent -&gt; &#123;<br>                <span class="hljs-keyword">if</span> (watchedEvent.getType() == Watcher.Event.EventType.NodeDeleted) &#123;<br>                    waitLockLatch.countDown();<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">// 判断比当前节点小的节点是否存在，不存在则获得锁</span><br>            <span class="hljs-keyword">if</span> (stat != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 阻塞主线程，等待上一个节点删除后唤醒线程</span><br>                waitLockLatch.await();<br>                nodeInfo.set(nodeName);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">nodeName</span> <span class="hljs-operator">=</span> nodeInfo.get();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断当前线程是否已上锁（在等待锁时不能解锁）</span><br>            <span class="hljs-keyword">if</span> (nodeName != <span class="hljs-literal">null</span>) &#123;<br>                zkClient.delete(nodeName, -<span class="hljs-number">1</span>);<br>                nodeInfo.remove();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">ZookeeperLock</span> <span class="hljs-variable">zookeeperLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZookeeperLock</span>(<span class="hljs-string">&quot;count&quot;</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    zookeeperLock.lock();<br>                    NUM++;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    zookeeperLock.unLock();<br>                    latch.countDown();<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        latch.await();<br>        log.info(<span class="hljs-string">&quot;NUM = &#123;&#125;&quot;</span>, NUM);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="curator-框架实现"><a class="markdownIt-Anchor" href="#curator-框架实现"></a> Curator 框架实现</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6984742386744164388">Curator使用手册</a></p><p>Curator是Netflix公司开源的一套zookeeper客户端框架，Curator是对Zookeeper支持最好的客户端框架。Curator封装了大部分Zookeeper的功能，比如Leader选举、分布式锁等，减少了技术人员在使用Zookeeper时的底层细节开发工作</p><p class="note note-primary">使用原生API存在的问题</p><ul><li>会话连接是异步的，需要自己去处理。比如使用 CountDownLatch</li><li>Watch 需要重复注册，不然就不能生效</li><li>开发的复杂性比较高</li><li>不支持多节点删除和创建。需要自己去递归</li></ul><p class="note note-primary">Curator主要实现了下面四种锁</p><ul><li>InterProcessMutex：分布式可重入排它锁</li><li>InterProcessSemaphoreMutex：分布式排它锁</li><li>InterProcessReadWriteLock：分布式读写锁</li><li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li></ul><p class="note note-primary">分布式可重入排他锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterProcessMutexTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockNode</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/lock&quot;</span>;<br>        <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(curatorFramework, lockNode);<br><br>        <span class="hljs-comment">// 多线程竞争锁</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取锁</span><br>                    lock.acquire();<br>                    log.info(<span class="hljs-string">&quot;线程：&#123;&#125; 获得分布式锁&quot;</span>, Thread.currentThread().getName());<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.release();<br>                        countDownLatch.countDown();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        countDownLatch.await();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">分布式排他锁</p><p>用法和 InterProcessMutex 一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterProcessSemaphoreMutexTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockNode</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/lock&quot;</span>;<br>        <span class="hljs-type">InterProcessSemaphoreMutex</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessSemaphoreMutex</span>(curatorFramework, lockNode);<br><br>        <span class="hljs-comment">// 多线程竞争锁</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取锁</span><br>                    lock.acquire();<br>                    log.info(<span class="hljs-string">&quot;线程：&#123;&#125; 获得分布式锁&quot;</span>, Thread.currentThread().getName());<br>                    <span class="hljs-comment">// TimeUnit.MILLISECONDS.sleep(100);</span><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.release();<br>                        countDownLatch.countDown();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        countDownLatch.await();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">分布式读写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterProcessReadWriteLockTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">22</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockNode</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/lock&quot;</span>;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, lockNode);<br>        <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> lock.readLock();<br>        <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> lock.writeLock();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executorService.execute(() -&gt; tryLock(readLock, <span class="hljs-string">&quot;获取读锁&quot;</span>, countDownLatch));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            executorService.execute(() -&gt; tryLock(writeLock, <span class="hljs-string">&quot;获取写锁&quot;</span>, countDownLatch));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executorService.execute(() -&gt; tryLock(readLock, <span class="hljs-string">&quot;获取读锁&quot;</span>, countDownLatch));<br>        &#125;<br><br>        countDownLatch.await();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(InterProcessMutex lock, String msg, CountDownLatch countDownLatch)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.acquire();<br>            log.info(<span class="hljs-string">&quot;线程：&#123;&#125; 获取&#123;&#125;&quot;</span>, Thread.currentThread().getName(), msg);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.release();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">分布式锁容器</p><p>curator实现了一个类似容器的锁<code>InterProcessMultiLock</code>，它可以把多个锁包含起来像一个锁一样进行操作，简单来说就是对多个锁进行一组操作。当acquire的时候就获得多个锁资源，否则失败。当release时候释放所有锁资源，不过如果其中一把锁释放失败将会被忽略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterProcessMultiLockTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockNode1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/lock1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockNode2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/lock2&quot;</span>;<br>        <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(curatorFramework, lockNode1);<br>        <span class="hljs-type">InterProcessSemaphoreMutex</span>  <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessSemaphoreMutex</span>(curatorFramework, lockNode2);<br><br>        <span class="hljs-comment">// 锁容器，合并多个锁</span><br>        <span class="hljs-type">InterProcessMultiLock</span> <span class="hljs-variable">multiLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMultiLock</span>(Arrays.asList(lock1, lock2));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executorService.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    multiLock.acquire();<br>                    log.info(<span class="hljs-string">&quot;线程：&#123;&#125; 获取锁&quot;</span>, Thread.currentThread().getName());<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        multiLock.release();<br>                        countDownLatch.countDown();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        countDownLatch.await();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="底层原理"><a class="markdownIt-Anchor" href="#底层原理"></a> 底层原理</h2><h3 id="持久化机制"><a class="markdownIt-Anchor" href="#持久化机制"></a> 持久化机制</h3><p>ZooKeeper将所有的数据存储在一个内存中的数据结构称为 <code>Data Tree</code> 中。这允许快速的读取操作，因为所有的数据都在内存中。但为了持久化和恢复，ZooKeeper使用了以下机制来保存数据到磁盘。</p><p class="note note-primary">事务日志</p><p><img src="/2022/08/18/zookeeper/%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97.png" srcset="/img/loading.gif" lazyload alt></p><p>每当ZooKeeper的数据发生变化时（例如，创建、删除或更新znodes），这些变化都会作为一个事务写入到事务日志中。事务日志是ZooKeeper保持数据一致性的关键，允许它在崩溃后重新构建数据状态。</p><p class="note note-primary">数据快照</p><p><img src="/2022/08/18/zookeeper/%E6%95%B0%E6%8D%AE%E5%BF%AB%E7%85%A7.png" srcset="/img/loading.gif" lazyload alt></p><p>为了减少磁盘I/O，ZooKeeper周期性地将整个Data Tree的状态保存到磁盘上的快照文件中。快照包含了在特定时间点上所有znodes的数据和状态信息。</p><div class="note note-warning"><p>zk通过两种形式的持久化，在恢复时先全量恢复快照文件中的数据到内存中，再用日志文件中的数据做增量恢复，这样的恢复速度更快。</p></div><h3 id="读流程"><a class="markdownIt-Anchor" href="#读流程"></a> 读流程</h3><p><code>集群中任意节点都是可读的</code></p><p><img src="/2022/08/18/zookeeper/%E9%9B%86%E7%BE%A4%E8%AF%BB%E6%93%8D%E4%BD%9C.png" srcset="/img/loading.gif" lazyload alt></p><p>遵循 <code>BASE</code> 理论</p><ul><li><strong><code>请求发送</code></strong>：客户端可以向集群中的任何服务器（ <code>Leader</code>、<code>Follower</code> 或 <code>Observer</code> ）发送读取请求。</li><li><strong><code>本地读取</code></strong>：接收请求的ZooKeeper服务器将直接在本地数据副本上执行读取操作。因为ZooKeeper集群中的数据是一致的，没有分片，每个服务器都包含完整的数据集。</li><li><strong><code>最终一致性</code></strong>：尽管每个服务器都保存有全量数据，但由于Zab协议的事务处理方式，集群可能存在一个时间窗口的数据不一致，但经过一段时间数据同步或，保证最终一致性。</li></ul><h3 id="zab协议"><a class="markdownIt-Anchor" href="#zab协议"></a> Zab协议</h3><p>ZooKeeper 是一个为分布式应用提供协调服务的关键系统，通常部署多节点集群以确保高可用性。集群中的节点可以扮演领导者（Leader）、跟随者（Follower）或观察者（Observer）的角色。领导者处理所有的写请求，确保数据的一致性，而跟随者和观察者则参与读请求和状态的复制。</p><p>ZooKeeper 通过实现 ZAB（ZooKeeper Atomic Broadcast）协议来维护集群数据的一致性。ZAB 协议是特别为ZooKeeper设计的，以确保即使在领导者更换或系统崩溃后也能够保持数据的一致性。ZAB协议负责：</p><ul><li><p><code>消息广播</code>：ZAB 保证所有的写操作，如创建、更新或删除数据节点等事务性请求，都按照全局一致的顺序被应用到每一个服务器上，从而保持整个集群的一致性。</p></li><li><p><code>状态恢复</code>：当一个新的服务器节点加入集群，或者一个已有的服务器节点在崩溃后重新加入集群时，ZAB 保证这个节点能够与当前领导者同步，获得最新的系统状态。</p></li><li><p><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#zab%E7%AE%80%E4%BB%8B">Zab 协议简介</a></p></li><li><p><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#%E5%8E%9F%E5%AD%90%E5%B9%BF%E6%92%AD">原子广播</a></p></li><li><p><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D">崩溃恢复</a></p><ul><li><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#%E9%9B%86%E7%BE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%89%E4%B8%BE">集群初始化选举</a></li><li><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E9%80%89%E4%B8%BE">运行期间选举</a></li></ul></li></ul><h3 id="为什么集群节点推荐奇数"><a class="markdownIt-Anchor" href="#为什么集群节点推荐奇数"></a> 为什么集群节点推荐奇数</h3><ol><li><p><code>最大化容错能力</code></p><p>奇数节点集群能够在不增加冗余节点的同时，最大化容错能力。例如，有3个节点的集群可以容忍1个节点失败。一个有4个节点的集群也只能容忍1个节点失败。</p></li><li><p><code>避免脑裂</code></p><p>脑裂是指集群在网络分区发生时分成两个独立的部分，每部分都可能独自做出决策。奇数节点集群在分区发生时，不可能有两个等大的部分，这样就总有一个部分能够维持多数派，从而保持集群的正常运作。</p></li><li><p><code>决策效率</code></p><p>在进行领导者选举或其他需要多数派同意的操作时，奇数节点集群能更快地达成决策，因为不会出现票数相等的情况，从而避免了决策的延迟。</p></li></ol><h3 id="zk中的nio"><a class="markdownIt-Anchor" href="#zk中的nio"></a> ZK中的NIO</h3><p><img src="/2022/08/18/zookeeper/NIO.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="zk追求的模型"><a class="markdownIt-Anchor" href="#zk追求的模型"></a> ZK追求的模型</h3><p>遵循 <a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#base%E7%90%86%E8%AE%BA">BASE理论</a></p><p>ZooKeeper选择优先保证一致性（C）和分区容错性（P），在网络分区发生时，它会牺牲一部分可用性以保持一致性。这里的一致性是指线性一致性或顺序一致性，意味着系统保证一旦更新操作完成，所有后续的读操作都将返回该更新的值，形成一个全局一致的操作顺序。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>zookeeper</div><div>https://wugengfeng.cn/2022/08/18/zookeeper/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年8月18日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/09/26/MAT%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/" title="MAT中文文档"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MAT中文文档</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/07/13/dubbo3/" title="dubbo3"><span class="hidden-mobile">dubbo3</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>