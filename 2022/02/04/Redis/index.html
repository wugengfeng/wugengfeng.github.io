<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="思维导图  前言 文章源码  NoSql NoSQL（Not Only SQL）数据库主要指在设计上不遵循传统关系型数据库的模式。它包括了一系列不同类型的数据存储方式，不仅仅局限于简单的 key-value 存储模型。NoSQL 数据库的类型包括文档型、列存储、图形数据库等。   不遵循 SQL 标准。   大多不支持 ACID事务。   特定领域远超于 SQL 的性能。   适用场景  高并发读"><meta property="og:type" content="article"><meta property="og:title" content="Redis"><meta property="og:url" content="https://wugengfeng.cn/2022/02/04/Redis/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="思维导图  前言 文章源码  NoSql NoSQL（Not Only SQL）数据库主要指在设计上不遵循传统关系型数据库的模式。它包括了一系列不同类型的数据存储方式，不仅仅局限于简单的 key-value 存储模型。NoSQL 数据库的类型包括文档型、列存储、图形数据库等。   不遵循 SQL 标准。   大多不支持 ACID事务。   特定领域远超于 SQL 的性能。   适用场景  高并发读"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/redis.png"><meta property="article:published_time" content="2022-02-04T09:33:58.000Z"><meta property="article:modified_time" content="2023-12-06T04:01:06.190Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/redis.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>Redis - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Redis"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-02-04 17:33" pubdate>2022年2月4日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 101k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 842 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Redis</h1><div class="markdown-body"><p><a target="_blank" rel="noopener" href="https://www.mubu.com/doc/usUYfiHWaO">思维导图</a></p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p><a target="_blank" rel="noopener" href="https://github.com/wugengfeng/redis-example">文章源码</a></p><h3 id="nosql"><a class="markdownIt-Anchor" href="#nosql"></a> NoSql</h3><p>NoSQL（Not Only SQL）数据库主要指在设计上不遵循传统关系型数据库的模式。它包括了一系列不同类型的数据存储方式，不仅仅局限于简单的 key-value 存储模型。NoSQL 数据库的类型包括文档型、列存储、图形数据库等。</p><ul><li><p>不遵循 SQL 标准。</p></li><li><p>大多不支持 ACID事务。</p></li><li><p>特定领域远超于 SQL 的性能。</p></li></ul><p class="note note-primary">适用场景</p><ul><li>高并发读写处理能力</li><li>海量数据处理</li><li>数据的高可扩展性</li></ul><p class="note note-primary">不适用场景</p><ul><li><code>需要强事务支持的场景</code>： 对于那些需要严格的事务一致性和复杂事务管理的应用，NoSQL数据库可能不是最佳选择。虽然一些NoSQL数据库提供了一定程度的事务支持，但它们无法与传统的关系型数据库（如PostgreSQL或MySQL）相比，后者提供更全面、更复杂的事务管理能力，如ACID事务。</li><li><code>复杂SQL查询和结构化数据的场景</code>： NoSQL数据库通常不支持复杂的SQL查询和那些需要高度结构化和关联数据的应用场景。对于需要执行复杂的连接操作、子查询、存储过程和视图等SQL特性的场景，传统的关系型数据库是更合适的选择，因为它们原生支持这些功能，能多更好地处理复杂的数据关系和结构化查询。</li></ul><h3 id="redis是什么"><a class="markdownIt-Anchor" href="#redis是什么"></a> Redis是什么</h3><p>Redis（Remote Dictionary Server，远程字典服务器）是一个完全开源且免费的、用C语言编写的基于内存的高性能键值（Key/Value）存储系统。遵循BSD协议，Redis不仅作为分布式内存数据库获得广泛应用，同时也是支持持久化的NoSQL数据库。由于其灵活的数据结构和高效的性能，Redis被广泛认为是当前最受欢迎的NoSQL数据库之一，并常被称作数据结构服务器。</p><p>Redis与其他KV系统相比具有以下独特特点：</p><ul><li><code>数据持久化</code>：Redis支持将内存中的数据持久化到磁盘中，通过RDB（快照）或AOF（追加文件）两种方式实现。这使得Redis在重启后能够重新加载并使用之前的数据。</li><li><code>丰富的数据类型</code>：不同于普通的键值存储，Redis提供了多种数据结构，如列表（list）、集合（set）、有序集合（zset）、散列（hash）等，增强了其存储和处理数据的灵活性。</li><li><code>数据备份和主从复制</code>：Redis支持数据备份，以及通过主从（master-slave）模式实现数据的复制。这增强了数据的可用性和容错能力，使Redis在分布式系统中更为可靠。</li></ul><h3 id="redis能做什么"><a class="markdownIt-Anchor" href="#redis能做什么"></a> Redis能做什么</h3><ul><li><code>缓存系统</code>：使用Redis作为数据缓存，减少数据库的读取压力，提高系统响应速度。这是Redis最常见的用途之一。</li><li><code>序列生成器</code>：用于构建分布式系统下全局唯一的序列号。</li><li><code>分布式锁</code>：在多个进程或服务间同步资源访问时，Redis可以用作分布式锁的实现工具。</li><li><code>分布式任务队列</code>：在多个服务间分配任务，当没任务时线程阻塞。</li><li><code>排行榜/计分板</code>：使用Redis的有序集合（Sorted Sets），可以方便地实现排行榜或计分板等功能。</li><li><code>实时计数器</code>：Redis的原子操作特性使其适合于实现如网站访问量、在线用户数等实时计数功能。</li><li><code>地理空间数据处理</code>：Redis的Geo类型支持地理空间数据的存储和查询，适用于地理位置服务。</li></ul><h3 id="redis为什么这么快"><a class="markdownIt-Anchor" href="#redis为什么这么快"></a> Redis为什么这么快</h3><p><code>高性能服务器并非必须依赖多线程</code>：经常存在一个误区，认为高性能服务器一定需要通过多线程来实现。其实并不一定，首先需要明确，对于CPU、内存和硬盘的速度和工作机制有基本的了解是非常重要的，服务器的性能不仅仅取决于是否采用多线程。</p><p><code>多线程不一定比单线程更高效</code>：另一个误解是多线程在所有情况下都比单线程更有效率。<span class="green-line">实际上，多线程编程涉及复杂性和额外的性能开销，如线程管理和上下文切换。</span>而单线程模型，通过避免这些问题，在特定情况下可以提供更优的性能。</p><ol><li><code>内存存储</code>：Redis将所有数据保存在内存中，内存访问速度远快于磁盘。这种内存中数据处理机制使得Redis能够提供极快的数据读写速度。</li><li><code>单线程架构</code>：虽然Redis是单线程的，但这恰恰使其避免了常见的多线程编程问题，如线程间的上下文切换和锁竞争。单线程也意味着在处理请求时几乎没有任何内存锁定的开销。</li><li><code>I/O多路复用</code>：Redis使用非阻塞I/O多路复用技术（线程模型）。这意味着Redis可以在单个线程中同时处理多个网络连接，提高I/O操作的效率。</li></ol><p>Redis单实例理论QPS为 8W (来源：阿里云redis 参考值)</p><h2 id="五大基础数据类型"><a class="markdownIt-Anchor" href="#五大基础数据类型"></a> 五大基础数据类型</h2><p><a target="_blank" rel="noopener" href="https://www.redis.net.cn/tutorial/3501.html">文档来源</a></p><h3 id="key"><a class="markdownIt-Anchor" href="#key"></a> key</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3528.html"><code>DEL key</code></a> 该命令用于在 key 存在时删除 key。</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.com.cn/commands/unlink.html"><code>UNLINK key</code></a> 非阻塞删除Key，异步删除</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3529.html"><code>DUMP key</code></a> 序列化给定 key ，并返回被序列化的值。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3530.html"><code>EXISTS key</code></a> 检查给定 key 是否存在。</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3531.html"><code>EXPIRE key</code></a> seconds 为给定 key 设置过期时间。</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3532.html"><code>EXPIREAT key timestamp</code></a> EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3533.html"><code>PEXPIRE key milliseconds</code></a> 设置 key 的过期时间以毫秒计。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3534.html"><code>PEXPIREAT key milliseconds-timestamp</code></a> 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3535.html"><code>KEYS pattern</code></a> 查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3536.html"><code>MOVE key db</code></a> 将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3537.html"><code>PERSIST key</code></a> 移除 key 的过期时间，key 将持久保持。</strong></td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3538.html"><code>PTTL key</code></a> 以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3539.html"><code>TTL key</code></a> 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</strong></td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3540.html"><code>RANDOMKEY</code></a> 从当前数据库中随机返回一个 key 。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3541.html"><code>RENAME key newkey</code></a> 修改 key 的名称</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3542.html"><code>RENAMENX key newkey</code></a> 仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3543.html"><code>TYPE key</code></a> 返回 key 所储存的值的类型。</strong></td></tr></tbody></table><p class="note note-primary">数据库</p><table><thead><tr><th>序号</th><th>命令</th></tr></thead><tbody><tr><td><a target="_blank" rel="noopener" href="https://www.redis.com.cn/commands/select.html"><code>SELECT index</code></a></td><td>切换数据库</td></tr><tr><td><a target="_blank" rel="noopener" href="http://redisdoc.com/database/dbsize.html"><code>DBSIZE</code></a></td><td>返回当前数据库的 key 的数量</td></tr><tr><td><a target="_blank" rel="noopener" href="http://redisdoc.com/database/flushdb.html"><code>FLUSHDB</code></a></td><td>清空当前数据库中的所有 key</td></tr><tr><td><a target="_blank" rel="noopener" href="http://redisdoc.com/database/flushall.html"><code>FLUSHALL</code></a></td><td>清空整个 Redis 服务器的数据(删除所有数据库的所有 key )</td></tr><tr><td><a target="_blank" rel="noopener" href="http://redisdoc.com/database/sort.html"><code>SORT</code></a></td><td>返回或保存给定列表、集合、有序集合 <code>key</code> 中经过排序的元素</td></tr></tbody></table><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><p>Redis中的字符串（String）类型是最基本且广泛使用的数据结构。在内部，这种类型的数据实际上是以 <code>字节数组</code>（byte array）的形式存储的。这意味着字符串在Redis中不仅可以存储文本，还可以存储任何形式的二进制数据，比如图片或序列化的对象。</p><p><img src="/2022/02/04/Redis/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="http://redisdoc.com/string/set.html"><code>SET key value [EX seconds] [PX milliseconds] [NX]</code></a> 设置指定 key 的值</strong><br>EX: 过期时间：秒<br>PX: 过期时间：毫秒<br>NX: 不存在才设置成功</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3545.html"><code>GET key</code></a> 获取指定 key 的值。</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3546.html"><code>GETRANGE key start end</code></a> 返回 key 中字符串值的子字符</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3547.html"><code>GETSET key value</code></a> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3548.html"><code>GETBIT key offset</code></a> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3549.html"><code>MGET key1 [key2…]</code></a> 获取所有(一个或多个)给定 key 的值。</strong></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3550.html"><code>SETBIT key offset value</code></a> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3551.html"><code>SETEX key seconds value</code></a> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</strong></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3552.html"><code>SETNX key value</code></a> 只有在 key 不存在时设置 key 的值。</strong></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3553.html"><code>SETRANGE key offset value</code></a> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3554.html"><code>STRLEN key</code></a> 返回 key 所储存的字符串值的长度。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3555.html"><code>MSET key value [key value …]</code></a> 同时设置一个或多个 key-value 对。</strong></td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3556.html"><code>MSETNX key value [key value …]</code></a> 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3557.html"><code>PSETEX key milliseconds value</code></a> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3558.html"><code>INCR key</code></a> 将 key 中储存的数字值增一。</strong></td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3559.html"><code>INCRBY key increment</code></a> 将 key 所储存的值加上给定的增量值（increment） 。</strong></td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3560.html"><code>INCRBYFLOAT key increment</code></a> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3561.html"><code>DECR key</code></a> 将 key 中储存的数字值减一。</strong></td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3562.html"><code>DECRBY key decrement</code></a> key 所储存的值减去给定的减量值（decrement） 。</strong></td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3563.html"><code>APPEND key value</code></a> 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td></tr></tbody></table><div class="note note-primary"><p><strong>数据结构</strong></p><p><img src="/2022/02/04/Redis/%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SDS</span>&lt;</span>T&gt; &#123;<br>  T capacity; <span class="hljs-comment">// 数组容量</span><br>  T len; <span class="hljs-comment">// 数组长度</span><br>  byte flags; <span class="hljs-comment">// 特殊标识位</span><br>  byte[] content; <span class="hljs-comment">// 数组内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>String 的数据结构为简单动态字符串(Simple Dynamic String,缩写 <code>SDS</code>)。是可以修改的字符串，内部结构实现上类似于 Java的ArrayList。创建字符串时 <code>len</code> 和 <code>capacity</code> 一样长，不会多分配冗余空间。这是因为绝大多数场景下我们不会使用 <code>append</code> 操作来修改字符串。</p><p>当字符串较短时，<code>len</code> 和 <code>capacity</code> 字段可能使用较小的数据类型（如8位或16位整数）来存储，以节省内存，对于更长的字符串，这些字段会使用更大的数据类型（如32位或64位整数），因此SDS多种结构体。</p></div><div class="note note-primary"><p><strong>字符串扩容策略</strong></p><ul><li>小于1MB的字符串扩容每次是翻倍。</li><li>超过1MB的字符串，每次扩容将增加1MB空间。</li><li>字符串最大长度限制为512MB。</li></ul></div><div class="note note-primary"><p><strong>存储方式</strong></p><p><img src="/2022/02/04/Redis/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis对象，是Redis内部用于表示所有键值数据的基础数据结构。这个对象不仅用于字符串，还用于列表、集合、哈希表等所有Redis支持的数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RedisObject</span> &#123;</span><br>    int4 type; <span class="hljs-comment">// 4bits</span><br>    int4 encoding; <span class="hljs-comment">// 4bits</span><br>    int24 lru; <span class="hljs-comment">// 24bits</span><br>    int32 refcount; <span class="hljs-comment">// 4bytes</span><br>    <span class="hljs-type">void</span> *ptr; <span class="hljs-comment">// 8bytes，64-bit system</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><ul><li><code>Emb</code>（嵌入式）<ul><li>String小于 <code>44</code> 字节。</li><li>字符串数据直接存储在Redis对象的内部，避免了额外的内存分配。</li></ul></li><li><code>Raw</code>（原始式）<ul><li>Redis对象包含元数据。</li><li>字符串数据（SDS）存储在对象之外的单独内存区域，需要额外的内存分配。</li></ul></li></ul><p>内存分配最多可以给 RedisObject 分配到64字节，去掉RedisObject本身元数据占用剩下45个字节，因为字符串是以 ‘\0’ 结尾，所以剩下 44 字节。</p></div><p class="note note-primary">简单分布式锁</p><p><img src="/2022/02/04/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3><p><img src="/2022/02/04/Redis/List.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边) 或者尾部(右边)。</p><p><code>主要特点</code></p><ol><li><code>自然顺序</code>：List中的元素按照插入的顺序排列。</li><li><code>双端</code>：可以在列表的头部或尾部添加或删除元素。</li><li><code>元素可重复</code>：List中的元素可以重复，即同一个值可以出现多次。</li><li><code>自动删除</code>：当列表没有元素自动删除。</li><li><code>可用于实现队列和栈</code></li></ol><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3577.html"><code>BLPOP key1 [key2 ] timeout</code></a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3578.html"><code>BRPOP key1 [key2 ] timeout</code></a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3579.html"><code>BRPOPLPUSH source destination timeout</code></a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3580.html"><code>LINDEX key index</code></a> 通过索引获取列表中的元素</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3581.html">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3582.html"><code>LLEN key</code></a> 获取列表长度</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3583.html"><code>LPOP key</code></a> 移出并获取列表的第一个元素</strong></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3584.html"><code>LPUSH key value1 [value2]</code></a> 将一个或多个值插入到列表头部</strong></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3585.html"><code>LPUSHX key value</code></a> 将一个或多个值插入到已存在的列表头部</strong></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3586.html"><code>LRANGE key start stop</code></a> 获取列表指定范围内的元素</strong></td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3587.html"><code>LREM key count value</code></a> 移除列表元素</strong></td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3588.html"><code>LSET key index value</code></a> 通过索引设置列表元素的值</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3589.html"><code>LTRIM key start stop</code></a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td style="text-align:left">1<strong>4</strong></td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3590.html"><code>RPOP key</code></a> 移除并获取列表最后一个元素</strong></td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3591.html"><code>RPOPLPUSH source destination</code></a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</strong></td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3592.html"><code>RPUSH key value1 [value2]</code></a> 在列表中添加一个或多个值</strong></td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3593.html"><code>RPUSHX key value</code></a> 为已存在的列表添加值</strong></td></tr></tbody></table><div class="note note-primary"><p><strong>数据结构</strong></p><p><img src="/2022/02/04/Redis/list%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <code>zipList</code>，也即是压缩列表，它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 <code>quickList</code> (快速链表)。</p><p><strong>zipList 转 quickList</strong></p><p>注意：这两个条件是可以修改的，在 redis.conf 中</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">list-max-ziplist-value</span> <span class="hljs-string">64</span> <br><span class="hljs-built_in">list-max-ziplist-entries</span> <span class="hljs-string">512</span> <br></code></pre></td></tr></table></figure><ul><li>试图往列表新添加一个字符串值，且这个字符串的长度超过 server.list_max_ziplist_value （默认值为 64 ）</li><li>ziplist 包含的节点超过 server.list_max_ziplist_entries （默认值为 512 ）</li></ul></div><div class="note note-primary"><p><strong>zipList</strong></p><p>压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。</p><p><img src="/2022/02/04/Redis/%E5%8E%8B%E7%BC%A9%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ziplist</span>&lt;</span>T&gt; &#123;<br>    int32 zlbytes; <span class="hljs-comment">// 整个压缩列表占用字节数</span><br>    int32 zltail_offset; <span class="hljs-comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span><br>    int16 zllength; <span class="hljs-comment">// 元素个数</span><br>    T[] entries; <span class="hljs-comment">// 元素内容列表，挨个挨个紧凑存储</span><br>    int8 zlend; <span class="hljs-comment">// 标志压缩列表的结束，值恒为 0xFF</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> &#123;</span><br>    <span class="hljs-type">int</span>&lt;var&gt; prevlen; <span class="hljs-comment">// 前一个 entry 的字节长度</span><br>    <span class="hljs-type">int</span>&lt;var&gt; encoding; <span class="hljs-comment">// 元素类型编码</span><br>    optional byte[] content; <span class="hljs-comment">// 元素内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>压缩列表为了支持双向遍历，所以才会有 <code>ztail_offset</code> 这个字段，用来快速定位到最后一个元素，然后倒着遍历。</p><p>Redis的压缩链表是一种内存高效的数据结构，主要用于存储较小的元素集合。它的特殊之处在于它不使用传统的链表结构，即没有为每个元素维护前驱和后继指针（prev和next）。相反，<span class="green-line">它通过存储每个元素（entry）的长度来定位元素，这样可以减少所需的存储空间。</span></p><p><strong>原理</strong></p><ul><li>访问下一个元素，程序简单地将当前元素的长度加到当前元素的指针上。</li><li>访问前一个元素，程序则将前一个元素的长度从当前元素的指针上减去。</li></ul><p>在集合元素较少时，通过元素长度定位元素，避免存储前驱和后继指针带来的内存开销，是一种 <code>时间换空间</code> 的做法。</p></div><div class="note note-primary"><p><strong>quickList</strong></p><ul><li>快速链表是由多个压缩列表（ziplists）组成的双向链表。</li><li>每个节点（ziplist）包含了列表的一部分元素。</li></ul><p><strong>为什么从压缩链表转向快速链表</strong></p><ul><li><p>提高性能：大的压缩链表在扩容时效率更低。</p></li><li><p>灵活性：拆分小的压缩列表在数据插入和删除时更具备灵活性。</p></li><li><p>减少了对大量连续内存的需求。</p></li></ul><p><img src="/2022/02/04/Redis/%E5%BF%AB%E9%80%9F%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ziplist</span> &#123;</span><br>    ...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ziplist_compressed</span> &#123;</span><br>    int32 size;<br>    byte[] compressed_data;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    quicklistNode* prev;<br>    quicklistNode* next;<br>    ziplist* zl; <span class="hljs-comment">// 指向压缩列表</span><br>    int32 size; <span class="hljs-comment">// ziplist 的字节总数</span><br>    int16 count; <span class="hljs-comment">// ziplist 中的元素数量</span><br>    int2 encoding; <span class="hljs-comment">// 存储形式 2bit，原生字节数组还是 LZF 压缩存储</span><br>    ...<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    quicklistNode* head;<br>    quicklistNode* tail;<br>    <span class="hljs-type">long</span> count; <span class="hljs-comment">// 元素总数</span><br>    <span class="hljs-type">int</span> nodes; <span class="hljs-comment">// ziplist 节点的个数</span><br>    <span class="hljs-type">int</span> compressDepth; <span class="hljs-comment">// LZF 算法压缩深度</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/12624691.html">快速链表插入、查找操作</a></p><p>为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 <code>LZF</code> 算法压缩，可以选择压缩深度。</p></div><p class="note note-primary">任务队列实现</p><p><img src="/2022/02/04/Redis/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3><p><em><strong>Set</strong></em> 对外提供的功能与 <em><strong>List</strong></em> 类似列表的功能，特殊之处在于 <em><strong>Set</strong></em> 是可以 <strong><u>自动排重</u></strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<em><strong>Set</strong></em> 是一个很好的选择，并且 <em><strong>Set</strong></em> 提供了判断某个成员是否在一个 <em><strong>Set</strong></em> 集合内的重要接口，这个也是 <em><strong>List</strong></em> 所不能提供的。</p><ul><li><code>随机获取</code></li><li><code>去重</code></li><li><code>无序</code></li><li><code>交集</code></li><li><code>并集</code></li><li><code>差集</code></li></ul><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3594.html"><code>SADD key member1 [member2]</code></a> 向集合添加一个或多个成员</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3595.html"><code>SCARD key</code></a> 获取集合的成员数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3596.html"><code>SDIFF key1 [key2]</code></a> 返回给定所有集合的差集</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3597.html"><code>SDIFFSTORE destination key1 [key2]</code></a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3598.html"><code>SINTER key1 [key2]</code></a> 返回给定所有集合的交集</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3599.html"><code>SINTERSTORE destination key1 [key2]</code></a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3600.html"><code>SISMEMBER key member</code></a> 判断 member 元素是否是集合 key 的成员</strong></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3601.html"><code>SMEMBERS key</code></a> 返回集合中的所有成员</strong></td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3602.html"><code>SMOVE source destination member</code></a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3603.html"><code>SPOP key</code></a> 移除并返回集合中的一个随机元素</strong></td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3604.html"><code>SRANDMEMBER key [count]</code></a> 返回集合中一个或多个随机数</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3605.html"><code>SREM key member1 [member2]</code></a> 移除集合中一个或多个成员</strong></td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3606.html"><code>SUNION key1 [key2]</code></a> 返回所有给定集合的并集</strong></td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3607.html"><code>SUNIONSTORE destination key1 [key2]</code></a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3608.html"><code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></a> 迭代集合中的元素</td></tr></tbody></table><div class="note note-primary"><p><strong>数据结构</strong></p><p>Redis的 set 底层使用了 intset 和 hashtable 两种数据结构存储。</p><p><code>Intset</code>（整数集合）</p><p><code>使用条件</code>：</p><ul><li>当所有元素都是 <code>整数</code> 且集合元素少于 512，Redis使用<code>intset</code>。</li><li><code>intset</code>本质上就是一个数组，用于高效地存储整数值。</li></ul><p><code>特点</code>：</p><ul><li>内存效率：对于小整数集合，<code>intset</code>非常节省内存。</li><li>性能：操作<code>intset</code>通常比操作哈希表快，尤其是在集合较小的情况下。</li><li>插入元素时，通过二分查找法确保元素唯一。</li></ul></div><div class="note note-primary"><p><strong>intset</strong></p><p><img src="/2022/02/04/Redis/intset.png" srcset="/img/loading.gif" lazyload alt></p><p>intset是一个由 <code>整数</code> 组成的 <code>有序</code> 集合，从而便于在上面进行 <code>二分查找</code>，用于快速地判断一个元素是否属于这个集合。主要就是针对整数型的小集合进行性能优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>	<span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">// 编码类型 int_16t、int_32t、int_64t</span><br>	<span class="hljs-type">uint32_t</span> length;   <span class="hljs-comment">// 元素数量</span><br>	<span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">// 元素数组</span><br>&#125;intset;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))   <span class="hljs-comment">//16位，2个字节，表示范围-32,768~32,767</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))   <span class="hljs-comment">//32位，4个字节，表示范围-2,147,483,648~2,147,483,647</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))   <span class="hljs-comment">//64位，8个字节，表示范围-9,223,372,036,854,775,808~9,223,372,036,854,775,807</span></span><br></code></pre></td></tr></table></figure><p><strong>intset 升级与降级</strong><br>比如一开始set存储的是int16_t类型的数据, 但是当我们添加了一个int32_t类项的数据时，就需要操作升级。</p><p>根据新元素的类型, 扩展底层元素的空间, 并为新元素分配空间将现有的元素都转为新的元素类型, 并存储在正确的空间上面将新元素添加进数组内，不支持降级。</p><p><strong>为什么不使用 zipList</strong></p><p>Set需要对自身元素进行去重，HashTable和数组（二分查找）能提供更高效的排重性能。zipList的优势是少量集合内存使用效率高。</p></div><div class="note note-primary"><p><strong>Dict 字典</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>	<span class="hljs-comment">// 指向 dictType 结构的指针（dictType 结构保存的是操作特定类型键值对的函数）</span><br>    dictType *type;<br>    <span class="hljs-comment">// 保存上述所说函数的参数</span><br>    <span class="hljs-type">void</span> *privdata;<br>    <span class="hljs-comment">// 哈希表，2个hash table，一个新的与一个旧的</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// rehash 索引，rehash 不进行时值为 -1 </span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-comment">// 正在运行的迭代器数量</span><br>    <span class="hljs-type">int</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><p>类似 Java 的HashMap，存储使用到Key，Value为空。</p><p><strong>特点</strong>：</p><ul><li>灵活性：可以存储任意类型的元素，包括字符串和复杂对象。</li><li>扩展性：适用于较大的集合，哈希表的性能优于 intset。</li></ul></div><p class="note note-primary">文章关注共同好友实现(取交集)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">## 文章关注人<br>sadd article zhangsan lisi wangwu luliu chenqi<br><br>## 我的好友<br>sadd friend zhangsan wangwu<br><br>## 文章共同关注好友<br>sinter article friend<br></code></pre></td></tr></table></figure><p class="note note-primary">抽奖系统</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">## 初始化奖品  1 一等奖，2 二等奖，3 三等奖，&lt;3 谢谢惠顾</span><br><span class="hljs-attribute">sadd</span> lottery <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">## 开始抽奖</span><br><span class="hljs-attribute">srandmember</span> lottery<br></code></pre></td></tr></table></figure><h3 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h3><p><code>特点</code>：<span class="green-line"><strong>Hash 是一个string类型的field和value的映射表，<code>hash特别适合用于存储对象</code></strong>。</span></p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3564.html"><code>HDEL key field1 [field2]</code></a> 删除一个或多个哈希表字段</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3565.html"><code>HEXISTS key field</code></a> 查看哈希表 key 中，指定的字段是否存在。</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3566.html"><code>HGET key field</code></a> 获取存储在哈希表中指定字段的值</strong></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3567.html"><code>HGETALL key</code></a> 获取在哈希表中指定 key 的所有字段和值</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3568.html"><code>HINCRBY key field increment</code></a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</strong></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3569.html"><code>HINCRBYFLOAT key field increment</code></a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3570.html"><code>HKEYS key</code></a> 获取所有哈希表中的字段</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3571.html"><code>HLEN key</code></a> 获取哈希表中字段的数量</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3572.html"><code>HMGET key field1 [field2]</code></a> 获取所有给定字段的值</strong></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3573.html"><code>HMSET key field1 value1 [field2 value2 ]</code></a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</strong></td></tr><tr><td style="text-align:left"><strong>11</strong></td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3574.html"><code>HSET key field value</code></a> 将哈希表 key 中的字段 field 的值设为 value 。</strong></td></tr><tr><td style="text-align:left">1<strong>2</strong></td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3575.html"><code>HSETNX key field value</code></a> 只有在字段 field 不存在时，设置哈希表字段的值。</strong></td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3576.html"><code>HVALS key</code></a> 获取哈希表中所有值</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hashes-hscan.html"><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></a> 迭代哈希表中的键值对。</td></tr></tbody></table><div class="note note-primary"><p><strong>数据结构</strong></p><ul><li><p>zpiList</p><ul><li>元素个数小于hash-max-ziplist-entries 配置（默认 <code>512</code> 个）</li><li>所有值都小于hash-max-ziplist-value 配置（默认 <code>64</code> 字节）</li></ul></li><li><p>hashTable</p><p>元素过多或者value太长影响zipList性能时切换数据结构</p></li></ul></div><div class="note note-primary"><p><strong>zipList</strong></p><p><img src="/2022/02/04/Redis/hash_zipList.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>存储格式</code>：在 <code>ziplist</code> 中，Hash 被存储为字段和值的连续序列。首先是字段名，紧接着是对应的值，然后是下一个字段名，以此类推。</li><li><code>优化</code>：通过这种方式，<code>ziplist</code> 能够在保持良好读写性能的同时，显著减少内存使用。</li><li><code>自动转换</code>：当 <code>ziplist</code> 中的数据超过配置的阈值时，Redis 会自动将其转换为一个更标准的哈希表结构，以维持性能。</li></ul></div><div class="note note-primary"><p><strong>Dict 字典</strong></p><p><img src="/2022/02/04/Redis/hashTable.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span> &#123;<br>	<span class="hljs-comment">// 指向 dictType 结构的指针（dictType 结构保存的是操作特定类型键值对的函数）</span><br>    dictType *type;<br>    <span class="hljs-comment">// 保存上述所说函数的参数</span><br>    <span class="hljs-type">void</span> *privdata;<br>    <span class="hljs-comment">// 哈希表，2个hash表，一个新的与一个旧的</span><br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">// rehash 索引，rehash 不进行时值为 -1 </span><br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-comment">// 正在运行的迭代器数量</span><br>    <span class="hljs-type">int</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span><br>&#125; dict;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 哈希表结构</span><br><span class="hljs-comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictht</span> &#123;<br>	<span class="hljs-comment">// 哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">// 哈希表的大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-comment">// 哈希表的大小掩码（总是 size-1）</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>	<span class="hljs-comment">// 哈希表当前的已有结点数量</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> &#123;<br>	<span class="hljs-comment">// 键</span><br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-comment">// 指向下一个哈希表结点的指针</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dictEntry</span> *next;<br>&#125; dictEntry;<br><br></code></pre></td></tr></table></figure><p>当 <strong>哈希类型</strong> 无法满足 <code>ziplist</code> 的条件时，<code>Redis</code> 会使用 <code>hashtable</code> 作为 <strong>哈希</strong> 的 <strong>内部实现</strong>，因为此时 <code>ziplist</code> 的 <strong>读写效率</strong> 会下降。</p></div><p class="note note-primary">维护用户信息</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hmset wgf name wgf age <span class="hljs-number">18</span> <span class="hljs-keyword">address </span><span class="hljs-keyword">shenzhen</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 获取用户信息</span><br>hget wgf<br><br><span class="hljs-comment"># 维护年龄</span><br>hincrby wgf age <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 维护地址</span><br>hset wgf <span class="hljs-keyword">address </span>guangzhou<br></code></pre></td></tr></table></figure><h3 id="sorted-setz-set"><a class="markdownIt-Anchor" href="#sorted-setz-set"></a> Sorted Set（Z set）</h3><ul><li><code>成员唯一</code>：有序集合也是由字符串类型的元素组成的集合，其中每个成员都是唯一的，不允许重复。</li><li><code>关联双精度分数</code>：有序集合中的每个元素都会关联一个 double 类型的分数，作为排序的依据。</li><li><code>按分数排序</code>：Redis 通过这个分数来对集合中的成员进行从小到大的排序。</li><li><code>分数可重复，成员不重复</code>：尽管有序集合的成员是唯一的，但是不同的成员可以有相同的分数。</li></ul><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3609.html"><code>ZADD key score1 member1 [score2 member2]</code></a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3610.html"><code>ZCARD key</code></a> 获取有序集合的成员数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3611.html"><code>ZCOUNT key min max</code></a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3612.html"><code>ZINCRBY key increment member</code></a> 有序集合中对指定成员的分数加上增量 increment</strong></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3613.html"><code>ZINTERSTORE destination numkeys key [key ...]</code></a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3614.html"><code>ZLEXCOUNT key min max</code></a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3615.html"><code>ZRANGE key start stop [WITHSCORES]</code></a> 通过索引区间返回有序集合成指定区间内的成员</strong></td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3616.html"><code>ZRANGEBYLEX key min max [LIMIT offset count]</code></a> 通过字典区间返回有序集合的成员</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3617.html"><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</code></a> 通过分数返回有序集合指定区间内的成员</strong></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3618.html"><code>ZRANK key member</code></a> 返回有序集合中指定成员的索引</strong></td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3619.html"><code>ZREM key member [member ...]</code></a> 移除有序集合中的一个或多个成员</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3620.html"><code>ZREMRANGEBYLEX key min max</code></a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3621.html"><code>ZREMRANGEBYRANK key start stop</code></a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3622.html"><code>ZREMRANGEBYSCORE key min max</code></a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3623.html"><code>ZREVRANGE key start stop [WITHSCORES]</code></a> 返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3624.html"><code>ZREVRANGEBYSCORE key max min [WITHSCORES]</code></a> 返回有序集中指定分数区间内的成员，分数从高到低排序</strong></td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3625.html"><code>ZREVRANK key member</code></a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</strong></td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3626.html"><code>ZSCORE key member</code></a> 返回有序集中，成员的分数值</strong></td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3627.html"><code>ZUNIONSTORE destination numkeys key [key ...]</code></a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3628.html"><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><div class="note note-primary"><p><strong>数据结构</strong></p><p><strong><code>ziplist</code></strong></p><p><img src="/2022/02/04/Redis/zset_ziplist.png" srcset="/img/loading.gif" lazyload alt></p><p>zset底层的存储结构包括<code>ziplist</code>或<code>skiplist</code>，在同时满足以下两个条件的时候使用ziplist，其他时候使用skiplist，两个条件如下：</p><ul><li>有序集合保存的元素数量小于128个</li><li>有序集合保存的所有元素的长度小于64字节</li></ul><p>当ziplist作为zset的底层存储结构时候，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。</p></div><div class="note note-primary"><p><strong><code>skiplist + dict</code></strong></p><p><img src="/2022/02/04/Redis/zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>双重数据结构的优势：<ul><li>跳跃表：用于维护元素的有序性。跳跃表优势在于它提供了快速的顺序访问，特别适用于执行范围查询和迭代操作。</li><li>字典：用于高效的元素查找。字典以成员作为键，分数作为值，使得对特定元素的访问、更新或删除操作变得极为迅速。</li></ul></li><li>空间效率和内存优化：<ul><li>成员（Member）：成员由 <code>redisObject</code> 结构表示的字符串，dict 和 skipList 通过指针引用同一个成员。</li><li>分数（Score）：在跳跃表中，每个元素的分数是直接存储在每个节点中的；在字典中，元素的成员作为键，其对应的分数作为值。</li></ul></li></ul></div><p class="note note-primary">skiplist详解</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6901139528422178824">skiplist</a></p><p><img src="/2022/02/04/Redis/skiplist.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">排行榜实现</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">## 初始化日销售排行榜</span><br><span class="hljs-attribute">zadd</span> rank  <span class="hljs-number">98789</span> wgf  <span class="hljs-number">23476</span> zs  <span class="hljs-number">48739</span> ls <span class="hljs-number">28374</span> ww<br><br><span class="hljs-comment">## 更新日销量</span><br><span class="hljs-attribute">zadd</span> rank <span class="hljs-number">99746</span> wgf<br><br><span class="hljs-comment">## 获取日销量第一名</span><br><span class="hljs-attribute">zrevrange</span> rank <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment">## 获取销量榜前三名及销售额</span><br> <span class="hljs-attribute">zrevrange</span> rank <span class="hljs-number">0</span> <span class="hljs-number">2</span> withscores<br></code></pre></td></tr></table></figure><h3 id="redis-内部数据结构"><a class="markdownIt-Anchor" href="#redis-内部数据结构"></a> Redis 内部数据结构</h3><p><img src="/2022/02/04/Redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/317523">redis 内部数据结构详解</a></p><h2 id="三大特殊类型"><a class="markdownIt-Anchor" href="#三大特殊类型"></a> 三大特殊类型</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/redis">参考文档</a></p><h3 id="geo"><a class="markdownIt-Anchor" href="#geo"></a> GEO</h3><p><strong>特点</strong>：GEO 是 Redis 3.2 版本中新增的功能，专门用于存储和操作地理位置信息。这一功能允许用户高效地处理和查询地理空间数据，适用于多种地理位置相关的应用场景。</p><table><thead><tr><th>序号</th><th>描述及命令</th></tr></thead><tbody><tr><td>1</td><td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html"><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></a> geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中</td></tr><tr><td>2</td><td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html"><code>GEOPOS key member [member ...]</code></a> 用于从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil</td></tr><tr><td>3</td><td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html"><code>GEODIST key member1 member2 [m|km|ft|mi]</code></a> 用于返回两个给定位置之间的距离<br>m: 米<br>km:千米<br>mi:英里<br>ft:英尺</td></tr><tr><td>4</td><td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html"><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></a> 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素</td></tr><tr><td>5</td><td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html"><code>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></a> 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点</td></tr><tr><td>6</td><td><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html"><code>GEOHASH key member [member ...]</code></a> GEO 使用 geohash 来保存地理位置的坐标</td></tr></tbody></table><p class="note note-primary">数据结构</p><p>底层采用 <code>Zset</code> 数据结构，Menber存储值，Score存储经纬度</p><p><img src="/2022/02/04/Redis/geo.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">使用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">## 初始化城市</span><br><span class="hljs-attribute">geoadd</span> city <span class="hljs-number">114</span>.<span class="hljs-number">100</span> <span class="hljs-number">22</span>.<span class="hljs-number">200</span> xianggang<br><span class="hljs-attribute">geoadd</span> city <span class="hljs-number">113</span>.<span class="hljs-number">233</span> <span class="hljs-number">23</span>.<span class="hljs-number">166</span> guangzhou<br><span class="hljs-attribute">geoadd</span> city <span class="hljs-number">113</span>.<span class="hljs-number">516</span> <span class="hljs-number">22</span>.<span class="hljs-number">300</span> zhuhai<br><span class="hljs-attribute">geoadd</span> city <span class="hljs-number">114</span>.<span class="hljs-number">066</span> <span class="hljs-number">22</span>.<span class="hljs-number">616</span> shenzhen<br><br><span class="hljs-comment">## 获取深圳的经纬度</span><br><span class="hljs-attribute">geopos</span> city shenzhen<br><br><span class="hljs-comment">## 获取深圳和广州的直线距离</span><br><span class="hljs-attribute">geodist</span> city shenzhen guangzhou km<br><br><span class="hljs-comment">## 以给定的经纬度为中心，获取指定范围内的城市</span><br><span class="hljs-attribute">georadius</span> city <span class="hljs-number">114</span>.<span class="hljs-number">100</span> <span class="hljs-number">22</span>.<span class="hljs-number">200</span> <span class="hljs-number">150</span> km<br><br><span class="hljs-comment">## 获取深圳100KM内的城市</span><br><span class="hljs-attribute">GEORADIUSBYMEMBER</span> city shenzhen <span class="hljs-number">100</span> km<br></code></pre></td></tr></table></figure><p class="note note-primary">SpringBoot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeoTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;city&quot;</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">geoAddTest</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForGeo().add(KEY, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">114.100d</span>, <span class="hljs-number">22.200d</span>), <span class="hljs-string">&quot;xianggang&quot;</span>);<br>        redisTemplate.opsForGeo().add(KEY, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">113.233</span>, <span class="hljs-number">23.166d</span>), <span class="hljs-string">&quot;guangzhou&quot;</span>);<br>        redisTemplate.opsForGeo().add(KEY, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">113.516d</span>, <span class="hljs-number">22.300d</span>), <span class="hljs-string">&quot;zhuhai&quot;</span>);<br>        redisTemplate.opsForGeo().add(KEY, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">114.066d</span>, <span class="hljs-number">22.616d</span>), <span class="hljs-string">&quot;shenzhen&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">geoPosTest</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Point&gt; shenzhen = redisTemplate.opsForGeo().position(KEY, <span class="hljs-string">&quot;shenzhen&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, shenzhen.get(<span class="hljs-number">0</span>).getX(), shenzhen.get(<span class="hljs-number">0</span>).getY());<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">geoDistTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> redisTemplate.opsForGeo().distance(KEY, <span class="hljs-string">&quot;shenzhen&quot;</span>, <span class="hljs-string">&quot;guangzhou&quot;</span>, Metrics.KILOMETERS);<br>        log.info(<span class="hljs-string">&quot;value: &#123;&#125;&quot;</span>, distance.getValue());<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">geoRadiusTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">114.100d</span>, <span class="hljs-number">22.200d</span>);<br>        <span class="hljs-type">Metrics</span> <span class="hljs-variable">kilometers</span> <span class="hljs-operator">=</span> Metrics.KILOMETERS;<br>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">150</span>, kilometers);<br>        <span class="hljs-type">Circle</span> <span class="hljs-variable">circle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(point, distance);<br><br>        GeoResults&lt;RedisGeoCommands.GeoLocation&gt; radius = redisTemplate.opsForGeo().radius(KEY, circle);<br>        radius.forEach(geo -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, geo.getContent().getName());<br>        &#125;);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">geoRadiusByMemberTest</span><span class="hljs-params">()</span> &#123;<br>        GeoResults&lt;RedisGeoCommands.GeoLocation&gt; results = redisTemplate.opsForGeo().radius(KEY, <span class="hljs-string">&quot;shenzhen&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">100</span>, Metrics.KILOMETERS));<br>        results.forEach(geo -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;name: &#123;&#125;&quot;</span>, geo.getContent().getName());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用场景</p><ul><li><p><code>位置服务</code></p><p>如地点搜索、附近的人/商家等功能</p></li><li><p><code>地理围栏</code></p><p>判断是否在某个经纬度的半径范围内</p></li><li><p><code>距离计算</code></p><p>计算两个地点之间的直线距离</p></li></ul><h3 id="hyperloglog"><a class="markdownIt-Anchor" href="#hyperloglog"></a> HyperLogLog</h3><p>HyperLogLog 是一种用于高效进行<strong>基数统计</strong>的算法，特别适合处理大量数据元素。它的主要特点和应用场景如下：</p><ol><li><p><code>处理重复元素</code></p><p>​	HyperLogLog 算法在统计基数时，同一元素的多次出现只被计算一次。这意味着重复的元素对基数的贡献只会被累加一次，确保统计的是独一无二的元素数量。</p></li><li><p><code>基数估计而非值存储</code></p><p>​	HyperLogLog 专注于统计不同元素的数量（即基数），而不存储这些元素本身。因此，它无法像集合那样返回输入的各个元素。</p></li><li><p><code>空间效率</code></p><p>​	HyperLogLog 的一个显著优点是其内存效率。即使输入元素的数量或体积非常大，HyperLogLog 所需的存储空间总是固定且相对较小。每个 HyperLogLog 键仅需大约 12 KB 的内存，就可以计算接近 2^64 个不同元素的基数。</p></li><li><p><code>误差率</code></p><p>​	在进行基数估计时，HyperLogLog 存在一定的误差。标准误差率约为 <code>0.81%</code>，这对于大多数应用场景来说是一个可接受的误差范围。</p></li><li><p><code>应用场景</code></p><p>​	HyperLogLog 的主要应用场景包括统计大量数据的独特元素数。例如，在网站分析中，它被用于估算页面浏览量（PV）或独立访客数（UV）。</p></li></ol><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hyperloglog-pfadd.html"><code>PFADD key element [element ...]</code></a> 添加指定元素到 HyperLogLog 中。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hyperloglog-pfcount.html"><code>PFCOUNT key [key ...]</code></a> 返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/hyperloglog-pfmerge.html"><code>PFMERGE destkey sourcekey [sourcekey ...]</code></a> 将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><p class="note note-primary">数据结构</p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/de1eaa2d2133">TyperLogLog 详解</a></p><p><img src="/2022/02/04/Redis/hyperloglog.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><p><code>存储结构</code></p><p>HyperLogLog 在 Redis 中确实采用 String 类型进行存储。它通过一种特殊的编码方式，高效地维护统计信息。</p></li><li><p><code>桶（Bucket）的使用</code></p><p>HyperLogLog 内部维护了 16384（即 2^14）个桶。这些桶并不直接记录各自桶的元素数量，而是记录与元素散列值相关的特定统计信息。</p></li><li><p><code>元素的处理</code></p><p>当一个元素被添加到 HyperLogLog 中时，首先计算其散列值。这个散列值决定了元素被分配到哪个桶，并影响该桶的统计值。具体来说，散列值的一部分用于确定桶的编号，另一部分则用于计算并更新桶的统计信息。</p></li><li><p><code>概率算法</code></p><p>HyperLogLog 利用概率算法来估计基数。由于是基于概率的方法，每个桶的统计值并不代表精确计数，而是一个概率估计值。</p></li><li><p><code>基数的估算</code></p><p>通过将所有桶的计数值进行数学处理（如调和均值计算），HyperLogLog 能够估算出接近真实的总基数。虽然单个桶的统计值可能不够精确，但综合所有桶的信息后，得到的基数估算通常非常接近真实值。</p></li></ol><p class="note note-primary">计算页面UV</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">## 模拟用户访问</span><br><span class="hljs-attribute">pfadd</span> pv <span class="hljs-number">192.168.1.1</span><br>pfadd pv <span class="hljs-number">192.168.1.2</span><br>pfadd pv <span class="hljs-number">192.168.1.1</span><br>pfadd pv <span class="hljs-number">192.168.1.3</span><br>pfadd pv <span class="hljs-number">192.168.1.3</span><br>pfadd pv <span class="hljs-number">192.168.1.4</span><br><br><span class="hljs-comment">## 获取当前UV</span><br>pfcount pv<br><br>返回 <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p class="note note-primary">SpringBoot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HyperLogLogTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;pv&quot;</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pfAddTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            redisTemplate.opsForHyperLogLog().add(KEY, i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pfCountTest</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, redisTemplate.opsForHyperLogLog().size(KEY));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用场景</p><ul><li><p><code>独立访客计数</code></p><p>计算网站的独立访客量，比如通过ip维度</p></li><li><p><code>流量统计</code></p><p>估算一定时间内网页或API接口的独立请求次数</p></li><li><p><code>去重统计</code></p><p>处理大量数据时，移除或统计重复项</p></li></ul><h3 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> BitMap</h3><p>BitMap 是以二进制位（bit）为单位的数组，其中每个位可以是 0 或 1。在 Redis 中，BitMap 实际上是存储在字符串值中的位序列。</p><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/setbit.html"><code>SETBIT key offset value</code></a> 添加元素到BitMap</td></tr><tr><td>2</td><td><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/getbit.html"><code>GETBIT key offset</code></a> 根据偏移量获取BitMap上的元素</td></tr><tr><td>3</td><td><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitcount.html"><code>BITCOUNT key [start] [end]</code></a> 计算给定字符串中，被设置为 <code>1</code> 的比特位的数量</td></tr><tr><td>4</td><td><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitpos.html"><code>BITPOS key bit [start] [end]</code></a> 返回位图中第一个值为 <code>bit</code> 的二进制位的位置</td></tr><tr><td>5</td><td><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitop.html"><code>BITOP operation destkey key [key …]</code></a> 对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上</td></tr><tr><td>6</td><td><a target="_blank" rel="noopener" href="http://redisdoc.com/bitmap/bitfield.html"><code>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</code></a></td></tr></tbody></table><p class="note note-primary">数据结构</p><p><img src="/2022/02/04/Redis/bitmap.png" srcset="/img/loading.gif" lazyload alt></p><p>底层使用 <code>String</code> 数据类型，采用 <code>offset</code> 和 <code>bit</code> 存储数据，bit映射被限制在512MB之内，所以最大是2^32。</p><p><code>注意</code>：<span class="green-line">假设初始的offset非常大，BitMap的初始化会非常慢，假设offset值为 2^32-1=4294967295，由于 redis 没有采用压缩实现，就会直接申请到 512MB 内存空间来存储 2^32-1 bit 位置的值 1，中间的 bit 也会全填上 0</span>（内存暴涨），在偏移量较大的场景可以参考 <code>Kafka</code> 相对偏移量的做法。</p><p class="note note-primary">网站记录一周用户签到情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">## 用户一周签到情况, 1代表签到</span><br><span class="hljs-attribute">setbit</span> wgf <span class="hljs-number">0</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">setbit</span> wgf <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">setbit</span> wgf <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">setbit</span> wgf <span class="hljs-number">6</span> <span class="hljs-number">1</span><br><br><span class="hljs-comment">## 获取一周用户签到次数</span><br><span class="hljs-attribute">bitcount</span> wgf<br><br><span class="hljs-comment">## 获取周二用户是否签到</span><br><span class="hljs-attribute">getbit</span> wgf <span class="hljs-number">1</span><br><br><span class="hljs-comment">## 获取用户最早没有签到的日期</span><br><span class="hljs-attribute">bitpos</span> wgf <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p class="note note-primary">SpringBoot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitMapTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBitTest</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.opsForValue().setBit(<span class="hljs-string">&quot;wgf&quot;</span>, <span class="hljs-number">0</span> ,<span class="hljs-literal">true</span>);<br>        redisTemplate.opsForValue().setBit(<span class="hljs-string">&quot;wgf&quot;</span>, <span class="hljs-number">3</span> ,<span class="hljs-literal">true</span>);<br>        redisTemplate.opsForValue().setBit(<span class="hljs-string">&quot;wgf&quot;</span>, <span class="hljs-number">5</span> ,<span class="hljs-literal">true</span>);<br>        redisTemplate.opsForValue().setBit(<span class="hljs-string">&quot;wgf&quot;</span>,<span class="hljs-number">6</span> ,<span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getBitTest</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;value: &#123;&#125;&quot;</span>, redisTemplate.opsForValue().getBit(<span class="hljs-string">&quot;wgf&quot;</span>, <span class="hljs-number">0</span>));<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bitCountTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (Long) redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCallback</span>&lt;Long&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">doInRedis</span><span class="hljs-params">(RedisConnection connection)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>                <span class="hljs-keyword">return</span> connection.bitCount(<span class="hljs-string">&quot;wgf&quot;</span>.getBytes());<br>            &#125;<br>        &#125;);<br><br>        log.info(<span class="hljs-string">&quot;num: &#123;&#125;&quot;</span>, num);<br>    &#125;<br><br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bitPosTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (Long) redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; connection.bitPos(<span class="hljs-string">&quot;wgf&quot;</span>.getBytes(), <span class="hljs-literal">false</span>));<br>        log.info(<span class="hljs-string">&quot;value: &#123;&#125;&quot;</span>, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用场景</p><ul><li><p><code>用户签到功能</code></p></li><li><p><code>状态跟踪</code></p><p>通过唯一id跟踪用户上下线状态</p></li><li><p><code>数据去重</code></p></li><li><p><code>MQ消息队列幂等</code></p></li><li><p><code>分布式布隆过滤器</code></p></li></ul><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><ul><li><p><code>本质</code>：Redis事务通过将一系列命令放入一个队列中，并在<code>EXEC</code>命令发出时一次性、按顺序执行这些命令。这个过程确保了事务内的命令执行时不会被其他命令打断。</p></li><li><p><code>Redis事务的原子性</code>：在Redis中，事务提供了一种有限的原子性。如果事务中的命令无法执行（如因为语法错误），则整个事务将失败。然而，如果事务中的命令在运行时出错（例如，因数据类型不匹配），之前的命令仍然会被执行。</p></li><li><p><code>隔离级别</code>：Redis事务没有传统意义上的隔离级别概念。Redis的事务是通过单线程的特性来实现隔离的，即在执行事务中的命令序列时，不会有其他命令插队执行。</p></li></ul><p><span style="border-bottom:2px dashed green">Redis 事务可以一次执行多个命令</span>， 并且带有以下三个重要的保证：</p><ul><li>事务操作被放入一个队列中，并在事务提交时（使用<code>EXEC</code>命令）一起执行。</li><li>如果某个命令执行失败（语法性错误），其他命令仍然会继续执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p class="note note-primary">事务的三个阶段</p><p><img src="/2022/02/04/Redis/%E4%BA%8B%E5%8A%A1.png" srcset="/img/loading.gif" lazyload alt></p><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行 / 取消事务</li></ul><p class="note note-primary">命令</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-discard.html"><code>DISCARD</code></a> 取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-exec.html"><code>EXEC</code></a> 执行所有事务块内的命令。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-multi.html"><code>MULTI</code></a> 标记一个事务块的开始。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-unwatch.html"><code>UNWATCH</code></a> 取消 WATCH 命令对所有 key 的监视。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/transactions-watch.html"><code>WATCH key [key ...]</code></a> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr></tbody></table><h3 id="事务使用"><a class="markdownIt-Anchor" href="#事务使用"></a> 事务使用</h3><p class="note note-primary">正常提交事务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">## 设置库存</span><br>SET stock <span class="hljs-number">100</span><br><br><span class="hljs-comment">## 设置订单数量</span><br>SET <span class="hljs-keyword">order</span> <span class="hljs-title">0</span><br><br><span class="hljs-comment">## 开启事务模拟下单</span><br>MULTI<br>DECRBY stock <span class="hljs-number">10</span><br>INCRBY <span class="hljs-keyword">order</span> <span class="hljs-title">10</span><br>EXEC<br><br><span class="hljs-comment">## 提交事务返回结果</span><br><span class="hljs-number">90</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p class="note note-primary">取消事务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">## 设置库存</span><br>SET stock <span class="hljs-number">100</span><br><br><span class="hljs-comment">## 设置订单数量</span><br>SET <span class="hljs-keyword">order</span> <span class="hljs-title">0</span><br><br><span class="hljs-comment">## 开启事务模拟下单</span><br>MULTI<br>DECRBY stock <span class="hljs-number">10</span><br>INCRBY <span class="hljs-keyword">order</span> <span class="hljs-title">10</span><br><br><span class="hljs-comment">## 取消事务</span><br>DISCARD<br><br><span class="hljs-comment">## 查看数据</span><br>GET stock<br><span class="hljs-number">100</span><br><br>GET <span class="hljs-keyword">order</span><br><span class="hljs-title">0</span><br></code></pre></td></tr></table></figure><p class="note note-primary">命令性错误</p><p><code>不存在命令</code> <code>命令参数不正确</code></p><p><span class="green-line">若在事务队列中存在<code>命令性错误</code>（类似于java编译性错误），则执行EXEC命令时，<code>所有命令都不会执行</code></span></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">## 设置库存<br>SET stock <span class="hljs-number">100</span><br><br>## 开启事务<br>MULTI<br>DECRBY stock <span class="hljs-number">10</span><br>GETSET stock 	<span class="hljs-comment">// 命令性错误（缺少参数，或执行非Redis命令）</span><br>ERR wrong number <span class="hljs-keyword">of</span> arguments for <span class="hljs-string">&#x27;getset&#x27;</span> command<br>EXEC<br><br>## 再次获取库存<br>GET stock<br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p class="note note-primary">语法性错误</p><p><code>命令使用正确，但是语法使用不正确</code></p><p><span class="green-line">若在事务队列中存在<code>语法性错误</code>（类似于java的1/0的运行时异常），则执行EXEC命令时，<code>其他正确命令会被执行，错误命令抛出异常</code></span></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gams">## 设置库存<br><span class="hljs-keyword">SET</span> stock <span class="hljs-comment">100</span><br><span class="hljs-keyword">SET</span> <span class="hljs-comment">flag test</span><br><br>## 开启事务<br>MULTI<br>DECRBY <span class="hljs-comment">stock 10</span><br>INCRBY <span class="hljs-comment">flag 10</span>	// 语法性错误，字符串不能参与数字运算（命令没有错）<br>DECRBY <span class="hljs-comment">stock 20</span><br>EXEC<br><br>GET <span class="hljs-comment">stock</span><br>70				<span class="hljs-comment">// 事务中语法正常的命令被执行</span><br><br>GET <span class="hljs-comment">flag</span>		<br>test			// 事务中正确 命令会被执行，错误命令抛出异常<br></code></pre></td></tr></table></figure><h3 id="watch-监控key"><a class="markdownIt-Anchor" href="#watch-监控key"></a> WATCH 监控key</h3><ol><li><code>乐观锁定</code>：<ul><li><code>WATCH</code>命令用于监视一个或多个键，以检测这些键在事务执行之前是否被其他命令修改。</li><li>如果在执行事务的<code>EXEC</code>命令之前，任何被<code>WATCH</code>监视的键被修改（包括更新、删除或过期），那么事务不会执行。</li></ul></li><li><code>使用场景</code>：<ul><li><code>WATCH</code>命令通常用于复杂的事务场景，其中需要根据被监视键的值来决定是否执行事务。</li><li>它特别适用于需要避免竞态条件的场景，例如，在多个客户端同时修改同一个键的值时。</li></ul></li><li><code>事务流程</code>：<ul><li>一个典型的使用<code>WATCH</code>命令的事务流程包括：首先用<code>WATCH</code>命令监视一个或多个键，然后读取这些键的值，接着开始一个事务（使用<code>MULTI</code>命令），执行一系列命令，最后提交事务（使用<code>EXEC</code>命令）。</li><li>如果监视的键在执行<code>EXEC</code>之前被修改，事务将被取消，<code>EXEC</code>命令返回一个空回复以指示事务未执行。</li></ul></li><li><code>取消监视</code>：<ul><li>使用<code>UNWATCH</code>命令可以取消所有被<code>WATCH</code>命令设置的监视。</li><li>另外，执行<code>EXEC</code>命令后，无论事务是否成功执行，所有的监视都会自动被取消。</li></ul></li></ol><p class="note note-primary">使用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs clean">############# 窗口<span class="hljs-number">1</span> ##############<br>## 设置库存<br>SET stock <span class="hljs-number">100</span><br><br>## 开启库存监控<br>WATCH stock<br><br>## 开启事务<br>MULTI<br><br>## 下单<br>DECRBY stock <span class="hljs-number">1</span><br><br><br><br><br>############# 窗口<span class="hljs-number">2</span> ##############<br>## 获取库存<br>GET stock<br><span class="hljs-string">&quot;100&quot;</span><br><br>## 下单<br>DECRBY stock <span class="hljs-number">10</span><br><br><br><br><br>############# 窗口<span class="hljs-number">1</span> ##############<br>## 提交事务<br>EXEC<br>null	## 放弃事务执行<br><br>GET stock<br><span class="hljs-number">90</span><br><br>## 重试<br>WATCH stock<br>MULTI<br>DECRBY stock <span class="hljs-number">1</span><br>EXEC<br><span class="hljs-number">89</span>		## 事务执行成功，库存扣减<br></code></pre></td></tr></table></figure><h4 id="秒杀实现"><a class="markdownIt-Anchor" href="#秒杀实现"></a> 秒杀实现</h4><p><a target="_blank" rel="noopener" href="https://github.com/wugengfeng/redis-example/blob/main/src/main/java/com/wgf/controller/StockController.java">StockController</a></p><p>这里的秒杀只是用于实践 <code>事务</code> 和 <code>监控</code> 的用法，实际上秒杀使用 <code>Lua</code> 为最优解，因为简单使用 <code>decrby</code> 会存在库存遗留问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockController</span> &#123;<br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br> <br> <span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br> <br> <span class="hljs-meta">@GetMapping(&quot;decr2&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decr2</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>         <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> decrStock(<span class="hljs-string">&quot;stock&quot;</span>, getNum(), <span class="hljs-number">100</span>);<br>         <span class="hljs-keyword">if</span> (flag) &#123;<br>             log.info(<span class="hljs-string">&quot;下单成功&quot;</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             log.info(<span class="hljs-string">&quot;下单失败&quot;</span>);<br>         &#125;<br>     &#125;;<br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000</span>; i++) &#123;<br>         executorService.execute(task);<br>     &#125;<br> &#125;<br> <br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 秒杀扣减库存实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 库存key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> num 购买数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryCount 重试扣减次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Boolean <span class="hljs-title function_">decrStock</span><span class="hljs-params">(String key, <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> tryCount)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Boolean) <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCallback</span>&lt;Boolean&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisOperations operations)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tryCount; i++) &#123;<br>                    operations.watch(key);<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">stockNum</span> <span class="hljs-operator">=</span> (Integer) operations.opsForValue().get(key);<br>                    <span class="hljs-keyword">if</span> (stockNum &lt; num) &#123;<br>                        <span class="hljs-comment">// log.warn(&quot;库存不足&quot;);</span><br>                        operations.unwatch();<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">30</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br><br>                    operations.multi();<br>                    operations.opsForValue().decrement(key, num);<br><br>                    List&lt;Object&gt; result = <span class="hljs-literal">null</span>;<br>                    result = operations.exec();<br><br>                    <span class="hljs-keyword">if</span> (Objects.nonNull(result) &amp;&amp; result.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">//log.info(&quot;剩余库存：&#123;&#125;&quot;, result.get(0));</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发布订阅"><a class="markdownIt-Anchor" href="#发布订阅"></a> 发布订阅</h2><p>Redis的发布/订阅（Pub/Sub）是一种消息通信模式，允许客户端之间通过频道进行消息传递。这个模式包含发布者（发送消息的客户端）和订阅者（接收消息的客户端）。在Redis中，发布/订阅功能被广泛应用于构建消息队列、聊天系统、实时通知等场景。以下是其主要特点和工作方式：</p><ol><li><code>频道（Channels）</code>：<ul><li>在Redis的Pub/Sub系统中，消息是通过频道发送的。频道可以被视为消息传递的媒介。</li><li>客户端可以订阅任何频道。当消息发送到频道时，这些消息会被转发给所有订阅了该频道的客户端。</li></ul></li><li><code>发布（Publish）</code>：<ul><li>发布者使用<code>PUBLISH</code>命令发送消息到指定的频道。</li><li>当一个消息被发布到频道，所有订阅该频道的客户端都会收到这个消息。</li></ul></li><li><code>订阅（Subscribe）</code>：<ul><li>客户端使用<code>SUBSCRIBE</code>命令订阅一个或多个频道。</li><li>一旦订阅了频道，客户端会进入一个订阅状态，等待接收任何发送到这些频道的消息。</li></ul></li><li><code>模式订阅（Pattern Subscribe）</code>：<ul><li>Redis还提供了模式订阅功能，允许客户端订阅符合特定模式的频道。这通过<code>PSUBSCRIBE</code>命令实现。</li><li>比如，使用<code>PSUBSCRIBE news.*</code>可以订阅所有以<code>news.</code>开头的频道。</li></ul></li><li><code>取消订阅</code>：<ul><li>客户端可以使用<code>UNSUBSCRIBE</code>命令来取消订阅特定的频道。</li><li>类似地，<code>PUNSUBSCRIBE</code>命令用于取消模式订阅。</li></ul></li><li><code>应用场景</code>：<ul><li>Redis的Pub/Sub系统非常适合构建实时消息系统，例如实时聊天应用、实时广播更新、实时在线监控系统等。</li></ul></li><li><code>限制</code>：<ul><li>Redis的发布/订阅模型不保证消息的持久化或可靠性。如果在消息发布时没有订阅者在线，这些消息将会丢失。</li><li>它也不提供复杂的消息队列功能，如消息确认或持久订阅。</li></ul></li></ol><p>Redis的发布/订阅功能由于其简单性和高效性，在需要快速通信和实时更新的应用中非常有用。但是，在需要消息持久化和高可靠性的场景中，可能需要考虑其他消息队列解决方案。</p><p>订阅/发布消息图：</p><p><img src="/2022/02/04/Redis/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/pub-sub-psubscribe.html"><code>PSUBSCRIBE pattern [pattern ...]</code></a> 订阅一个或多个符合给定模式的频道。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/pub-sub-pubsub.html"><code>PUBSUB subcommand [argument [argument ...]]</code></a> 查看订阅与发布系统状态。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/pub-sub-publish.html"><code>PUBLISH channel message</code></a> 将信息发送到指定的频道。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/pub-sub-punsubscribe.html"><code>PUNSUBSCRIBE [pattern [pattern ...]]</code></a> 退订所有给定模式的频道。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/pub-sub-subscribe.html"><code>SUBSCRIBE channel [channel ...]</code></a> 订阅给定的一个或多个频道的信息。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/pub-sub-unsubscribe.html"><code>UNSUBSCRIBE [channel [channel ...]]</code></a> 指退订给定的频道。</td></tr></tbody></table><p class="note note-primary">命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">############ 窗口1 ##############</span><br><span class="hljs-meta">## 订阅频道</span><br>SUBSCRIBE mychannel<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;message&quot;</span>			<span class="hljs-meta"># 类型</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;mychannel&quot;</span>			<span class="hljs-meta"># 频道</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;hello!				# 窗口2发送消息这里会实时监控到</span><br><br><span class="hljs-meta">############ 窗口2 ##############</span><br><span class="hljs-meta">## 发送消息</span><br>PUBLISH mychannel <span class="hljs-string">&quot;hello!&quot;</span><br><span class="hljs-number">1</span>							<span class="hljs-meta"># 返回当前接收消息客户端数量</span><br><br><span class="hljs-meta">############ 窗口1 ##############</span><br><span class="hljs-meta">## 取消订阅频道</span><br>UNSUBSCRIBE mychannel<br></code></pre></td></tr></table></figure><h2 id="lua脚本"><a class="markdownIt-Anchor" href="#lua脚本"></a> Lua脚本</h2><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/790571">Lua 详解</a></p><p>Lua是一种轻量级的编程语言，被设计为嵌入到应用程序中，Redis从2.6版本开始内嵌了Lua解释器，允许执行Lua脚本。</p><p><strong><code>优点</code></strong></p><ul><li><code>原子性执行</code>：Lua脚本在Redis中以原子方式执行。这意味着在脚本执行期间，不会有其他Redis命令被执行，保证了操作的一致性和完整性。</li><li><code>减少网络开销</code>：通过在服务器端执行脚本，可以减少在客户端和Redis服务器之间的往返通信，降低网络延迟。</li><li><code>操作封装</code>：Lua脚本可以封装一系列复杂的Redis命令，简化客户端代码，使其更加整洁和易于维护。</li></ul><p><strong><code>缺点</code></strong></p><ul><li><code>性能影响</code>：虽然Lua脚本在Redis中执行效率很高，但是过于复杂的脚本可能会长时间占用CPU，影响Redis服务器的性能。</li><li><code>安全性考虑</code>：需要确保编写的Lua脚本安全可靠，特别是在处理外部输入数据时，避免执行恶意代码或操作。</li></ul><p class="note note-primary">EVAL 命令</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">EVAL script numkeys <span class="hljs-comment">[key <span class="hljs-comment">[key ...]</span>]</span> <span class="hljs-comment">[arg <span class="hljs-comment">[arg ...]</span>]</span><br></code></pre></td></tr></table></figure><ul><li><p><code>EVAL</code>：这是Redis执行Lua脚本的命令。</p></li><li><p><code>script</code>：这是要执行的Lua脚本的文本。它是一段Lua代码，可以包含任何有效的Lua命令和Redis命令。</p></li><li><p><code>numkeys</code>：这个参数指定了随后在命令中列出的键(<code>key</code>)的数量。这个数字告诉Redis，接下来的多少参数应该被视为键名。</p></li><li><p><code>[key [key ...]]</code>：这部分是可选的，包含了将要被脚本处理的键名。这些键名放在Lua脚本中的<code>KEYS</code>数组里。<code>numkeys</code>参数指定了这里有多少个键。</p></li><li><p><code>[arg [arg ...]]</code>：这部分也是可选的，包含了传递给脚本的其他参数，这些参数放在Lua脚本中的<code>ARGV</code>数组里。</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EVAL</span> <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;, KEYS[1], ARGV[1])&quot;</span> <span class="hljs-number">1</span> mykey myvalue<br><span class="hljs-attribute">OK</span><br></code></pre></td></tr></table></figure><p>这段脚本说明有一个KEYS参数 mykey，有一个ARGV参与 myvalue。然后Lua脚本使用 <code>redis.call</code> 调用 redis 命令，最终将执行结果返回。</p><p class="note note-primary">EVALSHA 脚本缓存语义</p><p><code>EVALSHA</code> 是 Redis 中用于执行 Lua 脚本的命令，它与 <code>EVAL</code> 命令类似，但有一个关键的区别：它使用 Lua 脚本的 SHA1 校验码来引用被Redis加载的脚本，而不是直接提供脚本代码。这样做的优点是，一旦脚本被加载到 Redis 中，就可以通过其 SHA1 校验码高效地多次调用，而无需重新发送整个脚本代码。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">SCRIPT LOAD <span class="hljs-keyword">script</span><br></code></pre></td></tr></table></figure><p>用于将 Lua 脚本加载到 Redis 内存缓存并返回一个 sha1 码，Redis重启缓存脚本失效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">EVALSHA sha1 numkeys key <span class="hljs-selector-attr">[key ...]</span> arg <span class="hljs-selector-attr">[arg ...]</span> <br></code></pre></td></tr></table></figure><ul><li><p><code>sha1</code>：这是预先加载到 Redis 中的 Lua 脚本的 SHA1 校验码。这个校验码是使用 SCRIPT LOAD 命令加载脚本时得到的。</p></li><li><p><code>numkeys</code>：这个参数指定了随后在命令中列出的 KEY 的数量。这个数字告诉 Redis，接下来的多少参数应该被视为键名。</p></li><li><p><code>[key [key ...]]</code>：这部分是可选的，包含了将要被脚本处理的键名。这些键名放在 Lua 脚本中的 KEYS 数组里。numkeys 参数指定了这里有多少个键。</p></li><li><p><code>[arg [arg ...]]</code>：这部分也是可选的，包含了传递给脚本的其他参数，这些参数放在 Lua 脚本中的 ARGV 数组里。这些参数可以是任何值，包括字符串、数字等，由脚本的逻辑来决定它们的用途。</p></li></ul><p>使用 EVALSHA 命令执行 Lua 脚本</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">&gt; <span class="hljs-keyword">SCRIPT </span>LOAD <span class="hljs-string">&quot;return &#x27;Hello World&#x27;&quot;</span>			<span class="hljs-comment"># 让Redis缓存一段脚本，但不执行，无限期缓存</span><br><span class="hljs-number">470877</span>a599ac<span class="hljs-symbol">74f</span>bfda41caa908de682c<span class="hljs-symbol">5f</span>c7d<span class="hljs-symbol">4b</span>		<span class="hljs-comment"># Redis返回的SHA1码</span><br><br>&gt; EVALSHA <span class="hljs-string">&quot;470877a599ac74fbfda41caa908de682c5fc7d4b&quot;</span> <span class="hljs-number">0</span>	<span class="hljs-comment"># 执行缓存脚本</span><br></code></pre></td></tr></table></figure><p><code>好处</code>：相对于<code>EVAL</code>，它的第一个参数是一段脚本。<code>EVALSHA</code> 在执行Lua脚本可以使用缓存脚本，减少额外的网络开销。</p><p class="note note-primary">Lua调用Redis命令</p><ul><li><p><code>redis.call()</code></p><p>如果执行的命令出现错误，<code>redis.call()</code> 会停止脚本的执行，并将错误返回给脚本的调用者，也就是说错误要在脚本之外处理。</p></li><li><p><code>redis.pcall()</code></p><p>与 <code>redis.call()</code> 不同的是，如果命令执行失败，<code>redis.pcall()</code> 不会停止脚本执行或抛出错误，而是返回一个包含错误信息的Lua表，可以在脚本内处理错误。</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua">set k v<br>eval <span class="hljs-string">&quot;return redis.call(&#x27;incr&#x27;, KEYS[1])&quot;</span> <span class="hljs-number">1</span> k<br>(<span class="hljs-built_in">error</span>) ERR Error <span class="hljs-built_in">running</span> script (call to f_2bab3b661081db58bd2341920e0ba7cf5dc77b25): @user_script:<span class="hljs-number">1</span>: ERR value is <span class="hljs-keyword">not</span> an integer <span class="hljs-keyword">or</span> out of range<br><br><br><span class="hljs-comment">-- 实际脚本要合并为一行才能执行，脚本内部错误处理</span><br>eval <span class="hljs-string">&quot;</span><br><span class="hljs-string">  local result = redis.pcall(&#x27;incr&#x27;, KEYS[1]) </span><br><span class="hljs-string">  if result.err then</span><br><span class="hljs-string">    return 0</span><br><span class="hljs-string">  else</span><br><span class="hljs-string">    return result</span><br><span class="hljs-string">  end    </span><br><span class="hljs-string">&quot;</span> <span class="hljs-number">1</span> k<br>(integer) <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p class="note note-primary">Redis 和 Lua 的数据关系</p><p><strong>在Lua 5.2及之前的版本中</strong>，Lua只有一种数字类型，即双精度浮点数。当需要将数字存储到Redis并期望它们作为整数处理时（例如用于<code>INCR</code>、<code>DECR</code>或其他需要整数的Redis命令），需要确保这些数字在转换前是整数，可以使用<code>math.floor</code>保证。</p><p><strong>在Lua 5.3及以后的版本中</strong>，Lua支持整数和浮点数。在这些版本中，Lua会根据数字的使用方式自动选择合适的类型。</p><p>Redis Lua 版本默认为5.1</p><table><thead><tr><th>Lua 数据类型</th><th>描述</th><th>转换为 Redis 数据类型</th><th>描述</th><th>示例（Lua -&gt; Redis）</th></tr></thead><tbody><tr><td>string</td><td>字符串</td><td>String</td><td>字符串，可以包含任何数据类型</td><td><code>redis.call('set', 'key', stringValue)</code></td></tr><tr><td>number</td><td>数字</td><td>String</td><td>数字存储为字符串</td><td><code>redis.call('set', 'key', tostring(numberValue))</code></td></tr><tr><td>table</td><td>数组型表</td><td>List/Set/Sorted Set</td><td>根据使用的命令转换为列表、集合或有序集合</td><td><code>redis.call('rpush', 'key', unpack(arrayTable))</code></td></tr><tr><td></td><td>键值对表</td><td>Hash</td><td>字符串字段和字符串值的映射</td><td><code>redis.call('hmset', 'key', unpack(hashTable))</code></td></tr><tr><td>boolean</td><td>布尔值</td><td>String</td><td>布尔值通常转换为&quot;0&quot;或&quot;1&quot;的字符串</td><td><code>redis.call('set', 'key', booleanValue and '1' or '0')</code></td></tr><tr><td>nil</td><td>空值</td><td>删除键</td><td>在Redis中删除对应的键</td><td><code>redis.call('del', 'key')</code></td></tr></tbody></table><table><thead><tr><th>Redis 数据类型</th><th>描述</th><th>转换为 Lua 数据类型</th><th>描述</th><th>示例（Redis -&gt; Lua）</th></tr></thead><tbody><tr><td>String</td><td>字符串，可以包含任何数据类型</td><td>string/number</td><td>字符串或数字</td><td><code>local value = redis.call('get', 'key')</code></td></tr><tr><td>List</td><td>字符串列表，按插入顺序排序</td><td>table</td><td>数组型表</td><td><code>local list = redis.call('lrange', 'key', 0, -1)</code></td></tr><tr><td>Set</td><td>无序集合，不重复的字符串集合</td><td>table</td><td>数组型表</td><td><code>local set = redis.call('smembers', 'key')</code></td></tr><tr><td>Sorted Set</td><td>有序集合，字符串和分数的映射</td><td>table</td><td>键值对表</td><td><code>local zset = redis.call('zrange', 'key', 0, -1, 'WITHSCORES')</code></td></tr><tr><td>Hash</td><td>字符串字段和字符串值的映射</td><td>table</td><td>键值对表</td><td><code>local hash = redis.call('hgetall', 'key')</code></td></tr><tr><td>Bitmap</td><td>由位组成的数组</td><td>string</td><td>字符串</td><td><code>local bitmap = redis.call('get', 'key')</code></td></tr><tr><td>HyperLogLog</td><td>用于基数统计的概率数据结构</td><td>nil</td><td>不直接转换</td><td>N/A</td></tr><tr><td>Stream</td><td>消息流</td><td>table</td><td>键值对表</td><td><code>local stream = redis.call('xrange', 'key', start, end)</code></td></tr><tr><td>Geo</td><td>地理位置信息</td><td>table</td><td>键值对表</td><td><code>local geopos = redis.call('geopos', 'key', 'member')</code></td></tr></tbody></table><p class="note note-primary">Lua脚本实现秒杀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> ExecutorService executorService;<br><br><span class="hljs-comment">// 定义Lua脚本，库存足够执行INCRBY命令后返回0，库存不够返回0</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RedisScript&lt;Long&gt; STOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;Long&gt;(<br>           <span class="hljs-string">&quot;local stock = redis.call(&#x27;get&#x27;, KEYS[1])\n&quot;</span> +<br>                   <span class="hljs-string">&quot;if (stock &gt;= ARGV[1]) then\n&quot;</span> +<br>                   <span class="hljs-string">&quot;  redis.call(&#x27;decrby&#x27;, KEYS[1], ARGV[1])\n&quot;</span> +<br>                   <span class="hljs-string">&quot;  return 1\n&quot;</span> +<br>                   <span class="hljs-string">&quot;else\n&quot;</span> +<br>                   <span class="hljs-string">&quot;  return 0\n&quot;</span> +<br>                   <span class="hljs-string">&quot;end&quot;</span>, Long.class);<br><br>   <span class="hljs-meta">@ApiOperation(value = &quot;使用Lua实现秒杀&quot;)</span><br>   <span class="hljs-meta">@GetMapping(&quot;decr3&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decr3</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> getNum();<br>           <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (Long) <span class="hljs-built_in">this</span>.redisTemplate.execute(STOCK_SCRIPT, Arrays.asList(<span class="hljs-string">&quot;stock&quot;</span>), num);<br>           <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;<br>               log.info(<span class="hljs-string">&quot;下单成功&quot;</span>);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               log.error(<span class="hljs-string">&quot;下单失败&quot;</span>);<br>           &#125;<br>       &#125;;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3000</span>; i++) &#123;<br>           executorService.execute(task);<br>       &#125;<br><br>       <span class="hljs-comment">// 测试最终结果： 执行效率高，解决库存遗留问题</span><br>   &#125;<br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNum</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>       <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> random.nextInt(max + min) + min;<br><br>       <span class="hljs-keyword">return</span> value;<br>   &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">Lua库存扣减脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- Lua 脚本实现多个产品库存的扣减</span><br><span class="hljs-comment">-- 检查所有产品库存是否满足扣减条件</span><br><span class="hljs-comment">-- 如果所有产品库存满足，执行 DECRBY</span><br><span class="hljs-comment">-- 如果任何一个产品库存不满足，返回该产品的 KEY</span><br><br><span class="hljs-comment">-- 获取键的数量</span><br><span class="hljs-keyword">local</span> numKeys = #KEYS<br><br><span class="hljs-comment">-- 确保 KEYS 和 ARGV 长度一致</span><br><span class="hljs-built_in">assert</span>(#ARGV == numKeys, <span class="hljs-string">&quot;每个键必须有对应的扣减值&quot;</span>)<br><br><span class="hljs-comment">-- 首先检查所有库存是否满足扣减条件</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, numKeys <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> key = KEYS[i]<br>    <span class="hljs-keyword">local</span> decrement = <span class="hljs-built_in">tonumber</span>(ARGV[i])<br>    <span class="hljs-keyword">local</span> currentStock = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, key) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">if</span> currentStock &lt; decrement <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 如果任何一个产品的库存不满足条件，返回该产品的 KEY</span><br>        <span class="hljs-keyword">return</span> key<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 执行库存扣减</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, numKeys <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> key = KEYS[i]<br>    <span class="hljs-keyword">local</span> decrement = <span class="hljs-built_in">tonumber</span>(ARGV[i])<br>    redis.call(<span class="hljs-string">&#x27;decrby&#x27;</span>, key, decrement)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 所有操作成功，返回 &quot;OK&quot;</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span><br></code></pre></td></tr></table></figure><h2 id="docker-安装-redis"><a class="markdownIt-Anchor" href="#docker-安装-redis"></a> Docker 安装 Redis</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis:latest<br><br><br>docker run -p 6379:6379 --name redis1 -v /data/redis/config/redis_1.conf:/etc/redis/redis.conf -v /data/redis/data/redis1:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes<br><br>说明<br>-v /data/redis/config/redis_1.conf:/etc/redis/redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中<br>-v /data/redis/data/redis1:/data： 把redis持久化的数据在宿主机内显示，做数据备份<br>redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动<br>–appendonly yes：redis启动后数据持久化<br></code></pre></td></tr></table></figure><p class="note note-primary">配置文件 redis.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">允许外部IP访问</span><br>bind 0.0.0.0<br>daemonize no<br>requirepass wgf123		# 密码<br>appendonly yes			# 持久化<br></code></pre></td></tr></table></figure><h2 id="redis-配置"><a class="markdownIt-Anchor" href="#redis-配置"></a> Redis 配置</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904032268451853">参考 掘金文档</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/9074787.html">Redis 配置</a></p><h2 id="redis的持久化"><a class="markdownIt-Anchor" href="#redis的持久化"></a> Redis的持久化</h2><p>Redis是一个高性能的内存键值存储数据库，它主要使用内存作为数据操作的主要媒介，这意味着数据主要在内存中进行读取和写入操作，确保了极高的处理速度。然而，内存的易失性意味着在服务器进程崩溃或由于其他原因意外停止时，存储在内存中的数据可能会丢失。为了克服这个挑战，Redis提供了两种主要的持久化机制：<code>RDB</code> 和 <code>AOF</code>。RDB持久化会在指定的时间间隔内创建数据集的时间点快照，而AOF持久化则记录每个写操作命令。</p><h3 id="rdb-redis-database-默认"><a class="markdownIt-Anchor" href="#rdb-redis-database-默认"></a> RDB (Redis DataBase 默认)</h3><p><code>性能比AOF优秀</code> <code>数据丢失风险大</code> <code>适合海量数据恢复</code> <code>适合对数据完整性要求不高的场景</code></p><p class="note note-primary">什么是RDB</p><p><img src="/2022/02/04/Redis/rdb.png" srcset="/img/loading.gif" lazyload alt></p><p>RDB（Redis Database）是 Redis 的一种持久化机制，它通过创建内存数据集的快照来实现持久化。在配置的时间间隔或满足特定条件时，Redis 会自动执行快照操作，将当前内存中的所有数据保存到一个 RDB 文件中。</p><p class="note note-primary">优点和缺点</p><p><strong><code>优点</code></strong></p><ol><li><code>数据恢复速度快</code>：在需要从磁盘恢复数据时，RDB 可以快速地加载快照文件，尤其适合大数据集的恢复。</li><li><code>节省磁盘空间</code>：RDB 文件会通过压缩来减少所需的磁盘空间。</li><li><code>较小的性能开销</code>：快照操作在子进程中执行，主进程可以继续处理客户端请求，对数据库性能的影响相对较小。</li></ol><p><strong><code>缺点</code></strong></p><ol><li><code>数据丢失的风险</code>：RDB 通过定时创建数据的快照。如果 Redis 服务器在两次快照之间发生故障，那么自上次快照以来的所有数据更改都将丢失。</li><li><code>不适合实时持久化</code>：由于 RDB 是周期性创建的，它不适合需要实时持久化的应用。</li><li><code>资源占用</code>：在执行快照时，Redis 需要 fork 一个子进程，这个过程中会消耗额外系统资源。</li></ol><p class="note note-primary">备份如何执行</p><p><img src="/2022/02/04/Redis/RDB%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><code>使用子进程进行持久化</code>：Redis 通过 <code>fork</code> 创建一个子进程来执行 RDB 持久化操作。这样做的目的确实是为了减少主进程的 I/O 阻塞，允许主进程在持久化过程中继续处理客户端请求。子进程利用操作系统的写时复制（Copy-On-Write, COW）机制来访问数据集的快照，这意味着当主进程修改内存中的数据时（修改数据的副本），子进程所访问的数据仍然保持不变。</li><li><code>使用临时文件写入</code>：子进程不是直接写入 <code>dump.rdb</code> 文件，而是先将快照数据写入一个临时文件中。这个过程中，子进程会创建整个数据集的一个完整、一致性的副本。</li><li><code>安全地同步文件</code>：一旦子进程完成数据的写入，它会将临时文件重命名为 <code>dump.rdb</code>。这种方式确保了即使在持久化过程中出现故障，原有的 <code>dump.rdb</code> 文件也不会受到影响，从而提供了一定程度的数据安全性。</li><li><code>恢复效率的考虑</code>：对于需要进行大规模数据恢复的场景，RDB 模式通常比 AOF 模式更高效，因为 RDB 文件是数据集的压缩表示，可以更快地被载入。同时，如果数据的完整性不是最重要的考虑因素，RDB 可能是更好的选择，因为 AOF 在恢复大量数据时会比较慢。</li></ol><p class="note note-primary">Fork工作原理</p><p><img src="/2022/02/04/Redis/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt="写时复制"></p><ul><li><p><code>初始共享</code>：Redis 通过 <code>fork</code> 创建一个子进程，他们实际上共享相同的物理内存页。操作系统只保留一份数据的副本，而多个进程可以同时访问这份副本。</p></li><li><p><code>写时复制</code>：Redis 主线程在持久化期间接收客户端请求，修改这些共享的数据时，操作系统首先会为该进程创建这些数据的一个私有副本。</p></li><li><p><code>数据快照</code>：子进程快照的是原始的共享数据，不会快照主线程在持久化期间创建的副本数据，这些副本数据会在下次快照时被持久化。</p></li></ul><p class="note note-primary">dump文件</p><p><img src="/2022/02/04/Redis/dump.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">配置位置及SNAPSHOTTING解析</p><p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/redis/redis/6.2/redis.conf">默认配置文件</a></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>dir</code></td><td>设置快照文件的存放路径，这个配置项一定是个目录</td></tr><tr><td><code>stop-writes-on-bgsave-error</code></td><td>默认值为yes。当启用了RDB磁盘满了，Redis是否停止接收数据</td></tr><tr><td><code>rdbcompression</code></td><td>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压<br>缩存储</td></tr><tr><td><code>rdbchecksum</code></td><td>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算<br>法来进行数据校验</td></tr><tr><td><code>dbfilename</code></td><td>设置快照的文件名，默认是 dump.rdb</td></tr><tr><td><code>save</code></td><td>这里是用来配置触发 Redis的持久化条件，也就是什么时候将内存<br>中的数据保存到硬盘</td></tr></tbody></table><p><img src="/2022/02/04/Redis/save.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>15分钟有一次修改触发保存</li><li>5分钟有十次修改触发保存</li><li>1分钟有一万次修改触发保存</li></ul><p>如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。若要修改完毕需要立马生效，可以手动使用 <code>save</code> 命令，立马生效。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">命令修改RDB频率<br><br><span class="hljs-keyword">save</span> <span class="hljs-number">120</span> <span class="hljs-number">10</span> <span class="hljs-meta"># 120秒内修改10次则触发RDB</span><br><br>如果想禁用RDB持久化的策略，只要不设置任何<span class="hljs-keyword">save</span>指令，或者给<span class="hljs-keyword">save</span>传入一个空字符串参数也可以。<br>若要修改完毕需要立马生效，可以手动使用 <span class="hljs-keyword">save</span> 命令！立马生效，需要删除dump.rdb文件<br></code></pre></td></tr></table></figure><p class="note note-primary">如何触发RDB快照</p><ul><li>配置文件配置了 <code>save</code> 策略，服务定期备份</li><li>命令save或者是bgsave<ul><li><code>save</code> 时只管保存，其他不管，全部阻塞</li><li><code>bgsave</code>，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间。</li></ul></li><li>执行 <code>flushall</code> 命令，也会产生 dump.rdb 文件，但里面是空的，无意义 !</li><li><code>退出</code> 的时候也会产生 dump.rdb 文件！</li></ul><p class="note note-primary">RDB恢复</p><ol><li><p>命令获取Redis目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; config get <span class="hljs-built_in">dir</span><br><span class="hljs-built_in">dir</span><br>/data<br></code></pre></td></tr></table></figure></li><li><p>将备份文件（dump.rdb）移动到redis安装目录并启动服务即可。</p></li></ol><h3 id="aofappend-only-file"><a class="markdownIt-Anchor" href="#aofappend-only-file"></a> AOF（Append Only File）</h3><p><code>数据完整性要求高</code> <code>内存数据量不大</code> <code>影响写入性能</code></p><p class="note note-primary">什么是AOF</p><p><img src="/2022/02/04/Redis/aof%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis的AOF（Append-Only File）持久化机制是一种用于确保数据持久性的方法，它通过记录并保存Redis服务器执行的所有写操作到磁盘上的一个文件中。这些记录包括了所有写命令及其参数，并以追加的方式保存在日志文件中。AOF机制的关键在于它记录的是实际执行的命令，而不仅仅是数据变更，这使得通过回放这些命令能够准确重建数据集。</p><p>AOF保存的是 <code>appendonly.aof</code> 文件</p><p><img src="/2022/02/04/Redis/aof%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">优点和缺点</p><p><strong><code>优点</code></strong></p><ul><li><code>安全性</code>：AOF 持久化可以配置为每次写操作后都同步到磁盘，或者每秒同步一次，这降低了数据丢失的风险。</li><li><code>可读的日志格式</code>：AOF 文件是一个只追加的日志文件，其内容是 Redis 命令的纯文本，这使得文件可以用于故障排查和数据恢复。</li><li><code>灵活的恢复策略</code>：可以通过编辑 AOF 文件来手动修复数据或删除错误的写操作。</li></ul><p><strong><code>缺点</code></strong></p><ul><li><code>恢复速度慢</code>：AOF 比 RDB 持久化有更高的磁盘 I/O 开销，尤其是在高写入负载的情况下。</li><li><code>对性能的影响</code>： AOF 需要记录每个写操作，因此在高写入负载下会对服务性能产生影响。</li><li><code>数据冗余</code>：随着时间的推移，AOF 文件可能包含一些过时或重复的命令，尽管 Redis 提供了重写机制来减少这种情况。</li></ul><p class="note note-primary">AOF配置</p><p><img src="/2022/02/04/Redis/aof.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>appendfilename</code></td><td>appendfilename AOF 文件名称</td></tr><tr><td><code>appendfsync</code></td><td>appendfsync aof持久化策略的配置<br><strong><code>no</code></strong> 写入系统内核缓冲区，由系统自动刷盘，速度最快<br><strong><code>always</code></strong> 每次执行写命令后都进行磁盘同步<br><strong><code>everysec</code></strong> 每秒进行一次磁盘同步</td></tr><tr><td><code>no-appendfsync-on-rewrite</code></td><td>重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性</td></tr><tr><td><code>auto-aof-rewrite-min-size</code></td><td>64mb。设置允许重写的最小aof文件大小</td></tr><tr><td><code>auto-aof-rewrite-percentage</code></td><td>默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重<br>写的aof文件大小的百分之多少进行重写</td></tr></tbody></table><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">no</span> <span class="hljs-comment"># 是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这</span><br>种方式在许多应用中已经足够用了<br><br>appendfsync everysec <span class="hljs-comment"># appendfsync aof持久化策略的配置</span><br><span class="hljs-comment"># no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="hljs-comment"># always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="hljs-comment"># everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br></code></pre></td></tr></table></figure><p class="note note-primary">正常恢复</p><ul><li>启动：修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录（config get dir）</li><li>恢复：重启redis然后重新加载</li></ul><p class="note note-primary">异常恢复</p><ul><li><p>启动：修改默认的appendonly no，改为yes</p></li><li><p>故意破坏 appendonly.aof 文件</p></li><li><p>修复： <span style="border-bottom:2px dashed green"><code>redis-check-aof --fix appendonly.aof</code> 进行修复</span></p></li><li><p>恢复：重启 redis 然后重新加载</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">## 开启aof,设置数据<br>&gt; <span class="hljs-keyword">set</span> k1 v1<br>OK<br>&gt; <span class="hljs-keyword">set</span> k2 v2<br>OK<br>&gt; <span class="hljs-keyword">set</span> k3 v3<br>OK<br>                          <br>停止Redis<br>                          <br>破坏aof文件结构<br>*<span class="hljs-number">2</span><br><span class="hljs-meta">$6</span><br><span class="hljs-keyword">SELECT</span><br><span class="hljs-meta">$1</span><br><span class="hljs-number">0</span><br>*<span class="hljs-number">3</span><br><span class="hljs-meta">$3</span><br><span class="hljs-keyword">set</span><br><span class="hljs-meta">$2</span><br>k1<br><span class="hljs-meta">$2</span><br>v1<br>*<span class="hljs-number">2</span><br><span class="hljs-meta">$6</span><br><span class="hljs-keyword">SELECT</span><br><span class="hljs-meta">$1</span><br><span class="hljs-number">0</span><br>*<span class="hljs-number">3</span><br><span class="hljs-meta">$3</span><br><span class="hljs-keyword">set</span><br><span class="hljs-meta">$2</span> // 删除<br>k2 // 删除<br><span class="hljs-meta">$2</span><br>v2<br>*<span class="hljs-number">3</span><br><span class="hljs-meta">$3</span><br><span class="hljs-keyword">set</span><br><span class="hljs-meta">$2</span><br>k3<br><span class="hljs-meta">$2</span><br>v3<br>                          <br>执行命令<br>/data/redis/data/redis1# redis-<span class="hljs-keyword">check</span>-aof <span class="hljs-comment">--fix appendonly.aof </span><br><span class="hljs-number">0</span>x              <span class="hljs-number">49</span>: Expected prefix <span class="hljs-string">&#x27;$&#x27;</span>, got: <span class="hljs-string">&#x27;*&#x27;</span><br>AOF analyzed: size=<span class="hljs-number">102</span>, ok_up_to=<span class="hljs-number">52</span>, diff=<span class="hljs-number">50</span><br>This will shrink the AOF <span class="hljs-keyword">from</span> <span class="hljs-number">102</span> bytes, <span class="hljs-keyword">with</span> <span class="hljs-number">50</span> bytes, <span class="hljs-keyword">to</span> <span class="hljs-number">52</span> bytes<br><span class="hljs-keyword">Continue</span>? [y/N]: y<br>Successfully truncated AOF<br>                          <br>启动Redis<br>&gt; keys *<br>k1<br></code></pre></td></tr></table></figure></li></ul><p class="note note-primary">AOF重写</p><p><strong><code>压缩AOF文件</code></strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-min-size <span class="hljs-number">64</span>MB   <span class="hljs-comment">// 当文件小于64M时不进行重写</span><br><span class="hljs-keyword">auto</span>-aof-rewrite-min-percenrage <span class="hljs-number">100</span>  <span class="hljs-comment">// 当文件比上次重写后的文件大100%时进行重写</span><br></code></pre></td></tr></table></figure><p>AOF采用文件追加方式，记录了所有写入命令，因此AOF文件会随着时间的推移变得越来越大。为了避免出现过大的AOF文件，Redis引入了AOF重写机制。当AOF文件的大小超过预设的阈值（默认为64MB），或者比上次重写后的文件大小增长了100%时，Redis会触发AOF重写。</p><p>AOF重写是一种内容压缩的过程，<span class="green-line">它会根据内存中的数据重新创建一个新的AOF文件，其中只包含能够完全恢复数据的最小指令集。</span>重写过程是在后台进行的，不会阻塞主线程的正常操作。可以使用命令 <code>bgrewriteaof</code> 手动触发AOF重写过程。</p><p>通过AOF重写，可以将过大的AOF文件压缩为较小的文件，从而减少磁盘空间的占用和提高AOF文件的读写效率。</p><p><strong><code>重写原理</code></strong></p><p>当Redis的AOF文件持续增长过大时，Redis会进行AOF重写操作以优化文件大小。AOF重写是通过fork出一个新的进程来实现的，首先该进程会将AOF文件的数据以二进制形式重新生成一个新的AOF文件，这个过程是在一个临时文件中进行的。当新的AOF文件生成完毕后，Redis会将旧的AOF文件进行覆盖，即先将临时文件重命名为新的AOF文件的名字，从而完成AOF重写操作。</p><p><a href="#aof%E5%9C%A8%E9%87%8D%E5%86%99%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BB%A7%E7%BB%AD%E6%9C%8D%E5%8A%A1">参考 AOF在重写时如何保证继续服务</a></p><p><strong><code>触发机制</code></strong></p><ul><li>当AOF文件超过64MB（可配置）或AOF文件超过上次重写大小的100%时。</li><li>调用 <code>BGREWRITEAOF</code> 手动触发</li></ul><p class="note note-primary">AOF和RDB同时开启</p><p><code>RDB</code> 和 <code>AOF</code> 不是互斥的，可以同时开启，如果AOF和RDB同时存在的时候，Redis会优先使用从AOF文件来还原数据库状态，如果AOF关闭状态时，则从RDB中恢复。</p><p><code>集群数据恢复</code></p><p>在Redis 集群中，如果整个集群的数据量非常庞大，主节点可以开启 <code>AOF</code> 保证数据完整性，从节点开启 <code>RDB</code> 策略。</p><p>当节点宕机恢复时，先关闭 <code>AOF</code> 功能，并且先从从节点中同步 <code>dump.rdb</code> 文件使用 <code>RDB</code> 方式进行数据恢复，待 <code>RDB</code> 恢复完毕后再使用命令动态启动 <code>AOF</code> 恢复，保证数据完整性</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-built_in">get</span> *<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> appendonly <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h4 id="aof在重写时如何保证继续服务"><a class="markdownIt-Anchor" href="#aof在重写时如何保证继续服务"></a> AOF在重写时如何保证继续服务</h4><p><code>AOF重写过程依旧提供服务，由子进程重写</code></p><p><img src="/2022/02/04/Redis/Aof%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="Aof重写过程"></p><p><img src="/2022/02/04/Redis/aof%E9%87%8D%E5%86%99.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><code>触发重写</code>：AOF 重写可以手动触发，也可以配置 Redis 自动在 AOF 文件达到特定大小后触发。手动触发是通过 <code>BGREWRITEAOF</code> 命令。</li><li><code>创建子进程</code>：Redis 使用子进程来执行重写操作。这样做的好处是避免阻塞主 Redis 进程，保证AOF重写期间主进程继续提供服务。</li><li><code>重建 AOF 文件</code>：子进程通过读取当前数据库的状态，重新生成一份写指令。</li><li><code>记录新命令</code>：在重写过程中，<span class="green-line">主进程继续处理新的写命令，将它们同时追加到旧的 AOF 文件和一个缓冲区中。</span>这确保了在重写期间对数据库所做的更改不会丢失。</li><li><code>切换 AOF 文件</code>：一旦子进程完成了重建过程，它会通知主进程。然后，主进程将缓冲区中的所有新命令追加到新的 AOF 文件中，以确保数据的完整性。</li><li><code>文件替换</code>：通过 <code>rename</code> 修改文件名完成新旧文件替换。</li></ol><h3 id="如何选择"><a class="markdownIt-Anchor" href="#如何选择"></a> 如何选择</h3><p><strong><code>结合使用</code></strong></p><p>为了平衡数据安全性和性能，可以同时启用 RDB 和 AOF。例如，可以使用 RDB 进行定时备份（例如每天一次），同时使用 AOF 来保证更高级别的数据安全性。</p><p><strong><code>集群上</code></strong></p><p>​	如果做Redis集群，那么主节点选择 <code>AOF</code> 持久化方式保证数据完整性，从节点选择 <code>RDB</code> 保证速度。</p><p><strong><code>业务场景</code></strong></p><ul><li><p>数据集大且读写频繁不太关注数据完整性场景如DB缓存层，可以使用 <code>RDB</code> 提高Redis性能。</p></li><li><p>数据集不大但对数据完整性要求高场景如商品库存数据，可以使用 <code>AOF</code> 保证数据完整性。</p></li></ul><h2 id="高可用"><a class="markdownIt-Anchor" href="#高可用"></a> 高可用</h2><h3 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h3><p><code>AP模型</code> <code>异步同步</code> <code>最终一致性保证</code> <code>主从同步延迟，数据可能不一致</code></p><p><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#cap-%E7%90%86%E8%AE%BA">CAP理论</a></p><p><img src="/2022/02/04/Redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt></p><p>主从复制是一种将一个Redis服务器的数据复制到其他Redis服务器的机制。在主从复制中，源服务器被称为主节点（master/leader），而目标服务器被称为从节点（slave/follower）。<span class="green-line">数据复制是单向的，只能从主节点复制到从节点。主节点负责写操作，而从节点主要用于读操作。</span></p><p>在默认情况下，每台Redis服务器都是主节点，也就是既能读取又能写入数据。每个主节点可以拥有多个从节点或者没有从节点。然而，每个从节点只能有一个主节点，它会从该主节点复制数据。</p><ul><li>主节点：负责读写操作。</li><li>从节点：只能执行读操作，不能写入数据。</li></ul><p class="note note-primary">主从复制的作用</p><ul><li><p><code>数据冗余</code>：主节点将数据复制到多个从服务器，实现数据冗余保证数据安全。</p></li><li><p><code>服务冗余</code>：主节点宕机，可以从从节点中重新指定一个主节点实现故障转移。</p></li><li><p><code>负载均衡</code>：从节点分担主节点读取压力，实现读取能力的水平扩展。</p></li></ul><p class="note note-primary">主从架构的缺点</p><ul><li><code>数据同步延迟</code>：在主从架构中，主节点负责接收写操作并将数据同步到从节点，存在一定时间的数据延迟。</li><li><code>写入性能未提升</code>：主从复制主要用于提高读取性能，因为所有写入操作仍然只能在主节点上进行。</li><li><code>单点故障</code>：尽管主从架构可以提供高可用性，但主节点本身仍然是一个单点故障，故障转移需要时间恢复。</li></ul><h4 id="全量同步"><a class="markdownIt-Anchor" href="#全量同步"></a> 全量同步</h4><p><code>slave初始化阶段</code></p><p><img src="/2022/02/04/Redis/%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.png" srcset="/img/loading.gif" lazyload alt></p><p>当一个从节点刚刚加入主从复制架构或由手动执行 <code>SLAVEOF</code> 命令，它需要从主节点获取所有数据的副本，以确保与主节点的数据一致性。这个过程称为全量同步。</p><p>全量同步过程如下：</p><ol><li>从节点发送 <code>SYNC</code> 命令给主节点，请求进行全量同步。</li><li>主节点在接收到 <code>SYNC</code> 命令后，会开始执行 <code>BGSAVE</code> 命令，将当前内存中的数据快照保存到磁盘上的 <code>RDB</code> 文件中。</li><li>主节点在完成 <code>BGSAVE</code> 后，将 <code>RDB</code> 文件发送给从节点，并将这段时间内的所有写命令发送给从节点。</li><li>从节点接收到 <code>RDB</code> 文件后，会将其加载到内存中，恢复主节点的数据。</li><li><code>RDB</code> 文件数据恢复后，从节点继续执行主节点发送的写命令，使自己的数据与主节点保持一致。</li></ol><h4 id="增量同步"><a class="markdownIt-Anchor" href="#增量同步"></a> 增量同步</h4><p>增量同步是指在主从复制过程中，主节点将自己的写操作日志（也称为命令传播）发送给从节点，使得从节点可以按照相同的顺序来执行这些写操作，从而保持与主节点的数据一致性。</p><p>增量同步过程如下：</p><ol><li>前提是完成全量同步。</li><li><code>从节点发送 SYNC 命令</code>：附带一个偏移量参数，表示从节点最后一次成功接收到的写操作日志的位置。</li><li><code>主节点处理</code>：<ul><li><code>有相应日志</code>： 将偏移量起始位置的所有操作日志发送给从节点，从节点安顺序执行。</li><li><code>没有相应日志</code>：重新全量同步。</li></ul></li></ol><h4 id="部分同步"><a class="markdownIt-Anchor" href="#部分同步"></a> 部分同步</h4><p>当从节点断线后重新连接时，可以使用部分同步来只同步断线期间的增量数据，而不是重新进行全量同步。</p><p>Redis 6.2 版本引入了复制积压缓冲区（Replication backlog）的功能。通过配置主节点的复制积压缓冲区大小，可以使主节点将写操作日志保存在缓冲区中，并在从节点重新连接时将缓冲区中的日志发送给从节点，从而实现部分同步（无磁盘复制）。</p><h4 id="无磁盘复制"><a class="markdownIt-Anchor" href="#无磁盘复制"></a> 无磁盘复制</h4><p>在传统的主从复制中，主节点会将数据写入磁盘，并将写操作的命令发送给从节点进行同步。而在无磁盘复制中，主节点在执行写操作后，将写操作的命令直接发送给从节点进行同步，而无需将数据写入磁盘。这种方式能够提高同步的速度和效率，减少了磁盘的IO开销。</p><p>无磁盘复制的实现主要依赖于Redis的复制功能。在Redis的复制模式下，主节点将写操作的命令发送给从节点进行同步。从节点会接收到命令并执行，从而达到数据同步的目的。主节点和从节点之间通过网络进行通信，数据的传输速度取决于网络的带宽和延迟。</p><h3 id="一主二从配置"><a class="markdownIt-Anchor" href="#一主二从配置"></a> 一主二从配置</h3><p class="note note-primary">Master配置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">0.0.0.0</span><br><span class="hljs-attribute">daemonize</span> no<br><span class="hljs-attribute">requirepass</span> wgf123<br><br><span class="hljs-comment"># 关闭rdb</span><br><span class="hljs-comment"># save &quot;&quot;</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># 关闭aof</span><br><span class="hljs-attribute">appendonly</span> no<br></code></pre></td></tr></table></figure><p class="note note-primary">Slave1配置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">0.0.0.0</span><br><span class="hljs-attribute">daemonize</span> no<br><span class="hljs-attribute">requirepass</span> wgf123<br><br><span class="hljs-comment"># 关闭rdb</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># 关闭aof</span><br><span class="hljs-attribute">appendonly</span> no<br><br><span class="hljs-comment">#主从复制</span><br><span class="hljs-comment"># 修改端口</span><br><span class="hljs-attribute">port</span> <span class="hljs-number">6380</span><br><br><span class="hljs-comment"># 配置master的ip和端口，如：192.168.1.2 6379</span><br><span class="hljs-attribute">slaveof</span> <span class="hljs-number">192.168.0.181</span> <span class="hljs-number">6379</span><br><br><span class="hljs-comment"># 如果当前服务器为slave，那么这里配置的就是master的访问密码</span><br><span class="hljs-attribute">masterauth</span> wgf123<br></code></pre></td></tr></table></figure><p class="note note-primary">Slave2配置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">0.0.0.0</span><br><span class="hljs-attribute">daemonize</span> no<br><span class="hljs-attribute">requirepass</span> wgf123<br><br><span class="hljs-comment"># 关闭rdb</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># 关闭aof</span><br><span class="hljs-attribute">appendonly</span> no<br><br><span class="hljs-comment">#主从复制</span><br><span class="hljs-comment"># 修改端口</span><br><span class="hljs-attribute">port</span> <span class="hljs-number">6381</span><br><br><span class="hljs-comment"># 配置master的ip和端口，如：192.168.1.2 6379</span><br><span class="hljs-attribute">slaveof</span> <span class="hljs-number">192.168.0.181</span> <span class="hljs-number">6379</span><br><br><span class="hljs-comment"># 如果当前服务器为slave，那么这里配置的就是master的访问密码</span><br><span class="hljs-attribute">masterauth</span> wgf123<br><br></code></pre></td></tr></table></figure><p class="note note-primary">docker 部署</p><p>主节点参考<a href="#docker-安装redis">docker-安装redis</a></p><p>docker 添加2个slave实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">需要保证 <br>	/data/redis/config/redis_slave_1.conf<br>	/data/redis/config/redis_slave_2.conf<br>这两个配置文件存在<br>创建两个目录<br>	/data/redis/data/redis_slave_1<br>	/data/redis/data/redis_slave_2<br><br>docker run -p 6380:6380 --name redis_slave_1 -v /data/redis/config/redis_slave_1.conf:/etc/redis/redis.conf -v /data/redis/data/redis_slave_1:/data -d redis redis-server /etc/redis/redis.conf<br><br>docker run -p 6381:6381 --name redis_slave_2 -v /data/redis/config/redis_slave_2.conf:/etc/redis/redis.conf -v /data/redis/data/redis_slave_2:/data -d redis redis-server /etc/redis/redis.conf<br></code></pre></td></tr></table></figure><p class="note note-primary">动态指定</p><p>还有一种方式可以不通过配置文件实现一主多从，使用<code>slaveof</code> 命令指定 master</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">slaveof</span> 主机<span class="hljs-built_in">ip</span> 主机端口<br></code></pre></td></tr></table></figure><p class="note note-primary">测试</p><p>查看节点信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">info</span> <span class="hljs-keyword">replication</span><br></code></pre></td></tr></table></figure><p><img src="/2022/02/04/Redis/%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### master ####<br><br>set k1 v1<br><br>set k2 v2<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### Slave1 ####<br><br>keys *<br>k1<br>k2<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### Slave2 ####<br><br>keys *<br>k1<br>k2<br></code></pre></td></tr></table></figure><p class="note note-primary">故障模拟</p><p>Docker 停止 <strong>Slave2</strong>, 模拟Slave 故障</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop redis_slave_2<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### master ####<br><br>set k3 v3<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### Slave1 ####<br><br>keys *<br>k1<br>k3<br>k2<br></code></pre></td></tr></table></figure><p>Docker 启动 <strong>Slave2</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> redis_slave_2<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### Slave2 ####<br><br>keys *<br>k1<br>k3<br>k2<br></code></pre></td></tr></table></figure><p>故障回复，数据重新同步</p><h4 id="薪火相传"><a class="markdownIt-Anchor" href="#薪火相传"></a> 薪火相传</h4><p><img src="/2022/02/04/Redis/%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">在Redis的主从架构中，一个从节点也可以充当其他从节点的主节点，实现多级主从复制，也被称为链式复制或级联复制。</span></p><p>在这种情况下，原本是主节点的节点称为顶层主节点或根节点。其他节点既是上一级节点的从节点，同时也是下一级节点的主节点。这样的架构可以形成一个主从节点的链条，实现数据的级联传递和复制。</p><p>当一个从节点成为其他从节点的主节点时，它会接收并复制来自上一级节点的数据和操作，并将这些数据和操作传递给下一级节点，以实现层层传递。</p><p>需要注意的是，在级联复制中，数据同步的延迟可能会增加，因为每个从节点都需要等待上一级节点同步数据后才能进行同步，链式复制的好处是降低根节点的数据同步压力。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">slaveof</span> 主机<span class="hljs-built_in">ip</span> 主机端口<br></code></pre></td></tr></table></figure><p class="note note-primary">使用场景</p><ol><li><code>减轻主节点同步压力</code>：多个从节点场景，主节点将数据同步给一个从节点X，其他从节点从从节点X处同步数据。</li><li><code>带宽优化</code>：不同地理位置的数据中心仅需要一个节点进行异地复制，其他节点可以是内网复制。</li></ol><h4 id="反客为主"><a class="markdownIt-Anchor" href="#反客为主"></a> 反客为主</h4><p>当主节点发生故障时，可以将一个从节点提升为新的主节点，接管写操作的处理。这个过程称为故障转移。一旦新的主节点选举完成并开始接收写操作，其他从节点会继续向新的主节点复制数据，以保持数据的一致性。</p><p>从节点切换为主节点的命令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one<br></code></pre></td></tr></table></figure><h3 id="哨兵模式"><a class="markdownIt-Anchor" href="#哨兵模式"></a> 哨兵模式</h3><p><code>Redis哨兵是独立于Redis服务外的独立进程</code> <code>Master故障转移</code></p><p><img src="/2022/02/04/Redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis哨兵模式通过使用独立的哨兵进程来提供一种高可用性的解决方案。每个哨兵进程都是独立运行的，它们通过发送命令给Redis服务器并等待其响应来监控一个或多个Redis实例的健康状况。当主Redis宕机后，哨兵自行将从Redis提升为主节点，实现故障转移。</p><p class="note note-primary">哨兵的作用</p><ul><li><p><code>监控</code>：通过心跳机制检测Redis的健康状态。</p></li><li><p><code>故障转移</code>：如果主服务器宕机。哨兵会自动将其中一个从服务器提升为新的主服务器，并让其余的从服务器更新配置，指向新的主服务器。</p></li><li><p><code>服务发现</code>：在主服务器发生故障转移后，客户端可以重新连接到新的主服务器，而无需人工修改配置。</p></li></ul><p><img src="/2022/02/04/Redis/%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7.png" srcset="/img/loading.gif" lazyload alt></p><div class="note note-warning"><p><strong>多哨兵</strong></p><p>Redis 哨兵实例间的相互发现是通过Redis的发布-订阅功能实现的。每个Sentinel定期在特定频道发布自己的信息，并同时订阅这个频道以接收来自其他哨兵的信息。这样，当一个新的哨兵加入网络时，它通过发布信息到这个频道，被其他哨兵发现并加入到监控网络中。因此，多个哨兵监控同一个Redis主节点，它们就能够发现彼此。</p><p>在一个哨兵系统中，多个哨兵实例不仅监控 Redis 主服务器和从服务器，而且互相监控以确保哨兵系统本身的健康和可靠性。</p><p><strong><code>哨兵Leader</code></strong>：哨兵们会选举出一个领导者来负责执行故障转移过程。</p><p><strong><code>共识决策</code></strong>：避免单个哨兵因网络问题或其他原因错误地判定主服务器故障，多哨兵间会达成共识。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">哨兵配置<br><br>#主节点信息，格式：sentinel <span class="hljs-tag">&lt;<span class="hljs-name">master-name</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">redis-port</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">quorum</span>&gt;</span><br>#<span class="hljs-tag">&lt;<span class="hljs-name">master-name</span>&gt;</span> 为主节点设定的一个自定义名称<br>#<span class="hljs-tag">&lt;<span class="hljs-name">ip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">redis-port</span>&gt;</span> 主节点的ip和端口<br>#<span class="hljs-tag">&lt;<span class="hljs-name">quorum</span>&gt;</span> 多少个 Sentinel 同意主节点不可达时，才会发起故障转移（共识决策）<br></code></pre></td></tr></table></figure><p><strong><code>主观下线</code></strong>：主观下线是单个哨兵实例认为主节点线下。</p><p><strong><code>客观下线</code></strong>：<code>quorum</code> 个哨兵认为主节点下线，此时需要进行故障转移。</p></div><p class="note note-primary">哨兵模式的缺点</p><ul><li><code>数据丢失</code>：主服务器在故障前未能将所有数据同步到从服务器，故障转移可能导致数据丢失。</li><li><code>数据不一致</code>：出现网络分区时，Sentinel 实例不能互相通信，可能导致多个从服务器被提升为主服务器，产生 <code>脑裂</code> 现象，导致数据不一致。</li></ul><p><em>避免脑裂：quorum（故障转移达成共识的最少哨兵数）要大于等于哨兵总数的半数 + 1，满足过半原则。</em></p><h4 id="哨兵配置说明"><a class="markdownIt-Anchor" href="#哨兵配置说明"></a> 哨兵配置说明</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Example sentinel.conf</span><br><br><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认26379</span><br>port 26379<br><br><span class="hljs-comment"># 哨兵sentinel的工作目录</span><br><span class="hljs-built_in">dir</span> /tmp<br><br><span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="hljs-comment"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="hljs-comment"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><br><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br>sentinel monitor mymaster 127.0.0.1 6379 2<br><br><span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br>sentinel auth-pass mymaster MySUPER--secret-0123passw0rd<br><br><br><span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel down-after-milliseconds mymaster 30000<br><br><span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br><span class="hljs-comment">#这个数字越小，完成failover所需的时间就越长，</span><br><span class="hljs-comment">#但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="hljs-comment">#可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br>sentinel parallel-syncs mymaster 1<br><br><br><br><span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="hljs-comment">#3.当想要取消一个正在进行的failover所需要的时间。  </span><br><span class="hljs-comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="hljs-comment"># 默认三分钟</span><br><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br>sentinel failover-timeout mymaster 180000<br><br><span class="hljs-comment"># SCRIPTS EXECUTION</span><br><br><span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="hljs-comment">#对于脚本的运行结果有以下规则：</span><br><span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><br><span class="hljs-comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><br><span class="hljs-comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><br><span class="hljs-comment">#一个是事件的类型，</span><br><span class="hljs-comment">#一个是事件的描述。</span><br><span class="hljs-comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="hljs-comment">#通知脚本</span><br><span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel notification-script mymaster /var/redis/notify.sh<br><br><span class="hljs-comment"># 客户端重新配置主节点参数脚本</span><br><span class="hljs-comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="hljs-comment"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-comment"># 目前&lt;state&gt;总是“failover”,</span><br><span class="hljs-comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="hljs-comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="hljs-comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh<br></code></pre></td></tr></table></figure><p class="note note-primary">配置哨兵</p><p><code>data/redis/config</code> 目录下添加配置</p><p><strong>sentinel.conf</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">port 26379<br>logfile <span class="hljs-string">&quot;26379.log&quot;</span><br>dir /data<br>sentinel<span class="hljs-built_in"> monitor </span>mymaster 192.168.0.181 6379 1<br>sentinel auth-pass mymaster wgf123<br>sentinel down-after-milliseconds mymaster 30000<br>sentinel parallel-syncs mymaster 2<br><span class="hljs-comment"># 故障转移</span><br>sentinel failover-timeout mymaster 60000<br><br></code></pre></td></tr></table></figure><p><strong>docker启动哨兵服务</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">26379</span>:<span class="hljs-number">26379</span> --name redis_sentinel \<br>-v <span class="hljs-regexp">/data/</span>redis<span class="hljs-regexp">/config/</span>sentinel.conf:<span class="hljs-regexp">/etc/</span>redis/redis-sentinel.conf \<br>-d redis redis-sentinel <span class="hljs-regexp">/etc/</span>redis/redis-sentinel.conf<br></code></pre></td></tr></table></figure><p><img src="/2022/02/04/Redis/docker%E5%93%A8%E5%85%B5.jpg" srcset="/img/loading.gif" lazyload alt></p><p><strong>查看节点信息</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">&gt; info replication<br><span class="hljs-meta"># Replication</span><br><span class="hljs-symbol">role:</span>slave						<span class="hljs-meta"># 当前节点身份</span><br><span class="hljs-symbol">master_host:</span><span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.181</span>		<span class="hljs-meta"># 主节点ip</span><br><span class="hljs-symbol">master_port:</span><span class="hljs-number">6379</span>				<span class="hljs-meta"># 主节点port</span><br><span class="hljs-symbol">master_link_status:</span>up<br><span class="hljs-symbol">master_last_io_seconds_ago:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">master_sync_in_progress:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">slave_read_repl_offset:</span><span class="hljs-number">2568</span><br><span class="hljs-symbol">slave_repl_offset:</span><span class="hljs-number">2568</span><br><span class="hljs-symbol">slave_priority:</span><span class="hljs-number">100</span><br><span class="hljs-symbol">slave_read_only:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">replica_announced:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">connected_slaves:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">master_failover_state:</span>no-failover<br><span class="hljs-symbol">master_replid:</span>c5b383caf344b7bfda01b3891a7cf149983341b7<br><span class="hljs-symbol">master_replid2:</span><span class="hljs-number">0000000000000000000000000000000000000000</span><br><span class="hljs-symbol">master_repl_offset:</span><span class="hljs-number">2568</span><br><span class="hljs-symbol">second_repl_offset:</span><span class="hljs-number">-1</span><br><span class="hljs-symbol">repl_backlog_active:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">repl_backlog_size:</span><span class="hljs-number">1048576</span><br><span class="hljs-symbol">repl_backlog_first_byte_offset:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">repl_backlog_histlen:</span><span class="hljs-number">2568</span><br></code></pre></td></tr></table></figure><p><strong>暂停主节点</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker stop redis1<br>等待<span class="hljs-number">1</span>分钟<br></code></pre></td></tr></table></figure><p><strong>查看节点信息</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">&gt; info replication<br><span class="hljs-meta"># Replication</span><br><span class="hljs-symbol">role:</span>slave<br><span class="hljs-symbol">master_host:</span><span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-symbol">master_port:</span><span class="hljs-number">6380</span>			<span class="hljs-meta"># 6380 节点被哨兵选择为主节点</span><br><span class="hljs-symbol">master_link_status:</span>up<br><span class="hljs-symbol">master_last_io_seconds_ago:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">master_sync_in_progress:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">slave_read_repl_offset:</span><span class="hljs-number">37895</span><br><span class="hljs-symbol">slave_repl_offset:</span><span class="hljs-number">37895</span><br><span class="hljs-symbol">slave_priority:</span><span class="hljs-number">100</span><br><span class="hljs-symbol">slave_read_only:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">replica_announced:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">connected_slaves:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">master_failover_state:</span>no-failover<br><span class="hljs-symbol">master_replid:</span><span class="hljs-number">556e8</span>cc700a7e93dc23b8e3bd5556302c15157cf<br><span class="hljs-symbol">master_replid2:</span>c5b383caf344b7bfda01b3891a7cf149983341b7<br><span class="hljs-symbol">master_repl_offset:</span><span class="hljs-number">37895</span><br><span class="hljs-symbol">second_repl_offset:</span><span class="hljs-number">35671</span><br><span class="hljs-symbol">repl_backlog_active:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">repl_backlog_size:</span><span class="hljs-number">1048576</span><br><span class="hljs-symbol">repl_backlog_first_byte_offset:</span><span class="hljs-number">173</span><br><span class="hljs-symbol">repl_backlog_histlen:</span><span class="hljs-number">37723</span><br></code></pre></td></tr></table></figure><p><strong>启动原主节点docker</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> redis1<br></code></pre></td></tr></table></figure><p><strong>查看节点信息</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">info replication<br><span class="hljs-meta"># Replication</span><br><span class="hljs-symbol">role:</span>slave<br><span class="hljs-symbol">master_host:</span><span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-symbol">master_port:</span><span class="hljs-number">6380</span>		<span class="hljs-meta"># 6380 还是主节点，原主节点下线再上线就变成从节点</span><br><span class="hljs-symbol">master_link_status:</span>down<br><span class="hljs-symbol">master_last_io_seconds_ago:</span><span class="hljs-number">-1</span><br><span class="hljs-symbol">master_sync_in_progress:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">slave_read_repl_offset:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">slave_repl_offset:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">master_link_down_since_seconds:</span><span class="hljs-number">-1</span><br><span class="hljs-symbol">slave_priority:</span><span class="hljs-number">100</span><br><span class="hljs-symbol">slave_read_only:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">replica_announced:</span><span class="hljs-number">1</span><br><span class="hljs-symbol">connected_slaves:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">master_failover_state:</span>no-failover<br><span class="hljs-symbol">master_replid:</span>bcbe300ea51d12f5a158f4967582598328e87864<br><span class="hljs-symbol">master_replid2:</span><span class="hljs-number">0000000000000000000000000000000000000000</span><br><span class="hljs-symbol">master_repl_offset:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">second_repl_offset:</span><span class="hljs-number">-1</span><br><span class="hljs-symbol">repl_backlog_active:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">repl_backlog_size:</span><span class="hljs-number">1048576</span><br><span class="hljs-symbol">repl_backlog_first_byte_offset:</span><span class="hljs-number">0</span><br><span class="hljs-symbol">repl_backlog_histlen:</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="springboot-集成哨兵模式"><a class="markdownIt-Anchor" href="#springboot-集成哨兵模式"></a> SpringBoot 集成哨兵模式</h4><p><code>项目连接哨兵服务</code></p><p class="note note-primary">添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">redis:</span><br> <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">password:</span> <span class="hljs-string">wgf123</span><br> <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">3000</span>   <span class="hljs-comment"># 连接超时时间（毫秒）</span><br> <span class="hljs-attr">sentinel:</span><br>   <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>   <span class="hljs-attr">nodes:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:26379</span>  <span class="hljs-comment"># 多个哨兵逗号隔开</span><br> <span class="hljs-attr">lettuce:</span> <span class="hljs-comment"># Redis的Java驱动包,使用lettuce连接池</span><br>   <span class="hljs-attr">pool:</span><br>     <span class="hljs-attr">max-active:</span> <span class="hljs-number">200</span> <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br>     <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span>    <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>     <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span>    <span class="hljs-comment"># 连接池中的最大空闲连接 (默认为8)</span><br>     <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>     <span class="hljs-comment"># 连接池中的最小空闲连接</span><br></code></pre></td></tr></table></figure><p class="note note-primary">测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelTest</span> &#123;<br> <span class="hljs-meta">@Autowired</span><br> RedisTemplate redisTemplate;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTest</span><span class="hljs-params">()</span> &#123;<br>     redisTemplate.opsForValue().set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);<br> &#125;<br><br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTest</span><span class="hljs-params">()</span> &#123;<br>   log.info(<span class="hljs-string">&quot;test = &#123;&#125;&quot;</span>, redisTemplate.opsForValue().get(<span class="hljs-string">&quot;test&quot;</span>));<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="redis-集群"><a class="markdownIt-Anchor" href="#redis-集群"></a> Redis 集群</h2><p><code>多主节点</code> <code>哈希槽数据分片</code></p><p><em>部分参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/yufeng218/p/13688582.html">https://www.cnblogs.com/yufeng218/p/13688582.html</a></em></p><p><img src="/2022/02/04/Redis/redis%E9%9B%86%E7%BE%A4.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis集群是一个由 <code>多个主从节点群</code> 组成的分布式服务集群，Redis集群不需要哨兵也能完成节点移除和 <code>故障转移</code> 的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展。以下是 Redis 集群的一些关键特点和功能：</p><ol><li><strong><code>数据分片</code></strong>：Redis 集群通过自动将数据分布在不同的节点（称为分片）上来提供数据的水平扩展能力。这种分片是基于哈希槽（Hash Slot）的，总共有 <code>16384</code> 个哈希槽。</li><li><strong><code>高可用性</code></strong>：集群模式支持主从复制（Master-Slave Replication），每个主节点都可以有一个或多个从节点。如果主节点宕机，集群会自动执行故障转移，将一个从节点提升为新的主节点。</li><li><strong><code>无中心架构</code></strong>：Redis 集群没有中心节点，每个节点都保存着部分哈希槽的数据。这样的设计提高了系统的可靠性和可伸缩性。</li><li><strong><code>故障转移</code></strong>：在节点出现故障时，集群能够自动进行故障转移，确保数据的持续可用性。</li><li><strong><code>读写分离</code></strong>：可以通过从节点来分担读取负载，从而实现读写分离，提高性能。</li><li><strong><code>请求重定向</code></strong>：客户端与集群中的任何一个节点通信，如果请求的数据不在该节点，客户端将被重定向到正确的节点。</li><li><strong><code>容错性</code></strong>：虽然 Redis 是基于内存的，但它也支持持久化。在集群模式下，即使部分节点宕机，其他节点仍然可以继续提供服务。</li><li><strong><code>水平扩展</code></strong>：Redis 集群支持通过增加更多节点来线性扩展系统的处理能力和存储容量。</li></ol><h3 id="集群搭建"><a class="markdownIt-Anchor" href="#集群搭建"></a> 集群搭建</h3><p class="note note-primary">部署规划</p><p>​	三组Redis主从复制，三个master，三个slave共6个节点</p><ul><li>第一组 6400(主) 6401(从)</li><li>第二组 7400(主) 7401(从)</li><li>第三组 8400(主) 8401(从)</li></ul><p class="note note-primary">创建文件夹</p><p>在<code>/data/redis/config/cluster</code>目录下分别按照端口创建文件夹，用于存放配置文件</p><p><img src="/2022/02/04/Redis/%E9%9B%86%E7%BE%A4%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" srcset="/img/loading.gif" lazyload alt></p><p>在<code>/data/redis/data/cluster</code>目录下分别按照端口创建文件夹，用于存放持久化数据</p><p class="note note-primary">配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 记得修改端口号</span><br>port 6400<br>daemonize no<br><br><span class="hljs-comment">#指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据(记得修改路径)</span><br><span class="hljs-built_in">dir</span> /data<br><br><span class="hljs-comment">#启动集群模式</span><br>cluster-enabled <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment">#集群节点信息文件，这里640x最好和port对应上</span><br>cluster-config-file nodes-6400.conf<br><br><span class="hljs-comment"># 节点离线的超时时间</span><br>cluster-node-timeout 5000<br><br><span class="hljs-comment">#去掉bind绑定访问ip信息</span><br><span class="hljs-built_in">bind</span> 0.0.0.0<br><br><span class="hljs-comment">#关闭保护模式</span><br>protected-mode no <br><br><span class="hljs-comment">#启动AOF文件</span><br>appendonly <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment">#如果要设置密码需要增加如下配置：</span><br><span class="hljs-comment">#设置redis访问密码</span><br>requirepass wgf123<br><br><span class="hljs-comment">#设置集群节点间访问密码，跟上面一致</span><br>masterauth wgf123<br></code></pre></td></tr></table></figure><p>分别复制6份到<code>/data/redis/config/cluster</code>目录对应的端口文件夹下，记得修改端口以及路径</p><p class="note note-primary">运行docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run -p 6400:6400 -p 16400:16400 --name redis_6400 -v /data/redis/config/cluster/6400/redis.conf:/etc/redis/redis.conf -v /data/redis/data/cluster/6400:/data -d redis redis-server /etc/redis/redis.conf<br><br>docker run -p 6401:6401 -p 16401:16401 --name redis_6401 -v /data/redis/config/cluster/6401/redis.conf:/etc/redis/redis.conf -v /data/redis/data/cluster/6401:/data -d redis redis-server /etc/redis/redis.conf<br><br>docker run -p 7400:7400 -p 17400:17400 --name redis_7400 -v /data/redis/config/cluster/7400/redis.conf:/etc/redis/redis.conf -v /data/redis/data/cluster/7400:/data -d redis redis-server /etc/redis/redis.conf<br><br>docker run -p 7401:7401 -p 17401:17401 --name redis_7401 -v /data/redis/config/cluster/7401/redis.conf:/etc/redis/redis.conf -v /data/redis/data/cluster/7401:/data -d redis redis-server /etc/redis/redis.conf<br><br>docker run -p 8400:8400 -p 18400:18400 --name redis_8400 -v /data/redis/config/cluster/8400/redis.conf:/etc/redis/redis.conf -v /data/redis/data/cluster/8400:/data -d redis redis-server /etc/redis/redis.conf<br><br>docker run -p 8401:8401 -p 18401:18401 --name redis_8401 -v /data/redis/config/cluster/8401/redis.conf:/etc/redis/redis.conf -v /data/redis/data/cluster/8401:/data -d redis redis-server /etc/redis/redis.conf<br><br>参数说明：-p 16400:16400 我除了要开放6400端口，还要在服务器控制台开放16400端口，才能建立起集群(原端口 +10000)<br></code></pre></td></tr></table></figure><p><img src="/2022/02/04/Redis/%E9%9B%86%E7%BE%A4%E5%88%97%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">创建集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># IP排在前面的是master节点</span><br><span class="hljs-comment"># 登录任意一台redis</span><br>redis-cli -a wgf123 --cluster create 192.168.0.181:6400 192.168.0.181:7400 192.168.0.181:8400 192.168.0.181:6401 192.168.0.181:7401 192.168.0.181:8401 --cluster-replicas 1<br><br><br>&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.181:6400)<br>M: 8974118e3a7f1a599c744b0b7b1c7ec12db541a3 192.168.0.181:6400<br>   slots:[0-5460] (5461 slots) master								<span class="hljs-comment"># 第一台master节点的hash槽分配</span><br>   1 additional replica(s)<br>S: 9bc6fc61a175c167c02b9c9817a17547098feb14 172.17.0.1:6401<br>   slots: (0 slots) slave<br>   replicates c9c36b72db1a20a2436d640ba5668caf611736f9<br>S: bafbf2b199305aacfe60ccdb5e049ba881a3d281 172.17.0.1:8401<br>   slots: (0 slots) slave<br>   replicates 8974118e3a7f1a599c744b0b7b1c7ec12db541a3<br>M: b4fae0480f54069e46b1ac3fd56b57426e37dc2d 172.17.0.1:8400			<br>   slots:[10923-16383] (5461 slots) master							<span class="hljs-comment"># 第三台master节点的hash槽分配</span><br>   1 additional replica(s)<br>M: c9c36b72db1a20a2436d640ba5668caf611736f9 172.17.0.1:7400<br>   slots:[5461-10922] (5462 slots) master							<span class="hljs-comment"># 第二台master节点的hash槽分配</span><br>   1 additional replica(s)<br>S: 52a7982c543f1131f7bea9a5886d3ef6fbf7b40f 172.17.0.1:7401<br>   slots: (0 slots) slave<br>   replicates b4fae0480f54069e46b1ac3fd56b57426e37dc2d<br>[OK] All nodes agree about slots configuration.<br>&gt;&gt;&gt; Check <span class="hljs-keyword">for</span> open slots...                                                                                                                                                                                                                                                       <br>&gt;&gt;&gt; Check slots coverage...<br>[OK] All 16384 slots covered.<br><br><br><span class="hljs-comment"># 参数说明</span><br>-a ：密码；<br>--cluster-replicas 1：表示1个master下挂1个slave； --cluster-replicas 2：表示1个master下挂2个slave<br></code></pre></td></tr></table></figure><p class="note note-primary">集群命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-cli --cluster help <br><br>create：创建一个集群环境host1:port1 ... hostN:portN<br>call：可以执行redis命令<br>add-<span class="hljs-keyword">node</span><span class="hljs-title">：将一个节点添加到集群里，第一个参数为新节点的ip</span>:port，第二个参数为集群中任意一个已经存在的节点的ip:port<br>del-<span class="hljs-keyword">node</span><span class="hljs-title">：移除一个节点</span><br><span class="hljs-title">reshard</span>：重新分片<br>check：检查集群状态<br></code></pre></td></tr></table></figure><p>查看集群的信息<code>cluster info</code>，登录任意一台node</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; cluster info<br>cluster_state:ok<br>cluster_slots_assigned:16384<br>cluster_slots_ok:16384<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:3<br>cluster_current_epoch:6<br>cluster_my_epoch:5<br>cluster_stats_messages_ping_sent:4634<br>cluster_stats_messages_pong_sent:4667<br>cluster_stats_messages_meet_sent:1<br>cluster_stats_messages_sent:9302<br>cluster_stats_messages_ping_received:4667<br>cluster_stats_messages_pong_received:4635<br>cluster_stats_messages_received:9302<br></code></pre></td></tr></table></figure><p>查看节点列表<code>cluster nodes</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">&gt; cluster nodes<br>b4fae0480f54069e46b1ac3fd56b57426e37dc2d 172.17.0.6:8400@18400 myself,master - 0 1644832798000 5 connected 10923-16383<br>52a7982c543f1131f7bea9a5886d3ef6fbf7b40f 172.17.0.1:7401@17401 slave b4fae0480f54069e46b1ac3fd56b57426e37dc2d 0 1644832800077 5 connected<br>bafbf2b199305aacfe60ccdb5e049ba881a3d281 172.17.0.1:8401@18401 slave 8974118e3a7f1a599c744b0b7b1c7ec12db541a3 0 1644832799575 1 connected<br>8974118e3a7f1a599c744b0b7b1c7ec12db541a3 172.17.0.1:6400@16400 master - 0 1644832799073 1 connected 0-5460<br>9bc6fc61a175c167c02b9c9817a17547098feb14 172.17.0.1:6401@16401 slave c9c36b72db1a20a2436d640ba5668caf611736f9 0 1644832799575 3 connected<br>c9c36b72db1a20a2436d640ba5668caf611736f9 172.17.0.1:7400@17400 master - 0 1644832799000 3 connected 5461-10922<br></code></pre></td></tr></table></figure><h3 id="查询集群中的值"><a class="markdownIt-Anchor" href="#查询集群中的值"></a> 查询集群中的值</h3><ul><li><p><code>CLUSTER KEYSLOT &lt;key&gt;</code>: 此命令用于查询某个特定键（key）被映射到的哈希槽的编号。</p></li><li><p><code>CLUSTER COUNTKEYSINSLOT &lt;slot&gt;</code>: 用于查询指定的哈希槽中包含的键的数量。</p></li><li><p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>: 此命令返回指定哈希槽中的一定数量的键。</p></li></ul><h3 id="hash-tag"><a class="markdownIt-Anchor" href="#hash-tag"></a> Hash Tag</h3><p>Redis 集群中的哈希标签（Hash Tag）是一种特殊的机制，用于确保特定的键被分配到相同的哈希槽（Hash Slot），从而允许在集群模式下完成对多个键的操作。</p><p>哈希标签通过在键名中加入 <code>&#123;&#125;</code> 来使用。在 <code>&#123;&#125;</code> 中的内容被用于计算哈希槽，而 <code>&#123;&#125;</code> 外的部分被忽略。例如，在键 <code>user&#123;12345&#125;:followers</code> 中，<code>12345</code> 是哈希标签。</p><div class="note note-warning"><p><strong>Hash Tag 使用</strong></p><p>在 Redis 集群模式下，<code>MSET</code> 命令默认情况下不可用，因为它涉及到一次性对多个键进行设置，而这些键可能属于不同的哈希槽。</p><p><img src="/2022/02/04/Redis/mset%E5%BC%82%E5%B8%B8.png" srcset="/img/loading.gif" lazyload alt></p><p>使用哈希标签解决 <code>MSET</code> 问题:</p><p><img src="/2022/02/04/Redis/mset%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" lazyload alt></p><p>例如，使用 <code>MSET key1{tag} value1 key2{tag} value2</code> 可以确保 <code>key1{tag}</code> 和 <code>key2{tag}</code> 被分配到同一个哈希槽，从而能使用 <code>MSET</code> 命令。</p></div><h3 id="集群原理分析"><a class="markdownIt-Anchor" href="#集群原理分析"></a> 集群原理分析</h3><ul><li><strong><code>槽位分配</code></strong>：Redis Cluster 将所有数据划分为 16384 个槽位（slots）。每个槽位负责存储一部分数据，从而实现数据的分布式存储。</li><li><strong><code>主从节点与槽位</code></strong>：在集群中，槽位只直接分配给主节点（master nodes）。每个主节点负责一部分槽位。虽然从节点（slave nodes）不直接分配槽位，但它们通过复制各自的主节点来存储相应槽位的数据。</li><li><strong><code>客户端的槽位缓存</code></strong>：当 Redis 集群的客户端连接到集群时，它会接收到集群的槽位配置信息，并在本地缓存这些信息。客户端可以直接定位到包含特定键的目标节点，提高查询效率。</li></ul><h3 id="槽位定位算法"><a class="markdownIt-Anchor" href="#槽位定位算法"></a> 槽位定位算法</h3><p><img src="/2022/02/04/Redis/%E9%9B%86%E7%BE%A4%E6%A7%BD%E4%BD%8D.png" srcset="/img/loading.gif" lazyload alt></p><p>Cluster 默认会对 key 值使用 <code>crc16</code> 算法进行 hash 得到一个整数值，然后用这个整数值对 <strong>16384</strong> 进行取模来得到具体槽位。</p><p><strong><code>HASH_SLOT = CRC16(key) % 16384</code></strong></p><h3 id="跳转重定位"><a class="markdownIt-Anchor" href="#跳转重定位"></a> <strong>跳转重定位</strong></h3><p><code>类似ES的协调节点</code> <code>纠正槽位映射</code></p><p><img src="/2022/02/04/Redis/%E8%BD%AC%E8%B7%B3%E9%87%8D%E6%96%B0%E5%AE%9A%E5%90%91.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/02/04/Redis/%E8%B7%B3%E8%BD%AC%E9%87%8D%E5%AE%9A%E5%90%91.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><strong><code>客户端指令处理</code></strong>：当客户端向 Redis 集群的某个节点发送指令时，这个节点首先根据指令中的 key 计算出对应的槽位。</li><li><strong><code>槽位归属检查</code></strong>：接着，该节点检查该槽位是否属于自己管理。如果是，它会直接执行该指令；如果不是，进入下一步。</li><li><strong><code>重定向操作</code></strong>：当槽位不属于当前节点时，该节点会向客户端发送一个重定向响应，其中包含负责该槽位的目标节点地址。</li><li><strong><code>响应客户端</code></strong>：客户端收到重定向响应后，会根据提供的信息连接到正确的节点，并在那里重新执行原指令。</li><li><strong><code>更新槽位映射表</code></strong>：客户端也会更新其本地槽位映射表，以反映最新的槽位和节点对应关系。这样，后续对相同或相关 key 的操作可以直接定位到正确的节点，减少重定向的发生。</li></ol><h3 id="redis集群节点发现"><a class="markdownIt-Anchor" href="#redis集群节点发现"></a> Redis集群节点发现</h3><p><a href="/2022/10/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/#gossip%E5%8D%8F%E8%AE%AE">gossip协议：</a></p><ul><li>Redis 集群使用 Gossip 协议进行节点间的通信和信息交换。这个协议允许节点定期随机交换信息，如其他节点的状态、已知的地址等。</li><li>Gossip 通信是增量的和不频繁的，帮助减少网络带宽消耗，同时确保了集群状态信息的最新性和一致性。</li></ul><p><code>节点发现</code>：</p><ul><li>新节点加入集群时，它会通过已知节点的信息来发现其他节点，并通过 Gossip 协议与它们建立通信。</li><li>节点使用 TCP 连接在集群内部彼此通信，默认端口为 Redis 服务端口的加10000，如 Redis 端口为6379，则集群通信端口为16379。</li></ul><h3 id="redis集群选举原理"><a class="markdownIt-Anchor" href="#redis集群选举原理"></a> <strong>Redis集群选举原理</strong></h3><p><code>过半机制</code> <code>由其他Master节点选取新的Master</code></p><ul><li><code>客观下线</code>：某个主节点宕机，够多的主节点（根据集群配置的 quorum）同意某个主节点失效时，该节点被标记为客观下线（ODOWN）。</li><li><code>发起投票</code>：从节点开始发起投投票，只有主节点能够投票。</li><li><code>投票限制</code>：每个主节点在一个选举周期内只能投票一次。</li><li><code>赢得选举</code>：某个节点获得超过半数主节点的投票，当选新的主节点。</li><li><code>通知和同步</code>：通过 Gossip 协议通知集群中的所有节点当选信息，从节点开始同步数据。</li></ul><h3 id="故障恢复"><a class="markdownIt-Anchor" href="#故障恢复"></a> 故障恢复</h3><p>如果主节点下线？从节点能否自动升为主节点？注意：<em><strong>15</strong></em> 秒超时。</p><p><img src="/2022/02/04/Redis/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>当 <em><strong>6400</strong></em> 挂掉后，<em><strong>8401</strong></em> 成为新的主机。</li></ul><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><p><img src="/2022/02/04/Redis/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D2.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/02/04/Redis/%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D3.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>当 <em><strong>6400</strong></em> 重启后，<em><strong>6400</strong></em> 成为 <em><strong>8401</strong></em> 的从机。</li></ul><p>如果所有某一段插槽的主从节点都宕掉，<em><strong>redis</strong></em> 服务是否还能继续?</p><ul><li>如果某一段插槽的主从都挂掉，而 <code>cluster-require-full-coverage=yes</code>，那么 ，整个集群都挂掉。</li><li>如果某一段插槽的主从都挂掉，而 <code>cluster-require-full-coverage=no</code>，那么，该插槽数据全都不能使用，也无法存储。</li></ul><p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p><h3 id="redis集群为什么至少需要三个奇数master节点"><a class="markdownIt-Anchor" href="#redis集群为什么至少需要三个奇数master节点"></a> <strong>Redis集群为什么至少需要三个（奇数）master节点</strong></h3><ol><li><strong><code>故障转移</code></strong>：在一个主节点故障时，至少需要另外两个主节点来达成共识（基于过半原则），以进行故障转移和选举新的主节点。如果只有两个主节点，当一个节点失效时，另一个节点无法单独做出决策。</li><li><strong><code>避免脑裂</code></strong>：在网络分区的情况下，集群可能被分成两部分。根据选举过半原则，三个节点被分成两部分，其中一部分满足选举过半机制，另一部分不满足。</li></ol><h3 id="集群的优缺点"><a class="markdownIt-Anchor" href="#集群的优缺点"></a> 集群的优缺点</h3><p class="note note-primary">优点</p><ul><li><strong><code>水平扩展</code></strong>：通过HashSlot对数据分片，实现水平扩展。</li><li><strong><code>高可用性</code></strong>：提供主从复制和故障转移能力。</li><li><strong><code>负载均衡</code></strong>：数据请求分摊到多个节点，避免单个节点过载。</li><li><strong><code>去中心化架构</code></strong>：减少单点故障的风险，提升了系统的稳定性。</li></ul><p class="note note-primary">缺点</p><ul><li><strong><code>多键操作限制</code></strong>：不允许跨节点的 <code>MSET</code>，<code>LUA</code>，<code>事务</code> 操作，这些操作只能在同一个节点。</li><li><strong><code>数据倾斜</code></strong>：数据可能在节点间分布不均，导致部分节点压力较大。</li></ul><h3 id="springboot-使用redis集群"><a class="markdownIt-Anchor" href="#springboot-使用redis集群"></a> SpringBoot 使用Redis集群</h3><p class="note note-primary">添加maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring‐boot‐starter‐data‐redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons‐pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">redis:</span><br> <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">password:</span> <span class="hljs-string">wgf123</span><br> <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">3000</span>   <span class="hljs-comment"># 连接超时时间（毫秒）</span><br> <span class="hljs-attr">cluster:</span><br>   <span class="hljs-attr">nodes:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:6400,127.0.0.1:6401,127.0.0.1:7400,127.0.0.1:7401,127.0.0.1:8400,127.0.0.1:8401</span><br> <span class="hljs-attr">lettuce:</span> <span class="hljs-comment"># Redis的Java驱动包,使用lettuce连接池</span><br>   <span class="hljs-attr">pool:</span><br>     <span class="hljs-attr">max-active:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制）</span><br>     <span class="hljs-attr">max-wait:</span> <span class="hljs-number">-1</span>    <span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br>     <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>    <span class="hljs-comment"># 连接池中的最大空闲连接 (默认为8)</span><br>     <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>     <span class="hljs-comment"># 连接池中的最小空闲连接</span><br><br></code></pre></td></tr></table></figure><p class="note note-primary">配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br> <span class="hljs-meta">@Bean</span><br> <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>     <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>     redisTemplate.setConnectionFactory(redisConnectionFactory);<br>     <span class="hljs-comment">// 使用Jackson2JsonRedisSerialize替换默认序列化</span><br>     <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>     <span class="hljs-type">ObjectMapper</span>                <span class="hljs-variable">objectMapper</span>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>     objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>     objectMapper.activateDefaultTyping(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LaissezFaireSubTypeValidator</span>(),<br>             ObjectMapper.DefaultTyping.EVERYTHING);<br>     jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>     <span class="hljs-comment">// 设置value的序列化规则和key的序列化规则</span><br>     redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>     redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>     redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>     redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>     redisTemplate.afterPropertiesSet();<br>     <span class="hljs-keyword">return</span> redisTemplate;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;k_&quot;</span> + i;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;v_&quot;</span> + i;<br>  redisTemplate.opsForValue().set(key, value);<br>  &#125;<br>&#125;<br><br>最终这<span class="hljs-number">100</span>个键值对会hash散落到<span class="hljs-number">3</span>个master实例中<br></code></pre></td></tr></table></figure><h2 id="分布式锁实现"><a class="markdownIt-Anchor" href="#分布式锁实现"></a> 分布式锁实现</h2><p>跨JVM的互斥机制来控制共享资源的访问</p><h3 id="spring-integration-redis"><a class="markdownIt-Anchor" href="#spring-integration-redis"></a> spring-integration-redis</h3><p><img src="/2022/02/04/Redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">申请锁LUA脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> lockClientId = redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>])					// 根据锁的key获取clientId<br><span class="hljs-keyword">if</span> lockClientId == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>redis.call(<span class="hljs-string">&#x27;PEXPIRE&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])						// 如果当前key的value和clientId一致，则重新设置锁时间（可重入）<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">elseif</span> <span class="hljs-keyword">not</span> lockClientId <span class="hljs-keyword">then</span>				<br>redis.call(<span class="hljs-string">&#x27;SET&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;PX&#x27;</span>, ARGV[<span class="hljs-number">2</span>])			// 如果clientId不存在，则尝试获取锁<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p class="note note-primary">释放锁LUA脚本(非阻塞)</p><p><strong>Reids <a target="_blank" rel="noopener" href="https://www.redis.com.cn/commands/unlink.html">unlink</a></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;unlink&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span>					// 将键与键空间断开连接，异步删除<br>redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>, ARGV[<span class="hljs-number">1</span>], KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p class="note note-primary">释放锁LUA脚本(阻塞)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span> <br>redis.call(<span class="hljs-string">&#x27;publish&#x27;</span>, ARGV[<span class="hljs-number">1</span>], KEYS[<span class="hljs-number">1</span>])  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>	<br></code></pre></td></tr></table></figure><p class="note note-primary">防止锁被误删</p><p>当线程A获取分布式锁后，如果不加控制，线程B调用释放锁方法可能会把线程A获得的锁进行释放，为了防止这种情况发生，Spring在实现 RedisLockRegistry 子类 RedisLock 的加锁方式时，RedisLock类内部会有一个获得锁的私有变量，当获得分布式锁时设置标志，释放锁时先判断 RedisLock 是否有获得锁的标志，有才执行锁释放方法防止误删</p><p>还有另一种做法是使用UUID，在 Redis set时，value拼接上UUID，删除时判断锁对象的UUID和Redis value的 UUID是否相等</p><p class="note note-primary">整合</p><p>添加maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 分布式锁支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.integration<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-integration-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">添加分布式锁配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLockConfiguration</span> &#123;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁前缀</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-lock&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁过期时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">EXPIRE</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000L</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisLockRegistry <span class="hljs-title function_">redisLockRegistry</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisLockRegistry</span>(redisConnectionFactory, LOCK_NAME, EXPIRE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;分布式锁API&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ExecutorService executorService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisLockRegistry redisLockRegistry;<br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;分布式锁&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;lock&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(countDownLatch);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            executorService.execute(task);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> NUM;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> CountDownLatch latch;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(CountDownLatch latch)</span> &#123;<br>            <span class="hljs-built_in">this</span>.latch = latch;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 获取锁对象</span><br>            <span class="hljs-type">Lock</span>    <span class="hljs-variable">lock</span>    <span class="hljs-operator">=</span> redisLockRegistry.obtain(<span class="hljs-string">&quot;lock&quot;</span>);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">lockRes</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 尝试获取锁，10秒超时</span><br>                <span class="hljs-comment">//lockRes = lock.tryLock(10, TimeUnit.SECONDS);</span><br><br>                <span class="hljs-comment">// 死等</span><br>                lock.lock();<br>                log.info(<span class="hljs-string">&quot;获取锁成功&quot;</span>);<br>                NUM--;<br>                latch.countDown();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">总结</p><p>​	<code>spring-integration-redis</code> 设计优秀之处在于引入本地锁概念，通过本地锁防止高并发场景频繁向Redis发起访问，降低Redis压力。其次是实现了可重入锁的功能，在锁里重新加锁则更新锁的持有时间（TTL）</p><h3 id="自定义实现极简版"><a class="markdownIt-Anchor" href="#自定义实现极简版"></a> 自定义实现极简版</h3><p class="note note-primary">分布式锁</p><p><strong><code>SET key value [PX milliseconds] [NX]</code></strong> 命令是实现分布式锁的核心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRedisLock</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis-lock:&quot;</span>;<br><br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockName    锁名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockTimeOut 锁超时时间 毫秒</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(String lockName, <span class="hljs-type">long</span> lockTimeOut)</span> &#123;<br>        lockName = getLockName(lockName);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockName, <span class="hljs-literal">null</span>, lockTimeOut, TimeUnit.MILLISECONDS);<br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获取锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockName    锁名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockTimeOut 锁超时时间 毫秒</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> waitTimeOut 获取锁等待超时时间 毫秒</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String lockName, <span class="hljs-type">long</span> lockTimeOut, <span class="hljs-type">long</span> waitTimeOut)</span> &#123;<br>        lockName = getLockName(lockName);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-keyword">while</span> ((System.currentTimeMillis() - startTime) &lt; waitTimeOut) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockName, <span class="hljs-literal">null</span>, lockTimeOut, TimeUnit.MILLISECONDS);<br><br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockName 锁名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        lockName = getLockName(lockName);<br>        <span class="hljs-keyword">return</span> redisTemplate.delete(lockName);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getLockName</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, PREFIX, lockName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">100000</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ExecutorService executorService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MyRedisLock myRedisLock;<br><br> <br>    <span class="hljs-meta">@ApiOperation(value = &quot;自定义分布式锁&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;my_lock&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">myLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">Runnable</span>       <span class="hljs-variable">task</span>           <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLockTask</span>(countDownLatch);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            executorService.execute(task);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> NUM;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLockTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> CountDownLatch latch;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLockTask</span><span class="hljs-params">(CountDownLatch latch)</span> &#123;<br>            <span class="hljs-built_in">this</span>.latch = latch;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                myRedisLock.lock(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>);<br>                log.info(<span class="hljs-string">&quot;获取锁成功&quot;</span>);<br>                NUM--;<br>                latch.countDown();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                myRedisLock.unlock(<span class="hljs-string">&quot;test&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">总结</p><p>不推荐这个例子分布式锁的实现方式，死循环获取锁实现过于粗暴，当有强烈的锁竞争场景对Redis会造成较大压力</p><h2 id="高可用问题"><a class="markdownIt-Anchor" href="#高可用问题"></a> 高可用问题</h2><h3 id="缓存穿透"><a class="markdownIt-Anchor" href="#缓存穿透"></a> 缓存穿透</h3><p><code>访问了根本不存在的数据</code> <code>请求全部落在DB上</code></p><p><strong>概念</strong></p><p><img src="/2022/02/04/Redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png" srcset="/img/loading.gif" lazyload alt></p><p><code>缓存穿透</code> 是指当请求查询一个在缓存和数据库中都不存在的数据时，请求会穿过缓存层直接查询数据库。这种情况如果被恶意利用或频繁发生，会给数据库带来很大压力，甚至导致数据库宕机。</p><p class="note note-primary">解决方案</p><div class="note note-warning"><p><strong><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039156246">布隆过滤器</a></strong></p><p><code>会有误判率</code> <code>元素不能删除</code> <code>布谷鸟过滤器</code></p><p>基本原理：</p><ul><li><code>数据结构</code>：布隆过滤器本质上是一个很大的位数组（bit array）和几个哈希函数。</li><li><code>插入操作</code>：当插入一个元素时，使用多个哈希函数对元素进行哈希，并将得到的哈希值所对应的位数组中的位置置为 1。</li><li><code>查询操作</code>：当查询一个元素时，同样使用这些哈希函数进行哈希，并检查位数组中相应的位置是否都是 1。如果都是 1，那么元素可能存在于集合中；如果任何一个位置是 0，则元素绝对不在集合中。</li></ul><p>特点：</p><ul><li><code>不确定性</code>：布隆过滤器可能会有误判。</li><li><code>不支持删除</code>：标准的布隆过滤器不支持从集合中删除元素，因为将位数组的位从 1 改回 0 会影响其他元素。</li></ul><p>应用场景：</p><ul><li><code>网络应用</code>：常被用于网络应用中，例如用于网页爬虫的 URL 检查。</li><li><code>数据库</code>：数据库系统使用布隆过滤器来快速判断数据是否存，从而避免不必要的访问。</li></ul><p><img src="/2022/02/04/Redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt="一个长长的数组加上几个 Hash 算法"></p><p><img src="/2022/02/04/Redis/BloomFilter.png" srcset="/img/loading.gif" lazyload alt></p></div><div class="note note-warning"><p><strong>缓存空对象</strong></p><p>基本原理：</p><ul><li>当缓存和数据库都未命中某个查询请求时，在缓存层添加一个 <code>空对象</code> 缓存，并设置 <code>过期时间</code>。</li><li>后续对同一不存在数据的查询可以直接从缓存中获取这个空对象，避免请求落库。</li></ul><p>存在的问题：</p><ul><li>存储大量空对象会占用缓存空间，被恶意攻击可能导致缓存空间迅速被耗尽。</li><li>即使设置了过期时间，也可能导致短暂时间的数据不一致（数据库后续添加了空对象对应的业务数据）。</li></ul></div><h3 id="缓存击穿"><a class="markdownIt-Anchor" href="#缓存击穿"></a> 缓存击穿</h3><p><code>承载大并发的热点Key过期失效</code> <code>海量请求落库查询</code></p><p><img src="/2022/02/04/Redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png" srcset="/img/loading.gif" lazyload alt></p><p>缓存击穿是指当某个热点数据（即高频访问数据）在缓存中失效（过期）的那一刻，同时有大量并发请求这个数据时，这些请求会直接击穿缓存，全部落到数据库上。在重新缓存数据这一期间，大量并发请求直接访问数据库，可能导致数据库崩溃。</p><p class="note note-primary">解决方案</p><div class="note note-warning"><p><strong>设置热点数据永不过期</strong></p><ul><li><code>不设置过期时间</code>：对于热点数据，缓存层不设置过期时间。</li><li><code>逻辑过期</code>：在缓存的 <code>value</code> 设置过期时间，使用单独线程定期扫描，发现逻辑过期后重新构建缓存。</li></ul><p><img src="/2022/02/04/Redis/%E9%87%8D%E5%BB%BA%E7%BC%93%E5%AD%98.png" srcset="/img/loading.gif" lazyload alt></p></div><div class="note note-warning"><p><strong>使用互斥锁</strong></p><p>当缓存失效时，不是每个请求都去数据库加载数据，而是使用互斥锁机制确保只有一个请求去数据库查询数据并重新加载到缓存中，其他请求等待缓存恢复后再访问缓存。</p><p><img src="/2022/02/04/Redis/%E5%8A%A0%E4%BA%92%E6%96%A5%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p></div><h3 id="缓存雪崩"><a class="markdownIt-Anchor" href="#缓存雪崩"></a> 缓存雪崩</h3><p><code>缓存集中失效</code> <code>缓存服务节点宕机、断网</code></p><p><span class="green-line">缓存雪崩是指在一个缓存系统中，由于缓存系统宕机或者缓存数据大面积失效，导致后续的请求都落到了数据库上，从而引发数据库压力剧增，甚至可能导致数据库服务崩溃<span>。场景如缓存服务宕机恢复后或大量缓存数据集中在同一时间过期。</span></span></p><p><img src="/2022/02/04/Redis/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">解决方案</p><div class="note note-warning"><p><strong>分散Key的过期时间</strong></p><ul><li><code>随机过期时间</code>：为缓存数据设置随机的过期时间，而不是统一的过期时间，以避免同时大量缓存失效。</li><li><code>预设不同过期时间</code>：根据数据的不同特性和重要性，设置不同的过期时间。</li></ul></div><div class="note note-warning"><p><strong>部署高可用缓存系统</strong></p><ul><li><code>集群部署</code>：Redis Cluster 缓存集群，提高缓存系统的高可用性。</li><li><code>哨兵模式</code>：部署一主多从模式，故障自动转移。</li></ul></div><div class="note note-warning"><p><strong>限流降级</strong></p><p>当缓存大面积失效后触发熔断器，对缓存服务进行降级处理，返回降级内容。</p><ul><li>在系统入口处实施限流措施，合理控制访问频率。</li><li>在缓存失效或不可用时，可以启用服务降级策略，如返回默认数据或简化的服务内容。</li></ul></div><h3 id="使用布隆过滤器"><a class="markdownIt-Anchor" href="#使用布隆过滤器"></a> 使用布隆过滤器</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Courage129/p/14337466.html">布隆过滤器介绍</a></p><p><a target="_blank" rel="noopener" href="https://www.jasondavies.com/bloomfilter/">布隆过滤器 动画演示</a></p><h4 id="单机-guava-版"><a class="markdownIt-Anchor" href="#单机-guava-版"></a> 单机 guava 版</h4><p class="note note-primary">添加maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>31.0.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-primary">使用源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;单机版本布隆过滤器&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaBloomFilterController</span> &#123;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入多少数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">insertions</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 期望的误判率</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.02</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单机版本布隆过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BloomFilter&lt;String&gt; bf;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于校验bloomFilter 准确性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; keySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据预热</span><br><span class="hljs-comment">     * 初始化布隆过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        bf = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions, fpp);<br><br>        <span class="hljs-comment">// 添加缓存数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span>   <span class="hljs-operator">=</span> generate(<span class="hljs-string">&quot;k&quot;</span>, i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> generate(<span class="hljs-string">&quot;v&quot;</span>, i);<br><br>            <span class="hljs-comment">// 数据添加布隆过滤器</span><br>            bf.put(key);<br>            keySet.add(key);<br>            redisTemplate.opsForValue().set(key, value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@ApiImplicitParams(&#123;</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;start&quot;, value = &quot;起始检索点 取值[0, 5000]&quot;, dataType = &quot;int&quot;),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;end&quot;, value = &quot;截止检索点 取值[0, 5000] 需要比start大&quot;, dataType = &quot;int&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;测试单机版布隆过滤器&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;test&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;start&quot;)</span> Integer start, <span class="hljs-meta">@RequestParam(&quot;end&quot;)</span> Integer end)</span> &#123;<br><br>        <span class="hljs-comment">// 根据参数生成key</span><br>        List&lt;String&gt; keyList = IntStream.range(start, end)<br>                .mapToObj(line -&gt; generate(<span class="hljs-string">&quot;k&quot;</span>, line))<br>                .collect(Collectors.toList());<br><br>        <span class="hljs-comment">// 布隆过滤器拦截</span><br>        <span class="hljs-type">int</span>          <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;String&gt; keys  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String key : keyList) &#123;<br><br>            <span class="hljs-comment">// 布隆过滤器过滤</span><br>            <span class="hljs-keyword">if</span> (bf.mightContain(key)) &#123;<br>                keys.add(key);<br>            &#125;<br><br>            <span class="hljs-comment">// 判断布隆过滤器准确性</span><br>            <span class="hljs-keyword">if</span> (keySet.contains(key)) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">accuracy</span> <span class="hljs-operator">=</span> keys.size() / count * <span class="hljs-number">100.0d</span>;<br><br>        <span class="hljs-type">List</span>                <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().multiGet(keys);<br>        Map&lt;String, Object&gt; map    = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;bloomFilter 准确率&quot;</span>, accuracy);<br>        map.put(<span class="hljs-string">&quot;缓存数据命中个数&quot;</span>, result.size());<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">generate</span><span class="hljs-params">(Object obj1, Object obj2)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s_%s&quot;</span>, obj1, obj2);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">测试</p><p>启动项目访问 <a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/default/%E5%8D%95%E6%9C%BA%E7%89%88%E6%9C%AC%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/testUsingGET">swagger</a></p><p><img src="/2022/02/04/Redis/bloomFilter%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="redis-bitmap-分布式版"><a class="markdownIt-Anchor" href="#redis-bitmap-分布式版"></a> Redis BitMap 分布式版</h4><p>核心是使用redis的<code>BitMap 位图</code>代替本地内存存储缓存标识，实现多实例分布式可用的BloomFilter；</p><p>实现上依赖 <code>com.google.guava</code></p><p class="note note-primary">源码实现</p><p>BitMapBloomFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitMapBloomFilter</span>&lt;T&gt; &#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 布隆过滤器Key</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String key;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要执行hash函数次数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numHashFunctions;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤器大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bitSize;<br><br>    <span class="hljs-keyword">private</span> Funnel&lt;T&gt;     funnel;<br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedInsertions 预计插入的元素数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BitMapBloomFilter</span><span class="hljs-params">(RedisTemplate redisTemplate, String key, <span class="hljs-type">int</span> expectedInsertions)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key           = key;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.funnel        = (Funnel&lt;T&gt;) Funnels.stringFunnel(Charset.defaultCharset());<br>        bitSize            = optimalNumOfBits(expectedInsertions, <span class="hljs-number">0.02</span>);<br>        numHashFunctions   = optimalNumOfHashFunctions(expectedInsertions, bitSize);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedInsertions 预计插入的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fpp                期望的误判率</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BitMapBloomFilter</span><span class="hljs-params">(RedisTemplate redisTemplate, String key, <span class="hljs-type">int</span> expectedInsertions, <span class="hljs-type">double</span> fpp)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key           = key;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.funnel        = (Funnel&lt;T&gt;) Funnels.stringFunnel(Charset.defaultCharset());<br>        bitSize            = optimalNumOfBits(expectedInsertions, fpp);<br>        numHashFunctions   = optimalNumOfHashFunctions(expectedInsertions, bitSize);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> funnel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedInsertions 预计插入的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fpp                期望的误判率</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BitMapBloomFilter</span><span class="hljs-params">(RedisTemplate redisTemplate, String key, Funnel&lt;T&gt; funnel, <span class="hljs-type">int</span> expectedInsertions, <span class="hljs-type">double</span> fpp)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key           = key;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.funnel        = funnel;<br>        bitSize            = optimalNumOfBits(expectedInsertions, fpp);<br>        numHashFunctions   = optimalNumOfHashFunctions(expectedInsertions, bitSize);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用murmur hash算法计算值的下标</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] murmurHashOffset(T value) &#123;<br>        <span class="hljs-type">int</span>[] offset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numHashFunctions];<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">hash64</span> <span class="hljs-operator">=</span> Hashing.murmur3_128().hashObject(value, funnel).asLong();<br>        <span class="hljs-type">int</span>  <span class="hljs-variable">hash1</span>  <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) hash64;<br>        <span class="hljs-type">int</span>  <span class="hljs-variable">hash2</span>  <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (hash64 &gt;&gt;&gt; <span class="hljs-number">32</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= numHashFunctions; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextHash</span> <span class="hljs-operator">=</span> hash1 + i * hash2;<br>            <span class="hljs-keyword">if</span> (nextHash &lt; <span class="hljs-number">0</span>) &#123;<br>                nextHash = ~nextHash;<br>            &#125;<br>            offset[i - <span class="hljs-number">1</span>] = nextHash % bitSize;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> offset;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算bit数组长度</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">optimalNumOfBits</span><span class="hljs-params">(<span class="hljs-type">long</span> n, <span class="hljs-type">double</span> p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span>) &#123;<br>            p = Double.MIN_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (-n * Math.log(p) / (Math.log(<span class="hljs-number">2</span>) * Math.log(<span class="hljs-number">2</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算hash方法执行次数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">optimalNumOfHashFunctions</span><span class="hljs-params">(<span class="hljs-type">long</span> n, <span class="hljs-type">long</span> m)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.max(<span class="hljs-number">1</span>, (<span class="hljs-type">int</span>) Math.round((<span class="hljs-type">double</span>) m / n * Math.log(<span class="hljs-number">2</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除布隆过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key KEY</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String key)</span> &#123;<br>        redisTemplate.delete(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据给定的布隆过滤器添加值，在添加一个元素的时候使用，批量添加的性能差</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bloomFilterHelper 布隆过滤器对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key               KEY</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value             值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;               泛型，可以传入任何类型的value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">int</span>[] offset = <span class="hljs-built_in">this</span>.murmurHashOffset(value);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : offset) &#123;<br>            redisTemplate.opsForValue().setBit(key, i, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据给定的布隆过滤器添加值，在添加一批元素的时候使用，批量添加的性能好，使用pipeline方式(如果是集群下，请使用优化后RedisPipeline的操作)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bloomFilterHelper 布隆过滤器对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key               KEY</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> valueList         值，列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;               泛型，可以传入任何类型的value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addList</span><span class="hljs-params">(List&lt;? extends T&gt; valueList)</span> &#123;<br>        redisTemplate.executePipelined(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCallback</span>&lt;Long&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">doInRedis</span><span class="hljs-params">(RedisConnection connection)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>                connection.openPipeline();<br>                <span class="hljs-keyword">for</span> (T value : valueList) &#123;<br>                    <span class="hljs-type">int</span>[] offset = murmurHashOffset(value);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : offset) &#123;<br>                        connection.setBit(key.getBytes(), i, <span class="hljs-literal">true</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据给定的布隆过滤器判断值是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bloomFilterHelper 布隆过滤器对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key               KEY</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value             值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">int</span>[] offset = <span class="hljs-built_in">this</span>.murmurHashOffset(value);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : offset) &#123;<br>            <span class="hljs-keyword">if</span> (!redisTemplate.opsForValue().getBit(key, i)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BitMapBloomFilterRegistry</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitMapBloomFilterRegistry</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BitMapBloomFilterRegistry</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认需要插入的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_EXPECTED_INSERTIONS</span> <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>;<br><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤器前缀</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis:bloomfilter:&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 布隆过滤器容器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BitMapBloomFilter&lt;CharSequence&gt;&gt; filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取布隆过滤器</span><br><span class="hljs-comment">     * 如果获取不到则根据默认配置创建布隆过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filterName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">public</span> BitMapBloomFilter&lt;CharSequence&gt; <span class="hljs-title function_">obtain</span><span class="hljs-params">(String filterName)</span> &#123;<br>        filterName = <span class="hljs-built_in">this</span>.getFilterName(filterName);<br>        BitMapBloomFilter&lt;CharSequence&gt; bitMapBloomFilter = filters.computeIfAbsent(filterName, <br>                key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitMapBloomFilter</span>&lt;CharSequence&gt;(redisTemplate, key, DEFAULT_EXPECTED_INSERTIONS));<br>        <span class="hljs-keyword">return</span> bitMapBloomFilter;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取布隆过滤器，获取不到则根据配置创建</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filterName         布隆过滤器名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expectedInsertions 预计插入的数量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fpp                期望的误判率</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BitMapBloomFilter&lt;CharSequence&gt; <span class="hljs-title function_">obtain</span><span class="hljs-params">(String filterName, <span class="hljs-type">int</span> expectedInsertions, <span class="hljs-type">double</span> fpp)</span> &#123;<br>        filterName = <span class="hljs-built_in">this</span>.getFilterName(filterName);<br>        Funnel&lt;CharSequence&gt;            funnel            = (Funnel&lt;CharSequence&gt;) Funnels.stringFunnel(Charset.defaultCharset());<br>        BitMapBloomFilter&lt;CharSequence&gt; bitMapBloomFilter = filters.computeIfAbsent(filterName, <br>                key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitMapBloomFilter</span>&lt;CharSequence&gt;(redisTemplate, key, funnel, expectedInsertions, fpp));<br>        <span class="hljs-keyword">return</span> bitMapBloomFilter;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getFilterName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, prefix, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">添加注册器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> BitMapBloomFilterRegistry <span class="hljs-title function_">bitMapBloomFilterRegistry</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitMapBloomFilterRegistry</span>(redisTemplate);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-comment">// 使用Jackson2JsonRedisSerialize替换默认序列化</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span>                <span class="hljs-variable">objectMapper</span>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        objectMapper.activateDefaultTyping(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LaissezFaireSubTypeValidator</span>(),<br>                ObjectMapper.DefaultTyping.EVERYTHING);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>        <span class="hljs-comment">// 设置value的序列化规则和key的序列化规则</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;Redis BitMap 版布隆过滤器&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;bitmap&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitMapBloomFilterController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BitMapBloomFilterRegistry bitMapBloomFilterRegistry;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据预热</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        BitMapBloomFilter&lt;CharSequence&gt; bloomFilter = bitMapBloomFilterRegistry.obtain(<span class="hljs-string">&quot;test&quot;</span>);<br>        List&lt;String&gt; valueList = IntStream.range(<span class="hljs-number">1</span>, <span class="hljs-number">2000</span>)<br>                .mapToObj(line -&gt; String.format(<span class="hljs-string">&quot;%s_%s&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, line))<br>                .collect(Collectors.toList());<br><br>        <span class="hljs-comment">// 初始化布隆过滤器</span><br>        bloomFilter.addList(valueList);<br><br>        <span class="hljs-comment">// 缓存数据初始化</span><br>        <span class="hljs-keyword">for</span> (String s : valueList) &#123;<br>            redisTemplate.opsForValue().set(s, s);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiImplicitParams(&#123;</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;start&quot;, value = &quot;起始检索点 取值[1, 2000]&quot;, dataType = &quot;int&quot;),</span><br><span class="hljs-meta">            @ApiImplicitParam(name = &quot;end&quot;, value = &quot;截止检索点 取值[1, 2000] 需要比start大&quot;, dataType = &quot;int&quot;)</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;Redis BitMap版布隆过滤器&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;test&quot;)</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;start&quot;)</span> Integer start, <span class="hljs-meta">@RequestParam(&quot;end&quot;)</span> Integer end)</span> &#123;<br>        <span class="hljs-comment">// 获取布隆过滤器</span><br>        BitMapBloomFilter&lt;CharSequence&gt; bloomFilter = bitMapBloomFilterRegistry.obtain(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-comment">// 根据参数生成数据</span><br>        List&lt;String&gt; dataList = IntStream.range(start, end)<br>                .mapToObj(line -&gt; String.format(<span class="hljs-string">&quot;%s_%s&quot;</span>, <span class="hljs-string">&quot;k&quot;</span>, line))<br>                .collect(Collectors.toList());<br><br>        <span class="hljs-type">int</span>          <span class="hljs-variable">errNum</span>        <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        List&lt;Object&gt; cacheDataList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String data : dataList) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> bloomFilter.contains(data);<br><br>            <span class="hljs-comment">// 根据BloomFilter 过滤器判断，如果数据存在，则取缓存</span><br>            <span class="hljs-keyword">if</span> (result) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(data);<br>                cacheDataList.add(cache);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 错误统计</span><br>                errNum++;<br>            &#125;<br>        &#125;<br><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(<span class="hljs-number">8</span>);<br>        map.put(<span class="hljs-string">&quot;命中缓存数据个数&quot;</span>, cacheDataList.size());<br>        map.put(<span class="hljs-string">&quot;误判个数&quot;</span>, errNum);<br><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="redis-插件版本"><a class="markdownIt-Anchor" href="#redis-插件版本"></a> Redis 插件版本</h4><p>Redis官方提供<code>module(插件)</code><a target="_blank" rel="noopener" href="https://docs.redis.com/latest/modules/redisbloom/commands/">redisbloom</a>，这个插件集成了<code>Bloom Filter</code>、<code>Cuckoo Filter</code>、<code>Count-Min-Sketch</code>、<code>Top-K</code></p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.add"><code>BF.ADD</code></a></td><td style="text-align:left">将 item 添加到布隆过滤器</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.exists"><code>BF.EXISTS</code></a></td><td style="text-align:left">检查过滤器中是否存在 item</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.info"><code>BF.INFO</code></a></td><td style="text-align:left">返回有关布隆过滤器的信息</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.insert"><code>BF.INSERT</code></a></td><td style="text-align:left">将多个 item 添加到过滤器。如果过滤器尚不存在，则可以选择设置容量</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.loadchunk"><code>BF.LOADCHUNK</code></a></td><td style="text-align:left">恢复以前使用 <a target="_blank" rel="noopener" href="https://redis.io/commands/bf.scandump">BF.SCANDUMP</a> 保存的布隆过滤器</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.madd"><code>BF.MADD</code></a></td><td style="text-align:left">将多个 item 添加到过滤器</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.mexists"><code>BF.MEXISTS</code></a></td><td style="text-align:left">对于多个 item，检查每个项目是否存在于过滤器中</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.reserve"><code>BF.RESERVE</code></a></td><td style="text-align:left">创建一个布隆过滤器。设置误判率和容量</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/bf.scandump"><code>BF.SCANDUMP</code></a></td><td style="text-align:left">对Bloom进行增量持久化操作</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://oss.redislabs.com/redisbloom/Bloom_Commands/">布隆过滤器</a></p><p><a target="_blank" rel="noopener" href="https://github.com/RedisBloom/RedisBloom">git源码下载</a></p><p><a target="_blank" rel="noopener" href="https://github.com/redis/jedis/tree/master/src/main/java/redis/clients/jedis/bloom">Jedis 提供客户端支持</a></p><p>官方docker整合镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> --name redis-redisbloom redislabs/rebloom:latest<br></code></pre></td></tr></table></figure><p class="note note-primary">docker 集成</p><p><a target="_blank" rel="noopener" href="https://github.com/RedisBloom/RedisBloom">源码下载</a> RedisBloomV2.2.12.tar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkidr /data/redis/module<br>cd /data/redis/module<br>wget https://codeload.github.com/RedisBloom/RedisBloom/tar.gz/refs/tags/v2.2.12<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">解压</span><br>tar -zvxf RedisBloom-2.2.12.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行安装</span><br>cd RedisBloom-2.2.12<br>make<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装成功在目录下会生成 redisbloom.so 文件</span><br></code></pre></td></tr></table></figure><p class="note note-primary">修改配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">bind 0.0.0.0<br>daemonize no<br>requirepass wgf123<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭rdb</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">save <span class="hljs-string">&quot;&quot;</span></span><br>save 900 1<br>save 300 10<br>save 60 10000<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭aof</span><br>appendonly no<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">module 配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">布隆过滤器 mudule</span><br>loadmodule /RedisBloom/redisbloom.so<br></code></pre></td></tr></table></figure><p class="note note-primary">启动容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> --name redis1\<br>-v <span class="hljs-regexp">/data/</span>redis<span class="hljs-regexp">/config/</span>redis_1.conf:<span class="hljs-regexp">/etc/</span>redis/redis.conf\<br>-v<span class="hljs-regexp">/data/</span>redis<span class="hljs-regexp">/data/</span>redis1:/data\<br>-v<span class="hljs-regexp">/data/</span>redis<span class="hljs-regexp">/module/</span>RedisBloom-<span class="hljs-number">2.2</span>.<span class="hljs-number">12</span><span class="hljs-regexp">/:/</span>RedisBloom\<br>-d redis redis-server <span class="hljs-regexp">/etc/</span>redis/redis.conf --appendonly yes<br></code></pre></td></tr></table></figure><p class="note note-primary">集成SpringBoot LUA脚本</p><p>LUA脚本对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomCommand</span> &#123;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建布隆过滤器脚本，支持指定过期时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; RESERVE =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;Boolean&gt;(<br>                    <span class="hljs-string">&quot;local exists = redis.call(&#x27;EXISTS&#x27;, KEYS[1])\n&quot;</span> +<br>                            <span class="hljs-string">&quot;if (exists == 0) then\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  redis.call(&#x27;BF.RESERVE&#x27;, KEYS[1], ARGV[1], ARGV[2])\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  if (tonumber(ARGV[3]) &gt; 0) then\n&quot;</span> +<br>                            <span class="hljs-string">&quot;    redis.call(&#x27;PEXPIRE&#x27;, KEYS[1], ARGV[3])\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  end\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  return true\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  else\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  return false\n&quot;</span> +<br>                            <span class="hljs-string">&quot;end&quot;</span>, Boolean.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将一个item添加到布隆过滤器，如果过滤器不存在则创建过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; ADD =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;Boolean&gt;(<span class="hljs-string">&quot;return redis.call(&#x27;BF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>, Boolean.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将多个item添加到布隆过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">M_ADD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;return redis.call(&#x27;BF.MADD&#x27;, KEYS[1], %s)&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 确定一个item是否可能存在于布隆过滤器中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; EXISTS =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(<span class="hljs-string">&quot;return redis.call(&#x27;BF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>, Boolean.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 确定过滤器中是否存在一个或多个item</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">M_EXISTS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;return redis.call(&#x27;BF.MEXISTS&#x27;, KEYS[1], %s)&quot;</span>;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取创建布隆过滤器脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getReserveScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> RESERVE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取添加脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getAddScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ADD;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取批量添加脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;List&gt; <span class="hljs-title function_">getMultiAdd</span><span class="hljs-params">(Collection&lt;Object&gt; values)</span> &#123;<br>        <span class="hljs-keyword">return</span> CommandHelper.generateScript(M_ADD, values);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取判断item是否存在脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getExistsScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> EXISTS;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取批量判断存在脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;List&gt; <span class="hljs-title function_">getMultiExists</span><span class="hljs-params">(Collection&lt;?&gt; values)</span> &#123;<br>        <span class="hljs-keyword">return</span> CommandHelper.generateScript(M_EXISTS, values);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">脚本助手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandHelper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> script</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;List&gt; <span class="hljs-title function_">generateScript</span><span class="hljs-params">(String script, Collection&lt;?&gt; values)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= values.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>) &#123;<br>                sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>            sb.append(<span class="hljs-string">&quot;ARGV[&quot;</span>).append(i).append(<span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;List&gt;(String.format(script, sb.toString()), List.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Object&gt; <span class="hljs-title function_">extract</span><span class="hljs-params">(List&lt;Long&gt; result, List&lt;Object&gt; values)</span> &#123;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == result.get(i)) &#123;<br>                list.add(values.get(i));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">布隆过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisBloomFilter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt;  key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisBloomFilter</span><span class="hljs-params">(RedisTemplate redisTemplate, String key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.key           = Collections.singletonList(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建布隆过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> errorRate    误报的期望概率 比如 &quot;0.0001&quot;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity     容量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> milliseconds 过期时间，单位毫秒。-1为用不过期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">(<span class="hljs-type">double</span> errorRate, <span class="hljs-type">int</span> capacity, <span class="hljs-type">int</span> milliseconds)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(BloomCommand.getReserveScript(), key, errorRate, capacity, milliseconds);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加item到布隆过滤器，不存在则创建布隆过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(BloomCommand.getAddScript(), key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量添加item到布隆过滤器，不存在则创建布隆过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> items</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回添加成功的item</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">multiAdd</span><span class="hljs-params">(List&lt;Object&gt; items)</span> &#123;<br>        List&lt;Long&gt; result = (List&lt;Long&gt;) redisTemplate.execute(BloomCommand.getMultiAdd(items), key, items.toArray());<br>        <span class="hljs-keyword">return</span> CommandHelper.extract(result, items);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断item是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(BloomCommand.getExistsScript(), key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量判断items是否存在</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> items</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回存在的item</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">multiExists</span><span class="hljs-params">(List&lt;Object&gt; items)</span> &#123;<br>        List&lt;Long&gt; result = (List&lt;Long&gt;) redisTemplate.execute(BloomCommand.getMultiExists(items), key, items.toArray());<br>        <span class="hljs-keyword">return</span> CommandHelper.extract(result, items);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">布隆过滤器注册器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BloomFilterRegistry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span>                        <span class="hljs-variable">PREFIX</span>    <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bloom:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span>        Map&lt;String, RedisBloomFilter&gt; container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">8</span>);<br><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BloomFilterRegistry</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> RedisBloomFilter <span class="hljs-title function_">getFilter</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getName(key);<br>        <span class="hljs-keyword">return</span> container.computeIfAbsent(name, line -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisBloomFilter</span>(redisTemplate, line));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, PREFIX, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">配置注册器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-comment">// 使用Jackson2JsonRedisSerialize替换默认序列化</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span>                <span class="hljs-variable">objectMapper</span>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        objectMapper.activateDefaultTyping(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LaissezFaireSubTypeValidator</span>(),<br>                ObjectMapper.DefaultTyping.EVERYTHING);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>        <span class="hljs-comment">// 设置value的序列化规则和key的序列化规则</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 布隆注册器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> BloomFilterRegistry <span class="hljs-title function_">bloomFilterRegistry</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BloomFilterRegistry</span>(redisTemplate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;Redis 插件 布隆过滤器&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;bloom&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisBloomFilterController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BloomFilterRegistry bloomFilterRegistry;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">filterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bloom-filter&quot;</span>;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;创建布隆过滤器&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;reserve&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RedisBloomFilter</span> <span class="hljs-variable">redisBloomFilter</span> <span class="hljs-operator">=</span> bloomFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> redisBloomFilter.reserve(<span class="hljs-number">0.001</span>, <span class="hljs-number">10000</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;添加数据到布隆过滤器&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;item&quot;, value = &quot;添加数据&quot;, dataType = &quot;obj&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;add&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;item&quot;)</span> Object item)</span> &#123;<br>        <span class="hljs-type">RedisBloomFilter</span> <span class="hljs-variable">redisBloomFilter</span> <span class="hljs-operator">=</span> bloomFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> redisBloomFilter.add(item);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;批量添加数据到布隆过滤器&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;values&quot;, value = &quot;添加数据，json数组 [1,2,3]&quot;)</span><br>    <span class="hljs-meta">@PostMapping(&quot;multi_add&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">multiAdd</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Object&gt; values)</span> &#123;<br>        <span class="hljs-type">RedisBloomFilter</span> <span class="hljs-variable">redisBloomFilter</span> <span class="hljs-operator">=</span> bloomFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> redisBloomFilter.multiAdd(values);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;判断数据是否存在&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;item&quot;, value = &quot;判断数据&quot;, dataType = &quot;obj&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;exists&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;item&quot;)</span> Object item)</span> &#123;<br>        <span class="hljs-type">RedisBloomFilter</span> <span class="hljs-variable">redisBloomFilter</span> <span class="hljs-operator">=</span> bloomFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> redisBloomFilter.exists(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;批量判断数据是否存在&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;values&quot;, value = &quot;判断数据,json数组 [1,2,3]&quot;)</span><br>    <span class="hljs-meta">@PostMapping(&quot;multi_exists&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">multiExists</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Object&gt; values)</span> &#123;<br>        <span class="hljs-type">RedisBloomFilter</span> <span class="hljs-variable">redisBloomFilter</span> <span class="hljs-operator">=</span> bloomFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> redisBloomFilter.multiExists(values);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：项目启动访问<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/default/Redis%20%E6%8F%92%E4%BB%B6%20%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/reserveUsingGET">swagger</a></p><p><img src="/2022/02/04/Redis/bloomFilter%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="布谷鸟过滤器-可删除元素"><a class="markdownIt-Anchor" href="#布谷鸟过滤器-可删除元素"></a> <a target="_blank" rel="noopener" href="https://oss.redislabs.com/redisbloom/Cuckoo_Commands/">布谷鸟过滤器 可删除元素</a></h3><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.add"><code>CF.ADD</code></a></td><td style="text-align:left">将 item 添加到过滤器</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.addnx"><code>CF.ADDNX</code></a></td><td style="text-align:left">仅当 item 不存在时才将项目添加到过滤器</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.count"><code>CF.COUNT</code></a></td><td style="text-align:left">返回 item 在过滤器中出现的可能次数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.del"><code>CF.DEL</code></a></td><td style="text-align:left">从过滤器中删除 item</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.exists"><code>CF.EXISTS</code></a></td><td style="text-align:left">检查过滤器中是否存在item</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.info"><code>CF.INFO</code></a></td><td style="text-align:left">返回过滤器信息</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.insert"><code>CF.INSERT</code></a></td><td style="text-align:left">将多个 item 添加到过滤器。如果过滤器尚不存在，则可以选择设置容量</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.insertnx"><code>CF.INSERTNX</code></a></td><td style="text-align:left">如果多个 item 尚不存在，则将它们添加到过滤器。如果过滤器尚不存在，则可以选择设置容量</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.loadchunk"><code>CF.LOADCHUNK</code></a></td><td style="text-align:left">恢复以前用<a target="_blank" rel="noopener" href="https://redis.io/commands/cf.scandump">CF.SCANDUMP</a> 保存的布谷鸟过滤器</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.mexists"><code>CF.MEXISTS</code></a></td><td style="text-align:left">对于多个 item，检查每个 item 是否存在于过滤器中</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.reserve"><code>CF.RESERVE</code></a></td><td style="text-align:left">创建布谷鸟过滤器并设置其容量</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://redis.io/commands/cf.scandump"><code>CF.SCANDUMP</code></a></td><td style="text-align:left">启动布谷鸟过滤器的增量保存</td></tr></tbody></table><p class="note note-primary">布谷鸟过滤器LUA脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuckooCommand</span> &#123;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建布谷鸟过滤器脚本，支持指定过期时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; RESERVE =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;Boolean&gt;(<br>                    <span class="hljs-string">&quot;local exists = redis.call(&#x27;EXISTS&#x27;, KEYS[1])\n&quot;</span> +<br>                            <span class="hljs-string">&quot;if (exists == 0) then\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  redis.call(&#x27;CF.RESERVE&#x27;, KEYS[1], ARGV[1])\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  if (tonumber(ARGV[2]) &gt; 0) then\n&quot;</span> +<br>                            <span class="hljs-string">&quot;    redis.call(&#x27;PEXPIRE&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  end\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  return true\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  else\n&quot;</span> +<br>                            <span class="hljs-string">&quot;  return false\n&quot;</span> +<br>                            <span class="hljs-string">&quot;end&quot;</span>, Boolean.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将一个item添加到布谷鸟过滤器，如果过滤器不存在则创建过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; ADD =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;Boolean&gt;(<span class="hljs-string">&quot;return redis.call(&#x27;CF.ADD&#x27;, KEYS[1], ARGV[1])&quot;</span>, Boolean.class);<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果item不存在，将一个item添加到布谷鸟过滤器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; ADD_NX =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;Boolean&gt;(<span class="hljs-string">&quot;return redis.call(&#x27;CF.ADDNX&#x27;, KEYS[1], ARGV[1])&quot;</span>, Boolean.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 确定一个item是否可能存在于布谷鸟过滤器中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; EXISTS =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(<span class="hljs-string">&quot;return redis.call(&#x27;CF.EXISTS&#x27;, KEYS[1], ARGV[1])&quot;</span>, Boolean.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除一个item</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; DEL =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(<span class="hljs-string">&quot;return redis.call(&#x27;CF.DEL&#x27;, KEYS[1], ARGV[1])&quot;</span>, Boolean.class);<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取创建布谷鸟过滤器脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getReserveScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> RESERVE;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取添加脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getAddScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ADD;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取添加脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getAddNxScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ADD_NX;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取判断item是否存在脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getExistsScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> EXISTS;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取删除item脚本</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RedisScript&lt;Boolean&gt; <span class="hljs-title function_">getDelScript</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> DEL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">布谷鸟过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCuckooFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt;  key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisCuckooFilter</span><span class="hljs-params">(RedisTemplate redisTemplate, String key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.key           = Collections.singletonList(key);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建布谷鸟过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity     容量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> milliseconds 过期时间，单位毫秒。-1为用不过期</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">int</span> milliseconds)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(CuckooCommand.getReserveScript(), key, capacity, milliseconds);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加item到布谷鸟过滤器，不存在则创建布隆过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(CuckooCommand.getAddScript(), key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果item不存在，添加item到布谷鸟过滤器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addNx</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(CuckooCommand.getAddNxScript(), key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断item是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(CuckooCommand.getExistsScript(), key, item);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除item</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">del</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">boolean</span>) redisTemplate.execute(CuckooCommand.getDelScript(), key, item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">布谷鸟过滤器注册器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuckooFilterRegistry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span>                         <span class="hljs-variable">PREFIX</span>    <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cuckoo:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span>        Map&lt;String, RedisCuckooFilter&gt; container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">private</span>              RedisTemplate                  redisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CuckooFilterRegistry</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> RedisCuckooFilter <span class="hljs-title function_">getFilter</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getName(key);<br>        <span class="hljs-keyword">return</span> container.computeIfAbsent(name, line -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCuckooFilter</span>(redisTemplate, line));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s%s&quot;</span>, PREFIX, key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">配置注册器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;<br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-comment">// 使用Jackson2JsonRedisSerialize替换默认序列化</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span>                <span class="hljs-variable">objectMapper</span>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        objectMapper.activateDefaultTyping(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LaissezFaireSubTypeValidator</span>(),<br>                ObjectMapper.DefaultTyping.EVERYTHING);<br>        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);<br>        <span class="hljs-comment">// 设置value的序列化规则和key的序列化规则</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br><br>    <span class="hljs-comment">// 布谷鸟注册器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CuckooFilterRegistry <span class="hljs-title function_">cuckooFilterRegistry</span><span class="hljs-params">(RedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CuckooFilterRegistry</span>(redisTemplate);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(tags = &quot;Redis 插件 布谷鸟过滤器&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;cuckoo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisCuckooFilterController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CuckooFilterRegistry cuckooFilterRegistry;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">filterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cuckoo-filter&quot;</span>;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;创建布谷鸟过滤器&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;reserve&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RedisCuckooFilter</span> <span class="hljs-variable">cuckooFilter</span> <span class="hljs-operator">=</span> cuckooFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> cuckooFilter.reserve(<span class="hljs-number">10000</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;添加数据到布谷鸟过滤器&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;item&quot;, value = &quot;添加数据&quot;, dataType = &quot;obj&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;add&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;item&quot;)</span> Object item)</span> &#123;<br>        <span class="hljs-type">RedisCuckooFilter</span> <span class="hljs-variable">cuckooFilter</span> <span class="hljs-operator">=</span> cuckooFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> cuckooFilter.add(item);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;数据不存在，添加数据到布谷鸟过滤器&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;item&quot;, value = &quot;添加数据&quot;, dataType = &quot;obj&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;add_nx&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addNx</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;item&quot;)</span> Object item)</span> &#123;<br>        <span class="hljs-type">RedisCuckooFilter</span> <span class="hljs-variable">cuckooFilter</span> <span class="hljs-operator">=</span> cuckooFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> cuckooFilter.addNx(item);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;判断数据是否存在&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;item&quot;, value = &quot;判断数据&quot;, dataType = &quot;obj&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;exists&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;item&quot;)</span> Object item)</span> &#123;<br>        <span class="hljs-type">RedisCuckooFilter</span> <span class="hljs-variable">cuckooFilter</span> <span class="hljs-operator">=</span> cuckooFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> cuckooFilter.exists(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@ApiOperation(value = &quot;删除数据&quot;)</span><br>    <span class="hljs-meta">@ApiImplicitParam(name = &quot;item&quot;, value = &quot;判断数据&quot;, dataType = &quot;obj&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;del&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;item&quot;)</span> Object item)</span> &#123;<br>        <span class="hljs-type">RedisCuckooFilter</span> <span class="hljs-variable">cuckooFilter</span> <span class="hljs-operator">=</span> cuckooFilterRegistry.getFilter(filterName);<br>        <span class="hljs-keyword">return</span> cuckooFilter.del(<span class="hljs-string">&quot;test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：项目启动访问<a href>swagger</a></p><p><img src="/2022/02/04/Redis/cuckooFilter%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">总结</p><p>​	如果是非分布式系统，不存在多服务使用同一布隆过滤器场景，推荐使用 <a href="#单机-guava-版">单机-guava-版</a> 性能最佳</p><p>​	如果是分布式系统，推荐使用 <a href="#布谷鸟过滤器-可删除元素">redis-插件版本的布谷鸟过滤器</a>, 性能和功能上比自定义的 <a href="#redis-bitmap-分布式版">redis-bitmap-分布式版</a> 强，<a href="#redis-bitmap-分布式版"> redis-bitmap-分布式版</a> 更多的意义是用于了解布隆过滤器的实现方式</p><h2 id="内存淘汰"><a class="markdownIt-Anchor" href="#内存淘汰"></a> 内存淘汰</h2><h3 id="键的过期删除策"><a class="markdownIt-Anchor" href="#键的过期删除策"></a> 键的过期删除策</h3><p><img src="/2022/02/04/Redis/%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis的数据已经设置了TTL，不是过期就已经删除了吗？为什么还存在所谓的淘汰策略呢？这个原因我们需要从redis的过期策略聊起</p><h4 id="主动删除"><a class="markdownIt-Anchor" href="#主动删除"></a> 主动删除</h4><p><code>过期字典</code> <code>随机扫描</code></p><ul><li><p><code>过期字典</code>：Redis 维护一个专门的过期字典，其中存放了所有设置了过期时间的键。这个字典用于跟踪各个键的过期时间。</p></li><li><p><code>定期扫描</code>： 默认每秒会进行十次过期扫描，大约每隔 100 毫秒一次。这个频率是为了平衡内存占用和性能开销。</p></li><li><p><code>扫描过程</code>：</p><p>每次扫描采用一种随机和贪心的策略（近视LRU）， 并不遍历整个过期字典。</p><ol><li>从过期字典中随机选择一定数量的键（默认为 20 个）。</li><li>检查并删除其中已过期的键。</li><li>如果在这批键中，超过一定比例（如 1/4）的键已过期，则进行另一轮随机扫描。</li></ol></li></ul><h4 id="被动删除"><a class="markdownIt-Anchor" href="#被动删除"></a> 被动删除</h4><p><code>和定期删除互补</code></p><ul><li><p><code>惰性删除</code>：与定期删除策略相辅相成。懒惰删除的主要特点是，它并不主动去查找和删除过期的键，而是在键被访问时才检查其是否已过期。</p></li><li><p><code>删除过程</code>：</p><ol><li><p>当一个键被访问时（例如通过 GET 命令），Redis 首先检查该键是否设置了过期时间，如果设置了，Redis 接下来会判断该键是否已经过期。</p></li><li><p>如果键已经过期，Redis 会在返回结果之前从数据库中删除该键。因此，过期的键不会被返回给客户端。</p></li></ol></li></ul><p>如果一个过期的键长时间没有被访问，那么它将一直留在数据库中。这种键只有在被访问或者通过定期删除策略被检查到时才会被删除。</p><h3 id="内存淘汰策略"><a class="markdownIt-Anchor" href="#内存淘汰策略"></a> 内存淘汰策略</h3><p><code>内存不足时触发</code></p><p>有了以上过期策略的说明后，就很容易理解为什么需要淘汰策略了，因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，当内存不足时，所以就需要内存淘汰策略进行补充。</p><table><thead><tr><th style="text-align:left">策略</th><th style="text-align:left">说明</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left">noeviction</td><td style="text-align:left">当内存使用超过配置时会返回错误，不会驱逐任何键（·默认策略）。</td><td style="text-align:left">适用于内存资源充足，或不允许丢失任何数据的场景。</td></tr><tr><td style="text-align:left">allkeys-lru</td><td style="text-align:left">如果内存限制被超出，首先通过 LRU 算法驱逐最久未使用的键。</td><td style="text-align:left">适用于普通缓存场景，特别是当存储空间有限但希望保留最活跃数据时。</td></tr><tr><td style="text-align:left">volatile-lru</td><td style="text-align:left">如果内存限制被超出，首先从设置了过期时间的键中驱逐最久未使用的键。</td><td style="text-align:left">适用于优先驱逐那些已设置过期时间且最少使用的键的场景。</td></tr><tr><td style="text-align:left">allkeys-random</td><td style="text-align:left">如果内存限制被超出，从所有键中随机删除。</td><td style="text-align:left">当其他方法的开销过大，或没有明确的访问模式时使用。</td></tr><tr><td style="text-align:left">volatile-random</td><td style="text-align:left">如果内存限制被超出，从设置了过期时间的键中随机删除。</td><td style="text-align:left">适用于随机驱逐已设置过期时间的键的场景。</td></tr><tr><td style="text-align:left">volatile-ttl</td><td style="text-align:left">从配置了过期时间的键中驱逐即将过期的键。</td><td style="text-align:left">适用于当内存紧张时优先删除即将过期的键。</td></tr><tr><td style="text-align:left">volatile-lfu</td><td style="text-align:left">从所有配置了过期时间的键中驱逐使用频率最低的键。</td><td style="text-align:left">适用于频繁访问的数据变化不大，但希望清理不经常使用的过期数据的场景。</td></tr><tr><td style="text-align:left">allkeys-lfu</td><td style="text-align:left">从所有键中驱逐使用频率最低的键。</td><td style="text-align:left">当数据的访问频率是驱逐决策的主要因素时使用。</td></tr></tbody></table><p><code>这八种大体上可以分为4种，lru、lfu、random、ttl</code></p><h3 id="内存淘汰流程"><a class="markdownIt-Anchor" href="#内存淘汰流程"></a> 内存淘汰流程</h3><p><img src="/2022/02/04/Redis/Redis%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0.png" srcset="/img/loading.gif" lazyload alt></p><p>Redis 的内存淘汰流程是在内存达到限制时被触发的一系列操作，用于释放内存空间以适应新的写入操作。以下是这个流程的基本步骤：</p><ol><li><strong><code>检测内存使用</code></strong>：Redis 持续监测内存使用情况。当内存使用接近配置的 <code>maxmemory</code> 限制时（默认没有设置），触发内存淘汰机制。</li><li><strong><code>淘汰样本数量</code></strong>：<ol><li><code>maxmemory-samples</code> 配置决定了在每次淘汰检查中考虑的键的数量，其默认值通常为 5。</li><li>增加 <code>maxmemory-samples</code> 的值可以提高接近真实 LRU 或 LFU 行为的准确性，但相应地会增加 CPU 使用率。</li></ol></li><li><strong><code>选择淘汰候选键</code></strong>：在淘汰过程中，Redis 从数据集中随机抽取 <code>maxmemory-samples</code> 个键，并根据配置的淘汰策略（LRU，LFU等）评估这些键。</li><li><strong><code>填充 eviction pool</code></strong>：在每次淘汰检查中，根据评估结果，Redis 会更新 <code>eviction pool</code>。<code>eviction pool</code> 是一个固定大小的结构（通常为 16 条目），用于跟踪当前最有可能被淘汰的键。</li><li><strong><code>执行淘汰</code></strong>：当需要释放内存时，Redis 会从 <code>eviction pool</code> 中选择并淘汰键。通常，从该池中淘汰的是评估为“最应该被淘汰”的键。</li></ol><h3 id="lru算法-最近最少使用算法"><a class="markdownIt-Anchor" href="#lru算法-最近最少使用算法"></a> LRU算法 (最近最少使用算法)</h3><p>LRU（Least Recently Used）算法，即最近最少使用算法，是一种常用的缓存淘汰策略。这种算法的核心思想是：如果数据在最近一段时间内没有被访问，那么将来被访问的可能性也不大。因此，当缓存空间不足时，LRU算法会优先淘汰那些最长时间没有被访问的数据。</p><p>工作原理：</p><ol><li><code>跟踪数据的访问顺序</code>：每当缓存中的一个数据项被访问时，这个数据项就被移到一个记录了访问顺序的列表的前端。</li><li><code>淘汰最久未使用的数据</code>：当需要空间来存储新的数据项时，位于这个列表末端的数据项（即最久未被访问的数据项）首先被淘汰。</li></ol><p><code>标准LRU算法</code></p><p><img src="/2022/02/04/Redis/URL%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">LRU算法优缺点</p><p><img src="/2022/02/04/Redis/LRU%E7%BC%BA%E7%82%B9.png" srcset="/img/loading.gif" lazyload alt></p><p>上面两张图片可见，<span style="border-bottom:2px dashed green">URL算法虽然可以淘汰最近一段时间访问频率比较少的数据。但是有些数据可能就某一段时间没有访问，其他时间段高频访问。</span>上图数据如果要淘汰的话，数据B会被淘汰（淘汰了真正热点数据），<em>URL不能准确判断淘汰的数据是否为热点数据</em>。</p><ul><li><strong>优点</strong>:<ul><li>相对简单，容易理解和实现。</li><li>在很多常见的场景下，能有效地预测数据项的访问模式。</li></ul></li><li><strong>缺点</strong>:<ul><li>实现和维护代价相对较高，特别是在数据量大时。</li><li>并非在所有场景下都是最优的淘汰策略，特别是在访问模式频繁变化的情况下。</li></ul></li></ul><h4 id="redis-lru实现"><a class="markdownIt-Anchor" href="#redis-lru实现"></a> Redis LRU实现</h4><p><code>全局时钟</code> <code>每个key内部维护时钟</code></p><p><span style="border-bottom:2px dashed green">Redis维护了一个24位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key对象内部同样维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰</span>，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span> &#123;</span><br>    <span class="hljs-type">pid_t</span> pid; <br>    <span class="hljs-type">char</span> *configfile; <br>    <span class="hljs-comment">//全局时钟</span><br>    <span class="hljs-type">unsigned</span> lruclock:LRU_BITS; <br>    ...<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br> <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br> <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br> <span class="hljs-comment">/* key对象内部时钟 */</span><br> <span class="hljs-type">unsigned</span> lru:LRU_BITS;<br> <span class="hljs-type">int</span> refcount;<br> <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br></code></pre></td></tr></table></figure><p>Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰</p><p class="note note-primary">为什么要使用近似LRU</p><p>1、性能问题，由于近似LRU算法只是最多<span style="border-bottom:2px dashed green">随机采样N个key并对其进行排序</span>，如果精准需要对所有key进行排序，这样近似LRU性能更高</p><p>2、内存占用问题，redis对内存要求很高，会尽量降低内存使用率，如果是抽样排序可以有效降低内存的占用</p><p>3、实际效果基本相等，如果请求符合长尾法则，那么真实LRU与Redis LRU之间表现基本无差异</p><p>4、在近似情况下提供可自配置的取样率来提升精准度，例如通过 CONFIG SET maxmemory-samples<count>指令可以设置取样数，取样数越高越精准，如果你的CPU和内存有足够，可以提高取样数看命中率来探测最佳的采样比例</count></p><h3 id="lfu算法-最不经常使用"><a class="markdownIt-Anchor" href="#lfu算法-最不经常使用"></a> LFU算法 (最不经常使用)</h3><p>LFU（Least Frequently Used）算法，即最不经常使用算法，是一种用于管理缓存空间的策略。与LRU（最近最少使用）算法不同，LFU算法的核心思想是根据数据项的访问频率来进行淘汰。简而言之，LFU算法会优先移除访问频率最低的数据项。</p><p>工作原理：</p><ol><li><code>统计访问频率</code>：每个数据项都有一个计数器，记录该数据项被访问的次数。</li><li><code>淘汰频率最低的数据</code>：当缓存空间不足时，LFU算法会淘汰那些访问频率最低的数据项。如果多个数据项的访问频率相同，则可能根据其他标准（如时间）来决定哪个数据项被淘汰。</li></ol><p>实现方式：</p><ol><li><code>计数器和优先队列</code>：实现LFU算法常用的一种方式是为每个数据项维护一个计数器，并使用优先队列来根据访问频率进行排序。</li><li><code>逐渐减少计数器的值</code>：为了应对长时间运行的情况，系统可能会定期减少所有或一部分数据项的计数器值，以便新的或最近变得活跃的数据项不会被过早地淘汰。</li></ol><p class="note note-primary">LFU算法优缺点</p><ul><li><strong>优点</strong>:<ul><li>更好地识别和保留那些频繁访问的数据项。</li><li>对于长期运行的应用，可能比LRU表现得更好，因为它考虑了整个运行期间的访问历史。</li></ul></li><li><strong>缺点</strong>:<ul><li>实现较为复杂，特别是需要准确且高效地处理访问计数和排序。</li><li>如果访问模式发生变化，旧的数据项可能由于历史高访问频率而不被淘汰。</li></ul></li></ul><p>LFU算法非常适用于访问模式相对稳定的情况，其中一些数据项显著地比其他数据项被更频繁地访问。通过淘汰那些很少被访问的数据项，LFU算法能够有效地管理有限的缓存空间。</p><h2 id="redis-常见问题汇总"><a class="markdownIt-Anchor" href="#redis-常见问题汇总"></a> Redis 常见问题汇总</h2><h3 id="redis-的优缺点"><a class="markdownIt-Anchor" href="#redis-的优缺点"></a> Redis 的优缺点</h3><p class="note note-primary">优点</p><ul><li><code>读写性能优异</code>， Redis能读的速度是110000次/s，写的速度是81000次/s</li><li><code>支持数据持久化</code>，支持AOF和RDB两种持久化方式</li><li><code>单线程执行</code>，Redis的所有操作都是原子性的</li><li><code>数据结构丰富</code>，除了支持string类型的value外还支持hash、set、zset、list等数据结构</li><li><code>支持主从复制</code>，主机会自动将数据同步到从机，可以进行读写分离</li></ul><p><em><font color="red">优点主要集中在redis的工作模式上，单线程、内存存储、IO复用、主从复制</font></em></p><p class="note note-primary">缺点</p><ul><li><code>内存限制</code>，不能作用于海量数据的高性能读写</li><li>主机宕机，会<code>丢失部分数据</code></li></ul><h3 id="使用redis有哪些好处"><a class="markdownIt-Anchor" href="#使用redis有哪些好处"></a> 使用redis有哪些好处</h3><ul><li>数据读写速度快，基于内存操作</li><li>支持丰富的数据类型，基本类型五种，特殊类型三种</li><li>所有命令都是原子性操作</li><li>key过期自动删除（定期删除和惰性删除）</li></ul><h3 id="为什么要用redis做缓存"><a class="markdownIt-Anchor" href="#为什么要用redis做缓存"></a> 为什么要用Redis做缓存</h3><p><font color="red">主要从“高性能”和“高并发”这两点来看待这个问题</font></p><p class="note note-primary">高性能</p><p>​	相比从DB中获取数据，由DB再到磁盘加载数据的整个过程耗费时间长，用户体验差。使用Redis做缓存直接在内存中获取数据速度快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可</p><p class="note note-primary">高并发</p><p>​	当遇到高并发场景时，DB数据库容易达到性能瓶颈。如果将部分数据放在内存缓存中则可以有效降低数据库压力，防止数据库宕机</p><h3 id="为什么要用-redis-而不用-mapguava-做缓存"><a class="markdownIt-Anchor" href="#为什么要用-redis-而不用-mapguava-做缓存"></a> 为什么要用 Redis 而不用 map/guava 做缓存</h3><p><font color="red">主要从“本地缓存”、“分布式缓存”、”缓存一致性“作为思考点</font></p><ul><li><code>本地缓存与分布式缓存</code>： 如果缓存数据只是被一个服务独享，那么使用map是最好的选择。但大多数情况下，系统中的一份缓存数据通常被多个服务共同使用，使用Redis的好处就是能让缓存转变为分布式缓存并提供给多个系统使用</li><li><code>保证缓存一致性</code>：本地缓存由各服务独立维护，无法统一管理。Redis作为分布是缓存底层就只有一份缓存数据，不存在缓存不一致场景</li></ul><h3 id="redis和mysql如何保持数据一致性"><a class="markdownIt-Anchor" href="#redis和mysql如何保持数据一致性"></a> Redis和Mysql如何保持数据一致性</h3><p class="note note-primary">一致性</p><ul><li><code>强一致性</code>： 这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验性好，但实现起来往往对系统的性能影响大</li><li><code>弱一致性</code>： 这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别(比如秒级别)后，数据能够达到一致状态</li><li><code>最终一致性</code>： 最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</li></ul><p><em>实际上，没办法做到数据库和缓存的<strong>绝对的一致性，只能保证最终一致性</strong></em></p><p class="note note-primary">延迟双删</p><ul><li><code>优点</code>：数据不一致的时间很短暂，只有休眠那段时间会不一致</li><li><code>缺点</code>：需要考虑删除失败造成数据不一致问题</li></ul><p><img src="/2022/02/04/Redis/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0.png" srcset="/img/loading.gif" lazyload alt></p><p>流程</p><ul><li>1.先删除缓存</li><li>2.再写数据库</li><li>3.短暂休眠</li><li>4.再次删除缓存</li></ul><p><strong>为什么需要休眠n毫秒？如何计算？</strong></p><p>n毫秒 = 读数据业务逻辑的耗时 + 时间冗余（几百毫秒）+ Redis主从同步延迟时间</p><p>休眠延迟删除是为了防止缓存脏读（并发场景下）</p><p>在高并发的场景下，即使是在更新数据库之后立即删除缓存，也可能存在其他线程在这两个操作之间查询缓存并将旧数据加载回缓存的情况。</p><p class="note note-primary">binlog订阅，异步更新</p><p>也可以使用消息队列替代binlog，实现异步更新，比如RabbitMq的延迟队列</p><ul><li><p><code>优点</code>：不需要删除多次</p></li><li><p><code>缺点</code>：实现成本高，延迟受mysql压力影响</p></li></ul><p><strong>流程</strong></p><p>A服务</p><ol><li>发起修改请求</li><li>修改数据库数据</li><li>返回响应</li></ol><p>缓存服务</p><ol><li>订阅binlog</li><li>解析binlog</li><li>更新缓存</li></ol><p class="note note-primary">缓存失效</p><ul><li><code>写入时使缓存失效</code>：每当数据在 MySQL 中被更新时，而不是更新缓存，而是简单地从 Redis 中删除相应的缓存数据。下次需要这些数据时，从 MySQL 中重新加载并更新缓存。</li><li><code>定时使缓存失效</code>：为缓存数据设置过期时间，强制定期从数据库中重新加载数据。</li></ul><h3 id="缓存穿透-缓存击穿-缓存雪崩"><a class="markdownIt-Anchor" href="#缓存穿透-缓存击穿-缓存雪崩"></a> 缓存穿透、缓存击穿、缓存雪崩</h3><p><a href="#高可用问题">高可用问题</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6847902224144662542">掘金文章</a></p><p class="note note-primary">缓存穿透</p><p>缓存没有，数据库也没有数据。高频缓存穿透 <em>恶意攻击：访问数据库不存在的数据</em></p><ul><li>缓存空对象</li><li>布隆过滤器</li></ul><p class="note note-primary">缓存击穿</p><p>某个承载高并发的热点key过期</p><ul><li>热点数据不过期</li><li>互斥锁</li></ul><p class="note note-primary">缓存雪崩</p><p>上面说的缓存击穿是一个热点key的失效，而缓存雪崩是多个热点key同时失效或缓存服务崩溃</p><ul><li>数据预热，缓存时间随机</li><li>限流降级</li><li>redis集群</li></ul><h3 id="redlock"><a class="markdownIt-Anchor" href="#redlock"></a> RedLock</h3><p>RedLock 是 Redis 官方推出的一种分布式锁的实现算法。这种算法的目的是在分布式环境中提供一种相对安全和可靠的方式来实现锁机制。RedLock 主要用于那些需要跨多个进程或系统同步资源访问的场景。</p><p>RedLock 算法的工作原理:</p><ol><li><p><strong>多个 Redis 实例</strong>:</p><ul><li>RedLock 算法要求部署多个（通常是五个）独立的 Redis 实例。这些实例互不相同，不是主从关系也不是集群模式。</li></ul></li><li><p><strong>获取锁</strong>:</p><ul><li>当客户端尝试获取锁时，它会向所有的 Redis 实例发送获取锁的请求。请求包含一个唯一的锁标识符和一个时间戳。</li><li>客户端尝试在每个 Redis 实例上使用 <code>SETNX</code> 命令（或 <code>SET</code> 命令的 <code>NX</code> 选项）来设置一个具有过期时间的锁。</li></ul></li><li><p><strong>锁的获取规则</strong>:</p><ul><li>客户端需要在大多数（至少三个）Redis 实例上成功设置锁，才被认为是成功获取了锁。</li><li>如果客户端在多数实例上未能成功获取锁，它会立即释放在所有实例上的锁。</li></ul></li><li><p><strong>锁的释放</strong>:</p><ul><li>当客户端完成其操作时，它会向所有 Redis 实例发送释放锁的命令。</li></ul></li></ol><p>RedLock 的特点:</p><ul><li><strong>容错性</strong>:<ul><li>由于 RedLock 需要在大多数实例上获取锁，因此即使其中某些实例不可用，仍然可以保证锁的有效性。</li></ul></li><li><strong>安全性</strong>:<ul><li>RedLock 提供了比单个 Redis 实例更高的安全保障，因为它减少了单点故障的风险。</li></ul></li><li><strong>公平性</strong>:<ul><li>通过在多个实例上获取锁，RedLock 尝试确保锁的公平分配，防止单个客户端长时间占用锁。</li></ul></li></ul><p>RedLock 算法在学术和工业界有一些争议。有些专家认为 RedLock 不能提供严格的安全保障，特别是在网络分区和其他极端情况下。</p><h3 id="为什么是删除缓存不是更新缓存"><a class="markdownIt-Anchor" href="#为什么是删除缓存不是更新缓存"></a> 为什么是删除缓存，不是更新缓存</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40857858/article/details/122871527">参考文章</a></p><ul><li><p><code>避免脏数据</code>：在高并发的环境下，直接更新缓存可能导致数据不一致的情况，尤其是当有多个线程同时更新数据时。</p></li><li><p><code>按需缓存</code>：不是所有数据都需要被频繁访问。通过删除缓存，可以确保只有真正需要的数据被缓存，从而有效管理缓存空间。</p></li><li><p><code>性能考虑</code>：删除操作通常比更新操作要快，并且更新的数据不一定需要被缓存。</p></li></ul><h3 id="redis-和-memcached-有啥区别为什么选择redis"><a class="markdownIt-Anchor" href="#redis-和-memcached-有啥区别为什么选择redis"></a> Redis 和 Memcached 有啥区别，为什么选择Redis</h3><p class="note note-primary">数据类型</p><p>与Memcached仅支持简单的key-value结构的数据记录不同，Redis支持的数据类型要丰富得多。<span style="border-bottom:2px dashed green">Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能</span></p><p class="note note-primary">持久性</p><p>redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储</p><p class="note note-primary">分布式存储</p><p>redis支持master-slave复制模式</p><p>memcache可以使用一致性hash做分布式</p><p class="note note-primary">cpu利用</p><p>redis单线程执行</p><p>memcache支持多核，海量数据性能高于Redis</p><p class="note note-primary">为什么是Redis</p><p>首先Redis支付丰富的数据类型，满足日常开发场景需求，可以做分布式锁，可以使用List做任务队列等。其次提供AOF和RDB持久化数据，数据安全性有保证</p><h3 id="redis-的线程模型"><a class="markdownIt-Anchor" href="#redis-的线程模型"></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrmirror/p/13587311.html">Redis 的线程模型</a></h3><p><code>文件事件处理模型</code></p><p><img src="/2022/02/04/Redis/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><strong>单线程的文件事件处理器</strong>:<ul><li>Redis 的核心是基于单线程的文件事件处理模型。这意味着它的网络请求处理、命令执行等，都在一个单线程中顺序执行。</li></ul></li><li><strong>IO 多路复用</strong>:<ul><li>Redis 使用 IO 多路复用机制来同时监控多个 Socket。这允许单线程高效地处理多个并发网络连接。</li></ul></li><li><strong>文件事件处理器的组成</strong>:<ul><li>文件事件处理器由以下四个主要部分组成：<ul><li><strong>多 Socket</strong>：负责与客户端的网络连接。</li><li><strong>IO 多路复用程序</strong>：监控多个客户端请求，并将请求转为事件放入事件队列。</li><li><strong>文件事件分派器</strong>：从事件队列获取事件，并根据事件类型将它们分派给对应的事件处理器。</li><li><strong>事件处理器</strong>：包括连接应答处理器、命令请求处理器、命令回复处理器等，根据不同事件执行相应操作。</li></ul></li></ul></li><li><strong>事件处理流程</strong>:<ul><li>当多个 Socket 并发产生不同的操作时，这些操作产生的文件事件被 IO 多路复用程序捕获并放入队列。事件分派器然后逐一从队列中取出事件，并将其交给相应的事件处理器进行处理。</li></ul></li><li><strong>Redis 6.0 及以上版本的多线程 I/O</strong>:<ul><li>从 Redis 6.0 开始，引入了多线程来处理网络 I/O 的读写操作，但数据的实际读取、处理和回复操作仍在单个主线程中完成。</li></ul></li></ol><h3 id="redis分布式锁过期了但业务还没有执行完怎么办"><a class="markdownIt-Anchor" href="#redis分布式锁过期了但业务还没有执行完怎么办"></a> Redis分布式锁过期了但业务还没有执行完，怎么办</h3><p><code>看门狗机制自动延长</code></p><p><img src="/2022/02/04/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%87%E6%9C%9F.png" srcset="/img/loading.gif" lazyload alt></p><p><em>参考 redisson 的实现，就是会有watchdog定时判断key是否过期，否则就延长key</em></p><ul><li><a href="#spring-integration-redis">redis分布式锁</a>需要实现一个可延期的策略，相同的客户端可以实现锁延期</li><li>锁延期的条件，锁的key存在，并且锁的value值和当前的Client要一致</li><li>每个客户端对应一个定时任务，入参为锁的key和ClientId，定期轮询，比如10秒。当redis中的key相同value和ClientId相同时，自动延长锁时间</li></ul><p class="note note-primary">客户端宕机</p><p>​	这种时候锁不会自动延期，那就等key的过期时间到期后自动删除其他客户端再申请锁</p><h3 id="客户端宕机立即释放分布式锁"><a class="markdownIt-Anchor" href="#客户端宕机立即释放分布式锁"></a> 客户端宕机立即释放分布式锁</h3><p><img src="/2022/02/04/Redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%93%A8%E5%85%B5.png" srcset="/img/loading.gif" lazyload alt></p><p><code>思路</code>：<span style="border-bottom:2px dashed green">客户端宕机说明不能在客户端上有任何期望，可以参考Redis哨兵的实现方式。我们额外开发一个分布式锁哨兵，它独立于Redis和客户端之外</span></p><p><code>方案</code>：</p><ul><li>研发一个独立的服务分布式锁哨兵</li><li>客户端启动的时候将ClientId和Redis连接信息上报给哨兵</li><li>哨兵定期心跳访问客户端，如果发现客户端宕机则遍历所有分布式锁Key, 判断其value是否为宕机的ClientId，是则删除该key</li></ul><h3 id="多个系统同时操作并发redis带来的数据问题"><a class="markdownIt-Anchor" href="#多个系统同时操作并发redis带来的数据问题"></a> 多个系统同时操作（并发）Redis带来的数据问题</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903991562747912#heading-6">参考</a></p><p>多个系统需要修改同一个key,可能有网络波动，如何保持顺序性</p><ul><li>加分布式锁，保证一段时间内只有某个服务可读可写</li><li>使用事务<code>Watch</code>，乐观锁方案</li></ul><h3 id="redis的应用场景"><a class="markdownIt-Anchor" href="#redis的应用场景"></a> Redis的应用场景</h3><p class="note note-primary">计数器</p><p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量</p><p class="note note-primary">缓存</p><p>将热点数据放到内存中，减少数据加载时间损耗</p><p class="note note-primary">会话缓存</p><p>可以使用 Redis 来统一存储多台应用服务器的会话信息，实现会话共享</p><p class="note note-primary">分布式锁实现</p><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现</p><h3 id="redis持久化"><a class="markdownIt-Anchor" href="#redis持久化"></a> Redis持久化</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失</p><ul><li><a href="#rdb-redis-database-%E9%BB%98%E8%AE%A4">RDB 默认</a></li><li><a href="#aofappend-only-file">AOF</a></li><li><a href="#aof%E5%9C%A8%E9%87%8D%E5%86%99%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BB%A7%E7%BB%AD%E6%9C%8D%E5%8A%A1">AOF在重写时如何保证继续服务</a></li></ul><h3 id="如何选择合适的持久化方式"><a class="markdownIt-Anchor" href="#如何选择合适的持久化方式"></a> 如何选择合适的持久化方式</h3><ul><li><p>如果对数据有<span style="border-bottom:2px dashed green">安全性要求</span>，同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，如果数据量大可以使用<code>RDB</code>做全量数据恢复，<code>AOF</code>做增量恢复</p></li><li><p>如果Redis<span style="border-bottom:2px dashed green">数据量不大并对数据完整性有严格要求</span>则使用<code>AOF</code>方式,它会记录每个写操作</p></li><li><p>如果Redis<span style="border-bottom:2px dashed green">数据量很大并且对数据完整性没有强制要求</span>则使用<code>RDB</code>,RDB数据恢复速读比AOF快</p></li><li><p>如只希望<span style="border-bottom:2px dashed green">数据在服务器运行的时候存在</span>，也可以不使用任何持久化方式</p></li></ul><h3 id="redis持久化数据和缓存怎么做扩容"><a class="markdownIt-Anchor" href="#redis持久化数据和缓存怎么做扩容"></a> Redis持久化数据和缓存怎么做扩容</h3><p>如果Redis被当做缓存使用，使用一致性哈希（hash槽）实现动态扩容缩容</p><ul><li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1152240">hash环实现 一致性hash</a></p></li><li><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15281317/3008526">redis 扩容</a></p></li></ul><h3 id="redis的过期键的删除策略-对过期的数据怎么处理"><a class="markdownIt-Anchor" href="#redis的过期键的删除策略-对过期的数据怎么处理"></a> Redis的过期键的删除策略 （对过期的数据怎么处理）</h3><p><a href="#键的过期删除策"><strong>键的过期删除策</strong></a></p><ul><li>定期删除</li><li>惰性删除</li></ul><p class="note note-primary">内存淘汰策略</p><ul><li>内存满了报错，默认</li><li>LRU</li><li>LRF</li><li>TTL</li><li>随机</li></ul><h3 id="redis-key的过期时间和永久有效分别怎么设置"><a class="markdownIt-Anchor" href="#redis-key的过期时间和永久有效分别怎么设置"></a> Redis key的过期时间和永久有效分别怎么设置</h3><p><code>expire</code>和<code>persist</code>命令</p><h3 id="如何保证redis中的数据都是热点数据"><a class="markdownIt-Anchor" href="#如何保证redis中的数据都是热点数据"></a> 如何保证redis中的数据都是热点数据</h3><p><font color="red">这里主要考虑到使用redis的内存淘汰策略实现</font></p><p><a href="#内存淘汰策略">内存淘汰策略</a></p><h3 id="redis如何做内存优化"><a class="markdownIt-Anchor" href="#redis如何做内存优化"></a> Redis如何做内存优化</h3><p><code>合理使用数据结构</code> <code>使用更优秀的序列化技术</code></p><p>可以好好利用hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。尽可能使用散列表（hashset），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key，而是应该把这个用户的所有信息存储到一张散列表里面</p><h3 id="什么是redis事务"><a class="markdownIt-Anchor" href="#什么是redis事务"></a> 什么是Redis事务</h3><p>Redis 事务的本质是通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中,不保证原子性</p><p><a href="#事务">事务</a></p><h3 id="redis分布式寻址算法"><a class="markdownIt-Anchor" href="#redis分布式寻址算法"></a> Redis分布式寻址算法</h3><p><code>hash槽</code></p><p>在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？如何动态增加和删除一个节点？</p><p>hash 算法（大量缓存重建） 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡） Redis cluster 的 hash slot 算法</p><p class="note note-primary">hash 算法</p><p>来了一个 key，首先计算 hash 值，然后对节点数取模，接着打在不同的 master 节点上。缺点也很明显：某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去库中取数据进行缓存。这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库</p><p><strong><a target="_blank" rel="noopener" href="https://juejin.cn/post/6850418113830846471">一致性 hash 算法</a></strong></p><p>将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置，这样就能确定每个节点在其哈希环上的位置。在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。 虚拟节点：一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡</p><p><strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41587243/article/details/115331897">hash slot 算法</a></strong></p><p>Redis cluster 有固定的 16384 个 hash slot，slot是槽的概念（理解为数据管理和迁移的基本单位），所有的键根据哈希函数映射到 0~16383 整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据。 公式：slot = CRC16（key）&amp; 16384。解释：对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。hash slot可以像磁盘分区一样自由分配槽位，在配置文件里可以指定，也可以让redis自己选择分配，结果均匀，这种结构很容易添加或者删除节点。如果增加一个节点，就需要从节点已有的节点 获得部分槽分配到新的节点 上。如果想移除已有的一个节点，需要将节点中的槽移到其他节点上，然后将没有任何槽的节点从集群中移除就可以了。由于缓存的key hash结果是和slot绑定的，而不是和服务器节点绑定，所以节点的更替只需要迁移slot即可平滑过渡。从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>Redis</div><div>https://wugengfeng.cn/2022/02/04/Redis/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年2月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/02/24/Kafka/" title="Kafka"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Kafka</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/01/25/RabbitMQ/" title="RabbitMQ"><span class="hidden-mobile">RabbitMQ</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>