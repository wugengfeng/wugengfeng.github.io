<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="思维导图  数据库概念  关系型数据库（RDBMS） 概念 关系型数据库，如MySQL、Oracle、DB2、SQL Server等，是建立在关系模型的基础上的。这种数据库由多个相互关联的二维表组成。每个二维表，就像Excel的工作表一样，由行（代表记录）和列（代表数据字段）构成。表格中的每一行通常代表一个实体的实例，而列则表示实体的属性。关键的一点在于，这些表之间可以通过键（例如主键和外键）相互"><meta property="og:type" content="article"><meta property="og:title" content="Mysql"><meta property="og:url" content="https://wugengfeng.cn/2022/02/26/Mysql/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="思维导图  数据库概念  关系型数据库（RDBMS） 概念 关系型数据库，如MySQL、Oracle、DB2、SQL Server等，是建立在关系模型的基础上的。这种数据库由多个相互关联的二维表组成。每个二维表，就像Excel的工作表一样，由行（代表记录）和列（代表数据字段）构成。表格中的每一行通常代表一个实体的实例，而列则表示实体的属性。关键的一点在于，这些表之间可以通过键（例如主键和外键）相互"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/mysql.png"><meta property="article:published_time" content="2022-02-26T02:51:54.000Z"><meta property="article:modified_time" content="2024-02-19T08:22:42.720Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/mysql.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>Mysql - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Mysql"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-02-26 10:51" pubdate>2022年2月26日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 94k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 783 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Mysql</h1><div class="markdown-body"><p><a target="_blank" rel="noopener" href="https://www.mubu.com/doc/eANwO2YOmO">思维导图</a></p><h1 id="数据库概念"><a class="markdownIt-Anchor" href="#数据库概念"></a> 数据库概念</h1><h2 id="关系型数据库rdbms"><a class="markdownIt-Anchor" href="#关系型数据库rdbms"></a> 关系型数据库（RDBMS）</h2><p class="note note-primary">概念</p><p>关系型数据库，如MySQL、Oracle、DB2、SQL Server等，是建立在关系模型的基础上的。这种数据库由多个相互关联的二维表组成。每个二维表，就像Excel的工作表一样，由行（代表记录）和列（代表数据字段）构成。表格中的每一行通常代表一个实体的实例，而列则表示实体的属性。关键的一点在于，这些表之间可以通过键（例如主键和外键）相互关联，使得不同表中的数据能够相互参照和整合。这样的设计允许数据库高效地组织、查询和维护大量 <code>结构化</code> 数据。</p><p>此外，关系型数据库与非关系型数据库（NoSQL）的主要区别在于数据存储和处理方式。关系型数据库依赖于预定义的模式和二维表来组织数据，而非关系型数据库可能使用更灵活的数据模型，如键值对、文档或图形结构，这使它们更适合处理非结构化或半结构化数据。</p><p><img src="/2022/02/26/Mysql/%E4%BA%8C%E7%BB%B4%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">特点</p><ol><li><strong><code>结构化数据存储</code></strong>：使用规范化的表结构来组织数据，保证数据结构一致性和完整性。</li><li><strong><code>SQL标准</code></strong>：通过统一的SQL语言进行数据查询和操作，实现高效的数据库管理。</li><li><strong><code>事务处理支持</code></strong>：提供完整的事务处理机制，确保数据库操作的原子性和一致性。</li><li><strong><code>索引和性能优化</code></strong>：利用索引来加速数据检索，采用各种优化策略提高数据库性能。</li></ol><h2 id="sql语句分类"><a class="markdownIt-Anchor" href="#sql语句分类"></a> SQL语句分类</h2><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr><tr><td>TCL</td><td>Transaction Control Language</td><td>事务控制语言</td></tr></tbody></table><h2 id="mysql架构"><a class="markdownIt-Anchor" href="#mysql架构"></a> MySql架构</h2><p><img src="/2022/02/26/Mysql/MySql%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><div class="note note-warning"><p><strong><code>连接层</code></strong></p><ul><li><strong>客户端连接管理</strong>：负责管理客户端和服务器之间的连接。它接收客户端请求，并建立、管理、终止客户端到服务器的连接。</li><li><strong>认证与安全</strong>：在此层进行用户认证，检查用户是否有权限连接到MySQL服务器，并对数据传输进行加密处理以保证安全。</li><li><strong>连接池</strong>：优化资源使用，复用现有连接。</li></ul></div><div class="note note-warning"><p><strong><code>服务层</code></strong></p><ul><li><strong>SQL解析</strong>：解析SQL查询，进行语法检查，生成解析树。</li><li><strong>查询优化</strong>：优化器对查询进行优化，选择最有效的查询路径。</li><li><strong>缓存</strong>：查询缓存可以存储SELECT语句及其结果，加速后续相同的查询过程。</li></ul></div><div class="note note-warning"><p><strong><code>引擎层</code></strong></p><ul><li><strong>存储引擎</strong>：MySQL支持多种存储引擎，每种引擎都有其特点。例如，InnoDB支持事务处理、行级锁定和外键；MyISAM提供高速存储、全文搜索功能等。</li><li><strong>事务管理</strong>：对于支持事务的存储引擎（如InnoDB），在此层进行事务的管理。</li><li><strong>数据处理</strong>：执行具体的数据读写、缓存、锁定等操作。</li></ul></div><div class="note note-warning"><p><strong><code>存储层</code></strong></p><ul><li><strong>数据文件</strong>：物理存储数据的文件，包括数据文件和索引文件。</li><li><strong>数据组织</strong>：数据按照存储引擎的格式在磁盘上进行组织，例如InnoDB存储引擎使用表空间来存储数据。</li><li><strong>数据备份与恢复</strong>：负责数据的备份和在系统崩溃后的数据恢复。</li></ul></div><h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎"></a> 存储引擎</h2><p>存储引擎是数据库管理系统中用于实现 <code>数据存储</code>、<code>索引建立</code> 以及 <code>数据更新</code> 和 <code>查询</code> 等功能的底层软件组件。<span class="green-line">存储引擎是基于表的，而非基于整个数据库（库）。</span>这意味着在同一个数据库中，不同的表可以使用不同的存储引擎，根据它们各自的需求优化性能和功能。因此，存储引擎也可以被称为 <code>表类型</code>。</p><p>在创建表时，可以明确指定要使用的存储引擎。如果在创建表时没有指定存储引擎，MySQL将使用默认的存储引擎，这通常是InnoDB，因为它提供了全面的事务支持、数据完整性和性能优化。</p><p class="note note-primary">指定存储引擎</p><p>MySql5.6以后，如果不指定存储引擎，则默认使用 <code>InnoDB</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [ COMMENT 字段<span class="hljs-number">1</span>注释 ] ,<br>    ......<br>    字段n 字段n类型 [COMMENT 字段n注释 ]<br>) ENGINE <span class="hljs-operator">=</span> INNODB [ COMMENT 表注释 ];<br></code></pre></td></tr></table></figure><p>查询当前数据库支持的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> engines;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/02/26/Mysql/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="myisam"><a class="markdownIt-Anchor" href="#myisam"></a> MyISAM</h3><p class="note note-primary">特性</p><ul><li>不支持事务</li><li>不支持外键</li><li>仅支持表级锁</li><li>全文索引</li><li>数据压缩</li><li>高速读取：读取性能比写入性能好，特别是在读密集型的应用中</li></ul><p class="note note-primary">存储文件</p><ul><li><code>.frm</code> 存储表结构定义，如字段名称、数据类型和其他与表结构相关的细节。</li><li><code>.MYD</code> 存储表的实际数据。.MYD 文件包含了表中的行数据，但不包含任何索引信息。</li><li><code>.MYI</code> 专门用于存储表的索引。这个文件包含了所有用于加速查询的索引信息。</li></ul><p class="note note-primary">故障恢复</p><ul><li><p>健康状态查询 <em>check table table_name</em></p></li><li><p>表损坏修复 <em>repair table table_name</em></p></li></ul><p class="note note-primary">存储格式</p><ul><li><code>静态表</code>（默认）：所有字段都有固定长度。常见的静态字段类型包括<code>CHAR</code>、<code>INT</code>、<code>FLOAT</code>等。</li><li><code>动态表</code>：包含可变长度字段，如<code>VARCHAR</code>、<code>BLOB</code>和<code>TEXT</code>。</li><li><code>压缩表</code>：MyISAM表可以转换为压缩表，以节省空间并提高读取效率，只能读取，不能插入。</li></ul><p class="note note-primary">读写互斥</p><ul><li><code>写操作锁定</code>：当执行写操作时，MyISAM 会锁定整个表。这意味着，在写操作完成之前，其他任何读或写操作都必须等待。</li><li><code>写锁优先级高于读锁</code>：在默认情况下，MyISAM倾向于优先赋予写操作锁。这意味着，如果读写操作同时到达，写操作将优先获得锁，这是为了防止写锁饥饿。</li></ul><p class="note note-primary">全文索引</p><p><code>不支持中文</code></p><p>MyISAM存储引擎支持全文索引（Full-Text Indexes），这是一种特别为文本搜索设计的索引类型。全文索引提供了一种比传统的<code>LIKE</code>查询更快、更高效的方式来搜索大量文本数据。</p><p><strong>特点</strong></p><ol><li><code>快速文本搜索</code>：全文索引允许对文本内容进行快速搜索，尤其是在处理大量数据时，它比<code>LIKE</code>模糊查询更高效。</li><li><code>支持复杂查询</code>：全文索引支持自然语言搜索、布尔搜索等复杂查询，能够处理词组、否定词等。</li><li><code>索引更新</code>：当表中的文本数据被插入、更新或删除时，全文索引会自动更新。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询最小和最大搜索长度<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%ft%&#x27;</span>;<br><br>ft_max_word_len <span class="hljs-number">84</span><br>ft_min_word_len <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><p><code>最小搜索长度</code> (ft_min_word_len)：这个变量定义了全文索引中词的最小长度。长度小于这个值的词将不会被包含在全文索引中。默认值通常是4。</p></li><li><p><code>最大搜索长度</code> (ft_max_word_len)：这个变量定义了索引中词的最大长度。长度超过这个值的词将不会被包含在全文索引中。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `my_isam` (<br>  `id` <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `email` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `address` <span class="hljs-type">varchar</span>(<span class="hljs-number">60</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> my_isam(name, age, email, address)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;test1&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;test1@test.com&#x27;</span>, <span class="hljs-string">&#x27;shenzhen&#x27;</span>),<br>       (<span class="hljs-string">&#x27;test2&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;test2@test.com&#x27;</span>, <span class="hljs-string">&#x27;beijing&#x27;</span>),<br>       (<span class="hljs-string">&#x27;test3&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;test3@test.com&#x27;</span>, <span class="hljs-string">&#x27;shanghai&#x27;</span>),<br>       (<span class="hljs-string">&#x27;test4&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;test4@test.com&#x27;</span>, <span class="hljs-string">&#x27;shandong&#x27;</span>),<br>       (<span class="hljs-string">&#x27;test5&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;test5@test.com&#x27;</span>, <span class="hljs-string">&#x27;hunan&#x27;</span>),<br>       (<span class="hljs-string">&#x27;test6&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;test6@test.com&#x27;</span>, <span class="hljs-string">&#x27;changsha&#x27;</span>);<br><br># 全文索引<br><span class="hljs-keyword">create</span> fulltext index idx_full <span class="hljs-keyword">on</span> my_isam(address)<br></code></pre></td></tr></table></figure><p class="note note-primary">自然语言全文索引</p><p>默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行<code>自然语言搜索</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">match</span> 可以多个字段，类似es的搜索<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> my_isam<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(address) against(<span class="hljs-string">&#x27;shen&#x27;</span>)<br><br>shen zhen<br></code></pre></td></tr></table></figure><p class="note note-primary">布尔全文索引</p><p>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索</p><ul><li><strong>+</strong> 必须包含该词</li><li><strong>-</strong> 必须不包含该词</li><li><strong>&gt;</strong> 提高该词的相关性，查询的结果靠前</li><li><strong>&lt;</strong> 降低该词的相关性，查询的结果靠后</li><li><strong>(*)星号</strong> 通配符，只能接在词后面</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> my_isam<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">match</span>(address) against(<span class="hljs-string">&#x27;sh*&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-type">boolean</span> mode)<br><br>shan dong<br>shang hai<br>shen zhen<br></code></pre></td></tr></table></figure><h3 id="innodb"><a class="markdownIt-Anchor" href="#innodb"></a> InnoDB</h3><p><code>事务</code> <code>行锁</code> <code>间隙锁</code> <code>外键</code> <code>MVCC</code> <code>自动生成hash索引</code></p><p>从MySQL 5.5版本开始，InnoDB成为默认的存储引擎。InnoDB提供全面的 <code>ACID</code> 事务支持，是MySQL中实现这一关键数据库特性的首要存储引擎之一。此外，InnoDB支持 <code>行级锁定</code>（Row-level Locking）和 <code>多版本并发控制</code>（MVCC），这两种机制共同提高了数据库在高并发环境下的读写性能和一致性。</p><p class="note note-primary">特性</p><ul><li><p><code>ACID兼容事务</code>：InnoDB提供完整的 <code>ACID</code> 事务支持。这意味着它可以保证即使在系统崩溃或宕机的情况下，数据库操作也能保持一致性和完整性。</p></li><li><p><code>行级锁定</code>：行级锁定允许数据库在执行事务时只锁定影响的数据行，而不是整个表，这显著提高了多用户环境中的并发性能。</p></li><li><p><code>MVCC</code>：MVCC支持高效的读写分离，减少了读写操作之间的冲突（快照读和当前写）。</p></li><li><p><code>外键约束</code>：InnoDB支持外键约束，这有助于维护不同表之间的参照完整性，自动处理相关表的更新和删除操作。</p></li><li><p><code>崩溃恢复</code>：通过使用redo log（重做日志）和undo log（回滚日志），InnoDB能够在系统崩溃后恢复到一致状态，保证数据不丢失。</p></li><li><p><code>聚簇索引</code>：InnoDB使用聚簇索引，将数据行直接存储在主键索引的叶节点中。这种方式可以加快主键查询的速度和便于范围查找。</p></li></ul><div class="note note-warning"><p><strong>ACID</strong></p><ul><li><code>Atomicity（原子性）</code><ul><li><strong>含义</strong>：原子性确保事务中的所有操作要么全部完成，要么全部不执行。事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败回滚。</li><li><strong>例子</strong>：在银行系统中，从一个账户转账到另一个账户涉及两个操作：从第一个账户扣款和向第二个账户存款。这两个操作必须同时成功或同时失败。</li></ul></li><li><code>Consistency（一致性）</code><ul><li><strong>含义</strong>：一致性确保事务从一个一致的状态转变到另一个一致的状态。一致状态的定义是基于业务规则，确保数据库的数据和结构在事务前后都保持一致。</li><li><strong>例子</strong>：继续上面的银行转账例子，一致性确保在转账过程中账户的总额保持不变。</li></ul></li><li><code>Isolation（隔离性）</code><ul><li><strong>含义</strong>：隔离性确保并发事务的执行彼此独立，事务之间不会互相影响。这意味着事务对数据的修改在提交之前，对其他事务是不可见的。</li><li><strong>例子</strong>：当两个银行客户同时检查同一个账户余额时，他们看到的应该是不受对方事务影响的稳定视图。</li></ul></li><li><code>Durability（持久性）</code><ul><li><strong>含义</strong>：持久性确保一旦事务提交，它对数据库的更改就是永久性的。即使发生系统故障，事务的结果也不会丢失。</li><li><strong>例子</strong>：在银行转账事务提交后，即使系统崩溃，转账的结果（资金的移动）也会被永久保存。</li></ul></li></ul></div><p class="note note-primary">存储文件类型</p><ul><li><p><code>.frm</code> ：用于存储表的结构信息，包括表的定义，如字段名称、类型、大小等。</p></li><li><p><code>.ibd</code>：是一个完整的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A1%A8%E7%A9%BA%E9%97%B4&amp;spm=1001.2101.3001.7020">表空间</a>文件，其中最基本的单位为页(Page)，一个Page通常为16k(存放聚簇索引)。</p></li><li><p><code>redo log（重做日志）</code>：通常为<code>.ib_logfile0</code>和<code>.ib_logfile1</code>，这些文件用于记录事务操作，以便在数据库崩溃后进行数据恢复。</p></li><li><p><code>undo log（回滚日志）</code>：记录了数据的旧版本，用于回滚事务和MVCC。</p></li><li><p>表空间</p><ul><li>inodb_data_file_path：用于定义InnoDB共享表空间文件的名称和大小，例如<code>innodb_data_file_path=ibdata1:10M:autoextend</code></li><li>innodb_data_home_dir：定义了InnoDB表空间文件的默认位置。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_file_per_table&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>文件-per-table 模式</strong>：当<code>innodb_file_per_table</code>被设置为<code>ON</code>（或<code>1</code>），InnoDB为每个新创建的表单独创建一个<code>.ibd</code>文件。这个文件包含了该表的数据和索引。</li><li><strong>共享表空间</strong>：如果<code>innodb_file_per_table</code>被设置为<code>OFF</code>（或<code>0</code>），所有的InnoDB表都会共享一个大的表空间文件（通常是<code>ibdata1</code>）。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">idb2sid xxx.idb<br></code></pre></td></tr></table></figure><p>通过以上命令可以查看ibd文件内容，以JSON形式输出</p><p><img src="/2022/02/26/Mysql/ibd.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">逻辑存储结构</p><p><img src="/2022/02/26/Mysql/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>InnoDB存储引擎在MySQL中使用一种 <code>层级化</code> 的方式来组织数据，这种结构包括表空间、段、区、页和行。下面是这些组件的详细解释：</p><ul><li><p><code>表空间（Tablespace）</code>: 表空间是InnoDB存储结构的最顶层，可以看作是存储数据的容器。它可以是单个文件（如在文件-per-table模式下的<code>.ibd</code>文件），也可以是共享的大文件（如<code>ibdata1</code>）。表空间包含 <code>数据</code>、<code>索引</code>、<code>插入缓冲区</code>、<code>undo log</code> 等数据结构。</p></li><li><p><code>段</code> （Segment）: 段是表空间内的一个逻辑部分，用于管理特定类型的数据。例如，数据段用于存储实际的表数据，索引段用于存储索引数据。每个段由多个区（Extent）组成。</p></li><li><p><code>区（Extent）</code> : 区是表空间的一个分配单元。在InnoDB中，一个区是一组连续的页，通常包含64个页。区的大小固定，由页的大小决定（默认为1MB，基于16KB大小的页）</p></li><li><p><code>页（Page）</code> : 页是InnoDB存储结构中的基本单元，也是磁盘I/O操作的最小单位。每个页默认为16KB大小。页按照不同的类型存储不同的信息，如数据页、索引页、undo页等。</p></li><li><p><code>行（Row）</code> : 行是InnoDB的最小数据单位。InnoDB是面向行的存储引擎，这意味着数据按行来组织和存储。每个数据页包含多个行记录。</p></li></ul><hr><p><strong>三大特性</strong></p><ul><li><a href="#change-buffer">插入缓冲（Change Buffer ）</a></li><li><a href="#%E5%8F%8C%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA">双写缓冲区（Double Write Buffer）</a></li><li><a href="#%E8%87%AA%E9%80%82%E5%BA%94hash%E7%B4%A2%E5%BC%95">自适应哈希索引（Adaptive Hash Index）</a></li></ul><h3 id="memory"><a class="markdownIt-Anchor" href="#memory"></a> MEMORY</h3><p><code>Hash索引</code> <code>字段定长</code> <code>表级锁</code> <code>不支持大字段</code> <code>数据存储内存，重启丢失</code></p><p>Memory存储引擎使用存在内存中的内容来创建表，每个Memory表只实际对应一个磁盘文件，在磁盘中表现为.frm文件。Memory类型的表访问速度非常快，因为它的数据是放在内存中的，并且默认使用hash索引，但是一旦服务关闭，表中的数据就会丢失。</p><p class="note note-primary">特性</p><ol><li><strong><code>基于内存的存储</code></strong>：MEMORY引擎将数据存储在内存中，提供快速的数据访问速度，尤其适用于需要高速读取的场景。</li><li><strong><code>数据易失性</code></strong>：MEMORY表的内容在数据库服务器重启后会丢失，因此主要用于临时数据，如缓存或会话信息。</li><li><strong><code>索引类型</code></strong>：<ul><li>支持 <code>HASH索引</code>，默认使用，适合快速的等值查询。</li><li>支持 <code>B+Tree索引</code>，适用于范围查询。</li></ul></li><li><strong><code>固定长度</code></strong>：MEMORY引擎中所有字段都被视为固定长度。例如，即使定义为<code>VARCHAR(10)</code>，也会像<code>CHAR(10)</code>一样处理，占用固定空间。</li><li><strong><code>不支持大型字段</code></strong>：不支持BLOB和TEXT类型的字段，因为这些类型的数据通常较大，不适合存储在内存中。</li><li><strong><code>表级锁</code></strong>：MEMORY引擎使用表级锁定机制，这可能在高并发写操作场景中成为性能瓶颈。</li><li><strong><code>表大小限制</code></strong>：表的最大大小由系统变量<code>max_heap_table_size</code>决定，默认值通常是16MB。这个限制只对新创建的表有效。</li></ol><h3 id="merge"><a class="markdownIt-Anchor" href="#merge"></a> MERGE</h3><p><code>MyISAM表组合</code></p><p>MERGE存储引擎提供了一种将多个相同结构的MyISAM表合并为一个虚拟表的机制。这种引擎对于处理大量数据或分区数据特别有用。</p><p class="note note-primary">特性</p><ol><li><code>组合多个表</code>：MERGE引擎允许多个具有相同表结构（即相同的列和索引）的MyISAM表被合并为一个单一的虚拟表。这些实际的表被称为子表，而合并后的表被称为MERGE表。</li><li><code>查询优化</code>：通过合并表，可以在一个查询中同时访问多个子表的数据，这对于执行大规模查询非常有效。</li><li><code>数据管理和维护</code>：MERGE表本身不存储数据，数据仍然存储在子表中。这意味着对子表的更新会直接反映在MERGE表上。</li><li><code>只读或可写</code>：默认情况下，MERGE表是只读的，但是如果所有子表都具有相同的结构，并且MERGE表被显式地声明为可写，则可以在MERGE表上执行插入、更新和删除操作。</li></ol><h1 id="数据库基础"><a class="markdownIt-Anchor" href="#数据库基础"></a> 数据库基础</h1><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><p>MySQL中的数据类型有很多，主要分为三类：<code>数值类型</code>、<code>字符串类型</code>、<code>日期时间类型</code>。</p><h3 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">范围（有符号）</th><th style="text-align:left">范围（无符号）</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>TINYINT</code></td><td style="text-align:left">1 Bytes</td><td style="text-align:left">(-128，127)</td><td style="text-align:left">(0，255)</td><td style="text-align:left">小整数值</td></tr><tr><td style="text-align:left"><code>SMALLINT</code></td><td style="text-align:left">2 Bytes</td><td style="text-align:left">(-32 768，32 767)</td><td style="text-align:left">(0，65 535)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left"><code>MEDIUMINT</code></td><td style="text-align:left">3 Bytes</td><td style="text-align:left">(-8 388 608，8 388 607)</td><td style="text-align:left">(0，16 777 215)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left"><code>INT</code>或<code>INTEGER</code></td><td style="text-align:left">4 Bytes</td><td style="text-align:left">(-2 147 483 648，2 147 483 647)</td><td style="text-align:left">(0，4 294 967 295)</td><td style="text-align:left">大整数值</td></tr><tr><td style="text-align:left"><code>BIGINT</code></td><td style="text-align:left">8 Bytes</td><td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:left">(0，18 446 744 073 709 551 615)</td><td style="text-align:left">极大整数值</td></tr><tr><td style="text-align:left"><code>FLOAT</code></td><td style="text-align:left">4 Bytes</td><td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align:left">单精度 浮点数值</td></tr><tr><td style="text-align:left"><code>DOUBLE</code></td><td style="text-align:left">8 Bytes</td><td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:left">双精度 浮点数值</td></tr><tr><td style="text-align:left"><code>DECIMAL</code></td><td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:left"><code>DECIMAL(M，D)</code>表示列可以存储<code>D</code>位小数的<code>M</code>位数，DECIMAL(8,4)表示能存储8位数，其中包含四位小数</td><td style="text-align:left">依赖于M和D的值</td><td style="text-align:left">小数值</td></tr></tbody></table><ul><li><p><strong>int(5)</strong>：对于 <code>int(5)</code> 这样的声明，数字5表示展示宽度，而不是最大值。展示宽度并不限制值的范围，而是影响值的显示格式。</p></li><li><p><strong>zerofill</strong>：当字段声明为 <code>ZEROFILL</code> 时，MySQL会用零填充展示值，以使其符合指定的展示宽度。例如，<code>INT(5) ZEROFILL</code>会将数值123格式化为00123。</p></li><li><p><strong>无符号UNSIGNED</strong>：<code>UNSIGNED</code> 属性用于指定整数类型为无符号。无符号整数只能存储正数和零。例如，<code>INT UNSIGNED</code>的范围是0到4294967295。</p></li></ul><h3 id="日期时间类型"><a class="markdownIt-Anchor" href="#日期时间类型"></a> 日期时间类型</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小 ( bytes)</th><th style="text-align:left">范围</th><th style="text-align:left">格式</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>DATE</code></td><td style="text-align:left">3</td><td style="text-align:left">1000-01-01/9999-12-31</td><td style="text-align:left">YYYY-MM-DD</td><td style="text-align:left">日期值</td></tr><tr><td style="text-align:left"><code>TIME</code></td><td style="text-align:left">3</td><td style="text-align:left">‘-838:59:59’/‘838:59:59’</td><td style="text-align:left">HH:MM:SS</td><td style="text-align:left">时间值或持续时间</td></tr><tr><td style="text-align:left"><code>YEAR</code></td><td style="text-align:left">1</td><td style="text-align:left">1901/2155</td><td style="text-align:left">YYYY</td><td style="text-align:left">年份值</td></tr><tr><td style="text-align:left"><code>DATETIME</code></td><td style="text-align:left">8</td><td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td style="text-align:left">YYYY-MM-DD HH:MM:SS</td><td style="text-align:left">混合日期和时间值</td></tr><tr><td style="text-align:left"><code>TIMESTAMP</code></td><td style="text-align:left">4</td><td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align:left">YYYYMMDD HHMMSS</td><td style="text-align:left">混合日期和时间值，时间戳</td></tr></tbody></table><h3 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">大小</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>CHAR</code></td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">定长字符串</td></tr><tr><td style="text-align:left"><code>VARCHAR</code></td><td style="text-align:left">0-65535 bytes</td><td style="text-align:left">变长字符串</td></tr><tr><td style="text-align:left"><code>TINYBLOB</code></td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:left"><code>TINYTEXT</code></td><td style="text-align:left">0-255 bytes</td><td style="text-align:left">短文本字符串</td></tr><tr><td style="text-align:left"><code>BLOB</code></td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">二进制形式的长文本数据 <a target="_blank" rel="noopener" href="https://www.modb.pro/db/50038">数据空洞</a></td></tr><tr><td style="text-align:left"><code>TEXT</code></td><td style="text-align:left">0-65 535 bytes</td><td style="text-align:left">长文本数据 <a target="_blank" rel="noopener" href="https://www.modb.pro/db/50038">数据空洞</a></td></tr><tr><td style="text-align:left"><code>MEDIUMBLOB</code></td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:left"><code>MEDIUMTEXT</code></td><td style="text-align:left">0-16 777 215 bytes</td><td style="text-align:left">中等长度文本数据</td></tr><tr><td style="text-align:left"><code>LONGBLOB</code></td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">二进制形式的极大文本数据</td></tr><tr><td style="text-align:left"><code>LONGTEXT</code></td><td style="text-align:left">0-4 294 967 295 bytes</td><td style="text-align:left">极大文本数据</td></tr></tbody></table><ul><li><code>CHAR</code>：定长字符串，如果有空位则用空串补位，性能较好</li><li><code>VARCHAR</code>：性能较差，需要计算长度</li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><p>MySQL中的函数可以被理解为一组预定义的操作，这些操作封装了特定的逻辑或计算过程，使得用户可以在SQL查询中直接调用它们。这意味着用户无需编写复杂的代码来执行常见的数据库任务。函数在数据库中被设计为易于使用，并且是为了解决特定的业务或数据处理需求。</p><h3 id="数值函数"><a class="markdownIt-Anchor" href="#数值函数"></a> 数值函数</h3><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-abs.html">ABS</a></td><td style="text-align:left">返回数字的绝对值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-acos.html">ACOS</a></td><td style="text-align:left">返回数字的反余弦值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-asin.html">ASIN</a></td><td style="text-align:left">返回数字的反正弦值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-atan.html">ATAN</a></td><td style="text-align:left">返回一个或两个数字的反正切</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="http://www.begtut.com/sql/func-mysql-atan2.html">ATAN2</a></td><td style="text-align:left">返回两个数字的反正切</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-avg.html">AVG</a></td><td style="text-align:left">返回表达式的平均值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ceil.html">CEIL</a></td><td style="text-align:left">返回&gt; =到数字的最小整数值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ceiling.html">CEILING</a></td><td style="text-align:left">返回&gt; =到数字的最小整数值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-cos.html">COS</a></td><td style="text-align:left">返回数字的余弦值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-cot.html">COT</a></td><td style="text-align:left">返回数字的余切</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-count.html">COUNT</a></td><td style="text-align:left">返回select查询返回的记录数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-degrees.html">DEGREES</a></td><td style="text-align:left">将弧度值转换为度数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-div.html">DIV</a></td><td style="text-align:left">用于整数除法</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-exp.html">EXP</a></td><td style="text-align:left">返回e提升到指定数字的幂</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-floor.html">FLOOR</a></td><td style="text-align:left">返回&lt;=到数字的最大整数值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-greatest.html">GREATEST</a></td><td style="text-align:left">返回参数列表的最大值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-least.html">LEAST</a></td><td style="text-align:left">返回参数列表的最小值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ln.html">LN</a></td><td style="text-align:left">返回数字的自然对数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-log.html">LOG</a></td><td style="text-align:left">返回数字的自然对数，或数字的对数到指定的基数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-log10.html">LOG10</a></td><td style="text-align:left">返回数字的自然对数到10</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sqlfunc-mysql-log2.html">LOG2</a></td><td style="text-align:left">返回数字2的自然对数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-max.html">MAX</a></td><td style="text-align:left">返回一组值中的最大值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-min.html">MIN</a></td><td style="text-align:left">返回一组值中的最小值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-mod.html">MOD</a></td><td style="text-align:left">返回数字的余数除以另一个数字</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-pi.html">PI</a></td><td style="text-align:left">返回PI的值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-pow.html">POW</a></td><td style="text-align:left">返回被提升到另一个数的幂的数字的值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-power.html">POWER</a></td><td style="text-align:left">返回被提升到另一个数的幂的数字的值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-radians.html">RADIANS</a></td><td style="text-align:left">将度数值转换为弧度</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-rand.html">RAND</a></td><td style="text-align:left">返回一个随机数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-round.html">ROUND</a></td><td style="text-align:left">将数字舍入到指定的小数位数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-sign.html">SIGN</a></td><td style="text-align:left">返回数字的符号</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-sin.html">SIN</a></td><td style="text-align:left">返回数字的正弦值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-sqrt.html">SQRT</a></td><td style="text-align:left">返回数字的平方根</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-sum.html">SUM</a></td><td style="text-align:left">计算一组值的总和</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-tan.html">TAN</a></td><td style="text-align:left">返回数字的正切值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-truncate.html">TRUNCATE</a></td><td style="text-align:left">将数字截断为指定的小数位数</td></tr></tbody></table><h3 id="日期函数"><a class="markdownIt-Anchor" href="#日期函数"></a> 日期函数</h3><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-adddate.html">ADDDATE</a></td><td style="text-align:left">将时间/日期间隔添加到日期，然后返回日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-addtime.html">ADDTIME</a></td><td style="text-align:left">将时间间隔添加到时间/日期时间，然后返回时间/日期时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-curdate.html">CURDATE</a></td><td style="text-align:left">返回当前日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-current-date.html">CURRENT_DATE</a></td><td style="text-align:left">返回当前日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-current-time.html">CURRENT_TIME</a></td><td style="text-align:left">返回当前时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-current-timestamp.html">CURRENT_TIMESTAMP</a></td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-curtime.html">CURTIME</a></td><td style="text-align:left">返回当前时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-date.html">DATE</a></td><td style="text-align:left">从日期时间表达式中提取日期部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-datediff.html">DATEDIFF</a></td><td style="text-align:left">返回两个日期值之间的天数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-date-add.html">DATE_ADD</a></td><td style="text-align:left">将时间/日期间隔添加到日期，然后返回日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-date-format.html">DATE_FORMAT</a></td><td style="text-align:left">格式化日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-date-sub.html">DATE_SUB</a></td><td style="text-align:left">从日期中减去时间/日期间隔，然后返回日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-day.html">DAY</a></td><td style="text-align:left">返回给定日期的月中的某天</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-dayname.html">DAYNAME</a></td><td style="text-align:left">返回给定日期的工作日名称</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-dayofmonth.html">DAYOFMONTH</a></td><td style="text-align:left">返回给定日期的月中的某天</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-dayofweek.html">DAYOFWEEK</a></td><td style="text-align:left">返回给定日期的工作日索引</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-dayofyear.html">DAYOFYEAR</a></td><td style="text-align:left">返回给定日期的一年中的某一天</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-extract.html">EXTRACT</a></td><td style="text-align:left">从给定日期提取部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-from-days.html">FROM_DAYS</a></td><td style="text-align:left">从数字日期值返回日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-hour.html">HOUR</a></td><td style="text-align:left">返回给定日期的小时部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-last-day.html">LAST_DAY</a></td><td style="text-align:left">提取指定日期的月份的最后一天</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-localtime.html">LOCALTIME</a></td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-localtimestamp.html">LOCALTIMESTAMP</a></td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-makedate.html">MAKEDATE</a></td><td style="text-align:left">根据年份和天数值创建并返回日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-maketime.html">MAKETIME</a></td><td style="text-align:left">根据小时，分钟和秒值创建并返回时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-microsecond.html">MICROSECOND</a></td><td style="text-align:left">返回时间/日期时间的微秒部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-minute.html">MINUTE</a></td><td style="text-align:left">返回时间/日期时间的分钟部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-month.html">MONTH</a></td><td style="text-align:left">返回给定日期的月份部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-monthname.html">MONTHNAME</a></td><td style="text-align:left">返回给定日期的月份名称</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-now.html">NOW</a></td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-period-add.html">PERIOD_ADD</a></td><td style="text-align:left">在一段时间内添加指定的月数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-period-diff.html">PERIOD_DIFF</a></td><td style="text-align:left">返回两个句点之间的差异</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-quarter.html">QUARTER</a></td><td style="text-align:left">返回给定日期值的一年中的季度</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-second.html">SECOND</a></td><td style="text-align:left">返回时间/日期时间的秒部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-sec-to-time.html">SEC_TO_TIME</a></td><td style="text-align:left">返回基于指定秒数的时间值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-str-to-date.html">STR_TO_DATE</a></td><td style="text-align:left">返回基于字符串和格式的日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-subdate.html">SUBDATE</a></td><td style="text-align:left">从日期中减去时间/日期间隔，然后返回日期</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-subtime.html">SUBTIME</a></td><td style="text-align:left">从日期时间中减去时间间隔，然后返回时间/日期时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-sysdate.html">SYSDATE</a></td><td style="text-align:left">返回当前日期和时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-time.html">TIME</a></td><td style="text-align:left">从给定的时间/日期时间中提取时间部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-time-format.html">TIME_FORMAT</a></td><td style="text-align:left">按指定格式格式化时间</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-time-to-sec.html">TIME_TO_SEC</a></td><td style="text-align:left">将时间值转换为秒</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-timediff.html">TIMEDIFF</a></td><td style="text-align:left">返回两个时间/日期时间表达式之间的差异</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-timestamp.html">TIMESTAMP</a></td><td style="text-align:left">返回基于日期或日期时间值的日期时间值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-to-days.html">TO_DAYS</a></td><td style="text-align:left">返回日期和日期“0000-00-00”之间的天数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-week.html">WEEK</a></td><td style="text-align:left">返回给定日期的周数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-weekday.html">WEEKDAY</a></td><td style="text-align:left">返回给定日期的工作日编号</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-weekofyear.html">WEEKOFYEAR</a></td><td style="text-align:left">返回给定日期的周数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-year.html">YEAR</a></td><td style="text-align:left">返回给定日期的年份部分</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-yearweek.html">YEARWEEK</a></td><td style="text-align:left">返回给定日期的年和周数</td></tr></tbody></table><h3 id="字符串函数"><a class="markdownIt-Anchor" href="#字符串函数"></a> 字符串函数</h3><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ascii.html">ASCII</a></td><td style="text-align:left">返回特定字符的ASCII值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-char-length.html">CHAR_LENGTH</a></td><td style="text-align:left">返回字符串的长度（以字符为单位）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-character-length.html">CHARACTER_LENGTH</a></td><td style="text-align:left">返回字符串的长度（以字符为单位）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-concat.html">CONCAT</a></td><td style="text-align:left">一起添加两个或多个表达式</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-concat-ws.html">CONCAT_WS</a></td><td style="text-align:left">将两个或多个表达式与分隔符一起添加</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-field.html">FIELD</a></td><td style="text-align:left">返回值列表中值的索引位置</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="http://www.begtut.com/sql/func-mysql-find-in-set.html">FIND_IN_SET</a></td><td style="text-align:left">返回字符串列表中字符串的位置</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-format.html">FORMAT</a></td><td style="text-align:left">将数字格式化为“＃，###，###。##”等格式，舍入到指定的小数位数</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-insert.html">INSERT</a></td><td style="text-align:left">在指定位置的字符串中插入一个字符串，并插入一定数量的字符</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-instr.html">INSTR</a></td><td style="text-align:left">返回第一次出现在另一个字符串中的字符串的位置</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-lcase.html">LCASE</a></td><td style="text-align:left">将字符串转换为小写</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-left.html">LEFT</a></td><td style="text-align:left">从字符串中提取多个字符（从左开始）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-length.html">LENGTH</a></td><td style="text-align:left">返回字符串的长度（以字节为单位）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-locate.html">LOCATE</a></td><td style="text-align:left">返回字符串中第一次出现子字符串的位置</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-lower.html">LOWER</a></td><td style="text-align:left">将字符串转换为小写</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-lpad.html">LPAD</a></td><td style="text-align:left">左边用另一个字符串填充一个字符串到一定长度</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ltrim.html">LTRIM</a></td><td style="text-align:left">从字符串中删除前导空格</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-mid.html">MID</a></td><td style="text-align:left">从字符串中提取子字符串（从任何位置开始）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-position.html">POSITION</a></td><td style="text-align:left">返回字符串中第一次出现子字符串的位置</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-repeat.html">REPEAT</a></td><td style="text-align:left">按指定的次数重复一次字符串</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-replace.html">REPLACE</a></td><td style="text-align:left">使用新的子字符串替换字符串中所有出现的子字符串</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-reverse.html">REVERSE</a></td><td style="text-align:left">反转字符串并返回结果</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-right.html">RIGHT</a></td><td style="text-align:left">从字符串中提取多个字符（从右侧开始）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-rpad.html">RPAD</a></td><td style="text-align:left">右边用另一个字符串填充一个字符串到一定长度</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-rtrim.html">RTRIM</a></td><td style="text-align:left">从字符串中删除尾随空格</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-space.html">SPACE</a></td><td style="text-align:left">返回指定数量的空格字符的字符串</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-strcmp.html">STRCMP</a></td><td style="text-align:left">比较两个字符串</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-substr.html">SUBSTR</a></td><td style="text-align:left">从字符串中提取子字符串（从任何位置开始）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-substring.html">SUBSTRING</a></td><td style="text-align:left">从字符串中提取子字符串（从任何位置开始）</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-substring-index.html">SUBSTRING_INDEX</a></td><td style="text-align:left">在指定数量的分隔符出现之前返回字符串的子字符串</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-trim.html">TRIM</a></td><td style="text-align:left">从字符串中删除前导和尾随空格</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ucase.html">UCASE</a></td><td style="text-align:left">将字符串转换为大写</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-upper.html">UPPER</a></td><td style="text-align:left">将字符串转换为大写</td></tr></tbody></table><h3 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>COUNT()</td><td>没有数据时默认值是0</td></tr><tr><td>SUN()</td><td>没有数据时，默认值是null</td></tr><tr><td>MAX()</td><td>求最大值</td></tr><tr><td>MIN()</td><td>求最小值</td></tr><tr><td>AVG()</td><td>求平均值</td></tr><tr><td>GROUP_CONCAT()</td><td>这个函数把来自同一个组的某一列（或者多列）的数据连接起来成为一个字符串(逗号分隔)</td></tr><tr><td>JSON_ARRAYAGG()</td><td>select json_arrayagg(degree) from score group by cno<br>将结果集聚合为单个JSON数组</td></tr><tr><td>JSON_OBJECTAGG(key,value)</td><td>select JSON_OBJECTAGG(sno, degree) from score group by sno<br>第一个用作键，第二个用作值，并返回包含键值对的JSON对象</td></tr><tr><td>HAVING</td><td>对分组后的结果再进行条件过滤</td></tr><tr><td>WITH ROLLUP</td><td>select cno, count(0) from score group by cno with rollup<br>对分类聚合后的结果再汇总，再结果追加一条所有汇总数据,(count(0) 再汇总)</td></tr></tbody></table><h3 id="流程函数"><a class="markdownIt-Anchor" href="#流程函数"></a> 流程函数</h3><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-if.html">IF</a></td><td style="text-align:left">如果条件为TRUE则返回值，如果条件为FALSE则返回另一个值</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-ifnull.html">IFNULL</a></td><td style="text-align:left">如果表达式为NULL，则返回指定的值，否则返回表达式</td></tr></tbody></table><h3 id="其他常用函数"><a class="markdownIt-Anchor" href="#其他常用函数"></a> 其他常用函数</h3><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-database.html">DATABASE</a></td><td style="text-align:left">返回当前数据库的名称</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-version.html">VERSION</a></td><td style="text-align:left">返回MySQL数据库的当前版本</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.begtut.com/sql/func-mysql-user.html">USER</a></td><td style="text-align:left">返回当前的MySQL用户名和主机名</td></tr><tr><td style="text-align:left">UUID</td><td style="text-align:left">生成UUID</td></tr><tr><td style="text-align:left">MD5</td><td style="text-align:left">MD5加密</td></tr></tbody></table><h3 id="case-语法"><a class="markdownIt-Anchor" href="#case-语法"></a> CASE 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CASE</span><br>    <span class="hljs-keyword">WHEN</span> condition1 <span class="hljs-keyword">THEN</span> result1<br>    <span class="hljs-keyword">WHEN</span> condition2 <span class="hljs-keyword">THEN</span> result2<br>    <span class="hljs-keyword">WHEN</span> conditionN <span class="hljs-keyword">THEN</span> resultN<br>    <span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">END</span>; <br></code></pre></td></tr></table></figure><p>CASE第一种用法，指定字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">CASE</span> site<br><span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;MX&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;墨西哥&#x27;</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;ES&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;西班牙&#x27;</span><br><span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;US&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;美国&#x27;</span><br><span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;其他&#x27;</span> <span class="hljs-keyword">END</span><br><span class="hljs-keyword">from</span> site<br></code></pre></td></tr></table></figure><p>CASE第二种用法，满足条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">CASE</span><br><span class="hljs-keyword">WHEN</span> site_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;墨西哥&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;MX&#x27;</span><br><span class="hljs-keyword">WHEN</span> site_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;西班牙&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;ES&#x27;</span><br><span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;其他&#x27;</span> <span class="hljs-keyword">END</span><br><span class="hljs-keyword">from</span> site<br></code></pre></td></tr></table></figure><h2 id="sql语句优先级"><a class="markdownIt-Anchor" href="#sql语句优先级"></a> SQL语句优先级</h2><ol><li><code>from</code></li><li><code>join</code></li><li><code>on</code></li><li><code>where</code></li><li><code>group by</code></li><li><code>with rollup</code></li><li><code>having</code></li><li><code>select</code></li><li><code>distinct</code></li><li><code>order by</code></li><li><code>limit</code></li></ol><div class="note note-warning"><p><strong>WITH ROLLUP</strong></p><p><code>WITH ROLLUP</code> 用于在 <code>GROUP BY</code> 操作中生成额外的汇总行，它不仅返回常规的分组聚合结果，<span class="green-line">还会为每个分组级别以及总计提供聚合数据</span>。使用<code>WITH ROLLUP</code>可以方便地获取数据的层级汇总，从而避免编写额外的查询来获取这些汇总信息。</p><p><img src="/2022/02/26/Mysql/withrollup.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>WITH … AS …</strong></p><p><span class="green-line">如果一整句查询中多个子查询都需要使用同一个子查询的结果，那么就可以用<code>with as</code>，将共用的子查询提取出来，加个别名。</span>后面查询语句可以直接用，对于大量复杂的SQL语句起到了很好的优化作用</p><p>注意：</p><ul><li>相当于一个临时表，但是不同于视图，不会存储起来，要与select配合使用。</li><li>同一个select前可以有多个临时表，写一个with就可以，用逗号隔开，最后一个with语句不要用逗号。</li><li>with子句要用括号括起来。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看 <span class="hljs-number">3</span><span class="hljs-number">-105</span> 课程的最高分和最低分<br><span class="hljs-keyword">with</span> score_temp <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;3-105&#x27;</span>)<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(degree) <span class="hljs-keyword">as</span> degree <span class="hljs-keyword">from</span> score_temp<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(degree) <span class="hljs-keyword">as</span> degree <span class="hljs-keyword">from</span> score_temp<br></code></pre></td></tr></table></figure></div><h2 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h2><p>约束（CONSTRAINT ）是数据库表中字段上应用的规则，用于确保数据库表中数据的有效性和完整性。</p><table><thead><tr><th>约束类型</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>确保字段中的值不能为NULL，即字段必须有值。</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证表中一个字段或字段组合的值是唯一的，防止重复记<br>录的产生。</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>同时具备非空和唯一性约束，用于唯一标识表中的每条记录。</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>为字段指定一个默认值，如果插入记录时未提供值，则使<br>用此默认值。</td><td>DEFAULT</td></tr><tr><td>检查约束</td><td>确保字段值必须满足特定的条件，只有满足条件的值才被<br>允许插入或更新。</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用于在两个表之间建立关联，确保一个表中的数据引用另<br>一个表中的数据，从而维护跨表的数据完整性。</td><td>FOREIGN KEY</td></tr></tbody></table><div class="note note-warning"><p><strong>检查约束</strong></p><p><em>检查约束在MySQL中直到8.0.16版本才被完全支持。</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> age_check <span class="hljs-keyword">CHECK</span> (age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>添加一个检查约束，年龄只能在[18,30]之间。</p></div><h2 id="ddl"><a class="markdownIt-Anchor" href="#ddl"></a> DDL</h2><p>DDL（Data Definition Language，数据定义语言）是SQL语言中用于定义和修改数据库结构的一部分。DDL主要包括用于创建、修改、删除 <code>数据库</code>、<code>表</code>、<code>索引</code> 等数据库对象的命令。</p><div class="note note-warning"><p><strong>数据库操作</strong></p><ul><li><p>查询所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure></li><li><p>查询当前数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> database();<br></code></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-keyword">create</span> database [ if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> ] 数据库名 [ <span class="hljs-keyword">default</span> charset 字符集 ] [ <span class="hljs-keyword">collate</span> 排序规则 ];<br># 排序规则决定了字符串之间如何比较<br># 排序规则影响<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>子句的结果<br># 使用默认的utf8_general_ci，不区分大小写<br># 若要区分大小写，需要修改为utf8_bin<br><br><span class="hljs-keyword">create</span> database test_db <span class="hljs-keyword">default</span> charset utf8mb4_general_ci;<br></code></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database [ if <span class="hljs-keyword">exists</span> ] 数据库名;<br></code></pre></td></tr></table></figure></li><li><p>切换数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">use 数据库名;<br></code></pre></td></tr></table></figure></li></ul></div><div class="note note-warning"><p><strong>表操作</strong></p><ul><li><p>查询当前数据库所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> tables;<br></code></pre></td></tr></table></figure></li><li><p>查看指定表结构</p><p>通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> 表名;<br></code></pre></td></tr></table></figure></li><li><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名;<br></code></pre></td></tr></table></figure></li><li><p>创建表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [ COMMENT 字段<span class="hljs-number">1</span>注释 ],<br>    ...<br>    ) [ COMMENT 表注释 ];<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br>    id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    gender <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>) comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">TO</span> 新表名;<br></code></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [ IF <span class="hljs-keyword">EXISTS</span> ] 表名;<br></code></pre></td></tr></table></figure></li><li><p>删除指定表, 并重新创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><p><code>TRUNCATE TABLE</code> 命令用于快速删除表中的所有行，同时保留表结构。这个命令相比于使用 <code>DELETE</code> 命令删除所有行更为高效，特别是在处理大型表时。</p><p>和 <code>DELETE</code> 比较：</p><ul><li><strong>性能</strong>：对于大型表，<code>TRUNCATE TABLE</code> 比 <code>DELETE</code> 快。</li><li><strong>事务和日志</strong>：<code>DELETE</code> 是事务安全的，可以回滚；而 <code>TRUNCATE TABLE</code> 不是事务安全的，不能针对单个行操作进行回滚。</li><li><strong>自增计数器</strong>：<code>DELETE</code> 不会重置自增计数器，而 <code>TRUNCATE TABLE</code> 会。</li></ul></li></ul></div><div class="note note-warning"><p><strong>字段操作</strong></p><ul><li><p>添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">ADD</span> nickname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>修改字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型 (长度);<br></code></pre></td></tr></table></figure></li><li><p>修改字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp CHANGE nickname username <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">DROP</span> username;<br></code></pre></td></tr></table></figure></li></ul></div><h2 id="dml"><a class="markdownIt-Anchor" href="#dml"></a> DML</h2><p>DML（Data Manipulation Language，数据操纵语言）是SQL（Structured Query Language，结构化查询语言）的一部分，用于修改数据。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE）</li><li>删除数据（DELETE）</li></ul><p><strong>隐式事务：</strong></p><ul><li><strong><code>默认行为</code></strong>：在InnoDB存储引擎中，默认情况下，事务是隐式的。这意味着当执行一个 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 操作时，如果当前没有活跃的事务，则MySQL自动为这个操作开始一个新的事务。</li><li><strong><code>自动提交</code></strong>：每个独立的SQL语句都被视为一个事务。除非手动开始一个新的事务，否则执行完这些语句后，事务会自动提交。</li><li><strong><code>自动回滚</code></strong>：如果在执行过程中遇到错误，事务可能会被自动回滚。</li></ul><div class="note note-warning"><p><strong>添加数据</strong></p><ul><li><p>给指定字段添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure></li><li><p>给表所有的字段添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure></li><li><p>批量添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 (字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>, ...) <span class="hljs-keyword">VALUES</span> <br>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...), <br>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...),<br>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span> <br>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...),<br>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...),<br>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>, ...);<br></code></pre></td></tr></table></figure></li><li><p>查询添加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table2<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table1;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table2(field1,field2,...) <br><span class="hljs-keyword">SELECT</span> field1,field2,... <span class="hljs-keyword">FROM</span> table1 ...<br></code></pre></td></tr></table></figure></li></ul></div><div class="note note-warning"><p><strong>修改数据</strong></p><ul><li><p>修改数据的具体语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2, ...<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure></li><li><p>联表修改</p><p>联表操作不建议使用，<code>A join B</code> <code>B join A</code> 会产生死锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> course c <span class="hljs-keyword">join</span> teacher t <span class="hljs-keyword">on</span> (c.tno <span class="hljs-operator">=</span> t.tno)<br><span class="hljs-keyword">set</span> c.cname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;计算机导论&#x27;</span><br><span class="hljs-keyword">where</span> t.tname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;王萍&#x27;</span><br></code></pre></td></tr></table></figure></li></ul></div><div class="note note-warning"><p><strong>删除数据</strong></p><ul><li><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure></li><li><p>联表删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> t # 定义起作用的表<br><span class="hljs-keyword">from</span> teacher t <span class="hljs-keyword">join</span> course c <span class="hljs-keyword">on</span> (t.tno <span class="hljs-operator">=</span> c.tno)<br><span class="hljs-keyword">where</span> c.cname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;JAVA&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul></div><h2 id="dql"><a class="markdownIt-Anchor" href="#dql"></a> DQL</h2><p>DQL（Data Query Language，数据查询语言）是SQL（Structured Query Language，结构化查询语言）的一个组成部分，专门用于查询数据库中的数据。在实际应用中，DQL基本上是由<code>SELECT</code>语句组成的，它允许用户从数据库中检索数据，而不会对数据本身进行任何修改。</p><p>查询关键字: <code>SELECT</code></p><div class="note note-warning"><p><strong>基本语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>	字段列表<br><span class="hljs-keyword">FROM</span><br>	表名列表<br><span class="hljs-keyword">WHERE</span><br>	条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>	分组字段列表<br><span class="hljs-keyword">HAVING</span><br>	分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>	排序字段列表<br>LIMIT<br>	分页参数<br></code></pre></td></tr></table></figure></div><div class="note note-warning"><p><strong>基础查询</strong></p><p>在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：</p><ul><li><p>查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, 字段<span class="hljs-number">3</span> ... <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名 ;<br></code></pre></td></tr></table></figure></li><li><p>字段设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [ <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">1</span> ] , 字段<span class="hljs-number">2</span> [ <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">2</span> ] ... <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [ 别名<span class="hljs-number">1</span> ] , 字段<span class="hljs-number">2</span> [ 别名<span class="hljs-number">2</span> ] ... <span class="hljs-keyword">FROM</span> 表名; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>去除重复记录</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure></li></ul></div><div class="note note-warning"><p><strong>条件查询</strong></p><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 字段<span class="hljs-number">1</span> [条件<span class="hljs-number">1</span>] [查询条件<span class="hljs-number">1</span>] [逻辑运算符] 字段<span class="hljs-number">2</span> [条件<span class="hljs-number">2</span>] [查询条件<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure></li><li><p>条件</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围之内，区间 [min, max]</td></tr><tr><td>IN(…)</td><td>多值查询</td></tr><tr><td>LIKE 占位符</td><td>模糊查询</td></tr><tr><td>IS NULL</td><td>判空查询</td></tr></tbody></table></li><li><p>常用的逻辑运算符</p><table><thead><tr><th><strong>逻辑运算符</strong></th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且 (多个条件同时成立)</td></tr><tr><td>OR 或</td><td>或者 (多个条件任意一个成立)</td></tr><tr><td>NOT 或 !</td><td>非 , 不是</td></tr></tbody></table></li></ul></div><div class="note note-warning"><p><strong>聚合查询</strong></p><p>使用 <a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a> 将一列数据作为一个整体，进行纵向计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数(字段列表) <span class="hljs-keyword">FROM</span> 表名 ;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure></div><div class="note note-warning"><p><strong>分组查询</strong></p><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 [ <span class="hljs-keyword">WHERE</span> 条件 ] <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段名 [ <span class="hljs-keyword">HAVING</span> 分组后过滤条件 ];<br></code></pre></td></tr></table></figure></li><li><p>where 与 having 区别</p><ul><li><code>执行时机不同</code><ul><li>where是分组之前进行过滤，不满足where条件，不参与分组</li><li>having是分组之后对结果进行过滤</li></ul></li><li><code>判断条件不同</code><ul><li>where不能对聚合函数进行判断</li><li>而having可以对聚合函数进行判断</li></ul></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询<span class="hljs-number">45</span>元以下商品价位的总数，不展示少于<span class="hljs-number">3</span>款产品的价位<br><span class="hljs-keyword">select</span> price, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) price_count <br><span class="hljs-keyword">from</span> product <br><span class="hljs-keyword">where</span> price <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> price <br><span class="hljs-keyword">having</span> price_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项</p><p>• 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</p><p>• 执行顺序: where &gt; 聚合函数 &gt; having</p><p>• 支持多字段分组, 具体语法为 : group by columnA，columnB</p></blockquote></div><div class="note note-warning"><p><strong>排序查询</strong></p><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span> , 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>排序方式</p><ul><li>ASC ：升序（默认值，可缺省）</li><li>DESC：降序</li><li>Rand()：随机排序</li></ul></li></ul></div><div class="note note-warning"><p><strong>分页查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 LIMIT [<span class="hljs-keyword">offset</span>, <span class="hljs-keyword">rows</span>];<br></code></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ul><li>offset：数据的偏移量，（查询页码 - 1）* 每页显示记录数</li><li>rows：要从偏移量开始取多少条数据</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10</li></ul></blockquote></div><h2 id="dcl"><a class="markdownIt-Anchor" href="#dcl"></a> DCL</h2><p>DCL（Data Control Language，数据控制语言）主要用于管理数据库中的访问权限和安全性。DCL包括一系列的命令，允许数据库管理员控制用户对数据库对象的访问权限。</p><p>查询用户</p><p><img src="/2022/02/26/Mysql/%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.user;<br></code></pre></td></tr></table></figure><p><code>Host</code>列代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。</p><div class="note note-warning"><p><strong>用户操作</strong></p><p>在MySQL中需要通过<code>用户名@主机名</code>的方式，来唯一标识一个用户</p><p>主机名可以使用 % 通配</p><ul><li><p>创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建用户admin, 可以在任意主机访问该数据库, 密码<span class="hljs-number">123456</span>;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;admin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>修改用户密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> ;<br></code></pre></td></tr></table></figure></li></ul></div><div class="note note-warning"><p><strong>权限控制</strong></p><p>MySQL中定义了很多种权限，但是常用的就以下几种：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html">官方文档</a></p><ul><li><p>查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> grants <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;admin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> itcast.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;admin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>撤销权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> itcast.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;admin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul><p>多个权限之间，使用逗号分隔</p><p>授权时， 数据库名和表名可以使用 * 进行通配，代表所有</p></div><h2 id="tcl"><a class="markdownIt-Anchor" href="#tcl"></a> TCL</h2><div class="note note-warning"><p>TCL（Transaction Control Language，事务控制语言）用于管理数据库中的事务。</p><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span>;<br></code></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure></li></ul></div><h2 id="多表查询"><a class="markdownIt-Anchor" href="#多表查询"></a> 多表查询</h2><p>多表查询是SQL中的一项关键技术，它允许从两个或多个表中组合数据。这种查询通常通过在这些表之间的共同字段上建立关联来实现。通过多表查询，可以获得跨表的综合视图。</p><p>在数据库设计中，表与表之间的关系大致分为三种：</p><ol><li><p><strong><code>一对一</code></strong></p><ul><li><code>描述</code>：每个表中的一行与另一个表中的一行相关联。</li><li><code>实现</code>：通常通过在一个表中包含另一个表的主键作为外键来实现。</li><li><code>示例</code>：用户表和用户详细信息表，其中每个用户只有一组详细信息。</li></ul></li><li><p><strong><code>一对多</code></strong></p><ul><li><code>描述</code>：一个表中的一行与另一个表中的多行相关联。</li><li><code>实现</code>：在“多”的一方表中包含“一”的一方表的主键作为外键。</li><li><code>示例</code>：客户表和订单表，其中一个客户可以有多个订单，但每个订单只能属于一个客户。</li></ul></li><li><p><strong><code>多对多</code></strong></p><ul><li><code>描述</code>：一个表中的多行与另一个表中的多行相关联。</li><li><code>实现</code>：通常通过一个单独的关联表（或桥接表）实现，该表包含两个表的主键作为外键。</li><li><code>示例</code>：学生表和课程表，其中一个学生可以参加多个课程，一个课程可以有多个学生参加。</li></ul></li></ol><p class="note note-primary">笛卡尔积</p><p><img src="/2022/02/26/Mysql/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>定义</code>：当两个表进行交叉连接（CROSS JOIN）时，产生的结果集是这两个表的笛卡尔积。这意味着结果集中的每一行是由第一个表中的一行和第二个表中的一行组合而成的。</li><li><code>行为</code>：如果表A有M行，表B有N行，它们的笛卡尔积将包含M×N个结果。</li></ul><h3 id="内连接"><a class="markdownIt-Anchor" href="#内连接"></a> 内连接</h3><p><img src="/2022/02/26/Mysql/%E5%86%85%E8%BF%9E%E6%8E%A5.png" srcset="/img/loading.gif" lazyload alt="内连接查询的是两张表交集部分的数据"></p><p>内连接用于从两个或多个表中选择符合连接条件的记录。内连接仅返回两个表中关联键匹配的行。如果在一个表中的行在另一个表中没有匹配的行，则这些行不会出现在查询结果中。</p><ul><li><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件 ... ;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.name , dept.name <span class="hljs-keyword">from</span> emp , dept <span class="hljs-keyword">where</span> emp.dept_id <span class="hljs-operator">=</span> dept.id ;<br></code></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [ <span class="hljs-keyword">INNER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件 ... ;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> (e.dept_id <span class="hljs-operator">=</span> d.id);<br></code></pre></td></tr></table></figure></li></ul><h3 id="外连接"><a class="markdownIt-Anchor" href="#外连接"></a> 外连接</h3><p>外连接用于从两个表中检索数据，即使在另一个表中没有匹配的行也能返回结果。外连接可以是左连接（LEFT JOIN）或右连接（RIGHT JOIN）。</p><p><img src="/2022/02/26/Mysql/%E5%A4%96%E8%BF%9E%E6%8E%A5.png" srcset="/img/loading.gif" lazyload alt="外连接是以自我为中心的"></p><p class="note note-primary">左连接</p><p>左连接返回左表（<code>LEFT JOIN</code>左边的表）的所有行，以及右表中匹配的行。如果在右表中没有匹配的行，则结果中右表的部分将为NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><p class="note note-primary">右连接</p><p>右连接与左连接相反，返回右表的所有行，以及左表中匹配的行。如果在左表中没有匹配的行，则结果中左表的部分将为NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><h3 id="自连接"><a class="markdownIt-Anchor" href="#自连接"></a> 自连接</h3><p>自连接（Self Join）是一种特殊类型的连接，用于将一个表与自身进行连接。这在处理具有 <code>层级</code> 或 <code>递归</code> 关系的数据时特别有用，例如，当一个表中的记录引用了同一个表中的其他记录。自连接可以是内连接、左连接或右连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A 别名A <span class="hljs-keyword">JOIN</span> 表A 别名B <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><h3 id="on-和-where-的区别"><a class="markdownIt-Anchor" href="#on-和-where-的区别"></a> on 和 where 的区别</h3><ul><li>执行顺序<ul><li><code>ON</code> 子句在进行表的连接操作时先执行。</li><li><code>WHERE</code> 子句在 <code>JOIN</code> 操作之后执行。</li></ul></li><li>如果是 <code>内连接</code> 则条件放在 ON 和 WHERE 是一样的。</li><li><span class="green-line">如果是 <code>外链接</code> ON 过滤主表条件不成立，WHERE 过滤主表条件成立。</span></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> b <span class="hljs-keyword">on</span>(a.id<span class="hljs-operator">=</span>b.id <span class="hljs-keyword">and</span> a.id <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>)<br># 此时a.id <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span> 条件不成立<br></code></pre></td></tr></table></figure><h3 id="联合查询"><a class="markdownIt-Anchor" href="#联合查询"></a> 联合查询</h3><p>对于union查询，就是把多次查询的结果合组合起来，形成一个新的查询结果集，每个查询的列的数量、顺序、数据类型必须一致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A ...<br><span class="hljs-keyword">UNION</span> [ <span class="hljs-keyword">ALL</span> ]<br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表B ....;<br></code></pre></td></tr></table></figure><p class="note note-primary">UNION ALL</p><p><code>UNION ALL</code> 用于合并多个 <code>SELECT</code> 查询的结果集，但它包括所有重复的行。</p><p>假设 <code>student</code> 表有6个学生，直接合并结果集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sno<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> sno<br><span class="hljs-keyword">from</span> student<br># 返回<span class="hljs-number">12</span>条 sno, 每条重复<br></code></pre></td></tr></table></figure><p class="note note-primary">UNION</p><p><code>UNION</code> 用于合并多个 <code>SELECT</code> 查询的结果集，并且默认去除重复的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sno<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> sno<br><span class="hljs-keyword">from</span> student<br># 返回<span class="hljs-number">6</span>条 sno, 不重复<br></code></pre></td></tr></table></figure><h2 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h2><p>在 SQL 语句中，嵌套的 <code>SELECT</code> 语句称为子查询。子查询可以嵌入在 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句中。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 <span class="hljs-operator">=</span> ( <span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2 );<br></code></pre></td></tr></table></figure><p class="note note-primary">子查询分类</p><ul><li><strong><code>标量子查询</code></strong>：<ul><li>返回单个值的子查询。</li><li>通常用在条件表达式中，如 <code>WHERE</code> 子句或 <code>SELECT</code> 列表中。</li></ul></li><li><strong><code>列子查询</code></strong>：<ul><li>返回一列数据的子查询。</li><li>常用于 <code>IN</code> 或 <code>ANY/SOME</code> 子句中。</li></ul></li><li><strong><code>行子查询</code></strong>：<ul><li>返回一行数据的子查询。</li><li>可用于比较多个列，通常与行构造函数一起使用。</li></ul></li><li><strong><code>表子查询</code></strong>：<ul><li>返回多行多列的子查询。</li><li>常见于 <code>IN</code> 子句、<code>EXISTS</code> 子句或者作为 <code>FROM</code> 子句中的一个表。</li></ul></li></ul><p class="note note-primary">子查询位置</p><ul><li><strong><code>在 SELECT 之后</code></strong>：<ul><li>作为计算列的一部分，或者在 <code>SELECT</code> 列表中为列赋值。</li></ul></li><li><strong><code>在 FROM 之后</code></strong>：<ul><li>作为一个临时表使用，在主查询中用于联合、过滤或聚合。</li></ul></li><li><strong><code>在 WHERE 之后</code></strong>：<ul><li>作为条件筛选，与主查询表的数据进行比较或关联。</li></ul></li><li><strong><code>在 INSERT/UPDATE/DELETE 语句中</code></strong>：<ul><li>在 <code>INSERT INTO ... SELECT</code> 结构中用于提供要插入的数据。</li><li>在 <code>UPDATE ... SET column = (SELECT ...)</code> 结构中为列赋值。</li><li>在 <code>DELETE FROM ... WHERE column1 in (SELECT ...)</code> 结构中用于指定删除条件。</li></ul></li></ul><h3 id="标量子查询"><a class="markdownIt-Anchor" href="#标量子查询"></a> 标量子查询</h3><p>标量子查询在执行时返回单个值（即一个标量值）。这种子查询可以嵌入在更大的 SQL 查询中的多个位置，比如 <code>SELECT</code>、<code>WHERE</code> 或 <code>HAVING</code> 子句中。</p><p class="note note-primary">特性</p><ol><li>单值返回：<ul><li>标量子查询的主要特点是它只返回一个单一的值，而不是一列或多列的数据集。</li><li>如果子查询返回多于一个值，则 SQL 会报错。</li></ul></li><li>用途广泛：<ul><li>可以用在几乎任何需要单一值的地方，例如在 <code>SELECT</code> 列表中，或者作为 <code>WHERE</code> 或 <code>HAVING</code> 子句中的条件。</li></ul></li><li>与主查询的关系：<ul><li>可以独立于主查询执行，也可以引用主查询中的数据。</li></ul></li></ol><p class="note note-primary">用法</p><p>独立执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>);<br></code></pre></td></tr></table></figure><p>引用主查询中的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    e.name, <br>    e.salary, <br>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> e.department_id) <span class="hljs-keyword">AS</span> avg_department_salary<br><span class="hljs-keyword">FROM</span> <br>    employees e;<br></code></pre></td></tr></table></figure><h3 id="列子查询"><a class="markdownIt-Anchor" href="#列子查询"></a> 列子查询</h3><p>列子查询返回一个列的数据，而不是单个值或多行数据。这种子查询通常用于 <code>IN</code>、<code>NOT IN</code>、<code>ANY</code>、<code>SOME</code> 或 <code>ALL</code> 子句中，与主查询的条件进行比较。</p><table><thead><tr><th><strong>操作符</strong></th><th>描述</th></tr></thead><tbody><tr><td><code>IN</code></td><td>检查某个值是否在子查询或提供的值列表中。常用于确定一个值<br>是否属于列表中的某个值。</td></tr><tr><td><code>NOT IN</code></td><td>检查某个值是否不在子查询或提供的值列表中。用于排除列表中的值。</td></tr><tr><td><code>ANY</code></td><td>与比较运算符结合使用，检查是否至少有一个子查询返回的值满<br>足比较条件。</td></tr><tr><td><code>SOME</code></td><td>功能与 <code>ANY</code> 相同，与比较运算符结合使用，用于检查是否有子查询<br>返回的值中的某些值满足比较条件。</td></tr><tr><td><code>ALL</code></td><td>与比较运算符结合使用，确保子查询返回的所有值都满足比较条件。</td></tr></tbody></table><ul><li><p>根据部门ID, 查询员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;销售部&#x27;</span>,<span class="hljs-string">&#x27;市场部&#x27;</span>));<br></code></pre></td></tr></table></figure></li><li><p>比 财务部 所有人工资都高的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span> ( <span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span><br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>) );<br></code></pre></td></tr></table></figure></li><li><p>比 研发部 其中任意一人工资高的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span> ( <span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span><br>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>) );<br></code></pre></td></tr></table></figure></li></ul><h3 id="行子查询"><a class="markdownIt-Anchor" href="#行子查询"></a> 行子查询</h3><p>行子查询比较一个值组合（即一行数据）与子查询返回的一行或多行数据。这种类型的查询通常用于处理涉及多个列的复杂条件。</p><p>常用的操作符：= 、&lt;&gt; 、IN 、NOT IN等。</p><ul><li><p>查询与 “张三” 的薪资及直属领导相同的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary,managerid) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;wgf&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="表子查询"><a class="markdownIt-Anchor" href="#表子查询"></a> 表子查询</h3><p>表子查询，也称为派生表（Derived Tables），是一种在SELECT语句的FROM子句中使用的子查询。这种子查询返回一个临时表，可以在外部查询中像普通表一样使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customer_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_orders, <span class="hljs-built_in">AVG</span>(amount) <span class="hljs-keyword">as</span> avg_amount<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> customer_id, amount<br>    <span class="hljs-keyword">FROM</span> orders<br>) <span class="hljs-keyword">AS</span> order_summary<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> customer_id;<br></code></pre></td></tr></table></figure><h3 id="in-和-exists-的区别"><a class="markdownIt-Anchor" href="#in-和-exists-的区别"></a> in 和 exists 的区别</h3><div class="note note-warning"><p><strong>IN</strong></p><ul><li><code>IN</code> 子句用于检查某个值是否存在于由子查询或值列表提供的集合中。</li><li>当使用 <code>IN</code> 时，MySQL首先计算子查询，<span class="green-line">将所有结果存储在一个临时表中，外层查询数据的每行都需要判断是否包含在子查询结果中。</span></li><li>在子查询返回的结果集较小的情况下更高效，因为整个结果集需要被加载和存储在内存中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B)<br></code></pre></td></tr></table></figure></div><div class="note note-warning"><p><strong>EXISTS</strong></p><ul><li><code>EXISTS</code> 子句用于检查子查询是否返回至少一行数据。</li><li>使用 <code>EXISTS</code> 时，<span class="green-line">MySQL对外层查询的每一行执行子查询。只要子查询返回第一行数据，就会停止检查，因为它只关心是否存在符合条件的行。</span></li><li>通常在子查询与外层查询紧密相关，或当子查询可能返回大量数据时更有效，因为它不需要处理整个子查询的结果集。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id)<br></code></pre></td></tr></table></figure></div><div class="note note-warning"><p><strong>选择</strong></p><ul><li><code>子查询返回少量数据</code>：IN</li><li><code>子查询返回大量数据</code>：EXISTS</li></ul></div><h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2><p>MySQL中的事务是一系列操作，这些操作作为一个整体执行，要么全部成功，要么全部失败。事务是数据库管理的重要特性，确保数据的完整性和一致性。MySQL中的事务主要通过以下四个关键属性（ACID属性）来保障：</p><ol><li><code>原子性（Atomicity）</code>：事务中的所有操作要么全部完成，要么全部不完成。如果事务的一部分操作失败，整个事务会回滚到开始状态，如同这些操作从未发生过一样。</li><li><code>一致性（Consistency）</code>：事务确保数据库从一个一致的状态转换到另一个一致的状态。</li><li><code>隔离性（Isolation）</code>：事务的执行不应受其他事务的干扰。多个同时运行的事务之间是相互隔离的，每个事务对数据的修改在提交之前对其他事务不可见。</li><li><code>持久性（Durability）</code>：一旦事务被提交，它对数据库的修改是永久性的，即使发生系统故障也不会丢失。</li></ol><p class="note note-primary">事务控制</p><ul><li><p>查看/设置事务提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>;<br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>自动提交事务：</p><ul><li><p>默认 <code>开启</code> 自动提交事务。</p></li><li><p>每个单独的SQL语句（如 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 等）会立即执行并提交。这意味着，一旦语句执行，其更改就是永久性的，不能回滚。</p></li><li><p>如果你想在单个操作中执行多个语句，必须显式地开始一个新事务，并在所有操作完成后提交它。</p></li></ul></li><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION 或 <span class="hljs-keyword">BEGIN</span> ;<br></code></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="并发事务问题"><a class="markdownIt-Anchor" href="#并发事务问题"></a> 并发事务问题</h3><p class="note note-primary">脏读</p><p><img src="/2022/02/26/Mysql/%E8%84%8F%E8%AF%BB.png" srcset="/img/loading.gif" lazyload alt="事务B读取到事务A未提交的数据"></p><ul><li><code>定义</code>：脏读发生在一个事务读取了另一个事务未提交的数据。</li><li><code>举例</code>：事务A修改了一行数据但还未提交，这时事务B读取了这个未提交的数据。如果事务A回滚，事务B读取的数据就是不正确的，因为这些数据从未被实际提交到数据库中。</li></ul><p class="note note-primary">不可重复读</p><p><img src="/2022/02/26/Mysql/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" srcset="/img/loading.gif" lazyload alt="一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读"></p><ul><li><code>定义</code>：不可重复读发生在一个事务读取了相同的行两次，但在两次读取之间，另一个事务修改了该行并提交，导致两次读取的数据不一致。</li><li><code>举例</code>：事务A读取了一行数据，事务B修改了这行数据并提交。当事务A再次读取同一行数据时，数据已经改变。</li></ul><p class="note note-primary">幻读</p><p><img src="/2022/02/26/Mysql/%E5%B9%BB%E8%AF%BB.png" srcset="/img/loading.gif" lazyload alt="插入检查时不存在，插入又冲突"></p><ul><li><code>定义</code>：新增或删除操作，在一个事务内执行一个范围查询时，然后插入或删除满足条件的行，事务提交发现数据冲突。</li><li><code>举例</code>：事务A根据某个条件查询数据范围，而事务B在这个范围内插入了新的数据并提交。当事务A再次执行相同的范围查询时，会发现之前不存在的“幻”数据。</li></ul><h3 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h3><table><thead><tr><th><strong>隔离级别</strong>（+:允许出现，-:不允许出现）</th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>未提交读</td><td>+</td><td>+</td><td>+</td></tr><tr><td>提已交读</td><td>-</td><td>+</td><td>+</td></tr><tr><td>可重复读</td><td>-</td><td>-</td><td>+</td></tr><tr><td>序列化读</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><table><thead><tr><th>事务隔离级别</th><th>实现方式</th></tr></thead><tbody><tr><td>读未提交（RU）</td><td>事务可以读取未提交的数据。不使用行锁来防止对读取的数据的修改，允许脏读。</td></tr><tr><td>读已提交（RC）</td><td>事务只能读取已提交的数据。使用行锁，读取数据时加锁，读取完毕后立即释放锁，防止脏读，但允许不可重复读。</td></tr><tr><td>可重复读（RR）</td><td>事务读取数据时，对读取的数据加行锁直到事务结束，防止脏读和不可重复读。在MySQL中，还使用间隙锁来防止幻读。</td></tr><tr><td>串行化（S）</td><td>事务读取或修改数据时，使用表锁，直到事务结束。这避免了脏读、不可重复读和幻读，但可能导致性能问题。</td></tr></tbody></table><h1 id="数据库进阶"><a class="markdownIt-Anchor" href="#数据库进阶"></a> 数据库进阶</h1><h2 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h2><p>视图是一个虚拟表，它基于一个或多个实际表的查询结果。视图本身不包含数据，而是保存了一个SQL查询，这个查询动态地生成数据。</p><p><em>狭义理解：视图就是对sql逻辑的封装。</em></p><p>优点：</p><ol><li><code>安全性</code>：视图可以隐藏底层表的某些列和行，仅展示必要的数据，这有助于增强数据的安全性。</li><li><code>简化SQL操作</code>：如果你经常需要执行复杂的查询（例如包含多个表的JOIN操作），可以将这些复杂的查询封装在视图中，简化后续的查询操作。</li><li><code>逻辑数据独立</code>：视图提供了一种逻辑上的数据独立。应用程序可以只依赖视图，而不是实际的表结构。这意味着即使底层数据结构发生变化，只要视图保持不变，应用程序也不需要修改。</li><li><code>重用SQL语句</code>：视图允许重用SQL语句。你可以创建一个视图来封装复杂的SQL逻辑，然后在多处重用这个视图。</li></ol><p class="note note-primary">语法</p><ul><li><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">VIEW</span> 视图名称[(列名列表)] <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句 [ <span class="hljs-keyword">WITH</span> [<br><span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span> ] <span class="hljs-keyword">CHECK</span> OPTION ]<br></code></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">查看创建视图语句：<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称;<br>查看视图数据：<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 视图名称 ...... ;<br></code></pre></td></tr></table></figure></li><li><p>修改</p><p>使用 OR REPLACE 对原视图进行覆盖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">方式一：<span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">VIEW</span> 视图名称[(列名列表)] <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句 [ <span class="hljs-keyword">WITH</span><br>[ <span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span> ] <span class="hljs-keyword">CHECK</span> OPTION ]<br><br>方式二：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> 视图名称[(列名列表)] <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句 [ <span class="hljs-keyword">WITH</span> [ <span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span><br><span class="hljs-keyword">LOCAL</span> ] <span class="hljs-keyword">CHECK</span> OPTION ]<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] 视图名称 [,视图名称] ...<br></code></pre></td></tr></table></figure></li><li><p>索引</p><p>视图不能创建索引，但是能使用原表上的索引</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> score_view <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> degree <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span>);<br><br># 使用视图<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> score_view;<br><br># 修改视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> score_view <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> degree <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span>);<br></code></pre></td></tr></table></figure><h3 id="检查选项"><a class="markdownIt-Anchor" href="#检查选项"></a> 检查选项</h3><p><code>WITH CHECK OPTION</code> 是在创建或更改视图时使用的子句，用于确保所有通过视图进行的数据修改操作（如INSERT、UPDATE、DELETE）都符合视图定义的条件。</p><p><strong>目的</strong>：保证视图的完整性，防止通过视图进行的数据修改操作破坏视图定义的规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> v1 <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> degree <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span>);<br></code></pre></td></tr></table></figure><p>这个视图中可以插入 degree 大于90 的数据，但是视图查询不出来，因为这个视图没有声明检查选项。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"># 创建视图<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> v2 <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> score <span class="hljs-keyword">where</span> degree &gt;= <span class="hljs-number">90</span>) <span class="hljs-keyword">WITH</span> CASCADED CHECK <span class="hljs-keyword">OPTION</span>;<br></code></pre></td></tr></table></figure><p>这个视图中不可以插入 degree 大于90 的数据，在插入时会进行检查，因为声明了检查选项。</p><p class="note note-primary">CASCADED 级联</p><p>这是默认选项。当设置为 <code>CASCADED</code> 时，<code>WITH CHECK OPTION</code> 会检查所有基础视图的约束。换句话说，不仅当前视图的定义被用于检查数据的合法性，所有依赖的视图（如果当前视图是基于其他视图创建的）也会进行检查。</p><p class="note note-primary">LOCAL 本地</p><p>当设置为 <code>LOCAL</code> 时，<code>WITH CHECK OPTION</code> 仅检查当前视图的定义条件，不考虑任何基础视图的约束。</p><h3 id="视图的更新"><a class="markdownIt-Anchor" href="#视图的更新"></a> 视图的更新</h3><p><span class="green-line">为了使视图可更新，需要视图中的每一行都与基础表中的行存在一对一的关系。</span>这意味着对视图的更新可以无歧义地映射到基础表上。以下是影响视图可更新性的一些关键因素：</p><ol><li><strong><code>聚合函数或窗口函数</code></strong>：使用了如 <code>SUM()</code> , <code>MIN()</code> , <code>MAX()</code> , <code>COUNT()</code> 等函数的视图不可更新，因为这些操作改变了行与基础表的直接对应关系。</li><li><strong><code>DISTINCT</code></strong>：使用 <code>DISTINCT</code> 关键字的视图不可更新，因为 <code>DISTINCT</code> 可能会消除重复行，从而破坏行与基础表行之间的一对一关系。</li><li><strong><code>GROUP BY 和 HAVING</code></strong>：这些子句通常与聚合操作一起使用，它们改变数据的展示方式，使得视图中的行不再直接对应于基础表中的行，因此这样的视图不可更新。</li><li><strong><code>UNION 或 UNION ALL</code></strong>：由于 <code>UNION</code> 或 <code>UNION ALL</code> 合并了来自多个表或多个查询的结果，这可能导致行与基础表中行之间的对应关系不明确，因此包含这些操作的视图通常不可更新。</li></ol><h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h2><ul><li><code>自动化操作</code>：触发器是一种特殊类型的存储过程，它不是由直接调用执行的，而是在特定的数据库表事件发生时自动触发。这些事件通常包括<code>INSERT</code>、<code>DELETE</code>和<code>UPDATE</code>操作。</li><li><code>数据完整性和自动化</code>：触发器常用于保持数据的完整性和一致性，例如自动更新表中的数据，或检查插入/更新的数据是否满足特定的条件。</li><li><code>事件驱动</code>：触发器是事件驱动的。当与触发器关联的表发生特定操作时，触发器中定义的SQL语句会被执行。</li></ul><p class="note note-primary">触发阶段</p><ul><li><code>BEFORE</code>：在数据操作之前。</li><li><code>AFTER</code>：在数据操作之后。</li></ul><p class="note note-primary">触发条件</p><p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发</p><table><thead><tr><th>条件</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT</td><td>NEW表示将要或者已经新增的数据</td></tr><tr><td>UPDATE</td><td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE</td><td>OLD表示将要或者已经删除的数据</td></tr></tbody></table><p class="note note-primary">使用</p><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name<br>BEFORE<span class="hljs-operator">/</span>AFTER <span class="hljs-keyword">INSERT</span><span class="hljs-operator">/</span><span class="hljs-keyword">UPDATE</span><span class="hljs-operator">/</span><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> tbl_name <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-comment">-- 行级触发器</span><br><span class="hljs-keyword">BEGIN</span><br>	trigger_stmt ;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS;<br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> [schema_name.]trigger_name;<br></code></pre></td></tr></table></figure></li><li><p>INSERT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> test_insert AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> test1 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test2 ( id, test_name )<br>    <span class="hljs-keyword">VALUES</span>( new.id, new.test_name );<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></li><li><p>UPDATE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> test_update AFTER <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> test1 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">UPDATE</span> test2 <span class="hljs-keyword">set</span> test_name <span class="hljs-operator">=</span> new.test_name <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> old.id;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></li><li><p>DELETE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> test_delete AFTER <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">ON</span> test1 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> test2 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> old.id;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="分区"><a class="markdownIt-Anchor" href="#分区"></a> 分区</h2><p><code>分区键必须是主键的一部分</code></p><p>MySQL从5.1版本开始支持表的分区。分区是一种数据库架构技术，它允许将一个大型表或索引分解为多个较小、更易于管理的部分，这些部分称为分区。</p><p>特点：</p><ul><li><strong><code>物理分离</code></strong>：从应用程序的角度来看，仍然只操作一个逻辑表或索引。但在底层，这个逻辑表或索引实际上可能被分成许多物理分区。</li><li><strong><code>独立性</code></strong>：每个分区可以独立于其他分区进行处理。这意味着可以单独优化、备份或维护每个分区，而不影响整个表。</li></ul><p class="note note-primary">分区的好处</p><ol><li><strong><code>提高查询性能</code></strong>：对于大型表，特别是当查询可以限制在特定的几个分区中时，分区可以显著提高查询性能。这是因为查询操作只需要扫描相关分区的数据而不是整个表。</li><li><strong><code>并行处理</code></strong>：不同的分区可以在不同的处理器上并行进行查询处理，特别是针对分区键进行的大型扫描或聚合查询。这种并行性能够显著提高查询的处理速度，从而增加吞吐量。</li><li><strong><code>提高数据管理的效率</code></strong>：数据管理任务，如删除和归档数据，可以通过简单地删除整个分区来高效完成，这比逐行删除数据要快得多。</li></ol><p class="note note-primary">分区的限制和缺点</p><ol><li><strong><code>分区键限制</code></strong>：如果表有主键或唯一键，则分区键必须包含主键的一部分和唯一键所有列。这意味着你不能随意选择分区键，必须考虑表的主键或唯一键设计。</li><li><strong><code>跨分区操作</code></strong>：跨多个分区的查询和事务会比在单个分区内的操作性能差。</li><li><strong><code>数据分布</code></strong>：不均匀的数据分布可能导致分区效果不理想。例如，某些分区可能数据量非常大，而其他分区则数据量很小，这可能会影响查询和维护操作的性能。</li><li><strong><code>NULL值处理</code></strong>：如范围分区，NULL值的处理可能会导致数据分配到不预期的分区，需要特别注意。</li></ol><div class="note note-warning"><p><strong>分区和分表的区别</strong></p><ul><li><code>库的限制</code>：分区只能在一个数据库内进行；分表可以在同一个库分表，也可以跨库分表。</li><li><code>水平扩展</code>：跨库分表还提供水平扩展能力，水平扩展 CPU, I/O 资源。</li><li><code>实现方式</code>：分区由数据库层实现，使用简单；分表由服务层实现，增加系统复杂性。</li></ul></div><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_13675040/2114580">对已存在表创建分区</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zero_kill/article/details/52386468">添加分区</a></p><h3 id="range-分区"><a class="markdownIt-Anchor" href="#range-分区"></a> RANGE 分区</h3><p><code>分区范围：左开右闭</code></p><p><code>RANGE</code> 分区允许根据指定列的值范围来分配行到不同的分区。这种方法非常适合于那些数据值分布在一个可预知范围内的场景，如日期、时间、状态码等，这个范围遵循左开右闭的规则。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sales (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    sale_date <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id, sale_date)			   <span class="hljs-comment">-- 分区键必须是主键的一部分</span><br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span>( <span class="hljs-keyword">YEAR</span>(sale_date) ) (<br>    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1991</span>),  <span class="hljs-comment">-- 包括1990年及之前的数据</span><br>    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1992</span>),  <span class="hljs-comment">-- 包括1991年的数据</span><br>    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">1993</span>),  <span class="hljs-comment">-- 包括1992年的数据</span><br>    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> LESS THAN MAXVALUE <span class="hljs-comment">-- 包括1993年及之后的数据</span><br>);<br><br><br># 查看表的分区信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.partitions <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database() <span class="hljs-keyword">and</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;sales&#x27;</span><br></code></pre></td></tr></table></figure><div class="note note-warning"><p><strong>使用场景</strong></p><ul><li>适用于数据有明确的连续范围，如 <code>日期</code>、<code>时间</code>、<code>数值</code> 等。</li><li>常用于时间序列数据，例如日志、交易记录。</li><li>便于数据归档和删除，例如，快速删除某个日期范围的数据。</li></ul></div><h3 id="list-分区"><a class="markdownIt-Anchor" href="#list-分区"></a> LIST 分区</h3><p><code>分区列不能插入分区不存在的值</code> <code>适合分区键不会变的场景</code></p><p>LIST分区允许根据列值的列表将数据行分配到不同的分区中。<code>LIST</code> 分区非常适合于列值是离散的且 <code>预先已知</code> 的情况，例如状态码、地区代码、部门ID等。</p><p>工作原理：定义了一组值的列表，并为每组值指定一个分区。每行数据根据分区键的值被分配到相应的分区中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 上商品信息按照店铺分区<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> product (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  store_id <span class="hljs-type">INT</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  <span class="hljs-keyword">primary</span> key(id, store_id)<br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> LIST(store_id)(<br>  <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<br>  <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),<br>  <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)，<br>  <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">DEFAULT</span>  # 默认分区，<span class="hljs-number">5.7</span>支持。其他数据会添加到此分区<br>)<br></code></pre></td></tr></table></figure><p>假设上面未设置默认分区：在 <code>LIST</code> 分区中，如果尝试插入一个行，其分区键的值不在任何已定义的分区值列表中，该插入操作将失败，并显示错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> product(id, store_id)<br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-number">20</span>);<br>#[<span class="hljs-number">1526</span>] 找不到分区错误<br></code></pre></td></tr></table></figure><div class="note note-warning"><p><strong>适用场景</strong></p><ul><li>当数据的分区键列具有一组明确且离散的值，如 <code>状态</code>、<code>类型</code>、<code>地区代码</code> 等。</li><li>用于分类数据，便于管理特定类别或组的数据。</li><li>当数据行可以基于列值的列表明确分组时。</li></ul></div><h3 id="hash-分区"><a class="markdownIt-Anchor" href="#hash-分区"></a> HASH 分区</h3><p><code>支持自定义函数 PARTITION BY HASH(customer(id))</code></p><p>Hash分区根据用户定义的表达式将数据行分配到分区中。在 <code>HASH</code> 分区中，MySQL使用用户提供的表达式对每行数据的分区键值进行哈希处理，然后基于哈希值将数据行分配到特定的分区。</p><p>原理：在<code>HASH</code>分区中，分区键的哈希值是通过一个用户定义的表达式计算得出的。MySQL将这个哈希值对分区的数量取模，得到的结果决定了数据行应该存储在哪个分区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> store<br>(<br>    id      <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    area_id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    <span class="hljs-keyword">primary</span> key (id, area_id)<br>)<br>    <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> HASH (area_id)<br>        PARTITIONS <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p class="note note-primary">优缺点</p><p><strong><code>优点</code></strong></p><ul><li><code>均匀的数据分布</code>：<code>HASH</code>分区通常能够确保数据在各个分区之间较为均匀地分布。</li><li><code>简化查询</code>：对于基于分区键的查询，<code>HASH</code>分区可能提高查询性能。</li></ul><p><strong><code>缺点</code></strong></p><ul><li><code>不适合范围查询</code>：对于涉及分区键的范围查询，<code>HASH</code> 分区没有性能优势，因为数据行可能分布在所有分区中。</li><li><code>依赖分区表达式</code>：分区的有效性高度依赖于哈希表达式。如果表达式不合适，分区可能不会均匀。</li></ul><div class="note note-warning"><p><strong>适用场景</strong></p><ul><li>当没有明显的分区范围或列表，且需要均匀分布数据时。</li><li>对于分区键的值分布均匀，且查询模式不依赖于特定范围或列表的场景。</li><li>通常用于负载均衡，尤其是在数据行没有明显的逻辑分组时。</li></ul></div><h3 id="key-分区"><a class="markdownIt-Anchor" href="#key-分区"></a> KEY 分区</h3><p><code>KEY</code>分区是一种基于哈希的分区策略，它使用MySQL内置的哈希函数对一列或多列（分区键）的值进行哈希处理，然后根据这些哈希值将数据行分配到不同的分区。与 <code>HASH</code>分区相比，<code>KEY</code> 分区的特点是它使用MySQL的哈希函数而不是用户定义的表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user (<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    area <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> ,<br>    <span class="hljs-keyword">primary</span> key (id, area)<br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> KEY(area)<br>PARTITIONS <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><div class="note note-warning"><p><strong>适用场景</strong></p><ul><li>类似于<code>HASH</code>分区，但专用于MySQL环境，使用MySQL的哈希函数。</li><li>适用于需要均匀数据分布但不希望自定义哈希函数的场景。</li><li>常用于分布式场景中，以均衡存储和查询负载。</li></ul></div><h3 id="columns-分区"><a class="markdownIt-Anchor" href="#columns-分区"></a> COLUMNS 分区</h3><p>COLUMNS分区许根据一个或多个列的值直接进行分区。这种分区类型适用于无法使用普通的范围（<code>RANGE</code>）或列表（<code>LIST</code>）分区处理的数据类型，如字符串或日期时间类型。</p><p>工作原理：</p><ul><li>基于一列或多列的值进行分区。与 <code>RANGE</code> 和 <code>LIST</code> 分区类似，<code>COLUMNS</code> 分区允许你为每个分区指定一个 <code>值范围</code> 或 <code>值列表</code>。</li><li>不同于 <code>RANGE</code> 和 <code>LIST</code> 分区只能用于整数类型（Hash值），<code>COLUMNS</code> 分区可以用于非整数类型的列，如字符串、日期等。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> user_log(<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    create_time datetime<br>)<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> COLUMNS (create_time) (<br>  <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-string">&#x27;2017-01-01 00:00:00&#x27;</span>),<br>  <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-string">&#x27;2018-01-01 00:00:00&#x27;</span>),<br>  <span class="hljs-keyword">PARTITION</span> p_max <span class="hljs-keyword">values</span> less than  maxvalue<br>);<br></code></pre></td></tr></table></figure><div class="note note-warning"><p><strong>适用场景</strong></p><ul><li>当需要基于多个列进行分区，特别是非整数类型的列（如字符串、日期等）时。</li><li>适用于复合键分区，尤其是当这些键是不同类型的数据时。</li><li>当<code>RANGE</code>或<code>LIST</code>分区的列类型不是整数类型时。</li></ul></div><h3 id="查看分区数据量"><a class="markdownIt-Anchor" href="#查看分区数据量"></a> 查看分区数据量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> PARTITION_NAME,TABLE_ROWS<br><span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.PARTITIONS<br><span class="hljs-keyword">WHERE</span> TABLE_NAME <span class="hljs-operator">=</span> tablename;<br></code></pre></td></tr></table></figure><p><strong>分区性能参考</strong></p><table><thead><tr><th style="text-align:left"><strong>操作类型</strong></th><th style="text-align:left"><strong>记录数</strong></th><th style="text-align:left"><strong>非分区表</strong></th><th style="text-align:left"><strong>分区表</strong></th></tr></thead><tbody><tr><td style="text-align:left">插入性能</td><td style="text-align:left">500万</td><td style="text-align:left">2693 秒</td><td style="text-align:left">3084 秒</td></tr><tr><td style="text-align:left">插入性能</td><td style="text-align:left">1000万</td><td style="text-align:left">5440 秒</td><td style="text-align:left">6277 秒</td></tr><tr><td style="text-align:left">插入性能</td><td style="text-align:left">2000万</td><td style="text-align:left">12753 秒</td><td style="text-align:left">14175 秒</td></tr><tr><td style="text-align:left">查询性能</td><td style="text-align:left">2000万记录，分区键索引，查询100万次</td><td style="text-align:left">126 秒</td><td style="text-align:left">90 秒</td></tr><tr><td style="text-align:left">查询性能</td><td style="text-align:left">2000万记录，非分区键索引，查询100万次</td><td style="text-align:left">691 秒</td><td style="text-align:left">727 秒</td></tr><tr><td style="text-align:left">DDL性能</td><td style="text-align:left">新增索引</td><td style="text-align:left">66 秒</td><td style="text-align:left">56 秒</td></tr><tr><td style="text-align:left">存储空间</td><td style="text-align:left">500万(数据+索引)</td><td style="text-align:left">255+384 MB</td><td style="text-align:left">351+555 MB</td></tr><tr><td style="text-align:left">存储空间</td><td style="text-align:left">1000万(数据+索引)</td><td style="text-align:left">511+900 MB</td><td style="text-align:left">551+900 MB</td></tr><tr><td style="text-align:left">存储空间</td><td style="text-align:left">2000万(数据+索引)</td><td style="text-align:left">1000+1900 MB</td><td style="text-align:left">1000+2100 MB</td></tr></tbody></table><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037683781">索引</a></h2><p>索引是用于加速数据检索的数据结构，类似于书籍的目录。以下是索引的详细描述：</p><ul><li><code>数据结构</code>：索引是一种特殊的数据结构，存储在数据库的文件系统中，用于快速查找表中的特定行。常见的数据结构包括B+Tree和哈希表。</li><li><code>查询加速</code>：索引主要用于加速查询操作，尤其是对大数据量的表进行查询时。可以显著减少数据库需要扫描的数据量。</li></ul><p class="note note-primary">优缺点</p><p><strong><code>优点</code></strong></p><ul><li><code>提高检索效率</code>：能够快速定位所需数据，特别是在大型数据集或其连接查询中。</li><li><code>优化排序和分组</code>：加快了ORDER BY和GROUP BY子句的处理速度，因为索引是有序的。</li><li><code>支持唯一约束</code>：唯一索引可以确保表中每行数据的唯一性，保证数据的正确性。</li><li><code>索引覆盖</code>：只针对加了索引的字段进行查询，能够减少回表次数，提高查询效率。</li></ul><p><strong><code>缺点</code></strong></p><ul><li><code>降低写操作性能</code>：当表中的数据被修改时，索引也需要被更新。这会降低INSERT、UPDATE和DELETE语句的性能。</li><li><code>占用额外空间</code>：索引需要占用物理存储空间。对于拥有大量数据的表，可能会造成磁盘压力。</li><li><code>设计和维护成本</code>：设计有效的索引策略需要对数据的使用模式有深入的了解。不合理的索引反而会带来性能问题。</li></ul><h3 id="索引结构"><a class="markdownIt-Anchor" href="#索引结构"></a> 索引结构</h3><p>MySQL的索引是在 <code>存储引擎层</code> 实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+ Tree索引</td><td>最常见的索引类型，适用于全值匹配、范围查询和排序操作，大部分存储引擎都支持</td></tr><tr><td>Hash索引</td><td>基于哈希表实现，适用于精确匹配索引列的查询，不支持范围查询和排序，主要由Memory引擎使用</td></tr><tr><td>R-tree索引（空间索引）</td><td>专门用于空间数据类型，如地理数据存储，主要由MyISAM引擎支持</td></tr><tr><td>Full-text索引</td><td>用于全文搜索，建立倒排索引以快速匹配文档，MySQL 5.6及更高版本的InnoDB支持</td></tr></tbody></table><p>存储引擎对索引的支持：</p><table><thead><tr><th>索引类型</th><th>InnoDB支持情况</th><th>MyISAM支持情况</th><th>Memory支持情况</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>自适应哈希索引（特定情况下）</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text索引</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p><p><img src="/2022/02/26/Mysql/%E4%BA%8C%E5%8F%89%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt></p><p>如果主键是顺序插入的，那么二叉树就会退化成为一个链表，结构如下：</p><p><img src="/2022/02/26/Mysql/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%80%E5%8C%96%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt="二叉树退化链表"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li><code>退化为链表</code>：顺序插入时，会形成一个链表，查询性能大大降低。</li><li><code>树的层级较深</code>：大数据量情况下，层级较深，检索速度慢。</li></ul><p>防止树退化为单向链表的解决方法是 <code>红黑树</code>。</p><h4 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树</a></h4><p><code>一个节点存储一个元素</code> <code>一个节点只能拥有两个子节点</code> <code>左子树和右子树有序（左小右大），不是完全有序</code></p><p><img src="/2022/02/26/Mysql/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" srcset="/img/loading.gif" lazyload alt></p><p>红黑树是一种自平衡的二叉查找树，它通过左旋和右旋来保持树的平衡，从而防止树过度倾斜。在红黑树中，每个节点带有颜色属性，颜色为红色（Red）或黑色（Black）。</p><p><strong>红黑树的特性：</strong></p><ol><li><code>节点颜色</code>：每个节点要么是黑色，要么是红色。</li><li><code>根节点</code>：根节点总是黑色。</li><li><code>叶子节点</code>：所有叶子节点（NIL节点）是黑色。</li><li><code>红色节点的子节点</code>：如果一个节点是红色的，则它的直接子节点都是黑色的。</li><li><code>黑色路径</code>：从任一节点到其每个叶子的所有路径都包含相同数量的黑色节点。</li></ol><p><strong>特征</strong>：红黑树的关键特性是它的自平衡能力，确保树不会退化成链表，这避免了普通二叉查找树在最坏情况下可能出现的性能下降。</p><p><strong>在MySQL中的应用及局限性：</strong></p><ul><li><code>树的高度</code>：海量数据下树的高度非常高，影响查询性能。</li><li><code>范围搜索</code>：无法支持范围搜索。</li></ul><h4 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/qixinbo/p/11048269.html">B树</a></h4><p><code>一个节点存储多个元素</code> <code>一个节点可以拥有2个以上的子节点</code> <code>按递增次序排列，并遵循左小右大原则</code> <code>节点存储键值和数据</code></p><p><img src="/2022/02/26/Mysql/B-%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt="多路平衡查找树"></p><p>B树是一种多路平衡查找树，用于高效的数据存取，特别是在磁盘等外部存储上。以下是B树的主要特性和应用：</p><ul><li><code>多路平衡树</code>：B树是一种多叉树，每个节点可以有多个子节点，这减少了树的高度，并优化了数据的读取速度。</li><li><code>排序和子节点数</code>：节点中的键值按递增顺序排列，每个非叶节点的子节点数介于2到M之间（M是树的阶数）。</li><li><code>叶子节点</code>：所有叶子节点都位于同一层。</li><li><code>数据存储</code>：节点存储键值和数据，其中键值用于指导搜索和排序，数据则是与键值相关联的实际信息。</li></ul><p><font color="red">B树和红黑树最大的区别是B树是完全有序的，且B树是一颗多叉树（一个节点可以存储多个子节点）。</font></p><p class="note note-primary">Mysql为什么不用B树</p><ul><li>B树通过自平衡解决了退化链表问题。</li><li>B树是一颗多叉树，解决树高度问题，解决查询效率问题。</li></ul><p>不选择B树是因为B树无法支持高效的范围查询。</p><h4 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2"></a> <a target="_blank" rel="noopener" href="https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree">B+树</a></h4><p><code>一个节点存储多个元素</code> <code>按递增次序排列，并遵循左小右大原则</code> <code>非叶子节点存储键值，叶子节点存储键值和数据</code></p><p><code>叶子节点通过指针两两相连，便于实现范围查找和排序</code></p><p><img src="/2022/02/26/Mysql/B+%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt></p><p>B+树是一种自平衡的多路查找树，是B树的变体，用于数据库和文件系统中的索引和数据组织。其特点包括：</p><ul><li><code>多路平衡查找树</code>：B+树是一颗多叉树，其中每个节点有多个子节点。这种结构减少了树的高度，提高了查找效率。</li><li><code>存储结构</code>：非叶子节点存储数据的键，叶子节点存储数据的键值。</li><li><code>叶子节点之间相连</code>：B+树的所有叶子节点通过指针相连，形成了一个有序链表，这使得对数据的范围查询和顺序访问变得非常高效。</li></ul><div class="note note-warning"><p><strong>聚簇索引</strong></p><ul><li><code>B+树结构</code>：在nnoDB存储引擎中，聚簇索引使用B+树结构。这意味着表的数据实际上存储在B+树的叶子节点中。</li><li><code>排序和范围查找</code>：由于数据在叶子节点中按键值排序，聚簇索引特别适合于范围查找和排序操作。叶子节点之间的链接使得范围扫描变得高效。</li></ul></div><p class="note note-primary">MySql对B+树的优化</p><p><img src="/2022/02/26/Mysql/B+%E6%A0%91%E4%BC%98%E5%8C%96.png" srcset="/img/loading.gif" lazyload alt="相邻叶子节点添加指针"></p><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p class="note note-primary">B树和B+树的区别</p><ul><li>B树节点存储键值和数据，B+树非叶子节点存键值，叶子节点存键值和数据</li><li>B+树叶子节点两两相连形成一个有序的链表，可以支持高效的范围查询；而B树每个节点的键值存储在一起，无法行程一个有序列表。</li></ul><h4 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h4><p><code>原理类似HashMap,通过列的值转成hashCode,hash冲突就用链表</code></p><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="/2022/02/26/Mysql/hash.png" srcset="/img/loading.gif" lazyload alt="hash索引"></p><p>创建hash索引后，会为每个键值通过特定的算法计算出一个哈希码（hash code)，需要注意的是不同的键值计算出来的hash值可能是相同的，上图金庸和杨逍就存在hash冲突，当冲突时使用链表存储多个冲突的数据，然后再次遍历这条链表，找到需要的数据，这就解释了为啥hash冲突严重了，hash索引效率降低的原因。</p><p class="note note-primary">优缺点</p><p><strong><code>优点</code></strong></p><ul><li><code>快速查找</code>：对于等值查询，哈希提供了快速的访问速度。由于哈希函数的直接计算，它能够快速定位到数据的存储位置。</li><li><code>空间效率</code>：哈希通常比其他类型的（如B+树）更加紧凑，占用更少的空间。</li></ul><p><strong><code>缺点</code></strong></p><ul><li><code>不支持范围查询</code>：哈希不适用于范围查询。由于哈希函数的特性，无法用哈希索引来有效地处理大于、小于或介于某两个值之间的查询。</li><li><code>不支持排序操作</code>：哈希不保证顺序性，因此无法支持基于索引的数据排序。</li><li><code>Hash冲突</code>：当Hash冲突严重时，使用链表存储冲突的Hash数据，会严重影响查询性能。</li></ul><h3 id="索引语法"><a class="markdownIt-Anchor" href="#索引语法"></a> 索引语法</h3><ul><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT ] INDEX index_name <span class="hljs-keyword">ON</span> table_name (index_col_name,... );<br></code></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure></li></ul><h3 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类"></a> 索引分类</h3><p>MySql索引按叶子节点存储的是否为完整表数据分为：<code>聚簇索引</code>、<code>二级索引</code>（辅助索引）。全表数据存储在聚簇索引中，聚簇索引以外的其他索引叫做二级索引，也叫辅助索引。</p><p>在MySQL数据库，将索引的具体类型主要分为以下几类：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中的主键创建的索引</td><td>只能有一个，不可为空，性能最高</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>保证某列或列组合的数据唯一性</td><td>可以有多个，列值可以为空，确保数据的唯一性</td><td>UNIQUE</td></tr><tr><td>普通索引</td><td>用于快速定位特定数据</td><td>可以有多个，提升查询效率，不强制唯一性</td><td>INDEX</td></tr><tr><td>前缀索引</td><td>在字符串列上的索引，只对值的前缀部分建立索引</td><td>节省空间，适用于长文本字段</td><td></td></tr><tr><td>组合索引</td><td>在多个列上建立的索引，用于涵盖多个列的查询</td><td>提高多列查询的效率，顺序敏感</td><td></td></tr><tr><td>全文索引</td><td>用于全文搜索，特别是在文本数据中搜索关键词</td><td>针对大文本内容的快速搜索，不适用于精确匹配</td><td>FULLTEXT</td></tr></tbody></table><h4 id="聚簇索引"><a class="markdownIt-Anchor" href="#聚簇索引"></a> 聚簇索引</h4><p><img src="/2022/02/26/Mysql/B+%E6%A0%91.jpg" srcset="/img/loading.gif" lazyload alt="也叫主键索引"></p><p>InnoDB存储引擎使用聚簇索引存储数据（B+树），它有以下特点：</p><ul><li><code>数据与索引的存储</code>：在聚簇索引中，表数据直接存储在索引的叶子节点上，非叶子节点是主键索引。这意味着数据行和它的索引是紧密结合在一起的，索引结构实际上就是数据表。</li><li><code>主键顺序存储</code>：聚簇索引按照主键的顺序存储数据。如果表中定义了主键，InnoDB会使用这个主键作为聚簇索引的键。</li><li><code>主键选择</code>：<ul><li>默认创建表会定义一个主键。</li><li>没有主键，寻找第一个非空唯一列作为聚簇索引的键。</li><li>不存在非空唯一列，InnoDB会自动创建一个隐含的主键 <code>ROWID</code>。</li></ul></li><li><code>页分裂和插入顺序</code>：由于数据是按主键顺序存储的，非顺序插入（如随机插入）可能导致页分裂，影响性能。顺序插入，如使用自增主键，会有更好的性能。</li><li><code>页合并和数据删除</code>：当大量数据删除时，相邻的两个页数据达到合并的阈值时，会进行合并以提高查询性能。</li><li><code>主键更新</code>：在聚簇索引中，更新主键的代价较高，因为它涉及到实际数据的物理移动。</li></ul><p class="note note-primary">InnoDB表设计要有自增主键的原因</p><ul><li><code>聚簇索引</code>：如果表有一个主键，InnoDB就会使用这个主键作为聚簇索引。当主键是自增的，新记录会被顺序地添加到索引的末端，这有助于减少 <code>页分裂</code>，提高写入效率。</li><li><code>插入性能</code>：当使用自增主键时，每个新插入的行都会被顺序地添加到表的末尾。这种末尾追加与随机插入相比，减少了磁盘I/O，提高了插入速度。</li><li><code>数据排序</code>：聚簇索引（B+树）是有序的，需要根据主键对数据进行有序排序。</li><li><code>主键选择</code>：如果不指定索引则会选择第一个非空唯一列，否则会生成一个自增的 <code>ROWID</code>。</li></ul><p class="note note-primary">聚簇索引优缺点</p><p><code>优点</code></p><ul><li><code>主键查询效率高</code>：对于通过主键访问的查询，因为索引和数据是同时存储的，所以检索数据不需要额外的回表操作。</li><li><code>优化范围查询</code>：由于数据是按索引键顺序存储的，因此对数据进行范围查询会更快。</li><li><code>索引覆盖查询</code>：查询的列都是聚簇索引的键时，可以直接在索引中完成查询，无需进行回表查询。</li></ul><p><code>缺点</code></p><ul><li><code>需要顺序插入</code>：如果插入数据的主键不是有序的，会导致数据页分裂，影响插入性能。</li><li><code>数据碎片化</code>：数据的频繁插入和删除，聚簇索引可能导致数据在物理存储上的碎片化，影响数据库性能。<ul><li>OPTIMIZE TABLE table_name; 重建表消除磁盘碎片。</li></ul></li><li><code>非主键查询的性能影响</code>：非主键查询需要额外的回表操作才能获取查询数据，性能不如主键查询。</li></ul><p class="note note-primary">非聚簇索引</p><p>MyISAM表中的主键索引和非主键索引的结构是一样的。在这两种类型的索引中，索引的叶子节点并不直接存储表数据本身，而是存放指向表数据的物理地址。这种设计意味着MyISAM表的索引主要用于快速定位数据，而不是直接存储数据内容。</p><p><img src="/2022/02/26/Mysql/myISAM%E7%B4%A2%E5%BC%95.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="二级索引"><a class="markdownIt-Anchor" href="#二级索引"></a> 二级索引</h4><p><code>B+树</code></p><p>二级索引与聚簇索引分开存储，它自己是独立的一颗B+树，索引的键就是创建二级索引指定的字段，叶子节点不是存储完整的表数据，而是其对应的ID。</p><p><img src="/2022/02/26/Mysql/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.jpg" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">优缺点</p><p><strong><code>优点</code></strong></p><ul><li><code>提高查询效率</code>：对于非主键的查询，二级索引可以显著提高检索速度。</li><li><code>灵活的查询</code>：可以基于表中任意列组合创建索引，增加多字段查询的灵活性。</li></ul><p><strong><code>缺点</code></strong></p><ul><li><code>额外的存储开销</code>：每个二级索引都需要占用额外的存储空间。</li><li><code>性能损耗</code>：数据的插入、更新、删除操作都需要同时更新聚簇索引和所有相关的二级索引，降低数据修改效率。</li></ul><h5 id="回表查询"><a class="markdownIt-Anchor" href="#回表查询"></a> 回表查询</h5><p>回表查询也称为&quot;二次查找&quot;或&quot;索引跳跃&quot;，发生在使用二级索引检索数据时，二级索引不能完全提供所检索的数据，因此需要进一步访问聚簇索引来获取完整的数据行。</p><p>工作原理：</p><ol><li><code>扫描二级索引</code>：查询首先在二级索引中进行，以查找符合条件的索引条目。</li><li><code>获取主键</code>：二级索引的叶子节点存储对应数据行的聚簇索引键（通常是主键）。</li><li><code>访问聚簇索引</code>：数据库使用从二级索引中获取的聚簇索引键，去聚簇索引中检索完整的数据行。</li><li><code>返回数据</code>：最后，从聚簇索引中检索到的数据行被返回给用户。</li></ol><p><img src="/2022/02/26/Mysql/%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2.png" srcset="/img/loading.gif" lazyload alt></p><p>回表查询需要额外的聚簇索引搜索，必然会降低查询效率。</p><h5 id="索引覆盖"><a class="markdownIt-Anchor" href="#索引覆盖"></a> 索引覆盖</h5><p>定义：二级索引包含了所有的查询字段，查询结果直接由二级索引返回，不需要回到聚簇索获取完整的数据行。</p><p>工作原理：</p><ul><li><code>查询的列在索引中</code>：查询所涉及的所有列都包含在一个索引中。</li><li><code>索引满足查询需求</code>：查询可以完全通过查看索引来得到所需的结果，而不需要查找表中的实际数据行，提高查询效率。</li></ul><p>Example</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_test<br>(<br>id        <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br>user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>age       <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>sex       <span class="hljs-type">int</span>,<br>birthday  datetime<br>);<br># 建立组合索引<br><span class="hljs-keyword">create</span> index idx_user_name_age <span class="hljs-keyword">on</span> tb_test(user_name, age);<br># 进行索引覆盖查询<br>explain<br><span class="hljs-keyword">select</span> id, user_name, age   # 所有查询的字段都在二级索引中<br><span class="hljs-keyword">from</span> tb_test;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96.png" srcset="/img/loading.gif" lazyload alt></p><p><a href="#like%E4%BD%BF%E7%94%A8">索引覆盖解决%在左边的like查询索引失效</a></p><h5 id="索引下推"><a class="markdownIt-Anchor" href="#索引下推"></a> 索引下推</h5><p><strong>思想</strong>：尽早地利用索引信息来过滤掉不符合条件的行，减少数据访问和处理的开销。</p><p><strong>具体实现</strong>：查询涉及多个条件时，InnoDB 可以在索引的叶子节点上执行部分查询条件，将不符合条件的行过滤掉，只将符合条件的行返回给查询引擎。</p><p><strong>原理</strong>：</p><ol><li><code>索引遍历</code>：查询优化器确定使用索引后进行索引遍历。</li><li><code>条件下推</code>：遍历索引时，尽可能利用 Where 子句条件过滤索引数据。比如查询条件不包含组合索引中间字段，依然使用后面字段过滤索引数据。</li><li><code>减少数据返回Server层</code>：经过条件下推过滤后，减少返回Server层数据。</li><li><code>提高查询效率</code>：减少回表检索完整数据工作量。</li></ol><p><strong>特点</strong>：</p><ul><li><code>索引条件下推</code>：在索引扫描阶段，即使索引条件被中断，存储引擎仍能够在索引内部应用WHERE子句的一部分条件，从而减少返回的数据行数。</li><li><code>优势</code>：在索引层面提前过滤掉不满足条件的行，减少了对聚簇索引的访问次数。</li></ul><p class="note note-primary">EXAMPLE</p><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" srcset="/img/loading.gif" lazyload alt></p><p>使用一张用户表tuser，表里创建联合索引（name, age）</p><p><img src="/2022/02/26/Mysql/%E7%94%A8%E6%88%B7%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tuser <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;张%&#x27;</span> <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>最左匹配原则，那么就知道这个语句在搜索索引树的时候，只能用 <code>张</code>，找到的第一个满足条件的记录id为1。</p><div class="note note-warning"><p><strong>没有使用索引条件下推</strong></p><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A81.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><p>由于组合索引被 <code>like</code> 中断，引擎层在扫描索引时只扫描 <code>姓张</code> 的用户，即使 WHERE 子句还有其他条件用于索引过滤。</p></li><li><p>将粗略扫描的数据返回 <code>SERVER</code> 层。</p></li><li><p>根据返回数据回表到聚簇索引取出完整数据，然后再进行条件判断。</p></li><li><p>将筛选后的数据返回客户端。</p></li></ol></div><div class="note note-warning"><p><strong>使用索引条件下推</strong></p><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A82.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>条件下推</code>：在存储引擎扫描索引时，虽然使用了 <code>like</code> 查询，但是 WHERE 子句中有可用于当前索引的过滤条件，会继续取出过滤条件对索引进行数据过滤。</li><li><code>减少SERVER层数据返回</code>：通过下推条件对索引进行过滤后，返回少量数据到SERVER层；</li><li><code>减少回表次数</code>：由于 SERVER 层数据减少，需要回表的次数也相应减少。取出数据后继续过滤非索引条件。</li><li>将筛选后的数据返回客户端。</li></ul></div><h4 id="主键索引"><a class="markdownIt-Anchor" href="#主键索引"></a> 主键索引</h4><p><code>主键唯一，不能为空</code> <code>聚簇索引的key,不用回表，性能最佳</code></p><p>建立在主键上的索引被称为 <code>主键索引</code>，一张数据表只能有一个主键索引，索引列值不允许有空值，通常在创建表时一起创建。</p><p><strong>特点</strong>：</p><ol><li><code>唯一性</code>： 作为聚簇索引的键，保证每一行的主键都唯一。</li><li><code>非空性</code>： 主键字段不能包含NULL值。</li><li><code>查询优化</code>：作为聚簇索引的键，使用主键查询不需要回表操作，查询效率最高。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test<br>(<br> id        <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key # 建立主键时自动创建主键索引<br>);<br></code></pre></td></tr></table></figure><h4 id="唯一索引"><a class="markdownIt-Anchor" href="#唯一索引"></a> 唯一索引</h4><p><code>能为空</code> <code>建立聚簇索引Key的备选方案</code></p><p>唯一索引用于保证一个表中的每一行在指定列上的值是唯一的，一张表可以有多个唯一索引，<span class="green-line">索引列值允许为空，列值中出现多个空值不会发生重复冲突</span>。</p><p><strong>特点</strong>：</p><ul><li><code>保证唯一</code>：唯一索引在表的一列或列组合上创建，确保在这一列或列组合中的每个值都是唯一的。</li><li><code>约束检查</code>：当<code>增删改</code>数据时，会检查新的值是否违反了唯一约束，违反则抛出异常。</li><li><code>允许NULL</code>：NULL 不会引发唯一索引冲突。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index un_idx_user_name <span class="hljs-keyword">on</span> tb_test(user_name);<br></code></pre></td></tr></table></figure><h4 id="普通索引"><a class="markdownIt-Anchor" href="#普通索引"></a> 普通索引</h4><p><code>最常用</code></p><p>在MySQL中，建立在表的普通字段上的索引被称为 <code>普通索引</code> 或 <code>非唯一索引</code>。这种索引允许字段中包含重复的值。如果查询仅使用到了索引中的字段，这称为 <code>索引覆盖查询</code>，因为索引本身就足够满足查询需求，无需访问表中的实际数据。在非覆盖索引的情况下，数据库引擎需要进行 <code>回表查询</code>，即先通过索引找到对应的行标识（如行ID），然后再到数据表中检索完整的行数据。</p><p><strong>特点</strong>：</p><ul><li>优化查询。</li><li>索引覆盖查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_user_name <span class="hljs-keyword">on</span> tb_test(user_name);<br></code></pre></td></tr></table></figure><h4 id="前缀索引"><a class="markdownIt-Anchor" href="#前缀索引"></a> 前缀索引</h4><p>前缀索引是通过在创建索引时指定列值的 <code>前几个字符</code> 来建立的，而不是在整个字段上建索引。如果前几个字符基本就能确定数据唯一性， 前缀索引可以大大减少索引占用的存储空间，也能提升索引的查询效率。</p><p><strong>特点</strong>：</p><ul><li><p><code>长文本字段</code>：适合<em><strong>char、varchar、binary、varbinary、text</strong></em>的列上使用。</p></li><li><p><code>减少空间占用</code>：前缀索引只索引部分字符，占用的空间比完整索引小。</p></li><li><p><code>提高效率</code>：通过扫描字符前缀便能查找数据，比全字符查询效率高。</p></li><li><p><code>字段选择</code>：如果字段的字符前缀重复度很高，索引效果会很差。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 前<span class="hljs-number">5</span>个字符加索引<br><span class="hljs-keyword">create</span> index idx_user_name <span class="hljs-keyword">on</span> tb_test(user_name(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h4 id="组合索引"><a class="markdownIt-Anchor" href="#组合索引"></a> 组合索引</h4><p><code>查询优化</code> <code>索引覆盖</code></p><p>建立在多个列上的索引被称为组合索引（也称为复合索引或多列索引），它可以同时涵盖多个字段，使得基于这些字段的查询更加高效。</p><p><strong>原理</strong>：</p><ul><li><code>有序结构</code>：组合索引中的数据是根据索引列的顺序存储的。首先是第一列的数据排序，然后是第二列的数据排序，依此类推。</li><li><code>索引查找</code>：如果查询条件包含索引的首列，索引最为有效，跳过首列索引不生效。</li></ul><p><strong>特点</strong>：</p><ul><li><p><code>优化多列查询</code>：对于经常同时在多个列上进行查询的场景，组合索引可以显著提高查询效率。</p></li><li><p><code>排序和分组</code>：组合索引可以加速涉及多个列的排序（<code>ORDER BY</code>）和分组（<code>GROUP BY</code>）操作。</p></li><li><p><code>索引覆盖查询</code>：如果查询的选择列完全包含在索引中，则无需访问表中的行，这称为索引覆盖扫描。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_name_age <span class="hljs-keyword">on</span> tb_user(name, age);<br></code></pre></td></tr></table></figure><p>组合索引的使用需要遵循 <a href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99">最左匹配原则</a>。</p><div class="note note-warning"><p><strong>ORDER BY 优化</strong></p><p>假设 <code>employees</code> 表创建了<code>department_id</code>, <code>last_name</code>, <code>first_name</code> 这三个字段的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> department_id, last_name, first_name;<br></code></pre></td></tr></table></figure><p>即使 <code>WHERE</code> 子句没有使用组合索引，<code>ORDER BY</code> 或 <code>GROUP BY</code> 仍有可能利用该索引进行优化。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">WHERE</span> department_id = <span class="hljs-number">5</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> last_name, first_name;<br></code></pre></td></tr></table></figure></div><div class="note note-warning"><p><strong>GROUP BY 优化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <br><span class="hljs-keyword">FROM</span> employees <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, last_name, first_name;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, job_title, <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">AS</span> average_salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, job_title;<br></code></pre></td></tr></table></figure></div><h3 id="索引使用注意事项"><a class="markdownIt-Anchor" href="#索引使用注意事项"></a> 索引使用注意事项</h3><p>有效地使用 MySQL 中的索引可以显著提高数据库查询的性能，滥用索引反而会导致数据库性能下降。</p><h4 id="使用短索引"><a class="markdownIt-Anchor" href="#使用短索引"></a> 使用短索引</h4><p>当长字符串字段的前几位字符区别很大时，可以指定前缀长度来创建前缀索引。这种方法意味着只对字符串数据的前部分进行索引，而不是整个字段。</p><p><strong>优势</strong>：</p><ul><li><code>提高查询性能</code>：短索引的扫描速度更快，能提升查询效率。</li><li><code>减少磁盘空间占用</code>：短索引占用的磁盘空间更少。</li><li><code>优化I/O操作</code>：通过减少索引大小，MySQL可以更高效地维护和访问索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test(<br> id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key ,<br> business_no <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>)<br> ....             <br>);<br># 使用短索引<br><span class="hljs-keyword">create</span> index idx_business_no <span class="hljs-keyword">on</span> test(business_no(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><h4 id="频繁更新的字段不使用索引"><a class="markdownIt-Anchor" href="#频繁更新的字段不使用索引"></a> 频繁更新的字段不使用索引</h4><p>频繁更新的字段会导致索引经常重新构建，从而增加数据库的工作负担。</p><ul><li><code>额外性能开销</code>：每次对表中的数据进行更新操作时，都需要更新索引结构，这会导致额外的性能开销。</li><li><code>影响优化器选择</code>：频繁更新的字段加了索引，查询优化器可能会在选择执行计划时受到影响，导致查询性能下降。</li></ul><h4 id="索引列存在隐式类型转换"><a class="markdownIt-Anchor" href="#索引列存在隐式类型转换"></a> 索引列存在隐式类型转换</h4><p>如果索引列的数据类型和查询条件的数据类型不一致时，MySQL会进行 <code>隐式的类型转换</code>。使得优化器无法准确估计索引的查询成本。，从而降低查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user<br>(<br> id      <span class="hljs-type">int</span>         <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br> name    <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">null</span>,<br> age     <span class="hljs-type">int</span>         <span class="hljs-keyword">null</span>,<br> adderss <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">null</span><br>);<br><span class="hljs-keyword">create</span> index idx_address <span class="hljs-keyword">on</span> tb_user (adderss);<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.jpg" srcset="/img/loading.gif" lazyload alt></p><h4 id="不要在索引列上调用函数或数学运算"><a class="markdownIt-Anchor" href="#不要在索引列上调用函数或数学运算"></a> 不要在索引列上调用函数或数学运算</h4><p>在索引列上直接应用函数或进行数学运算可能导致MySQL查询优化器无法有效利用索引。</p><p>在MySQL中，如果在查询中对一个已经被索引的列直接使用函数调用或进行数学运算，例如 <code>SELECT * FROM table WHERE YEAR(date_column) = 2021</code>，这样的操作会使得优化器无法直接利用该列的索引。<span class="green-line">这是因为索引是针对列原始值建立的，而函数或数学运算改变了列的内容</span>，从而使得索引失效。</p><p><img src="/2022/02/26/Mysql/%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0.jpg" srcset="/img/loading.gif" lazyload alt></p><h4 id="like使用"><a class="markdownIt-Anchor" href="#like使用"></a> like使用</h4><p>LIKE查询中百分号（%）位置对索引的影响：</p><p><code>场景一</code>：当 <code>%</code> 出现在模式的左边或者两边时，索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;tom%&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%tom%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这两种情况下，由于MySQL无法从索引中快速定位起始匹配位置，必须对整个字段进行扫描来查找匹配项，因此索引不会被有效利用。</p><p><code>场景二</code>：当<code>%</code>仅出现在模式的右边时，索引可以生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;tom%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在这种情况下，查询能够利用索引，因为MySQL可以利用索引快速定位到以’tom’开头的记录。</p><p class="note note-primary">利用索引覆盖优化like的末尾匹配</p><p>当使用LIKE操作符进行模糊查询且模式以%开始时，如 <code>'%value%'</code> 或 <code>'%value'</code>，一般情况下索引会失效。这是因为搜索模式的起始部分不固定，导致MySQL无法利用索引进行高效搜索。然而，可以通过索引覆盖（Covering Index）来优化这类查询。</p><p>例如，如果在<code>user_name</code>, <code>user_age</code>, <code>user_level</code>上创建了组合索引，即使LIKE查询的模式以%开头，查询也可以更高效，因为MySQL会进行 <code>全索引扫描</code> 而非全表扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> user_name <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%jack%&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> user_name <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%jack&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> user_name, user_age, user_level <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span><span class="hljs-operator">-</span>name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%jack%&#x27;</span>;<br>EXPLAIN <span class="hljs-keyword">SELECT</span> user_name, user_age, user_level <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span><span class="hljs-operator">-</span>name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%jack%&#x27;</span>;<br></code></pre></td></tr></table></figure><p class="note note-primary">like失效原因</p><ul><li><strong><code>%号在右</code></strong>（如 <code>LIKE 'value%'</code>）：<ul><li><code>原理</code>：当%号在右侧时，搜索条件固定了字符串的开始部分。由于B+树索引是按字典顺序排序的，可以有效地在索引中定位到以指定前缀开头的字符串。</li><li><code>效果</code>：这种模式可以高效地利用索引进行范围查找，因为它限定了字符串的开始部分。</li></ul></li><li><strong><code>%号在左</code></strong>（如 <code>LIKE '%value'</code>）：<ul><li><code>原因</code>：当%号在左侧时，搜索条件固定了字符串的结束部分。由于B+树索引是基于整个字符串的字典顺序建立的，而不是基于字符串的尾部，这使得索引在这种情况下无法有效地定位匹配。</li><li><code>效果</code>：索引在这种模式下无法被有效利用，因为它没有限定字符串的开始部分。</li></ul></li><li><strong><code>两个%号</code></strong>（如 <code>LIKE '%value%'</code>）：<ul><li><code>原因</code>：当两边都有%号时，这表示在字符串的任意位置匹配给定的模式。由于B+树索引是基于整个字符串值的排序，而非其子部分，这种模式不利于在索引中定位匹配。</li><li><code>效果</code>：在这种情况下，索引通常也无法被有效利用。</li></ul></li></ul><h4 id="谨慎使用or"><a class="markdownIt-Anchor" href="#谨慎使用or"></a> 谨慎使用or</h4><p>如果OR连接的条件中，某些列有索引而另一些列没有，那么这通常会导致整个查询无法有效利用索引。</p><p><strong>优化建议</strong>：</p><ul><li><code>建立合适的索引</code>：确保所有在OR条件中涉及的列都有索引。</li><li><code>使用UNION替代</code>：可以使用UNION来重写含有OR的查询，因为UNION可以单独优化每个查询分支，并且可能更高效地利用索引。</li></ul><p><img src="/2022/02/26/Mysql/%E5%B0%91%E7%94%A8or.jpg" srcset="/img/loading.gif" lazyload alt></p><h4 id="索引列排序"><a class="markdownIt-Anchor" href="#索引列排序"></a> 索引列排序</h4><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E5%88%97%E6%8E%92%E5%BA%8F.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th><strong>排序处理方式</strong></th><th><strong>执行计划extra列信息</strong></th><th><strong>排序性能比较</strong></th></tr></thead><tbody><tr><td>利用索引进行排序</td><td>Using index</td><td>高</td></tr><tr><td>临时表排序<br>没有适合排序的索引,在内存创建临时表并在其中排序</td><td>Using temporary</td><td>低</td></tr><tr><td>文件排序<br>将排序数据存储在磁盘上的临时文件中，并进行排序操作</td><td>Using filesort</td><td>低</td></tr></tbody></table><p>当MySQL可以利用索引的有序性来执行 <code>ORDER BY</code> 操作时，这是最高效的排序方式。因为数据在索引中已经是有序的，所以MySQL可以直接按索引顺序检索数据，无需额外的排序操作。</p><h4 id="数据分布影响"><a class="markdownIt-Anchor" href="#数据分布影响"></a> 数据分布影响</h4><p>数据的分布特性会影响优化器是否选择使用索引。MySQL优化器在决定是否使用索引时，会评估使用索引的成本与全表扫描的成本，并选择更高效的方案。</p><ul><li><strong>使用索引的成本考虑</strong>：<ul><li><code>查询数据量少</code>：使用索引通常更高效，因为索引可以快速定位到符合条件的少量数据。</li><li><code>索引数据区分度高</code>：扫描索引能高效检索数据。</li></ul></li><li><strong>全表扫描的成本考虑</strong>：<ul><li><code>查询数量多</code>：如果查询条件涵盖了表中的大部分数据，索引的效益就会降低。在这种情况下，索引的使用可能不如全表扫描高效。</li><li><code>索引数据区分度低</code>：扫描索引收益不高可能选择全表扫描。</li></ul></li></ul><p>比如一张表只有10万条数据，并且id是自增的，使用以下Sql则会放弃索引走全表扫描，放弃索引的原因是因为表中大多数数据都满足条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">95000</span><br></code></pre></td></tr></table></figure><h4 id="最左匹配原则"><a class="markdownIt-Anchor" href="#最左匹配原则"></a> 最左匹配原则</h4><p>一个查询通常只使用一个索引来优化 <code>WHERE</code> 子句、<code>ORDER BY</code> 子句和 <code>GROUP BY</code> 子句。这意味着，如果WHERE子句已经使用了一个索引，那么在ORDER BY子句中使用另一个不同的索引来排序可能不会生效。为了优化含有多列排序的查询，可以考虑以下策略：</p><ul><li><code>避免多列非索引排序</code>：尽量避免在ORDER BY子句中包含没有被索引的多个列。</li><li><code>使用复合索引</code>：复合索引可以提高那些同时使用WHERE子句和ORDER BY子句的查询的效率。</li><li><code>索引覆盖</code>：查询字段和WHERE子句和ORDER BY子句中的列都属于同一个索引时，使用这个索引进行查询，排序和返回数据。</li></ul><p><img src="/2022/02/26/Mysql/%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>最佳左前缀底层原理</strong>：</p><ul><li><code>键值排序</code>：在复合索引中，数据首先按照索引的第一个列的值排序，对于第一个列值相同的行，再按照第二个列的值排序，以此类推。</li><li><code>连续匹配</code>：当执行查询时，MySQL会在索引中查找与查询条件匹配的行。为了高效地利用索引，查询条件需要从复合索引的最左边开始连续匹配索引中的列。这意味着，如果查询条件跳过了复合索引中的某个列，索引的后续部分就无法被有效利用。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> myTest(<br>a <span class="hljs-type">int</span>,<br>b <span class="hljs-type">int</span>,<br>c <span class="hljs-type">int</span>,<br>KEY a(a,b,c)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">4</span>;  <span class="hljs-comment">-- abc顺序</span><br>abc三个索引都在<span class="hljs-keyword">where</span>条件里面用到了，而且都发挥了作用<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span>  c<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">6</span> <span class="hljs-keyword">and</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span>;<br><span class="hljs-keyword">where</span>里面的条件顺序在查询之前会被自动优化，效果跟上一句一样<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">7</span>;<br>a用到索引，b没有用，所以c是没有用到索引效果的<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">&gt;</span><span class="hljs-number">7</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>;   <span class="hljs-comment">-- b范围值，断点，阻塞了c的索引</span><br>a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">&gt;=</span><span class="hljs-number">7</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>;   <span class="hljs-comment">-- abc全部使用索引</span><br>b是大于等于包含等值，因此不会阻断查询<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">4</span>;  <span class="hljs-comment">--组合索引必须遵循最左匹配原则</span><br>因为a索引没有使用，所以这里 bc都没有用上索引效果<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> b;<br>a用到了索引，b在结果排序中也用到了索引的效果，a下面任意一段的b是排好序的(索引列排序)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> c;<br>a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort (索引列排序不生效，使用文件排序)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a;<br>b没有用到索引，排序中a也没有发挥索引效果 (没有遵循最左匹配原则)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;7%&#x27;</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>; <span class="hljs-comment">-- 左前缀模糊匹配，索引生效</span><br>abc都使用了索引<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> myTest a<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">and</span> b <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%7&#x27;</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">3</span>; <span class="hljs-comment">-- 非左前缀模糊匹配，索引失效</span><br>a使用索引，b右匹配索引阻断<br></code></pre></td></tr></table></figure><p class="note note-primary">Index Skip Scan</p><p><code>索引跳跃扫描</code>（Index Skip Scanning）是在一个复合索引中（MySql 8.0），如果查询条件 <code>没有包含组合索引的第一列</code>，但包含了后续的某些列，传统的索引扫描方法可能无法直接使用这个索引。索引跳跃扫描的原理是在索引的第一列上“跳跃”查找，然后在找到的每个区间内，进一步检查是否满足查询的其他条件。</p><p><strong>原理</strong>：</p><ul><li><code>跳跃动作</code>：在扫描索引过程中，优化器会“跳过”不符合查询条件的索引部分，定位到下一个可能匹配的索引点。</li><li><code>重复跳跃</code>：这个跳跃过程可能会发生多次，直到找到满足所有查询条件的数据。</li><li><code>避免全索引扫描</code>：通过跳跃不满足查询条件的条目，提高索引扫描效率。</li></ul><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/range-optimization.html#range-access-skip-scan">官方例子</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1 (f1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, f2 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">PRIMARY</span> KEY(f1, f2));<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 <span class="hljs-keyword">VALUES</span><br>  (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">1</span>,<span class="hljs-number">5</span>),<br>  (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 <span class="hljs-keyword">SELECT</span> f1, f2 <span class="hljs-operator">+</span> <span class="hljs-number">5</span> <span class="hljs-keyword">FROM</span> t1;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 <span class="hljs-keyword">SELECT</span> f1, f2 <span class="hljs-operator">+</span> <span class="hljs-number">10</span> <span class="hljs-keyword">FROM</span> t1;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 <span class="hljs-keyword">SELECT</span> f1, f2 <span class="hljs-operator">+</span> <span class="hljs-number">20</span> <span class="hljs-keyword">FROM</span> t1;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 <span class="hljs-keyword">SELECT</span> f1, f2 <span class="hljs-operator">+</span> <span class="hljs-number">40</span> <span class="hljs-keyword">FROM</span> t1;<br>ANALYZE <span class="hljs-keyword">TABLE</span> t1;<br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> f1, f2 <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> f2 <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><p>索引跳跃过程：</p><ol><li>获取f1字段第一个唯一值，也就是f1=1。</li><li>构造f1=1 and f2 &gt; 40，进行范围查询。</li><li>获取f1字段第二个唯一值，也就是f1=2。</li><li>构造f1=2 and f2 &gt; 40，进行范围查询。</li><li>一直扫描完f1字段所有的唯一值，最后将结果合并返回。</li></ol><h3 id="索引创建原则"><a class="markdownIt-Anchor" href="#索引创建原则"></a> 索引创建原则</h3><ul><li>在 <code>经常需要搜索</code> 的列上创建索引，可以加快搜索的速度</li><li>针对于常作为查询<code>条件</code>（where）、<code>排序</code>（order by）、<code>分组</code>（group by）操作的字段建立索引</li><li>在经常用在 <code>连接的列</code> 上，这些列主要是一些外键，可以加快连接的速度</li><li>尽量选择 <code>区分度高</code> 的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>在经常需要根据 <code>范围进行搜索</code> 的列上创建索引，因为索引已经排序，其指定的范围是连续的</li><li>在经常需要 <code>排序的列</code> 上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以 <code>覆盖索引</code> ，节省存储空间，避免回表，提高查询效率</li><li>要 <code>控制索引的数量</code> ，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用 <code>NOT NULL约束</code> 它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ul><p><strong>InnoDB</strong>: <span clsss="green-line">最多 <code>64个二级索引</code> 和 <code>一个主键索引</code>, 单个索引最多包含<code>16列</code>。</span></p><h3 id="sql提示"><a class="markdownIt-Anchor" href="#sql提示"></a> SQL提示</h3><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><div class="note note-warning"><p><strong>USE INDEX</strong></p><p><code>USE INDEX</code> 提示可以在 <code>SELECT</code> 查询中使用，让MySQL参考使用指定的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> city use index(idx_city_name) <span class="hljs-keyword">where</span> city_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;深圳&#x27;</span>;<br></code></pre></td></tr></table></figure><p>需要注意的是，虽然 <code>USE INDEX</code> 提示可以用于指定要使用的索引，但它并不能保证 MySQL 实际会使用指定的索引。MySQL 查询优化器会在执行查询时根据统计信息和查询成本进行决策。如果查询优化器认为其他索引更适合执行查询，它可能会忽略 <code>USE INDEX</code> 提示。</p></div><div class="note note-warning"><p><strong>IGNORE INDEX</strong></p><p><code>IGNORE INDEX</code> 用于告诉查询优化器在执行查询时忽略特定的索引。通过使用 <code>IGNORE INDEX</code>，可以让查询优化器绕过指定的索引，而选择其他索引或执行全表扫描来处理查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> city ignore index(idx_user_pro) <span class="hljs-keyword">where</span> city_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;深圳&#x27;</span>;<br></code></pre></td></tr></table></figure><p>通常情况下，MySQL 的查询优化器会根据统计信息和索引选择算法选择最佳的索引，不需要手动干预。只有在特定的情况下，当你确定优化器选择了错误的索引时，才考虑使用 <code>IGNORE INDEX</code> 提示进行干预。</p></div><div class="note note-warning"><p><strong>FORCE INDEX</strong></p><p><code>FORCE INDEX</code> 是 MySQL 中用于强制查询优化器选择特定索引的语句。当你使用 <code>FORCE INDEX</code> 语句时，查询优化器将会忽略其他可能的索引并且只使用指定的索引来执行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> city force index(idx_user_pro) <span class="hljs-keyword">where</span> city_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;深圳&#x27;</span>;<br></code></pre></td></tr></table></figure><p>需要注意，强制使用索引可能导致查询性能下降，因为查询优化器无法选择更有效的索引。</p></div><h2 id="sql性能分析"><a class="markdownIt-Anchor" href="#sql性能分析"></a> SQL性能分析</h2><h3 id="show-status-运行状态"><a class="markdownIt-Anchor" href="#show-status-运行状态"></a> show status 运行状态</h3><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- session 是查看当前会话 ;</span><br><span class="hljs-comment">-- global 是查询全局数据 ;</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>Com_delete</code>: 删除次数。</li><li><code>Com_insert</code>: 插入次数。</li><li><code>Com_select</code>: 查询次数。</li><li><code>Com_update</code>: 更新次数。</li></ul><p><img src="/2022/02/26/Mysql/showStatus.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th><strong>状态名</strong></th><th><strong>作用域</strong></th><th><strong>详细解释</strong></th></tr></thead><tbody><tr><td>Aborted_clients</td><td>Global</td><td>由于客户端没有正确关闭连接导致客户端终止而中断的连接数</td></tr><tr><td>Aborted_connects</td><td>Global</td><td>试图连接到MySQL服务器而失败的连接数</td></tr><tr><td>Binlog_cache_disk_use</td><td>Global</td><td>使用临时二进制日志缓存但超过binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量</td></tr><tr><td>Binlog_cache_use</td><td>Global</td><td>使用临时二进制日志缓存的事务数量</td></tr><tr><td>Bytes_received</td><td>Both</td><td>从所有客户端接收到的字节数。</td></tr><tr><td>Bytes_sent</td><td>Both</td><td>发送给所有客户端的字节数。</td></tr><tr><td>com*</td><td></td><td>各种数据库操作的数量</td></tr><tr><td>Compression</td><td>Session</td><td>客户端与服务器之间只否启用压缩协议</td></tr><tr><td>Connections</td><td>Global</td><td>试图连接到(不管是否成功)MySQL服务器的连接数</td></tr><tr><td>Created_tmp_disk_tables</td><td>Both</td><td>服务器执行语句时在硬盘上自动创建的临时表的数量</td></tr><tr><td>Created_tmp_files</td><td>Global</td><td>mysqld已经创建的临时文件的数量</td></tr><tr><td>Created_tmp_tables</td><td>Both</td><td>服务器执行语句时自动创建的内存中的临时表的数量。如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时 表基于内存而不基于硬盘</td></tr><tr><td>Delayed_errors</td><td>Global</td><td>用INSERT DELAYED写的出现错误的行数(可能为duplicate key)。</td></tr><tr><td>Delayed_insert_threads</td><td>Global</td><td>使用的INSERT DELAYED处理器线程数。</td></tr><tr><td>Delayed_writes</td><td>Global</td><td>写入的INSERT DELAYED行数</td></tr><tr><td>Flush_commands</td><td>Global</td><td>执行的FLUSH语句数。</td></tr><tr><td>Handler_commit</td><td>Both</td><td>内部提交语句数</td></tr><tr><td>Handler_delete</td><td>Both</td><td>行从表中删除的次数。</td></tr><tr><td>Handler_discover</td><td>Both</td><td>MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。</td></tr><tr><td>Handler_prepare</td><td>Both</td><td>A counter for the prepare phase of two-phase commit operations.</td></tr><tr><td>Handler_read_first</td><td>Both</td><td>索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。</td></tr><tr><td>Handler_read_key</td><td>Both</td><td>根据键读一行的请求数。如果较高，说明查询和表的索引正确。</td></tr><tr><td>Handler_read_next</td><td>Both</td><td>按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</td></tr><tr><td>Handler_read_prev</td><td>Both</td><td>按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</td></tr><tr><td>Handler_read_rnd</td><td>Both</td><td>根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。</td></tr><tr><td>Handler_read_rnd_next</td><td>Both</td><td>在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</td></tr><tr><td>Handler_rollback</td><td>Both</td><td>内部ROLLBACK语句的数量。</td></tr><tr><td>Handler_savepoint</td><td>Both</td><td>在一个存储引擎放置一个保存点的请求数量。</td></tr><tr><td>Handler_savepoint_rollback</td><td>Both</td><td>在一个存储引擎的要求回滚到一个保存点数目。</td></tr><tr><td>Handler_update</td><td>Both</td><td>在表内更新一行的请求数。</td></tr><tr><td>Handler_write</td><td>Both</td><td>在表内插入一行的请求数。</td></tr><tr><td>Innodb_buffer_pool_pages_data</td><td>Global</td><td>包含数据的页数(脏或干净)。</td></tr><tr><td>Innodb_buffer_pool_pages_dirty</td><td>Global</td><td>当前的脏页数。</td></tr><tr><td>Innodb_buffer_pool_pages_flushed</td><td>Global</td><td>要求清空的缓冲池页数</td></tr><tr><td>Innodb_buffer_pool_pages_free</td><td>Global</td><td>空页数。</td></tr><tr><td>Innodb_buffer_pool_pages_latched</td><td>Global</td><td>在InnoDB缓冲池中锁定的页数。这是当前正读或写或由于其它原因不能清空或删除的页数。</td></tr><tr><td>Innodb_buffer_pool_pages_misc</td><td>Global</td><td>忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb_buffer_pool_pages_total - Innodb_buffer_pool_pages_free - Innodb_buffer_pool_pages_data。</td></tr><tr><td>Innodb_buffer_pool_pages_total</td><td>Global</td><td>缓冲池总大小（页数）。</td></tr><tr><td>Innodb_buffer_pool_read_ahead_rnd</td><td>Global</td><td>InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。</td></tr><tr><td>Innodb_buffer_pool_read_ahead_seq</td><td>Global</td><td>InnoDB初始化的顺序read-aheads数。当InnoDB执行顺序全表扫描时发生。</td></tr><tr><td>Innodb_buffer_pool_read_requests</td><td>Global</td><td>InnoDB已经完成的逻辑读请求数。</td></tr><tr><td>Innodb_buffer_pool_reads</td><td>Global</td><td>不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。</td></tr><tr><td>Innodb_buffer_pool_wait_free</td><td>Global</td><td>一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。</td></tr><tr><td>Innodb_buffer_pool_write_requests</td><td>Global</td><td>向InnoDB缓冲池的写数量。</td></tr><tr><td>Innodb_data_fsyncs</td><td>Global</td><td>fsync()操作数。</td></tr><tr><td>Innodb_data_pending_fsyncs</td><td>Global</td><td>当前挂起的fsync()操作数。</td></tr><tr><td>Innodb_data_pending_reads</td><td>Global</td><td>当前挂起的读数。</td></tr><tr><td>Innodb_data_pending_writes</td><td>Global</td><td>当前挂起的写数。</td></tr><tr><td>Innodb_data_read</td><td>Global</td><td>至此已经读取的数据数量（字节）。</td></tr><tr><td>Innodb_data_reads</td><td>Global</td><td>数据读总数量。</td></tr><tr><td>Innodb_data_writes</td><td>Global</td><td>数据写总数量。</td></tr><tr><td>Innodb_data_written</td><td>Global</td><td>至此已经写入的数据量（字节）。</td></tr><tr><td>Innodb_dblwr_pages_written</td><td>Global</td><td>已经执行的双写操作数量</td></tr><tr><td>Innodb_dblwr_writes</td><td>Global</td><td>双写操作已经写好的页数</td></tr><tr><td>Innodb_log_waits</td><td>Global</td><td>我们必须等待的时间，因为日志缓冲区太小，我们在继续前必须先等待对它清空</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Innodb_log_write_requests</td><td>Global</td><td>日志写请求数。</td></tr><tr><td>Innodb_log_writes</td><td>Global</td><td>向日志文件的物理写数量。</td></tr><tr><td>Innodb_os_log_fsyncs</td><td>Global</td><td>向日志文件完成的fsync()写数量。</td></tr><tr><td>Innodb_os_log_pending_fsyncs</td><td>Global</td><td>挂起的日志文件fsync()操作数量。</td></tr><tr><td>Innodb_os_log_pending_writes</td><td>Global</td><td>挂起的日志文件写操作</td></tr><tr><td>Innodb_os_log_written</td><td>Global</td><td>写入日志文件的字节数。</td></tr><tr><td>Innodb_page_size</td><td>Global</td><td>编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。</td></tr><tr><td>Innodb_pages_created</td><td>Global</td><td>创建的页数。</td></tr><tr><td>Innodb_pages_read</td><td>Global</td><td>读取的页数。</td></tr><tr><td>Innodb_pages_written</td><td>Global</td><td>写入的页数。</td></tr><tr><td>Innodb_row_lock_current_waits</td><td>Global</td><td>当前等待的待锁定的行数。</td></tr><tr><td>Innodb_row_lock_time</td><td>Global</td><td>行锁定花费的总时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_time_avg</td><td>Global</td><td>行锁定的平均时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_time_max</td><td>Global</td><td>行锁定的最长时间，单位毫秒。</td></tr><tr><td>Innodb_row_lock_waits</td><td>Global</td><td>一行锁定必须等待的时间数。</td></tr><tr><td>Innodb_rows_deleted</td><td>Global</td><td>从InnoDB表删除的行数。</td></tr><tr><td>Innodb_rows_inserted</td><td>Global</td><td>插入到InnoDB表的行数。</td></tr><tr><td>Innodb_rows_read</td><td>Global</td><td>从InnoDB表读取的行数。</td></tr><tr><td>Innodb_rows_updated</td><td>Global</td><td>InnoDB表内更新的行数。</td></tr><tr><td>Key_blocks_not_flushed</td><td>Global</td><td>键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。</td></tr><tr><td>Key_blocks_unused</td><td>Global</td><td>键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存</td></tr><tr><td>Key_blocks_used</td><td>Global</td><td>键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。</td></tr><tr><td>Key_read_requests</td><td>Global</td><td>从缓存读键的数据块的请求数。</td></tr><tr><td>Key_reads</td><td>Global</td><td>从硬盘读取键的数据块的次数。如果Key_reads较大，则Key_buffer_size值可能太小。可以用Key_reads/Key_read_requests计算缓存损失率。</td></tr><tr><td>Key_write_requests</td><td>Global</td><td>将键的数据块写入缓存的请求数。</td></tr><tr><td>Key_writes</td><td>Global</td><td>向硬盘写入将键的数据块的物理写操作的次数。</td></tr><tr><td>Last_query_cost</td><td>Session</td><td>用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。 默认值是0。Last_query_cost具有会话范围。</td></tr><tr><td>Max_used_connections</td><td>Global</td><td>服务器启动后已经同时使用的连接的最大数量。</td></tr><tr><td>ndb*</td><td></td><td>ndb集群相关</td></tr><tr><td>Not_flushed_delayed_rows</td><td>Global</td><td>等待写入INSERT DELAY队列的行数。</td></tr><tr><td>Open_files</td><td>Global</td><td>打开的文件的数目。</td></tr><tr><td>Open_streams</td><td>Global</td><td>打开的流的数量(主要用于记录)。</td></tr><tr><td>Open_table_definitions</td><td>Global</td><td>缓存的.frm文件数量</td></tr><tr><td>Open_tables</td><td>Both</td><td>当前打开的表的数量。</td></tr><tr><td></td><td></td><td></td></tr><tr><td>Opened_files</td><td>Global</td><td>文件打开的数量。不包括诸如套接字或管道其他类型的文件。 也不包括存储引擎用来做自己的内部功能的文件。</td></tr><tr><td>Opened_table_definitions</td><td>Both</td><td>已经缓存的.frm文件数量</td></tr><tr><td>Opened_tables</td><td>Both</td><td>已经打开的表的数量。如果Opened_tables较大，table_cache 值可能太小。</td></tr><tr><td>Prepared_stmt_count</td><td>Global</td><td>当前的预处理语句的数量。 (最大数为系统变量: max_prepared_stmt_count)</td></tr><tr><td>Qcache_free_blocks</td><td>Global</td><td>查询缓存内自由内存块的数量。</td></tr><tr><td>Qcache_free_memory</td><td>Global</td><td>用于查询缓存的自由内存的数量。</td></tr><tr><td>Qcache_hits</td><td>Global</td><td>查询缓存被访问的次数。</td></tr><tr><td>Qcache_inserts</td><td>Global</td><td>加入到缓存的查询数量。</td></tr><tr><td>Qcache_lowmem_prunes</td><td>Global</td><td>由于内存较少从缓存删除的查询数量。</td></tr><tr><td>Qcache_not_cached</td><td>Global</td><td>非缓存查询数(不可缓存，或由于query_cache_type设定值未缓存)。</td></tr><tr><td>Qcache_queries_in_cache</td><td>Global</td><td>登记到缓存内的查询的数量。</td></tr><tr><td>Qcache_total_blocks</td><td>Global</td><td>查询缓存内的总块数。</td></tr><tr><td>Queries</td><td>Both</td><td>服务器执行的请求个数，包含存储过程中的请求。</td></tr><tr><td>Questions</td><td>Both</td><td>已经发送给服务器的查询的个数。</td></tr><tr><td>Rpl_status</td><td>Global</td><td>失败安全复制状态(还未使用)。</td></tr><tr><td>Select_full_join</td><td>Both</td><td>没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引</td></tr><tr><td>Select_full_range_join</td><td>Both</td><td>在引用的表中使用范围搜索的联接的数量。</td></tr><tr><td>Select_range</td><td>Both</td><td>在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。</td></tr><tr><td>Select_range_check</td><td>Both</td><td>在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。</td></tr><tr><td>Select_scan</td><td>Both</td><td>对第一个表进行完全扫描的联接的数量。</td></tr><tr><td>Slave_heartbeat_period</td><td>Global</td><td>复制的心跳间隔</td></tr><tr><td>Slave_open_temp_tables</td><td>Global</td><td>从服务器打开的临时表数量</td></tr><tr><td>Slave_received_heartbeats</td><td>Global</td><td>从服务器心跳数</td></tr><tr><td>Slave_retried_transactions</td><td>Global</td><td>本次启动以来从服务器复制线程重试次数</td></tr><tr><td>Slave_running</td><td>Global</td><td>如果该服务器是连接到主服务器的从服务器，则该值为ON。</td></tr><tr><td>Slow_launch_threads</td><td>Both</td><td>创建时间超过slow_launch_time秒的线程数。</td></tr><tr><td>Slow_queries</td><td>Both</td><td>查询时间超过long_query_time秒的查询的个数。</td></tr><tr><td>Sort_merge_passes</td><td>Both</td><td>排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。</td></tr><tr><td>Sort_range</td><td>Both</td><td>在范围内执行的排序的数量。</td></tr><tr><td>Sort_rows</td><td>Both</td><td>已经排序的行数。</td></tr><tr><td>Sort_scan</td><td>Both</td><td>通过扫描表完成的排序的数量。</td></tr><tr><td>ssl＊</td><td></td><td>ssl连接相关</td></tr><tr><td>Table_locks_immediate</td><td>Global</td><td>立即获得的表的锁的次数。</td></tr><tr><td>Table_locks_waited</td><td>Global</td><td>不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。</td></tr><tr><td>Threads_cached</td><td>Global</td><td>线程缓存内的线程的数量。</td></tr><tr><td>Threads_connected</td><td>Global</td><td>当前打开的连接的数量。</td></tr><tr><td>Threads_created</td><td>Global</td><td>创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。</td></tr><tr><td>Threads_running</td><td>Global</td><td>激活的（非睡眠状态）线程数。</td></tr><tr><td>Uptime</td><td>Global</td><td>服务器已经运行的时间（以秒为单位）。</td></tr><tr><td>Uptime_since_flush_status</td><td>Global</td><td>最近一次使用FLUSH STATUS 的时间（以秒为单位）。</td></tr></tbody></table><h3 id="慢查询日志"><a class="markdownIt-Anchor" href="#慢查询日志"></a> 慢查询日志</h3><p>慢查询日志是一种记录执行时间超过指定阈值的SQL语句的日志。它可以帮助我们定位执行效率较低的查询，并进行性能优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看是否开启慢查询日志<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>作用</strong>：</p><ul><li><code>性能优化</code>：通过分析慢查询日志，可以找出执行效率较低的SQL语句，针对性地进行优化，提升数据库性能。</li><li><code>查询分析</code>：慢查询日志记录了执行时间超过指定阈值的SQL语句，可以用于查询分析、性能瓶颈定位和故障排查等工作。</li></ul><p class="note note-primary">开启慢查询日志</p><p>如果要开启慢查询日志，需要在MySQL的配置文件（my.cnf）中配置如下信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 设置为1表示开启慢查询日志</span><br><span class="hljs-attr">slow_query_log</span> = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 指定慢查询日志的文件路径和文件名</span><br><span class="hljs-attr">slow_query_log_file</span> = /path/to/slow-query.log<br><br><span class="hljs-comment"># 指定一个阈值，单位为秒，超过该阈值的SQL语句将被记录到慢查询日志中</span><br><span class="hljs-attr">long_query_time</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>配置完毕之后，通过以下指令重新启动MySQL服务器即可。</p><p><strong>慢查询日志的格式</strong>：</p><ul><li><code>执行时间</code>：Time字段，以秒为单位。</li><li><code>锁等待时间</code>：Lock_time字段，以秒为单位。</li><li><code>返回行数</code>：Rows_sent字段，表示查询结果返回的行数。</li><li><code>扫描行数</code>：Rows_examined字段，表示查询过程中扫描的行数。</li><li><code>SQL语句</code>：Query字段，记录执行的SQL语句。</li></ul><h3 id="profile详情"><a class="markdownIt-Anchor" href="#profile详情"></a> profile详情</h3><p>MySQL的慢查询日志是一种记录执行时间超过指定阈值的SQL语句的日志，而Profile是另一种用于分析SQL查询性能的工具。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 是否支持profile<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@have</span>_profiling;<br><br># 是否开启profile<br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@profiling</span>;<br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2022/02/26/Mysql/profile.png" srcset="/img/loading.gif" lazyload alt></div><div class="group-image-wrap"><img src="/2022/02/26/Mysql/profiling.png" srcset="/img/loading.gif" lazyload alt></div></div></div><p><strong>开启 profile</strong>：</p><ul><li>在执行SQL查询语句时，可以使用 <code>SET PROFILING = 1;</code> 命令来开启Profile功能。</li><li>开启Profile后，MySQL会记录查询的执行信息，包括每个阶段的耗时和资源消耗。</li></ul><p><strong>查询并获取Profile信息</strong>：</p><p>执行一系列Sql的操作，然后通过如下指令查看指令的执行耗时。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看每一条SQL的耗时基本情况</span><br><span class="hljs-keyword">show</span> profiles;<br><br><span class="hljs-comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id;<br><br><span class="hljs-comment">-- 查看指定query_id的SQL语句CPU的使用情况</span><br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><h3 id="explain-执行计划"><a class="markdownIt-Anchor" href="#explain-执行计划"></a> explain 执行计划</h3><p>EXPLAIN 是一种用于分析查询执行计划的工具。通过EXPLAIN命令，我们可以获取MySQL优化器在执行查询时选择的查询执行计划，从而了解查询的执行方式、索引使用情况以及可能存在的性能问题。</p><table><thead><tr><th>id</th><th>Columns</th><th>JSON Name</th><th>Meaning</th></tr></thead><tbody><tr><td>1</td><td>id</td><td>select_id</td><td>查询的标识符，每个查询都有一个唯一的标识符</td></tr><tr><td>2</td><td>select_type</td><td>None</td><td>查询的类型，常见的类型有SIMPLE、PRIMARY、SUBQUERY、DERIVED等</td></tr><tr><td>3</td><td>table</td><td>table_name</td><td>查询涉及的表名</td></tr><tr><td>4</td><td>partitions</td><td>partitions</td><td>查询涉及的分区信息</td></tr><tr><td>5</td><td><code>type</code></td><td>access_type</td><td>访问类型，表示MySQL在访问表时使用的策略，常见的类型有ALL、INDEX、RANGE、REF等</td></tr><tr><td>6</td><td><code>possible_keys</code></td><td>possible_keys</td><td>可能使用到的索引</td></tr><tr><td>7</td><td><code>key</code></td><td>key</td><td>经过优化器评估最终使用的索引</td></tr><tr><td>8</td><td>key_len</td><td>key_length</td><td>使用到的索引长度</td></tr><tr><td>9</td><td>ref</td><td>ref</td><td>与索引比较的列或常数</td></tr><tr><td>10</td><td>rows</td><td>rows</td><td>rows_examined，要得到最终记录索要扫描经过的记录数</td></tr><tr><td>11</td><td>filtered</td><td>filtered</td><td>通过条件过滤后的行百分比</td></tr><tr><td>12</td><td><code>Extra</code></td><td>None</td><td>额外的信息说明</td></tr></tbody></table><p><img src="/2022/02/26/Mysql/explain.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">select_type</p><p>​	表示查询中每个select子句的类型</p><p><img src="/2022/02/26/Mysql/select_type.jpg" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th>id</th><th>select_type value</th><th>JSON name</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>None</td><td>简单的SELECT语句（不包括UNION操作或子查询操作）</td></tr><tr><td>2</td><td>PRIMARY</td><td>None</td><td>PRIMARY：最外层的SELECT语句</td></tr><tr><td>3</td><td>UNION</td><td>None</td><td>UNION：UNION操作中的内层SELECT语句（内层的SELECT语句与外层的SELECT语句没有依赖关系）</td></tr><tr><td>4</td><td>DEPENDENT UNION</td><td>dependent(true)</td><td>DEPENDENT UNION：UNION操作中的内层SELECT语句（内层的SELECT语句与外层的SELECT语句有依赖关系）</td></tr><tr><td>5</td><td>UNION RESULT</td><td>union_result</td><td>UNION RESULT：UNION操作的结果，id值通常为NULL</td></tr><tr><td>6</td><td>SUBQUERY</td><td>None</td><td>SUBQUERY：子查询中的第一个SELECT语句（如果有多个子查询存在）</td></tr><tr><td>7</td><td>DEPENDENT SUBQUERY</td><td>dependent(true)</td><td>DEPENDENT SUBQUERY：子查询中的第一个SELECT语句，但依赖于外层的表（如果有多个子查询存在）</td></tr><tr><td>8</td><td>DERIVED</td><td>None</td><td>DERIVED：作为驱动表的SELECT子查询（子查询位于FROM子句）</td></tr><tr><td>9</td><td>MATERIALIZED</td><td>materialized_form_subquery</td><td>MATERIALIZED：被物化的子查询</td></tr><tr><td>10</td><td>UNCACHEABLE SUBQUERY</td><td>cacheable(false)</td><td>UNCACHEABLE SUBQUERY：对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）</td></tr><tr><td>11</td><td>UNCACHEABLE UNION</td><td>cacheable(false)</td><td>UNCACHEABLE UNION：UNION操作中的不可被物化的内层子查询（类似于UNCACHEABLE SUBQUERY）</td></tr></tbody></table><p class="note note-primary">type</p><p><code>type</code> 字段描述了查询执行计划中MySQL选择的访问方法，也称为访问类型（access type）。它指的是MySQL在执行查询时选择的如何访问表中数据的方式。</p><p>性能由好到坏排序：</p><table><thead><tr><th>id</th><th>type value</th><th>Meaning</th></tr></thead><tbody><tr><td>1</td><td>system</td><td>表示使用系统表，通常用于内部操作，不涉及具体的数据表。</td></tr><tr><td>2</td><td>const</td><td>表示通过常量条件（例如主键或唯一索引的等值查询）来访问表的一行数据。这是最快的访问方法之一。</td></tr><tr><td>3</td><td>eq_ref</td><td>表示在多表连接中，被驱动表的连接列上有主键或唯一索引的检索，用于精确匹配。</td></tr><tr><td>4</td><td>ref</td><td>表示使用非唯一索引或唯一索引的非唯一部分进行的等值查询。</td></tr><tr><td>5</td><td>range</td><td>表示使用索引进行范围查询，通常用于 BETWEEN、&gt;、&lt; 等条件的查询。</td></tr><tr><td>6</td><td>index</td><td>表示索引扫描，与&quot;ALL&quot;类型类似，但只扫描索引树，而不读取实际数据行。</td></tr><tr><td>7</td><td>all</td><td>表示全表扫描，即访问表的所有数据。这是最慢的访问方法之一，应尽量避免。</td></tr></tbody></table><p class="note note-primary">Extra</p><table><thead><tr><th>id</th><th>type value</th><th>Meaning</th></tr></thead><tbody><tr><td>1</td><td>const row not found</td><td>所要查询的表为空</td></tr><tr><td>2</td><td>Distinct</td><td>mysql正在查询distinct值，因此当它每查到一个distinct值之后就会停止当前组的搜索，去查询下一个值</td></tr><tr><td>3</td><td>Impossible WHERE</td><td>where条件总为false，表里没有满足条件的记录</td></tr><tr><td>4</td><td>Impossible WHERE noticed after reading const tables</td><td>在优化器评估了const表之后，发现where条件均不满足</td></tr><tr><td>5</td><td>no matching row in const table</td><td>当前join的表为const表，不能匹配</td></tr><tr><td>6</td><td>Not exists</td><td>优化器发现内表记录不可能满足where条件</td></tr><tr><td>7</td><td>Select tables optimized away</td><td>在没有group by子句时，对于MyISAM的select count(*)操作，或者当对于min(),max()的操作可以利用索引优化，优化器发现只会返回一行。</td></tr><tr><td>8</td><td><code>Using filesort</code></td><td><code>使用filesort来进行order by操作,出现filesort就说明拍序列没使用上索引</code></td></tr><tr><td>9</td><td><code>Using index</code></td><td><code>覆盖索引</code></td></tr><tr><td>10</td><td>Using index for group-by</td><td>对于group by列或者distinct列，可以利用索引检索出数据，而不需要去表里查数据、分组、排序、去重等等</td></tr><tr><td>11</td><td>Using join buffer</td><td>之前的表连接在nested loop之后放进join buffer，再来和本表进行join。适用于本表的访问type为range，index或all</td></tr><tr><td>12</td><td>Using sort_union,using union,using intersect</td><td>index_merge的三种情况</td></tr><tr><td>13</td><td>Using temporary</td><td>使用了临时表来存储中间结果集，适用于group by，distinct，或order by列为不同表的列。</td></tr><tr><td>14</td><td>Using where</td><td>在存储引擎层检索出记录后，在server利用where条件进行过滤，并返回给客户端</td></tr><tr><td>15</td><td><code>Using index condition</code></td><td>这是MySQL 5.6出来的新特性，叫做<code>索引条件下推</code></td></tr></tbody></table><h2 id="sql优化"><a class="markdownIt-Anchor" href="#sql优化"></a> SQL优化</h2><h3 id="insert-优化"><a class="markdownIt-Anchor" href="#insert-优化"></a> Insert 优化</h3><p class="note note-primary">单条插入效率问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br></code></pre></td></tr></table></figure><p>当对MySQL数据库进行 <code>大量</code> 的单条数据插入时，每条 <code>INSERT</code> 语句都被视作一个独立的操作。这意味着：</p><ul><li><code>效率低下</code>：每条 <code>INSERT</code> 语句都被视为一个独立的隐式事务，这意味着每次插入都涉及事务的开启和提交。</li><li><code>占用连接资源</code>：大量的单条插入语句占用更多的数据库连接资源，从而影响数据库的整体性能。</li><li><code>网络延迟累积</code>：单条插入语句占用一个数据库连接，单独与数据库交互。在大批量插入的情境下，会话延迟会累积，增加总的数据插入时间。</li></ul><p class="note note-primary">批量插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span><br>(...),<br>(...),<br>(...);<br></code></pre></td></tr></table></figure><p><strong>优势</strong>：</p><ul><li><code>减少网络延迟</code>：多条记录作为单个操作发送到数据库的，减少了与数据库的网络交互次数。</li><li><code>减少事务开销</code>：批量插入允许多条记录在一个事务中被插入，减少了事务提交和日志写入的次数，提高写入效率。</li><li><code>优化索引更新</code>：量插入减少了索引更新的次数，因为它在插入多条记录后一次性更新索引。</li><li><code>减少CPU占用</code>：批量插入一次性处理事务和索引的维护，避免频繁提交事务和维护索引带来的额外性能开销。</li></ul><p><strong>注意</strong>：</p><ul><li><code>批次大小</code>：通常建议的批次大小在500至1000条记录之间，过大的批次可能导致内存消耗增加或事务超时，而过小的批次则无法充分利用批量插入的优势。</li><li><code>大小限制</code>：单个<code>INSERT</code>语句的长度可能受到SQL语句大小限制（由<code>max_allowed_packet</code>参数控制）。</li></ul><p class="note note-primary">手动控制事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test <span class="hljs-keyword">values</span>(...);<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>在进行批量插入时，还有一种优化手段就是手段控制事务，将多条 Insert 语句在一个事务中提交。</p><p><strong>优势</strong>：</p><ul><li><code>减少事务开销</code>：批量插入允许多条记录在一个事务中被插入，减少了事务提交和日志写入的次数，提高写入效率。</li><li><code>灵活性</code>：可以在单独的 <code>INSERT</code> 语句间进行更复杂的操作，如条件逻辑、错误处理等。</li><li><code>适应性</code>：对于不能一次性装入一个<code>INSERT</code>语句的大量数据，可以分批进行插入。</li></ul><p class="note note-primary">load data infile</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pavel101/article/details/79489123">Mybatis 使用 load data infile</a></p><p><img src="/2022/02/26/Mysql/load.png" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 客户端连接服务端时，加上参数 -–local-infile<br>mysql –-local-infile -u root -p<br>-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>-- 执行load指令将准备好的数据，加载到表结构中<br>load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;<br>-- 意思是文件中每个字段用 `,` 分割，每行用 `\n` 分割<br></code></pre></td></tr></table></figure><p><code>LOAD DATA INFILE</code> 是用于高效地从文件中（CSV）批量加载数据到数据库表的命令。它特别适用于快速导入大量数据，比如在数据迁移或大规模数据处理场景中。</p><p><strong>优势</strong>：</p><ul><li><code>导入高效</code>：<code>LOAD DATA INFILE</code> 是导入大量数据到 MySQL 表中最快的方法之一。它比逐行使用 <code>INSERT</code> 语句或通过客户端脚本导入数据快得多。</li><li><code>支持大数据集</code>：对于非常大的数据集，使用 <code>LOAD DATA INFILE</code> 可以有效地处理和导入数据，而不必担心内存溢出或其他资源限制。</li><li><code>事务性</code>：整个 <code>LOAD DATA INFILE</code> 操作可以作为一个单独的事务进行处理，这有助于保持数据一致性。</li></ul><h3 id="order-by-优化"><a class="markdownIt-Anchor" href="#order-by-优化"></a> Order By 优化</h3><p>MySQL的排序，有两种方式：</p><ul><li><code>Using filesort</code> :<ul><li>当无法直接通过索引来满足排序要求时，会使用一种叫做 <code>Filesort</code> 的算法来进行排序，可以在内存中或者在磁盘上进行。</li><li>Filesort 排序会比索引排序效率低，尤其是当需要处理的数据量大而无法完全放入内存时。</li></ul></li><li><code>Using temporary</code> :<ul><li>没有适合排序的索引,在内存创建临时表并在其中排序。</li></ul></li><li><code>Using index</code> :<ul><li>当排序要求可以通过已有的索引顺序直接满足时，MySQL 会使用 <code>Using index</code> 方式来直接从索引中读取有序数据。这种情况下，MySQL 利用了索引的有序性质，无需额外进行排序操作。</li></ul></li></ul><p><strong>排序优化</strong>：</p><ul><li><p><code>利用索引进行排序</code>：根据排序字段建立合适的索引，多字段排序时，也遵循 <code>最左前缀法则</code>，避免了额外的排序步骤。</p></li><li><p><code>索引覆盖排序</code>：直接使用索引中的数据来完成查询，包括排序操作。</p></li><li><p><code>对索引字段指定排序方式</code>：多字段排序, 需要按照实际需求，可为每个字段指定升降序（ASC/DESC）。</p></li><li><p><code>调整排序缓冲区大小</code>：可以调整MySQL的排序缓冲区大小（<code>sort_buffer_size</code>参数，256KB），以适应特定的查询需求。</p></li></ul><p class="note note-primary">索引列排序</p><p>如果 <code>ORDER BY</code> 子句中的列完全匹配索引列，并且查询条件允许使用该索引，MySQL就会利用索引的有序性进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test2 (<br> id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br> user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br> age <span class="hljs-type">int</span>,<br> address <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>)<br>);<br><span class="hljs-keyword">create</span> index idx_age_user_name <span class="hljs-keyword">on</span> test2(age, user_name);<br><br>explain<br><span class="hljs-keyword">select</span> age, user_name<br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age; # 使用索引列排序<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E6%8E%92%E5%BA%8F%E7%B4%A2%E5%BC%95.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">遵循最左匹配原则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain<br><span class="hljs-keyword">select</span> user_name<br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>  address <span class="hljs-keyword">desc</span>, user_name <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><p>这时候索引排序不生效，没有遵循最左匹配原则。</p><p class="note note-primary">升降序排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain<br><span class="hljs-keyword">select</span> age, user_name<br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span>, user_name <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E5%8D%87%E9%99%8D%E5%BA%8F.png" srcset="/img/loading.gif" lazyload alt></p><p>此时 age 字段使用索引排序，user_name 字段使用 FileSort，因为索引在创建的时候默认是按照 <code>ASC</code> 排序的，优化此SQL可以重新创建一个索引，指定不同字段的排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_age_username_2 <span class="hljs-keyword">on</span> test2(age <span class="hljs-keyword">asc</span>, user_name <span class="hljs-keyword">desc</span>)<br></code></pre></td></tr></table></figure><p>再次执行SQL执行计划</p><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F3.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="group-by-优化"><a class="markdownIt-Anchor" href="#group-by-优化"></a> Group By 优化</h3><p>对 <code>GROUP BY</code> 子句的优化主要目的是提高数据聚合查询的效率，以下是一些针对<code>GROUP BY</code>查询的优化技巧：</p><ul><li><code>使用索引</code>：如果<code>GROUP BY</code>子句中的列已经被索引，MySQL可以直接使用索引进行分组操作，从而提高效率。</li><li><code>索引覆盖</code>：如果查询中的过滤条件列和 <code>GROUP BY</code> 列全部包含在一个索引中，可以实现索引覆盖。</li><li><code>防止滥用HAVING子句</code>：<code>HAVING</code>子句可以用来过滤分组后的结果，但如果能通过 <code>WHERE</code> 子句提前过滤数据，则更为高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test<br>(<br>    id        <span class="hljs-type">int</span> auto_increment<br>        <span class="hljs-keyword">primary</span> key,<br>    user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">null</span>,<br>    age       <span class="hljs-type">int</span>         <span class="hljs-keyword">null</span>,<br>    address   <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">null</span><br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">from</span> test<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> age, user_name<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E5%88%86%E7%BB%84.png" srcset="/img/loading.gif" lazyload alt></p><p>在额外信息中我们看到 <code>Using temporary</code>，意思是使用临时表进行分组或排序，其过程比较耗时。</p><p class="note note-primary">使用索引分组</p><p>前提：满足<code>索引覆盖</code></p><p>创建组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_age_user_name <span class="hljs-keyword">on</span> test(age, user_name);<br></code></pre></td></tr></table></figure><p>再次执行执行计划。</p><p><img src="/2022/02/26/Mysql/%E7%B4%A2%E5%BC%95%E5%88%86%E7%BB%84.png" srcset="/img/loading.gif" lazyload alt="索引分组"></p><p>说明使用了索引分组。</p><p class="note note-primary">最左匹配原则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">from</span> test<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> user_name;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E5%88%86%E7%BB%842.png" srcset="/img/loading.gif" lazyload alt="因为没有遵循索引的最左匹配原则，使用到了临时表排序"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">from</span> test<br><span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> user_name;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/Group3.png" srcset="/img/loading.gif" lazyload alt="因为where条件使用到了age,遵循了最左匹配原则"></p><h3 id="limit-优化"><a class="markdownIt-Anchor" href="#limit-优化"></a> Limit 优化</h3><p>在使用 <code>LIMIT</code> 进行分页查询时，尤其是深度分页（例如：<code>LIMIT 100000, 20</code>），MySQL需要先检索出前100020条记录，然后丢弃前100000条，这导致效率低下。</p><p class="note note-primary">索引覆盖和表子查询优化</p><p>利用索引覆盖和表子查询可以有效地优化深度分页的性能：</p><ul><li>先在子查询中使用 <code>LIMIT</code> 和 <code>索引覆盖</code> 定位到所需的数据行的索引或主键。</li><li>然后在外层查询中根据这些索引或主键检索完整的数据行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> sys_user a <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> sys_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">9000000</span>, <span class="hljs-number">20</span>) b <span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：确保子查询中的<code>ORDER BY</code>字段是索引覆盖的，这样可以提高定位效率。子查询的 <code>ORDER BY</code> 确保了数据的正确排序。</p><p class="note note-primary">主键索引优化</p><p>对于深度分页：</p><ul><li>记录上一页的最大ID值。</li><li>在后续查询中使用这个ID作为过滤条件，避免了 <code>LIMIT</code> 中过大的偏移量。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> sys_user a <span class="hljs-keyword">join</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> #&#123;maxId&#125; <br>limit <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：使用这种方法时，确保查询保持了逻辑上的连续性和一致性。这种方式适用于基于递增ID的连续分页，但可能不适用于需要复杂排序的场景。</p><h3 id="count-优化"><a class="markdownIt-Anchor" href="#count-优化"></a> Count 优化</h3><p>如果数据量很大，在执行count操作时，是非常耗时的</p><ul><li><code>MyISAM存储引擎</code>：在处理简单的 <code>COUNT(*)</code> 查询时效率更高，因为它可以直接读取存储的行数。然而，在处理带条件的 <code>COUNT()</code>查询时，MyISAM的效率也会下降，因为需要遍历符合条件的数据行。</li><li><code>InnoDB存储引擎</code>：在执行任何类型的 <code>COUNT()</code> 操作时通常效率较低，无论是带条件还是不带条件的查询。这是因为InnoDB需要遍历数据行来确保事务的可见性，而不是直接读取表的总行数。</li></ul><p class="note note-primary">Count用法</p><table><thead><tr><th><code>COUNT</code>用法</th><th>含义</th></tr></thead><tbody><tr><td><code>COUNT(主键)</code></td><td>InnoDB引擎会遍历整张表，把每一行的主键ID值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加。</td></tr><tr><td><code>COUNT(字段)</code></td><td><strong>没有NOT NULL约束</strong>：InnoDB引擎会遍历整张表，把每一行的字段值都取出来，返回给服务层，服务层判断是否为NULL，不为NULL时，计数累加。<br><strong>有NOT NULL约束</strong>：InnoDB引擎会遍历整张表，把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr><tr><td><code>COUNT(数字)</code></td><td>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</td></tr><tr><td><code>COUNT(*)</code></td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，<code>COUNT(字段)</code> &lt; <code>COUNT(主键 ID)</code> &lt; <code>COUNT(1)</code> ≈ <code>COUNT(*)</code>，所以尽量使用 <code>COUNT(*)</code>。</p><h3 id="update-优化"><a class="markdownIt-Anchor" href="#update-优化"></a> Update 优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> sys_user <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test1&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>锁升级问题</code>：在执行上述SQL时，如果 <code>name</code> 字段没有索引，InnoDB可能无法有效地定位需要更新的行，导致MySQL对更多的行甚至整个表加锁，从而影响性能。</li><li><code>行锁与索引</code>：InnoDB的行锁是基于索引的。如果WHERE子句中使用的字段没有索引，InnoDB可能无法使用行锁，而是使用更粗粒度的锁，如表锁。</li></ul><p><code>注意</code>：<span class="green-line">InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 </span>，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>因此在进行 <code>Update</code> <code>Delete</code> 操作时尽量优先使用 <code>主键</code>，没有主键也要使用<code>索引字段</code>操作，防止行锁升级表锁。</p><p><strong>优化策略</strong>：</p><ol><li><code>使用索引</code>：为 <code>UPDATE</code> 操作中的WHERE子句中的字段添加索引。在本例中，为 <code>name</code> 字段添加索引可以帮助InnoDB更高效地定位到需要更新的行，减少锁的粒度。</li><li><code>优先使用主键</code>：在可能的情况下，使用主键进行 <code>UPDATE</code> 和 <code>DELETE</code> 操作。主键索引是最高效的，可以最大程度地减少锁竞争。</li><li><code>避免大范围更新</code>：避免一次性更新大量行，这可能导致锁竞争和性能下降。如果需要，可以分批次执行更新。</li><li><code>监控锁等待</code>：使用性能监控工具观察锁等待情况，以识别和解决性能瓶颈。</li><li><code>考虑查询效率</code>：确保<code>UPDATE</code>查询尽可能高效，以减少锁持有时间。</li><li><code>事务管理</code>：合理管理事务，避免长事务，因为长事务会持有锁更长时间，增加锁竞争。</li></ol><h3 id="not-in-优化"><a class="markdownIt-Anchor" href="#not-in-优化"></a> NOT IN 优化</h3><p>查询 <code>address</code> 表中不存在于 <code>user</code> 表的地址。</p><p>原始SQL示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> address<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> address_id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>);<br></code></pre></td></tr></table></figure><p><strong>优化方法</strong>：</p><ol><li><p><code>使用 LEFT JOIN</code>：使用 <code>LEFT JOIN</code> 代替 <code>NOT IN</code> 可以提高查询效率，特别是当子查询返回的结果集较大时。</p></li><li><p><code>优化后的SQL</code>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> a.*<br><span class="hljs-keyword">FROM</span> address a<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> b <span class="hljs-keyword">ON</span> a.id = b.address_id<br><span class="hljs-keyword">WHERE</span> b.id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>使用索引</code>：确保 <code>address</code> 表的 <code>id</code> 列和 <code>user</code> 表的 <code>address_id</code> 列都有索引。这有助于提高 <code>JOIN</code> 操作的效率。</p></li></ol><h3 id="or-优化"><a class="markdownIt-Anchor" href="#or-优化"></a> OR 优化</h3><p>原始SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TB1 <span class="hljs-keyword">WHERE</span> c1 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span> <span class="hljs-keyword">OR</span> c2 <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>优化方法</strong>：</p><ol><li><p><code>使用UNION代替OR</code>：当 <code>OR</code> 条件中的每个列都有索引时，可以使用 <code>UNION</code> 来代替 <code>OR</code>，以提高查询效率。这是因为 <code>OR</code> 可能导致索引失效，而 <code>UNION</code> 可以分别利用各个列上的索引。</p></li><li><p><code>优化后的SQL</code>：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> TB1 <span class="hljs-keyword">WHERE</span> c1 = <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> TB1 <span class="hljs-keyword">WHERE</span> c2 = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ol><p>确保 <code>c1</code> 和 <code>c2</code> 上各自有索引，这样每个分开的查询都能高效地利用索引。</p><h3 id="主键优化"><a class="markdownIt-Anchor" href="#主键优化"></a> 主键优化</h3><p>在InnoDB中，表数据按主键顺序存储。如果主键插入顺序是随机的，可能导致页频繁分裂，进而影响性能。这是因为每次插入都可能需要重新整理页中的数据以保持顺序。</p><p class="note note-primary">页分裂</p><p><img src="/2022/02/26/Mysql/%E9%A1%B5%E5%88%86%E8%A3%821.png" srcset="/img/loading.gif" lazyload alt="乱序插入"></p><p>上图是一个主键乱序插入的场景，<code>1#page</code> 和 <code>2#page</code> 此时已经存满了，但是此时需要插入一条id为50的数据，由于聚簇索引（B+树）数据是根据id排序的，50应该插入到47后面的位置，页如果存储不了则会进行分裂。</p><p><img src="/2022/02/26/Mysql/%E9%A1%B5%E5%88%86%E8%A3%82.png" srcset="/img/loading.gif" lazyload alt="页分裂"></p><p>页分裂是一种耗费性能的操作，因为它涉及到数据移动和页指针的更新。在主键乱序插入的场景中，页分裂尤为频繁。</p><p class="note note-primary">页合并</p><p>当我们对已有数据进行删除时，具体的效果如下:</p><p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用（自由空间链表）。</p><p><img src="/2022/02/26/Mysql/%E9%A1%B5%E5%90%88%E5%B9%B6.png" srcset="/img/loading.gif" lazyload alt></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><p><img src="/2022/02/26/Mysql/%E9%A1%B5%E5%90%88%E5%B9%B62.png" srcset="/img/loading.gif" lazyload alt="页合并"></p><p>页合并通常在页中大量数据被删除后发生，这可以减少存储空间的浪费。页合并也是一个性能密集型操作，因为它可能涉及数据移动和页重新组织。</p><p class="note note-primary">主键选择</p><ul><li><strong><code>使用自增主键</code></strong>：自增主键是最佳选择，特别是对于InnoDB存储引擎。它们保证新插入的数据总是添加到索引的末尾，避免页分裂并提高插入效率。</li><li><strong><code>降低主键长度</code></strong>：在满足业务需求的情况下，应尽量减少主键长度。较短的主键可以减少索引占用的空间，提高数据处理效率。例如，选择<code>INT</code>而非<code>BIGINT</code>可以节省空间。</li><li><strong><code>单调递增的主键策略</code></strong>：如果使用自定义生成的主键，应确保它是单调递增的。这样可以减少随机插入导致的页分裂，从而优化插入性能。</li><li><strong><code>避免使用UUID作为主键</code></strong>：尽管UUID在全局唯一性方面表现优秀，其高度随机性可能导致频繁的页分裂，并增加索引大小。在InnoDB中，尤其要注意这一点。如果必须使用UUID，考虑优化其生成方式以减少对性能的影响。</li></ul><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>在MySQL中，锁是用来管理多个用户或进程同时访问数据库时数据一致性和完整性的机制。MySQL支持多种类型的锁，不同的存储引擎支持不同的锁机制。</p><p class="note note-primary">MySql中的锁</p><ol><li><strong><code>全局锁（Global Locks）</code></strong><ul><li><code>描述</code>：全局锁会锁定整个数据库实例，阻止对数据库实例的所有修改操作。它通常用于全库导出或其他维护任务，以确保数据一致性。</li><li><code>用途</code>：例如，<code>FLUSH TABLES WITH READ LOCK</code> 是设置全局读锁的命令，用于创建数据库的全备份。</li></ul></li><li><strong><code>表锁（Table Locks）</code></strong><ul><li><code>描述</code>：表锁会锁定整张表，阻止对该表的并发写操作。在MyISAM和InnoDB使用非索引修改数据中常见。</li><li><code>用途</code>：适用于读多写少的场景。读操作不阻塞其他读操作，但写操作会阻塞所有其他读写操作。</li></ul></li><li><strong><code>行锁（Row-Level Locks）</code></strong><ul><li><code>描述</code>：行锁会锁定单个或多个数据行。InnoDB存储引擎支持行锁，它允许高度并发的数据访问。</li><li><code>用途</code>：适用于事务性操作，减少锁定资源的数量，提高并发访问性能。</li></ul></li><li><strong><code>间隙锁（Gap Locks）</code></strong><ul><li><code>描述</code>：间隙锁不锁定实际的数据行，而是锁定索引之间的间隙，或者是一个索引与范围末尾之间的间隙。主要用于防止幻读。</li><li><code>用途</code>：保证可重复读（Repeatable Read）隔离级别下的一致性，阻止其他事务在间隙内插入行。</li></ul></li></ol><p class="note note-primary">数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test2<br>(<br>    id        <span class="hljs-type">int</span> auto_increment<br>        <span class="hljs-keyword">primary</span> key,<br>    user_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">null</span>,<br>    age       <span class="hljs-type">int</span>         <span class="hljs-keyword">null</span>,<br>    address   <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;shenzhen&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;test2&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&#x27;guangzhou&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;test1&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;shenzhen&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;test2&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;shanghai&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;test3&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;beijing&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">19</span>, <span class="hljs-string">&#x27;test4&#x27;</span>, <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;guangzhou&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">25</span>, <span class="hljs-string">&#x27;test5&#x27;</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&#x27;zhongshan&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> test.test2 (id, user_name, age, address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;shenzhen&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="全局锁"><a class="markdownIt-Anchor" href="#全局锁"></a> 全局锁</h3><p>全局锁会对整个MySQL数据库实例加锁。在加锁期间，整个数据库实例将处于只读状态。这意味着任何数据修改语句（DML）、数据定义语句（DDL）以及试图提交更新操作的事务都将被阻塞。</p><p><code>作用</code>：全局锁的典型使用场景包括进行全库逻辑备份。通过对所有表加锁，可以确保获得一致性的数据库快照，从而保证备份数据的完整性和一致性。</p><p class="note note-primary">语法</p><p><code>加全局锁</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">FLUSH TABLES <span class="hljs-keyword">WITH</span> READ LOCK<br></code></pre></td></tr></table></figure><p><code>数据备份</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysqldump <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>pPassword [database name] <span class="hljs-operator">&gt;</span> [dump file]<br></code></pre></td></tr></table></figure><p>mysqldump 也可用于远程连接备份。</p><p><code>释放锁</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><p>数据库中加全局锁，存在以下性能问题：</p><ul><li><code>主库备份的问题</code>：在主库上进行带全局锁的备份会阻止所有更新操作，这可能会导致业务暂停或性能下降。</li><li><code>从库备份的问题</code>：在从库上进行备份时，由于全局锁的存在，从库可能无法应用主库同步过来的二进制日志（binlog），导致主从复制的延迟。</li></ul><p class="note note-primary">InnoDB的备份策略优化</p><ul><li>对于InnoDB引擎，可以使用 <code>mysqldump --single-transaction</code> 参数来进行不加锁的一致性数据备份。</li><li>此选项会启动一个新的事务，并将隔离级别设置为REPEATABLE READ，确保在备份过程中数据的一致性。由于InnoDB的多版本并发控制（MVCC）特性，这种备份方式不会锁定表。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysqldump <span class="hljs-comment">--single-transaction -u root -p[Password] [database name] &gt; [dump file]</span><br></code></pre></td></tr></table></figure><p><code>注意</code>：在使用<code>--single-transaction</code>参数进行备份时，应确保备份期间没有执行DDL操作（如<code>ALTER TABLE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code>, <code>RENAME TABLE</code>, <code>TRUNCATE TABLE</code>等），因为这些操作可能会影响事务的一致性读。</p><h3 id="表级锁"><a class="markdownIt-Anchor" href="#表级锁"></a> 表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p><p>对于表级锁，主要分为以下三类</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁"><a class="markdownIt-Anchor" href="#表锁"></a> 表锁</h4><p>对于表锁，分为两类：</p><ol><li><strong><code>读锁（共享锁, Read Lock）</code></strong><ul><li><code>特点</code>：允许多个会话对表进行读取操作，但不允许任何会话进行写操作。</li><li><code>适用场景</code>：适合在数据不需要被修改的情况下进行大量的读取操作，如数据分析或报告生成。</li><li><code>加锁方式</code>：可以通过<code>LOCK TABLES table_name READ</code>命令显示加读锁。</li></ul></li><li><strong><code>写锁（排他锁, Write Lock）</code></strong><ul><li><code>特点</code>：只允许一个会话对表进行读写操作，阻止其他会话的所有读写操作。</li><li><code>适用场景</code>：适合需要修改数据且要防止其他会话读取或修改同一数据的情况。</li><li><code>加锁方式</code>：可以通过<code>LOCK TABLES table_name WRITE</code>命令显示加写锁。</li></ul></li><li><strong><code>释放锁</code></strong>：unlock tables</li></ol><h4 id="元数据锁"><a class="markdownIt-Anchor" href="#元数据锁"></a> 元数据锁</h4><p><strong>作用</strong>：</p><ul><li><code>自动加锁</code>：MDL（Meta Data Lock）的加锁过程是由MySQL系统自动控制的，无需用户显式操作。在访问或修改表的结构时，MySQL会自动加上相应的MDL。</li><li><code>数据一致性</code>：MDL的主要作用是维护表的元数据（如表结构）的一致性。当一张表上有活动事务时，不允许对该表的元数据进行修改。</li><li><code>防止冲突</code>：MDL用于避免DML（数据修改语句）和DDL（数据定义语句）之间的冲突，保证数据库操作的正确性。</li></ul><p><strong>应用</strong>：</p><ul><li><code>表的结构修改</code>：当表涉及到未提交的事务时，不允许修改该表的结构（例如，通过<code>ALTER TABLE</code>）。</li><li><code>版本引入</code>：MDL在MySQL 5.5中被引入，用于提高数据库操作的安全性和一致性。</li><li><code>锁类型</code>：<ul><li>对于非结构性的表操作（如查询、插入、更新、删除），MySQL加MDL读锁（共享锁）。</li><li>对于表结构变更操作，加MDL写锁（排他锁）。</li></ul></li></ul><p>锁类型和SQL操作对应关系:</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td><code>LOCK TABLES xxx READ / WRITE</code></td><td><code>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</code></td><td></td></tr><tr><td><code>SELECT</code>、<code>SELECT ... LOCK IN SHARE MODE</code></td><td><code>SHARED_READ</code></td><td>与<code>SHARED_READ</code>、<code>SHARED_WRITE</code>兼容，与<code>EXCLUSIVE</code>互斥</td></tr><tr><td><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT ... FOR UPDATE</code></td><td><code>SHARED_WRITE</code></td><td>与<code>SHARED_READ</code>、<code>SHARED_WRITE</code>兼容，与<code>EXCLUSIVE</code>互斥</td></tr><tr><td><code>ALTER TABLE ...</code></td><td><code>EXCLUSIVE</code></td><td>与其他MDL互斥</td></tr></tbody></table><p class="note note-primary">操作</p><p><code>查看元数据锁</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="hljs-keyword">from</span><br>performance_schema.metadata_locks;<br></code></pre></td></tr></table></figure><p><code>元数据排它锁</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test2<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> test <span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure><p><code>下面操作将阻塞</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> test <span class="hljs-keyword">set</span> user_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;test1&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="意向锁"><a class="markdownIt-Anchor" href="#意向锁"></a> 意向锁</h4><p><img src="/2022/02/26/Mysql/%E6%B2%A1%E6%9C%89%E6%84%8F%E5%90%91%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="没有意向锁时的上锁检查"></p><p><img src="/2022/02/26/Mysql/%E6%84%8F%E5%90%91%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="上锁前先获取意向锁"></p><p><code>定义</code>：意向锁是一种表级锁，它表明事务打算在表中的某些行上加行级锁。</p><p><code>两种类型</code>：</p><ul><li>意向共享锁（Intention Shared Lock, IS）：表明事务打算在表中的某些行上加共享锁。</li><li>意向排他锁（Intention Exclusive Lock, IX）：表明事务打算在表中的某些行上加排他锁。</li></ul><p><code>作用</code>：</p><ul><li><code>兼容性检查</code>：意向锁使得InnoDB能够快速判断是否可以在表上加表级锁。例如，如果有事务持有意向排他锁，InnoDB知道不能在该表上加共享表级锁，意向锁是一个标识，为了解决表锁和行锁冲突而设计的锁。</li><li><code>避免死锁</code>：通过在表级别上快速检查锁的兼容性，意向锁有助于避免死锁的发生。</li></ul><p class="note note-primary">意向锁实践</p><ul><li><code>意向共享锁(IS)</code>: 由语句select … lock in share mode添加 。 与表锁共享(read)兼容，与表锁排他锁(write)互斥</li><li><code>意向排他锁(IX)</code>: 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥</li></ul><p>事务的提交或回滚意向锁都会释放</p><p><img src="/2022/02/26/Mysql/%E9%94%81%E5%85%BC%E5%AE%B9.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">意向共享锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 上行共享锁<br><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> lock <span class="hljs-keyword">in</span> share mode;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 此时上表读锁可以兼容，因为意向共享锁兼容表共享锁<br>lock tables test2 read;<br></code></pre></td></tr></table></figure><p class="note note-primary">意向排它锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 上行排它锁<br><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">update</span> test2<br>    <span class="hljs-keyword">set</span> user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test2&#x27;</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 此时不能上锁，意向排它锁和表排他锁互斥<br>lock tables test2 write;<br></code></pre></td></tr></table></figure><p>查看意向锁和行锁加锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="hljs-keyword">from</span><br>performance_schema.data_locks;<br></code></pre></td></tr></table></figure><h3 id="行级锁"><a class="markdownIt-Anchor" href="#行级锁"></a> 行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中</p><p>InnoDB的数据是基于索引组织的，<span class="green-line">行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</span>对于行级锁，主要分为以下三类：</p><p><img src="/2022/02/26/Mysql/%E8%A1%8C%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="行锁"></p><p><code>行锁</code>（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 <code>update</code> 和 <code>delete</code> 。在 <code>RC</code>、<code>RR</code> 隔离级别下都支持</p><p><img src="/2022/02/26/Mysql/%E9%97%B4%E9%9A%99%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="间隙锁"></p><p><code>间隙锁</code>（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 <code>insert</code>，产生<code>幻读</code>。在 <code>RR</code> 隔离级别下支持</p><p><img src="/2022/02/26/Mysql/%E4%B8%B4%E9%94%AE%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="临键锁"></p><p><code>临键锁</code>（Next-Key Lock）：<code>行锁</code> 和 <code>间隙锁</code> 组合，同时锁住数据，并锁住数据前面的间隙Gap，在 <code>RR</code> 隔离级别下支持</p><h4 id="行锁"><a class="markdownIt-Anchor" href="#行锁"></a> 行锁</h4><p><img src="/2022/02/26/Mysql/%E8%A1%8C%E9%94%81%E5%85%BC%E5%AE%B9.png" srcset="/img/loading.gif" lazyload alt></p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 <code>临键锁</code>（next-key） 锁进行搜索和索引扫描，以防止 <code>幻读</code></p><p>针对 <code>唯一索引</code> 进行检索时，对 <code>已存在的记录进行等值匹配时</code>，将会自动优化为 <code>行锁</code></p><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><code>共享锁</code>（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁</li><li><code>排他锁</code>（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li></ul><p>常见的SQL语句，在执行时，所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p class="note note-primary">共享锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> lock <span class="hljs-keyword">in</span> share mode; # 唯一索引加共享锁，行锁<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> lock <span class="hljs-keyword">in</span> share mode; # 唯一索引加共享锁，行锁<br></code></pre></td></tr></table></figure><p>在两个会话中分别开启事务，对id为1的数据进行加锁，结果是两个会话都可以将数据查询出来</p><p>查看加锁情况，发现id=的数据被加上了两把共享锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="hljs-keyword">from</span><br>performance_schema.data_locks;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E5%85%B1%E4%BA%AB%E9%94%81-%E8%A1%8C%E9%94%81.png" srcset="/img/loading.gif" lazyload alt="行共享锁"></p><p class="note note-primary">排它锁</p><p>排它锁与排他锁之间互斥</p><p>当会话一执行 id=1 的 update 语句后， 如果事务没有提交，那么会话一的事务会一直持有 id=1 这条数据的锁，其他会话事务的上锁操作将被阻塞，除非会话一的事务提交或回滚</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">update</span> test2<br><span class="hljs-keyword">set</span> user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test99&#x27;</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E6%9F%A5%E8%AF%A2%E8%A1%8C%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p>此时会话二被阻塞，查看行锁情况，id=1 的排他锁确实没有释放</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2;<br></code></pre></td></tr></table></figure><p>打开会话三开启新事务进行查询，查询不会阻塞（快照读），因为 select 不加锁</p><p class="note note-primary">升级表锁</p><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">update</span> test2<br><span class="hljs-keyword">set</span> user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test99&#x27;</span><br><span class="hljs-keyword">where</span> user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;test&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E5%8D%87%E7%BA%A7%E8%A1%A8%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p>此时我们先查询锁的占用情况，发现表的所有id都被加了排他锁，原因就是行锁是对索引加锁的，user_name 字段没有加锁则升级为全局锁</p><h4 id="间隙锁"><a class="markdownIt-Anchor" href="#间隙锁"></a> 间隙锁</h4><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 <code>临键锁</code>（next-key） 锁进行搜索和索引扫描，以防止 <code>幻读</code></p><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁</p><p>产生间隙锁原因：</p><ul><li>RR 隔离级别</li><li>对不存在的记录上锁</li><li>对索引列进行范围查询（in，between）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">where</span> id <span class="hljs-keyword">between</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E9%97%B4%E9%9A%99%E9%94%812.png" srcset="/img/loading.gif" lazyload alt></p><p>这里看到间隙锁标志，此时对 (5，12]，（13，18]，（19，24] 上间隙锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> test2 (id, user_name, age)<br><span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;test18&#x27;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>由于间隙锁的缘故，id = 8 的插入操作将被阻塞</p><h4 id="临键锁"><a class="markdownIt-Anchor" href="#临键锁"></a> 临键锁</h4><p><code>RR级别解决幻读</code>：在进行 <code>范围查询</code> 或 <code>索引扫描</code> 时，InnoDB会在涉及的索引范围内设置间隙锁和行锁，防止其他事务在这些范围内插入或删除记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建普通索引<br><span class="hljs-keyword">create</span> index idx_age <span class="hljs-keyword">on</span> test2(age);<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> test2<br><span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">18</span> <span class="hljs-keyword">and</span> <span class="hljs-number">21</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E4%B8%B4%E9%94%AE%E9%94%812.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>场景</strong>：</p><ol><li><strong><code>范围查询</code></strong>：当对非唯一索引执行范围查询（如<code>WHERE column &lt; 10</code>）时，InnoDB会使用临键锁锁定匹配范围内的所有记录以及这些记录之间的间隙。</li><li><strong><code>非唯一索引上的等值查询</code></strong>：对于非唯一索引的等值查询（如<code>WHERE column = 5</code>），由于可能有多条记录具有相同的索引值，InnoDB同样会使用临键锁来锁定这些记录和间隙。</li><li><strong><code>索引扫描</code></strong>：在执行索引扫描时（如全表扫描或使用索引进行部分表扫描），InnoDB会对扫描到的记录以及记录之间的间隙加临键锁。</li><li><strong><code>插入操作</code></strong>：当插入一条记录时，InnoDB会对新插入的记录前的间隙加锁，以防止幻读。</li><li><strong><code>更新和删除操作</code></strong>：在执行更新或删除操作时，如果这些操作涉及到非唯一索引上的范围查询或是非唯一值匹配，InnoDB也会使用临键锁。</li></ol><h3 id="锁优化"><a class="markdownIt-Anchor" href="#锁优化"></a> 锁优化</h3><p class="note note-primary">避免行锁升级为表锁</p><ul><li>控制事务大小，减少锁定的资源量和锁定时间长度,比如分批</li><li>合理设计索引，尽量缩小锁的范围(DML一定要使用索引列)</li><li>条件是大范围，可以按照范围分批</li></ul><h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3><p class="note note-primary">相互等待</p><table><thead><tr><th style="text-align:left">T1</th><th style="text-align:left">T2</th></tr></thead><tbody><tr><td style="text-align:left">set autocommit = 0;</td><td style="text-align:left">set autocommit = 0;</td></tr><tr><td style="text-align:left">select * from user where id = 1 for update;</td><td style="text-align:left">select * from user where id = 2 for update;</td></tr><tr><td style="text-align:left">select * from user where id = 2 for update;</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">此时T1等待T2释放锁</td><td style="text-align:left"></td></tr></tbody></table><p class="note note-primary">update join 多表加锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">T1<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> a <span class="hljs-keyword">join</span> address b <span class="hljs-keyword">on</span> a.address_id <span class="hljs-operator">=</span> b.id<br><span class="hljs-keyword">set</span> a.user_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;kkk&#x27;</span><br><span class="hljs-keyword">where</span> b.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>T2<br><span class="hljs-keyword">update</span> address<br><span class="hljs-keyword">set</span> address_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;HN&#x27;</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>此时T2会等待T1释放 address id<span class="hljs-operator">=</span><span class="hljs-number">1</span> 行锁<br></code></pre></td></tr></table></figure><p class="note note-primary">delete join 多表加锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">T1<br><span class="hljs-keyword">set</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">delete</span> a<br><span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> a <span class="hljs-keyword">join</span> address b <span class="hljs-keyword">on</span> a.address_id <span class="hljs-operator">=</span> b.id<br><span class="hljs-keyword">where</span> a.id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>T2<br><span class="hljs-keyword">set</span> autocommit  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">update</span> address<br><span class="hljs-keyword">set</span> address_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;HN&#x27;</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>T2等待T1释放 id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> 的行锁<br></code></pre></td></tr></table></figure><p class="note note-primary">解决死锁</p><ul><li>查看是否锁表： <strong>show OPEN TABLES where In_use &gt; 0</strong></li><li>查询进程： <strong>show processlist</strong></li><li>杀死进程id（就是上面命令的id列）： <strong>kill id</strong></li></ul><h1 id="innodb-底层原理"><a class="markdownIt-Anchor" href="#innodb-底层原理"></a> Innodb 底层原理</h1><p><img src="/2022/02/26/Mysql/InnoDB%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="架构图"></p><p>从MySQL 5.5版本开始，InnoDB成为了默认的存储引擎。这一变化标志着对事务安全和性能的重视。Innodb引擎具有以下特点：</p><ul><li><p><code>事务处理</code>：<span class="green-line">专为事务处理设计</span>，支持ACID（原子性、一致性、隔离性、持久性）事务，确保数据库操作的可靠性和完整性。</p></li><li><p><code>行级锁定和MVCC</code>：支持行级锁定和多版本并发控制（MVCC），优化了并发操作，减少了锁争用，提高了性能。</p></li><li><p><code>外键约束</code>：支持外键，允许在表之间创建参照完整性约束，这是其他一些存储引擎（如MyISAM）不支持的功能。</p></li><li><p><code>缓冲池</code>：拥有缓冲池（buffer pool）机制，用于缓存数据和索引，减少磁盘I/O操作，提升查询性能。</p></li><li><p><code>数据存储</code>：使用聚簇索引来存储表数据，这意味着表数据实际上存储在索引的叶节点上。</p></li><li><p><code>崩溃恢复</code>：具备崩溃恢复能力，通过日志（如重做日志，即redo log）来保证数据在系统崩溃后的完整性和一致性。</p></li></ul><h2 id="外存架构"><a class="markdownIt-Anchor" href="#外存架构"></a> 外存架构</h2><p><img src="/2022/02/26/Mysql/%E5%A4%96%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="表空间-table-space"><a class="markdownIt-Anchor" href="#表空间-table-space"></a> 表空间 table space</h3><p><code>定义</code>：表空间是数据库中用于存储数据的逻辑单元。它定义了数据存储的位置（物理文件）和方式。表空间可以包含一个或多个文件，这些文件位于文件系统上。</p><p>如果用户启用了参数 <code>innodb_file_per_table</code> (在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd）一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。表空间存储的对象是段，由一个或多个段组成</p><p><img src="/2022/02/26/Mysql/%E8%A1%A8%E7%A9%BA%E9%97%B4.png" srcset="/img/loading.gif" lazyload alt="表空间"></p><p>默认情况下，MySql的表空间目录在 <code>/var/lib/mysql</code> 目录下，每个数据库对应一个目录，每张表对应一个 <code>ibd</code>文件</p><p class="note note-primary">分类</p><ul><li>系统表空间</li><li>独立表空间</li><li>通用表空间<ul><li>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间</li></ul></li><li>undo表空间<ul><li>MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志</li></ul></li><li>临时表空间<ul><li>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据</li></ul></li></ul><p class="note note-primary">作用</p><ol><li><code>数据组织</code>：表空间允许将数据库数据分割成不同的部分，每部分可以单独管理和优化。</li><li><code>存储管理</code>：例如，可以将不同的表空间放置在不同的磁盘或存储设备上，以优化性能和空间使用。</li><li><code>备份和恢复</code>：可以单独备份或恢复特定的表空间。</li></ol><p class="note note-primary">语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建表空间<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>SPACE ts_name <span class="hljs-keyword">ADD</span> DATAFILE <span class="hljs-string">&#x27;file_name&#x27;</span> ENGINE <span class="hljs-operator">=</span> engine_name;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建表时指定表空间<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> xxx ... TABLESPACE ts_name;<br></code></pre></td></tr></table></figure><h3 id="段-segment"><a class="markdownIt-Anchor" href="#段-segment"></a> 段 segment</h3><p>段是一组具有相似特性的连续页（pages）的集合，<span class="green-line">每个段都用于特定类型的数据存储</span>，对存储数据进行分类，段用来管理多个Extent（区）。</p><p class="note note-primary">分类</p><ol><li><code>数据段</code>（Data Segment）：用于存储表的行数据。</li><li><code>索引段</code>（Index Segment）：用于存储B+树索引结构，包括主键索引和辅助索引。</li><li><code>回滚段</code>（Rollback Segment）：存储事务回滚时所需的数据。</li><li><code>临时段</code>（Temporary Segment）：用于存储临时数据，如排序操作或哈希表。</li></ol><p class="note note-primary">作用</p><ul><li><code>空间管理</code>：每个段负责管理其内部的页，包括分配新页和回收不再使用的页。</li><li><code>责任分离</code>：不同类型的段支持不同功能，如数据存储、索引维护和事务处理。</li><li><code>数据分类</code>：通过将数据划分到不同的段中，InnoDB可以更有效地组织数据。</li></ul><h3 id="区-extent"><a class="markdownIt-Anchor" href="#区-extent"></a> 区 extent</h3><p>一个区是由连续的页（Page）组成的数据块。在InnoDB中，默认情况下，一个区包含 <code>1MB</code> 的空间，这相当于连续的 <code>64</code> 个 <code>16KB</code> 大小的页。</p><p class="note note-primary">作用</p><ul><li><code>优化空间管理</code>：需要分配或回收大量空间时，InnoDB可以按区而不是页来操作，从而提高效率。</li><li><code>提升访问效率</code>：在处理大量数据时，区能提高数据访问效率。</li></ul><h3 id="页-page"><a class="markdownIt-Anchor" href="#页-page"></a> 页 page</h3><p><img src="/2022/02/26/Mysql/%E9%A1%B5.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/02/26/Mysql/%E9%A1%B5%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>页，<span class="green-line">是InnoDB 存储引擎磁盘管理的最小单元</span>，每个页的大小默认为 <code>16KB</code>。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">查看页大小<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Innodb_page_size&#x27;</span>;<br></code></pre></td></tr></table></figure><p class="note note-primary">数据结构</p><ul><li><code>页头 PageHeader</code>：记录页面控制信息；56个字节。包括页的<span class="green-line">左右兄弟页指针</span>、页面空间使用情况等</li><li><code>虚记录</code>：用于确定当前页的记录范围<ul><li><code>最小虚记录</code>：最小记录是数据页上最小的记录，比页内最小主键小</li><li><code>最大虚记录</code>：最大记录是这个数据页中逻辑上最大的记录，比页内最大主键还大</li></ul></li><li><code>记录堆</code> ：行记录存储区，包含已删除记录的空间（大链表）</li><li><code>自由空间链表</code>: 把被删除的记录空间链起来。便于重复利用空间</li><li><code>未分配空间</code>: 还未使用的记录堆</li><li><code>Slot区</code> （槽位）：槽位的作用是将页内的数据链表拆分成多个子链表（hashTable思想）， 类似跳表</li><li><code>页尾</code>: 8个字节，主要存储页面的校验信息</li></ul><p class="note note-primary">页内记录维护</p><p><strong><code>顺序保证</code></strong></p><ul><li><p>物理有序插入删除需要移动数据（连续的存储空间），IO操作较多，插入效率不理想。基本不会使用</p></li><li><p>逻辑有序使用链表实现，但是查询效率没有物理有序好（物理有序可以使用二分法）</p></li></ul><p>​	<strong><font color="red">InnoDB必然是使用逻辑有序，物理有序写操作没有优化空间，逻辑有序的查询可以通过数据结构和算法进行优化（槽位）</font></strong></p><p><strong><code>插入策略</code></strong></p><p>优先使用<span class="green-line">自由空间链表，减少空洞，其次使用未分配空间</span></p><p><em>即使是优先使用自由空间链表也不能保证表没有空洞，因为每条数据的长度不一致</em></p><p><strong><code>页内查询</code></strong></p><ol><li><p><code>页内槽位定位</code>：每个槽位对应于页内某个位置的记录，通过二分查找快速定位到接近目标记录的槽位。</p></li><li><p><code>链表遍历</code>：每个槽位都有一个链表，包含了所有映射到该槽位的记录。</p></li><li><p><code>找到目标记录</code>：根据槽位定位到链表后，在链表中顺序查找直到找到匹配的记录。</p></li></ol><p class="note note-primary">类型</p><ul><li><code>数据页</code>：存储表的实际行数据。</li><li><code>索引页</code>：存储B+树索引结构，包括主键索引和辅助索引。</li><li><code>Undo页</code>：存储事务的undo信息，用于数据恢复和MVCC。</li><li><code>系统页</code>：存储表空间的元数据和其他系统信息。</li></ul><h3 id="行-row"><a class="markdownIt-Anchor" href="#行-row"></a> 行 row</h3><p><img src="/2022/02/26/Mysql/%E8%A1%8C.png" srcset="/img/loading.gif" lazyload alt></p><p>行（Row）是数据存储和处理的基本单位。</p><p>在行中，默认有两个隐藏字段：</p><ul><li><code>Trx_id</code>：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li><code>Roll_pointer</code>：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到上个版本的信息，是 <code>MVCC</code> 实现的核心。</li></ul><h3 id="聚簇索引-2"><a class="markdownIt-Anchor" href="#聚簇索引-2"></a> 聚簇索引</h3><p>​	<img src="/2022/02/26/Mysql/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" srcset="/img/loading.gif" lazyload alt></p><p>数据结构：<a href="#b%E6%A0%91">B+树</a></p><p><span style="border-bottom:2px dashed green"><font color="red"><strong>聚簇索引并不是一种单独的索引类型，而是一种 InnoDB 数据存储方式</strong></font></span></p><h2 id="内存架构"><a class="markdownIt-Anchor" href="#内存架构"></a> 内存架构</h2><p><img src="/2022/02/26/Mysql/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>InnoDB会将近期使用的数据先加载到内存中，当内存满了则根据LRU算法将内存中的数据写盘或者释放。释放出内存给其他热点数据使用。</p><p>主要分为这么四大块：</p><ul><li>Buffer Pool</li><li>Change Buffer</li><li>AdaptiveHash Index</li><li>Log Buffer</li></ul><h3 id="buffer-pool"><a class="markdownIt-Anchor" href="#buffer-pool"></a> Buffer Pool</h3><p><img src="/2022/02/26/Mysql/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" srcset="/img/loading.gif" lazyload alt></p><p><code>缓冲池（Buffer Pool）</code>：一个内存中的区域，用于缓存InnoDB存储引擎最频繁访问的数据，包括数据页（Data Pages）和索引页（Index Pages）。</p><p><strong><code>作用</code></strong>：</p><ol><li><code>减少I/O操作</code>：通过在内存中缓存数据和索引，缓冲池减少了对磁盘的读写次数，从而提高了数据访问速度。</li><li><code>数据页缓存</code>：存储表数据的数据页在被访问时加载到缓冲池中。</li><li><code>索引页缓存</code>：用于表索引的B+树结构的索引页同样被缓存，以加快索引查找和维护速度。</li></ol><p><strong>管理</strong>：</p><ul><li><code>LRU算法</code>：InnoDB使用优化后的 <code>双段LRU算法</code> 来管理缓冲池中的页面。确保最活跃的数据保持在缓冲池中。</li><li><code>脏页刷新</code>：当缓冲池中的数据页被修改后，它们最终会被写回到磁盘以保持数据的持久性。这个过程称为“刷新”（Flush）。</li></ul><p>Buffer Pool默认大小是 <code>128M</code>，以 <code>Page</code> 页为单位，Page页默认大小 <code>16K</code>，而控制块的大小约为数据页的5%，大概是 <code>800字节</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看 buffer pool 信息<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_buffer%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/02/26/Mysql/%E7%BC%93%E5%86%B2%E6%B1%A0.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td><code>innodb_buffer_pool_chunk_size</code></td><td>定义InnoDB缓冲池大小调整操作的块大小</td></tr><tr><td><code>innodb_buffer_pool_size</code></td><td>缓冲池大小</td></tr><tr><td><code>innodb_buffer_pool_instances</code></td><td>InnoDB 缓冲池划分为的区域数</td></tr></tbody></table><p class="note note-primary">缓冲池中页的类型</p><ul><li><code>free page</code> ：<ul><li><strong>定义</strong>：空闲页是尚未被分配用来存储数据的页。</li><li><strong>位置</strong>：这些页位于Free List中，等待被分配用于存储新的数据或索引信息。</li><li><strong>特点</strong>：它们是完全空白的，不包含任何有效数据。</li></ul></li><li><code>clean page</code> ：<ul><li><strong>定义</strong>：干净页是已被分配并包含数据的页，但自上次读入缓冲池或写回磁盘后未被修改。</li><li><strong>位置</strong>：这些页位于LRU List中，表示它们是最近被访问过的，但并不需要写回磁盘，因为它们与磁盘上的数据一致。</li><li><strong>特点</strong>：在需要为新的数据页或更“脏”的页腾出空间时，干净页可以被较快地从缓冲池中移除，因为它们不需要额外的磁盘写入操作。</li></ul></li><li><code>dirty page</code>：<ul><li><strong>定义</strong>：脏页是已被分配并包含数据的页，且自上次读入缓冲池后已被修改。</li><li><strong>位置</strong>：这些页同时位于LRU List和Flush List中。LRU List表示它们是最近被访问过的，而Flush List用于跟踪需要被写回磁盘的脏页。</li><li><strong>特点</strong>：脏页需要在适当时机写回磁盘以保证数据的持久性和一致性。InnoDB会定期将脏页刷新回磁盘，特别是在事务提交或检查点（Checkpoint）发生时。</li></ul></li></ul><p class="note note-primary">Page List</p><ul><li><code>Free List</code>：<ul><li><strong>定义</strong>：包含当前未使用的页，即那些没有分配任何数据的空白页。</li><li><strong>用途</strong>：当InnoDB需要新的页来存储数据或索引时，它会从Free List中分配页。</li></ul></li><li><code>LRU List</code> ：<ul><li><strong>定义</strong>：LRU列表用于存储最近被访问过的页。</li><li><strong>干净页</strong>（Clean Page）：已分配且包含数据，但与磁盘上的数据一致，未被修改过。</li><li><strong>脏页</strong>（Dirty Page）：已分配且包含数据，且自上次读入后已被修改。</li></ul></li><li><code>Flush List</code>：<ul><li><strong>定义</strong>：用于跟踪那些标记为脏的页，即需要被写回磁盘的页。</li><li><strong>用途</strong>：Flush List确保数据的持久化和一致性，特别是在事务提交或达到检查点（Checkpoint）时。</li></ul></li></ul><h4 id="page-hash表"><a class="markdownIt-Anchor" href="#page-hash表"></a> Page Hash表</h4><p><img src="/2022/02/26/Mysql/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong><code>映射关系维护</code></strong>：<ul><li><code>描述</code>：Page Hash维护了磁盘上数据页和Buffer Pool中页的映射关系。</li><li><code>快速查找</code>：这种映射机制允许InnoDB快速确定某个特定的数据页是否已经在Buffer Pool中，以及它在Buffer Pool中的具体位置。</li><li><code>判断缓存</code>：通过Page Hash，InnoDB可以快速判断某个页是否已经在Buffer Pool中，从而避免不必要的磁盘I/O操作。</li></ul></li><li><strong><code>数据页加载单位</code></strong>：<ul><li><code>以页为单位</code>：InnoDB从磁盘加载数据到内存的操作是以页为单位进行的，每个页通常为16KB。</li><li><code>不以行为单位</code>：虽然基于行的加载可能提高内存利用率，但以页为单位可以优化I/O效率，尤其是对于排序、分页查询等操作。</li></ul></li></ul><h4 id="页面装载流程"><a class="markdownIt-Anchor" href="#页面装载流程"></a> 页面装载流程</h4><ol><li><strong><code>页面装载单位</code></strong>：数据库从磁盘加载数据到内存时，是以页（默认是16KB）为单位进行的。当数据库需要读取磁盘上的数据时，它会检查该数据是否已经在Buffer Pool中。如果不在，则从磁盘加载相应的页。</li><li><strong><code>使用Free List</code></strong>：当有新的页需要加载到Buffer Pool时，InnoDB首先会尝试使用Free List中的空闲页。</li><li><strong><code>LRU List淘汰</code></strong>：Free List中没有可用的空闲页，InnoDB会从LRU List的冷数据端开始驱逐，腾出空间加载新的数据页。</li><li><strong><code>脏页刷新</code></strong>：当LRU List驱逐数据后还是无法加载新的数据页，则将脏页进行刷新，保存到磁盘。</li></ol><h3 id="change-buffer"><a class="markdownIt-Anchor" href="#change-buffer"></a> Change Buffer</h3><p><img src="/2022/02/26/Mysql/changebuffer.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>定义</strong>：</p><ul><li><strong><code>优化写操作</code></strong>：Change Buffer是一个内存中的缓冲区域，用于暂时存储对非唯一索引的修改操作。这些修改操作随后会被批量地合并到磁盘上的实际索引页中。</li><li><strong><code>减少I/O需求</code></strong>：对于非唯一索引的修改，如果每次修改都直接写入磁盘，将会产生大量的随机I/O。Change Buffer通过合并这些操作，减少了I/O操作的次数。</li></ul><p><strong>工作机制：</strong></p><ol><li><code>缓存修改操作</code>：当对一个非唯一索引进行插入、删除或更新操作时，如果相应的 <code>索引页</code> 不在缓冲池中，InnoDB会将这些修改操作记录到Change Buffer中，而不是立即从磁盘加载索引页。</li><li><code>延迟合并</code>：随后，在后台，当这些被修改的索引页因其他查询或操作而被加载到缓冲池时，InnoDB会将Change Buffer中的修改与这些页中的数据合并。</li><li><code>优化I/O</code>：这种延迟合并操作减少了对磁盘的即时I/O需求，因为它避免了为了执行每个小的索引修改而频繁地从磁盘读取和写入索引页。</li></ol><p class="note note-primary">为什么只针对非唯一索引优化</p><p><img src="/2022/02/26/Mysql/CG%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p><strong><code>唯一约束校验</code></strong>：对于具有唯一性约束的索引，任何插入和更新操作都直接在Buffer Pool中进行，确保唯一性约束在修改时被即时验证，它们不能被缓存在Change Buffer中。</p><h3 id="log-buffer"><a class="markdownIt-Anchor" href="#log-buffer"></a> Log Buffer</h3><p><strong>定义：</strong></p><ul><li><strong><code>缓存事务日志</code></strong>：Log Buffer是一个在内存中的缓存区域，用于暂时存储事务的日志信息（<code>Redo Log</code>），比如数据的修改操作。</li><li><strong><code>减少磁盘I/O</code></strong>：通过首先将日志信息写入到Log Buffer，InnoDB减少了直接写入到磁盘的操作，提高I/O性能。</li><li><strong><code>提高事务性能</code></strong>：Log Buffer允许事务快速完成，因为事务的日志信息不需要即时写入磁盘。</li></ul><p><strong>工作原理：</strong></p><ol><li><strong><code>记录事务日志</code></strong>：当执行事务时，所有的修改操作（如INSERT、UPDATE、DELETE）会生成日志记录，并首先被写入Log Buffer。</li><li><strong><code>异步刷新到磁盘</code></strong>：Log Buffer中的内容会定期或在特定事件（如事务提交）时被刷新到磁盘上的重做日志文件（Redo Log）中。</li><li><strong><code>日志序列号</code>（LSN）</strong>：每个日志记录都有一个唯一的日志序列号，用于跟踪和管理日志记录。</li></ol><p class="note note-primary">参数配置</p><ul><li><p><code>innodb_log_buffer_size</code>：设置Log Buffer的大小。根据事务的大小和频率进行适当调整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看 Log Buffer 大小<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;innodb_log_buffer_size&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>innodb_flush_log_at_trx_commit</code></p><p>控制重做日志写入和刷新到磁盘的时机：</p><ul><li><code>0</code>：<ul><li>事务提交时不会立即将日志写入磁盘，而是将日志缓存在操作系统的页缓存中，之后由操作系统决定何时将其刷新到磁盘。</li><li>这种模式提供了最高的性能，但在崩溃的情况下，会丢失数据。</li></ul></li><li><code>1</code>（默认值）：<ul><li>每次事务提交时，InnoDB都会将日志刷新到磁盘。</li><li>这提供了最高的数据持久性保证，因为即使发生崩溃，最近提交的事务也不会丢失。</li><li>因为每次事务都需要磁盘I/O而降低性能。</li></ul></li><li><code>2</code>：<ul><li>日志只在每个事务提交时写入日志缓冲区，每秒钟将日志刷新到磁盘一次。</li><li>这提供了折中的性能和持久性保证，但在发生崩溃时，最近一秒的事务可能会丢失。</li></ul></li></ul></li></ul><p><strong>性能考虑</strong>：如果存在大量的更新、插入或删除操作，增加Log Buffer的大小可以减少I/O操作，特别是在高并发的OLTP系统中。</p><h3 id="自适应hash索引"><a class="markdownIt-Anchor" href="#自适应hash索引"></a> 自适应Hash索引</h3><p><img src="/2022/02/26/Mysql/%E8%87%AA%E9%80%82%E5%BA%94Hash%E7%B4%A2%E5%BC%95.png" srcset="/img/loading.gif" lazyload alt></p><p>InnoDB会自动监控对表上索引的查询模式。当它发现某些查询符合使用哈希索引的效率优势时，就会为这些查询自动创建哈希索引。这个过程是完全自动的，不需要用户干预。</p><p><strong>使用场景</strong>：</p><ul><li><code>频繁等值查询</code>：当表上的特定数据行被频繁查询时，例如通过主键或唯一索引的等值查询。</li><li><code>读密集型应用</code>：适用于读操作远多于写操作的应用场景。</li></ul><p><strong>创建条件</strong>：当InnoDB检测到对某些 <code>索引</code> 的等值查询非常频繁时，它会自动在内存中为这些索引创建哈希索引。</p><p class="note note-primary">配置</p><ul><li>默认情况下，自适应哈希索引功能是开启的。</li><li>可以通过<code>SET GLOBAL innodb_adaptive_hash_index=OFF/ON;</code>来关闭或开启这一功能。</li><li>使用<code>SHOW VARIABLES LIKE '%adaptive_hash_index';</code>来查看当前设置。</li></ul><p><a href="#hash">Hash索引的优缺点</a></p><h3 id="双写缓冲区"><a class="markdownIt-Anchor" href="#双写缓冲区"></a> 双写缓冲区</h3><p>MySQL Buffer 一页的大小是 <code>16K</code>，文件系统一页的大小是 <code>4K</code>，也就是说，MySQL将 Buffer 中一页数据刷入磁盘，要写4个文件系统里的页。</p><p><strong>注意</strong>：Innodb Page 默认不是 4K 是因为考虑I/O效率，较大的页大小可以减少数据库在读写操作时需要的I/O次数，更大尺寸的页适合于表扫描和大范围查询。</p><p><img src="/2022/02/26/Mysql/%E5%8F%8C%E5%86%99%E7%BC%93%E5%86%B2%E5%8C%BA.png" srcset="/img/loading.gif" lazyload alt></p><p>如上图所示，MySQL里page=1的页，等于物理磁盘的四个页，刷盘的这个操作并非原子，如果执行到一半断电或宕机，就会出现 <code>页数据损坏</code>。</p><p><img src="/2022/02/26/Mysql/%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%8D%9F%E5%9D%8F.png" srcset="/img/loading.gif" lazyload alt="页数据损坏"></p><p>如上图所示，MySQL内page=1的页准备刷入磁盘，才刷了3个文件系统里的页，断电了。重启后，page=1的页，物理上对应磁盘上的1+2+3+4四个格，数据完整性被破坏。</p><p class="note note-primary">解决页数据损坏</p><p><img src="/2022/02/26/Mysql/DWB%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p>如上图所示，当有页数据要刷盘时：</p><ol><li><strong><code>预写入</code></strong>：当脏页被刷新到磁盘时，InnoDB首先将这些页的副本写入双写缓冲区（一个特定的磁盘区域）。</li><li><strong><code>确认写入</code></strong>：只有双写缓冲区数据成功写入磁盘文件后，InnoDB才会将这些页写入实际的表空间文件。</li><li><strong><code>恢复使用</code></strong>：如果发生崩溃，InnoDB在重启时会检查双写缓冲区，以确保页的完整性。</li></ol><h2 id="内外存数据交换"><a class="markdownIt-Anchor" href="#内外存数据交换"></a> 内外存数据交换</h2><p class="note note-primary">内存数据淘汰</p><p><code>触发条件</code></p><ul><li>Buffer Pool空间不足。</li><li>需要加载新的数据页到内存。</li></ul><p class="note note-primary">内存淘汰算法 LRU</p><p><img src="/2022/02/26/Mysql/URL%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><code>LRU</code>： (Least recently used) 最近最少使用。</p><p><img src="/2022/02/26/Mysql/%E4%BC%98%E5%8C%96%E7%9A%84URL.png" srcset="/img/loading.gif" lazyload alt></p><p>使用全表扫描对 <code>普通LRU</code> 算法的影响：</p><ul><li>如果全表扫描一张大表，根据 <code>普通LRU</code> 算法，会淘汰内存中所有数据。</li><li>全表扫描的数据可能就只使用一次，造成 <code>缓存污染</code>。</li></ul><p class="note note-primary">MySql 改良的URL</p><p><img src="/2022/02/26/Mysql/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862.png" srcset="/img/loading.gif" lazyload alt></p><p>InnoDB实际上使用一个单一的LRU链表，但这个链表被分为两个部分：热数据区域（LRU列表的前端）和冷数据区域（LRU列表的尾部）。这种分区有助于保护频繁访问的热点数据不被轻易淘汰。</p><ul><li><p><code>页面淘汰时机</code>：当Buffer Pool中的Free List没有空闲页，并且需要加载新的数据页时，InnoDB会根据LRU算法从LRU List中淘汰页。</p></li><li><p><code>保护热数据</code>：为了减少全表扫描等操作对Buffer Pool的影响，InnoDB引入了中段插入策略。新加载的页不是直接被放到LRU列表的最前端，而是被放置在列表的 <code>中间位置</code>。</p></li></ul><p><strong>淘汰流程</strong>：</p><ul><li><strong><code>淘汰LRU列表尾部的页</code></strong>：优先淘汰LRU列表尾部的数据，是较少访问的冷数据。</li><li><strong><code>脏页的处理</code></strong>：如果需要淘汰的页是脏页（即已修改但未写回磁盘的页），则这些页需要先被刷新（写回）到磁盘。</li><li><strong><code>锁定页的处理</code></strong>：如果LRU列表尾部的某些页被锁定或无法淘汰（例如，由于正在参与活跃事务），则向前移动，寻找可淘汰的页。</li><li><strong><code>重新分配到Free List</code></strong>：一旦页被淘汰，它们的空间被释放回Free List，供新的页使用。</li></ul><p class="note note-primary">冷数据变为热数据</p><p>当数据页被首次读取到Buffer Pool时，它们被放入LRU链表的中间部分，即所谓的 <code>冷数据</code> 区域。这是为了防止大规模的非顺序读取（如全表扫描）迅速淘汰掉已经存在于LRU链表前端的热点数据。</p><p><strong>冷数据晋升热数据条件</strong>：</p><ol><li><strong><code>初次加载</code></strong>：当数据页首次加载到Buffer Pool时，被放置在LRU链表的冷数据区域（冷数据区域头部）。</li><li><strong><code>存活时间</code></strong>：数据页在冷数据区域中必须存活一定时间，这个时间由参数<code>innodb_old_blocks_time</code>设定（单位是毫秒）。默认值通常是1000毫秒（1秒）。</li><li><strong><code>再次访问</code></strong>：如果在存活时间过后，这个页再次被访问，它将从冷数据区域移动到热数据区域（LRU链表的前端）。这标志着数据页从冷数据变成了热数据。</li><li><strong><code>访问频率</code></strong>：只有那些被重新访问的页才会从冷数据区晋升到热数据区，这意味着频繁访问的页更有可能成为热数据。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 必须在冷数据区停留多长才有资格晋升热数据区<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_old_blocks_time&#x27;</span><br></code></pre></td></tr></table></figure><p><code>总结</code>：在冷数据区存活一定时间，并且再次访问。</p><p><code>好处</code>：进行全表扫描频繁淘汰的区域是冷数据区，热数据区域的热点数据不会受影响。</p><p class="note note-primary">热数据淘汰</p><p><strong>Midpoint</strong></p><ul><li><p><strong><code>定义</code></strong>：Midpoint是LRU链表中的一个指针，标识着热数据区域和冷数据区域的分界点。</p></li><li><p><strong><code>指针移动</code></strong>：</p><ul><li><code>向左移动</code>：热数据区域将数据淘汰到冷数据区域。</li><li><code>向右移动</code>：冷数据区域的数据晋升到热数据区域。</li></ul></li><li><p><strong><code>位置保持</code></strong>：热数据区域占整个LRU链表的大约 <code>5/8</code>，而冷数据区域占 <code>3/8</code>。数据的晋升和淘汰让指针一直保持这个比例。</p></li></ul><p><strong>数据淘汰优化</strong>：</p><ul><li><strong><code>free_page_clock</code></strong>：是一个全局计数器，当缓冲池中的页被访问时 <code>free_page_clock</code> 会递增。</li><li><strong><code>快照计数器的值</code></strong>：一个页从冷数据区域晋升到热数据区域时，会记录当前的 <code>free_page_clock</code> 值。</li><li><strong><code>数据移动</code></strong>：当前的 <code>free_page_clock</code> 与页晋升时的快照差超过热区域长度的 <code>1/4</code> 时，数据页才向左移动。</li><li><strong><code>降低频率</code></strong>：这种机制降低了页移动的频率，从而减少了由频繁的页移动引起的性能开销。</li></ul><h2 id="后台线程"><a class="markdownIt-Anchor" href="#后台线程"></a> 后台线程</h2><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p><div class="note note-warning"><p><strong>Master Thread</strong></p><ul><li><strong><code>职责</code></strong>：Master Thread是InnoDB的核心后台线程，负责多种调度和维护任务。</li><li><strong><code>主要功能</code></strong>:<ul><li><code>异步刷新</code>：将缓冲池中的脏页异步刷新到磁盘。</li><li><code>合并Change Buffer</code>：合并Change Buffer中的数据到实际的索引页。</li><li><code>Undo页的回收</code>：清理不再需要的Undo页。</li></ul></li></ul></div><div class="note note-warning"><p><strong>IO Thread</strong></p><ul><li><strong><code>AIO处理</code></strong>：InnoDB大量使用异步I/O（AIO）来提高性能，IO Thread主要负责处理这些异步I/O请求。</li><li><strong><code>职责</code></strong>：<ul><li><code>Read Thread</code>：处理读取操作。</li><li><code>Write Thread</code>：处理写操作。</li><li><code>Log Thread</code>：负责将重做日志（Redo Log）刷新到磁盘。</li><li><code>Insert Buffer Thread</code>：处理Change Buffer的合并操作。</li></ul></li></ul></div><div class="note note-warning"><p><strong>Purge Thread</strong></p><p><strong><code>Undo日志回收</code></strong>：回收事务提交后不再需要的Undo日志，释放空间。</p></div><div class="note note-warning"><p><strong>Page Cleaner Thread</strong></p><p><strong><code>辅助刷新脏页</code></strong>：主要职责是协助Master Thread将脏页刷新到磁盘，减轻Master Thread的负担，降低刷新操作对性能的影响。</p></div><h2 id="事务原理"><a class="markdownIt-Anchor" href="#事务原理"></a> 事务原理</h2><p>事务是数据库执行过程中的一个逻辑单位，由一系列的操作组成。这些操作要么全部成功，要么全部失败。事务处理保证了即使在系统故障的情况下，操作的完整性也不会被破坏。</p><p>事务的四大特性：</p><ul><li><strong><code>原子性</code>（Atomicity）</strong>：事务中的所有操作要么全部成功，要么全部失败，不会停留在中间状态。</li><li><strong><code>一致性</code>（Consistency）</strong>：事务必须保证数据库从一个一致性状态转移到另一个一致性状态。</li><li><strong><code>隔离性</code>（Isolation）</strong>：事务的执行不会被其他事务干扰，多个并发事务之间的数据库操作是隔离的。</li><li><strong><code>持久性</code>（Durability）</strong>：一旦事务完成，其对数据库的修改应该是永久性的，即使出现系统故障。</li></ul><p><img src="/2022/02/26/Mysql/%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>原理</strong>：</p><ul><li><p><strong><code>Redo Log</code></strong>：保证事务的 <code>持久性</code>，即使在系统崩溃后，已提交事务的修改不会丢失。</p></li><li><p><strong><code>Undo Log</code></strong>：支持 <code>原子性</code> 和 <code>一致性</code>，用于在事务失败时回滚操作，并支持MVCC中的读一致性。</p></li><li><p><strong><code>隔离性保证</code></strong></p><ul><li><code>写隔离</code>：InnoDB通过锁定机制来维护事务的隔离性，防止数据在并发环境下被破坏。</li><li><code>读隔离</code>：允许多个事务同时读取同一数据而无需等待其他事务完成（MVCC快照读取）。</li></ul></li></ul><h3 id="redo-log"><a class="markdownIt-Anchor" href="#redo-log"></a> redo log</h3><p><img src="/2022/02/26/Mysql/redologfile.png" srcset="/img/loading.gif" lazyload alt="redo log"></p><p><span class="green-line">重做日志是事务持久性的关键</span>，通过记录数据页的物理修改日志，它确保了即使在数据库崩溃的情况下，所有已提交事务的修改都能被恢复。</p><p><strong>组成</strong>：</p><ul><li><strong><code>重做日志缓冲</code>（Log Buffer）</strong>：<ul><li><code>功能</code>：位于内存中，用于临时存放生成的重做日志记录。这些记录表示了事务对数据页的物理修改。</li><li><code>作用</code>：使用内存缓冲区可以提高日志记录的写入效率，减少对磁盘的直接写操作。</li></ul></li><li><strong><code>重做日志文件</code>（Redo Log File）</strong>：<ul><li><code>持久存储</code>：位于磁盘上，用于持久化存储事务的修改。这些文件确保了即使在系统崩溃的情况下，所有已提交的事务修改都可以被恢复。</li><li><code>循环写入</code>：包含多个文件，以循环方式写入，当一个文件写满后，日志写入移动到下一个文件。<ul><li>当前重做日志文件（例如，<code>ib_logfile0</code>）写满后，日志写入操作会转移到下一个文件（例如，<code>ib_logfile1</code>）。</li><li>当所有的重做日志文件都被写满后，系统会回到第一个文件并开始覆盖旧的日志记录，从而形成一个循环。</li></ul></li></ul></li></ul><p class="note note-primary">redo log作用</p><p><img src="/2022/02/26/Mysql/redolog3.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>背景</strong>：InnoDB对数据的修改在缓冲池中会产生 <code>脏页</code>。 脏页不是实时刷新到磁盘的，而是在特定时机进行刷新，那么内存数据和磁盘数据就有一段时间不一致。</p><p><strong>作用</strong>：</p><ul><li><strong><code>保证事务持久性</code></strong>：当事务执行数据修改操作时，这些更改首先被记录到 <code>Redo Log Buffer</code> 中，然后根据策略刷新到磁盘的Redo Log文件中。</li><li><strong><code>支持数据恢复</code></strong>：在数据库崩溃后重启时，InnoDB使用Redo Log中的信息来恢复崩溃时尚未刷新到磁盘的脏页数据，恢复未刷盘的事务操作。</li></ul><p><strong>工作流程</strong>：</p><ol><li><strong><code>修改数据页</code></strong>：当事务执行数据修改操作时，这些更改首先在内存中的缓冲池（Buffer Pool）上进行，修改后的数据页变成了所谓的“脏页”。</li><li><strong><code>记录Redo Log</code></strong>：与此同时，对这些脏页的修改会生成相应的重做日志记录，这些记录被写入到内存中的 <code>Log Buffer</code>。</li><li><strong><code>刷新Redo Log</code></strong>：Log Buffer中的内容会根据特定的策略定期或在事务提交时刷新到磁盘上的Redo Log文件中。</li><li><strong><code>脏页刷新</code></strong>：脏页的刷新到磁盘是一个独立的过程，它可能发生在事务提交之后的某个时间点，由InnoDB的后台进程管理。</li></ol><p class="note note-primary">事务提交为什么要先写redo log</p><p><code>Write-Ahead Logging</code>（WAL，先写日志）：是一种在数据库管理系统中广泛使用的日志技术，核心原则是在任何数据库数据被永久写入到磁盘之前，先将其修改操作写入到日志中。</p><ul><li><strong><code>提高事务执行效率</code></strong>：直接写入数据文件涉及随机I/O操作，这在大多数存储介质上效率较低。相比之下，写入Redo Log文件是顺序I/O操作，效率更高（WAL）。</li><li><strong><code>简化崩溃恢复过程</code></strong>：使用WAL，数据库恢复只需重放Redo Log文件中记录的操作，而无需检查和重写每个数据文件。</li></ul><h3 id="undo-log"><a class="markdownIt-Anchor" href="#undo-log"></a> undo log</h3><p><span class="green-line">回滚日志是用来记录数据变更前的状态</span>。当事务进行修改操作时，会同时记录相应的Undo Log，以便在事务回滚时使用。</p><div class="note note-warning"><p><strong>作用</strong></p><ul><li><strong>支持事务回滚</strong>：如果事务失败或被显式回滚，用来恢复数据到事务开始之前的状态。</li><li><strong>实现MVCC</strong>：多版本并发控制（MVCC）中，Undo Log被用来为不同事务提供历史数据的快照。即使数据被一个事务修改了，其他事务仍然可以看到修改前的数据版本。</li></ul></div><div class="note note-warning"><p><strong>生命周期</strong></p><ol><li><strong>生成</strong>：当事务执行数据修改操作（如INSERT、UPDATE、DELETE）时，InnoDB会生成相应的Undo Log。</li><li><strong>存储</strong>：Undo Log以段（segment）的形式存储在 <code>表空间</code> 中，每个Undo段包含多个Undo日志页。</li><li><strong>销毁</strong>：当没有任何事务需要访问Undo Log中的旧数据版本时，这些日志记录才会被清理。</li></ol></div><h3 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc"></a> MVCC</h3><p><img src="/2022/02/26/Mysql/%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8E%E5%BF%AB%E7%85%A7%E8%AF%BB.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>定义</strong>：</p><ul><li><strong><code>全称</code></strong>：Multi-Version Concurrency Control（多版本并发控制）。</li><li><strong><code>作用</code></strong>：MVCC允许在数据库中维护数据的多个版本，这样就可以在读写操作中减少冲突，提高并发性能。</li></ul><p><strong>实现机制</strong>：</p><ul><li><strong><code>隐式字段</code></strong>：每条数据库记录包含隐式字段。<ul><li><code>DB_TRX_ID</code>（事务ID）：记录了最后修改该记录的事务ID。</li><li><code>DB_ROLL_PTR</code>（回滚指针）：指向该记录对应的undo log记录。</li></ul></li><li><strong><code>Undo Log</code></strong>：存储了数据的旧版本信息，用于在读取时提供历史数据，以及在需要时回滚事务。</li><li><strong><code>Read View</code></strong>：在事务开始时创建的一致性视图，用于保证事务在执行期间看到数据库的一个一致性状态。</li></ul><p class="note note-primary">当前读</p><ul><li><strong><code>定义</code></strong>：当前读（Current Read）确保读取数据的最新版本，同时在读取过程中对数据加锁，防止其他并发事务对这些数据进行修改。</li><li><strong><code>加锁目的</code></strong>：加锁机制防止了数据在读取过程中被其他并发事务所更改。</li><li><strong><code>当前读的操作类型</code></strong>：<ul><li><code>加共享锁的读</code>：<code>SELECT ... LOCK IN SHARE MODE</code>，这个操作在读取数据的同时对其加上共享锁，允许其他事务读取但阻止修改。</li><li><code>加排他锁的读</code>：<ul><li><code>SELECT ... FOR UPDATE</code>：对所选记录加排他锁，阻止其他事务读取或修改这些记录。</li><li><code>UPDATE</code>、<code>INSERT</code>、<code>DELETE</code>：这些DML操作不仅修改数据，而且还会对所涉及的记录加排他锁。</li></ul></li></ul></li></ul><p class="note note-primary">快照读</p><ul><li><strong><code>定义</code></strong>：指的是在执行普通的<code>SELECT</code>查询（不加锁）时，读取的数据版本取决于事务开始的时间点。它不会看到在事务开始之后其他事务所做的修改。</li><li><strong><code>基于MVCC</code></strong>：快照读的实现基于MVCC机制，MVCC通过维护数据的不同版本来允许多个读写操作并发执行，而不直接影响彼此。</li></ul><p><strong>特点</strong>：</p><ul><li><strong><code>一致性视图</code></strong>：快照读提供了一个事务开始时的数据视图，避免了读取过程中的数据变动。</li><li><strong><code>非阻塞操作</code></strong>：由于快照读不加锁，它允许其他事务并发地修改数据。</li><li><strong><code>避免非重复读</code></strong>：在<code>Repeatable Read</code>级别下，快照读避免了非重复读的问题，即在同一事务中多次读取同一数据集返回的结果始终保持一致。</li></ul><p><strong>事务隔离级别的影响</strong>：</p><ul><li><code>Read Committed</code>：每次<code>SELECT</code>查询都会读取最新提交的数据。这意味着如果其他事务在两次查询之间提交了更改，后续的查询将看到这些更改。。</li><li><code>Repeatable Read</code>：事务中的第一个<code>SELECT</code>创建一个快照，后续的<code>SELECT</code>查询在事务内将读取这个快照，即使其他事务提交了更改。</li><li><code>Serializable</code>：最高的事务隔离级别，它要求事务之间完全串行执行，退化为当前读。</li></ul><p class="note note-primary">隐藏字段</p><p>在创建表时，InnoDB会自动创建两个隐藏字段用来实现 MVCC。</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td><code>DB_TRX_ID</code></td><td>事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td><code>DB_ROLL_PTR</code></td><td>回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本，实现快照读</td></tr><tr><td><code>DB_ROW_ID</code></td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p>上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><p class="note note-primary">测试</p><p><code>快照读</code></p><p>RR 隔离级别</p><table><thead><tr><th>T1事务</th><th>T2事务</th></tr></thead><tbody><tr><td>begin; 开启事务</td><td></td></tr><tr><td>select * from test2 where id = 100; //查询不到</td><td>begin; 开启事务</td></tr><tr><td></td><td>insert into test2(id, user_name, age, address)<br>values(100, ‘test100’, 20, null);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select * from test2 where id = 100; //快照读不可见</td><td></td></tr><tr><td>select * from test2 where id = 100 for update; //当前读可见</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table><h4 id="版本链"><a class="markdownIt-Anchor" href="#版本链"></a> 版本链</h4><p><img src="/2022/02/26/Mysql/%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8E%E5%BF%AB%E7%85%A7%E8%AF%BB.png" srcset="/img/loading.gif" lazyload alt></p><div class="note note-warning"><p><strong>工作机制</strong></p><ul><li><strong><code>版本链构建</code></strong>：InnoDB通过<code>DB_ROLL_PTR</code>字段在undo log中构建了一个版本链，每个版本代表了数据行在历史上的某个状态。</li><li><strong><code>读取操作</code></strong>：当进行快照读（如普通<code>SELECT</code>查询）时，InnoDB会根据事务的版本（由<code>DB_TRX_ID</code>和Read View确定）在版本链中查找相应的数据版本。</li><li><strong><code>版本可见性</code></strong>：根据当前事务的ID和Read View，判断各个历史版本是否对当前事务可见。</li></ul></div><div class="note note-warning"><p><strong>作用</strong></p><ul><li><strong><code>支持MVCC</code></strong>：版本链是MVCC实现的核心，允许事务访问数据的一致性历史版本，而不影响其他事务的操作。</li><li><strong><code>高效并发控制</code></strong>：通过维护数据的多个版本，InnoDB能够支持高并发的读写操作，减少锁的需求。</li></ul></div><h4 id="read-view"><a class="markdownIt-Anchor" href="#read-view"></a> Read View</h4><p><strong><code>定义</code></strong>：Read View（读视图）是一个用于实现多版本并发控制（MVCC）的内部数据结构，它定义了在一个给定事务中哪些数据版本是可见的。</p><p>ReadView 中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务列表，包括ReadView创建时刻所有已开始但未提交的事务ID</td></tr><tr><td>m_up_limit_id</td><td>最小活跃事务ID，<code>m_ids</code>集合中的最小事务ID，小于这个事务ID的数据都是可见的</td></tr><tr><td>m_low_limit_id</td><td>下一个将要被分配的事务ID，是ReadView可见事务的上界</td></tr><tr><td>m_creator_trx_id</td><td>ReadView创建者的事务ID，标识创建此ReadView的事务</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><code>READ COMMITTED</code> ：在每个SQL语句执行前生成ReadView。</li><li><code>REPEATABLE READ</code>：只在事务的第一个SELECT语句执行时生成。一旦生成，整个事务期间都会使用这个ReadView。</li></ul><p class="note note-primary">事务可见性判断</p><p><img src="/2022/02/26/Mysql/%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%A7%81%E6%80%A7%E5%88%A4%E6%96%AD.png" srcset="/img/loading.gif" lazyload alt></p><p>RR 隔离级别：</p><ul><li>创建快照这一刻，还未提交的事务不能读。</li><li>创建快照之后创建的事务不能读。</li></ul><p class="note note-primary">ReadView判断过程</p><p><img src="/2022/02/26/Mysql/%E4%BA%8B%E5%8A%A1%E6%B4%BB%E8%B7%83%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><p>RR 隔离级别：</p><ul><li><strong><code>生成ReadView</code></strong>：当事务进行第一次SELECT查询时，InnoDB为该事务生成一个ReadView。ReadView中包含当前活跃的事务ID集合（m_ids），最小活跃事务ID（min_trx_id），以及下一个将要分配的事务ID（max_trx_id）。</li><li><strong><code>读取判断</code></strong>：<ul><li><p>如果数据的创建事务ID小于 <code>最小活跃事务id</code>，说明这个事务在当前事务开始之前已提交，因此数据行对当前事务是可见的。</p></li><li><p>如果数据的创建事务ID <code>在活跃事务id中</code>，说明当前事务是活跃的，数据对当前事务是不可见。</p></li><li><p>如果数据的创建事务ID大于或等于 <code>下一个要分配的事务ID</code>，说明这个事务在当前事务开始之后开始，因此数据行对当前事务是不可见的。</p></li></ul></li></ul><h2 id="查询流程"><a class="markdownIt-Anchor" href="#查询流程"></a> 查询流程</h2><p><img src="/2022/02/26/Mysql/mysql%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p><strong>查询缓存（Query Cache）</strong>：</p><ul><li>在解析之前，MySQL会检查查询缓存。如果相同的查询之前已执行并且结果存储在查询缓存中，则直接返回缓存结果。</li></ul></li><li><p><strong>解析器（Parser）</strong>：</p><ul><li>当用户发出SQL查询时，MySQL首先通过解析器对SQL语句进行语法分析。解析器检查SQL语句的语法是否正确，并将其转换为一种内部格式的查询表示（解析树）。</li></ul></li><li><p><strong>预处理器（Preprocessor）</strong>：</p><ul><li>在解析后，预处理器进一步检查解析树的语义正确性，比如表和列的存在性、数据类型的匹配等。</li></ul></li><li><p><strong>优化器（Optimizer）</strong>：</p><ul><li>优化器负责查询的优化。它分析多种可能的执行计划，选择一种成本最低的计划来执行查询。这包括决定使用哪些索引，如何连接表等。</li></ul></li><li><p><strong>执行查询执行（Execution）</strong>：</p><ul><li>MySQL根据执行计划对数据库进行操作。在InnoDB存储引擎中，这涉及到如下几个步骤：<ul><li><strong>a. 行锁定</strong>：如果是当前读，会对数据行进行锁定。</li><li><strong>b. 数据检索</strong>：访问存储在磁盘上的数据页面，可能涉及到索引的使用。</li><li><strong>c. 缓冲池（Buffer Pool）</strong>：InnoDB会首先检查数据是否已在缓冲池中。如果不在，从磁盘读取数据并放入缓冲池。</li><li><strong>d. ReadView</strong>：在RR隔离级别下，如果进行的是一致性读操作，InnoDB会创建一个ReadView来保证数据的一致性。</li></ul></li></ul></li><li><p><strong>结果返回</strong>：</p><ul><li>执行完查询后，将结果返回给用户。对于SELECT查询，这包括了从数据行中检索出的数据；对于UPDATE、INSERT或DELETE查询，这包括了影响的行数等信息。</li></ul></li></ul><p class="note note-primary">查询缓存</p><ol><li><strong><code>工作机制</code></strong>：<ul><li>当一个SELECT查询执行时，MySQL首先检查查询缓存。</li><li>如果找到一个与当前查询完全相同（文本匹配，包括空格和注释）的缓存条目，MySQL就会直接返回缓存中的结果。</li><li>如果没有找到匹配的缓存，查询将继续进行SQL解析、优化和执行。</li></ul></li><li><strong><code>缓存失效</code></strong>：<ul><li>查询缓存对数据变动非常敏感。当任何涉及缓存查询的表被修改（INSERT、UPDATE、DELETE等），所有相关的缓存条目都会立即失效。</li></ul></li><li><strong><code>局限性</code></strong>：<ul><li>查询缓存在高并发和高更新场景下成为性能瓶颈，因为频繁的缓存失效和重建会消耗大量资源。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询查询缓存是否开启<br><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%query_cache%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong><code>查询缓存被移除</code></strong>：在MySQL 8.0及以后的版本中，查询缓存功能被完全移除。这是因为查询缓存在现代高并发数据库系统中往往带来更多的性能问题而非益处。</li><li><strong><code>性能优化</code></strong>：MySQL 8.0集中优化了查询执行器和优化器，提供更高效的查询处理机制，尤其是在高并发场景下。</li></ul><p class="note note-primary">语法解析和预处理</p><div class="note note-warning"><p><strong>语法解析</strong></p><ul><li><code>分析SQL语句</code>：检查SQL语句的语法是否正确。这包括识别关键字、运算符、表名、列名等。</li><li><code>生成解析树</code>：如果语法没有错误，解析器将SQL语句转换为一种内部表示形式，是一种解析树（也称为语法树）。这个树结构表示了SQL语句的组成部分及其关系。</li><li><code>错误处理</code>：如果解析器发现语法错误，它会停止处理并返回错误消息。</li></ul></div><div class="note note-warning"><p><strong>预处理</strong></p><ul><li><code>语义检查</code>：确保SQL语句在语义上是有效的。这包括检查引用的表和列是否存在，数据类型是否匹配，解析名称等。</li><li><code>权限验证</code>：检查执行该查询的用户是否具有相应的权限。</li><li><code>变量替换</code>：处理SQL语句中的变量和参数。</li><li><code>解析表达式</code>：评估SQL语句中的表达式。</li></ul></div><p class="note note-primary">查询优化</p><div class="note note-warning"><p><strong>优化器</strong></p><ul><li><code>查询重写</code>：优化器可能会改写查询，例如简化查询条件、去除冗余的条件等。</li><li><code>索引选择</code>：优化器根据可用的索引和统计信息来决定是否使用索引，以及使用哪个索引。</li><li><code>连接顺序</code>：在涉及多个表的查询中，确定连接这些表的最有效顺序。</li><li><code>连接策略</code>：选择适合的连接算法，如嵌套循环连接（Nested-Loop Join）或哈希连接（Hash Join）。</li></ul></div><div class="note note-warning"><p><strong>成本估算和执行计划选择</strong></p><ul><li>基于表的统计信息和索引特性，优化器会估算不同执行计划的成本，包括I/O成本、CPU成本等。</li><li>最终选择总成本最低的执行计划。</li></ul></div><p class="note note-primary">查询执行引擎</p><ul><li><code>查询执行</code>：执行引擎根据优化器提供的执行计划执行查询，包括从存储引擎检索数据、执行联接、处理排序和聚合等操作。</li><li><code>存储引擎接口</code>：查询执行过程中，执行引擎会调用存储引擎（如InnoDB）提供的接口，这些接口被称为handler API。它们用于完成数据的实际读取、写入以及处理事务等任务。</li></ul><p class="note note-primary">返回客户端结果</p><ul><li><code>缓存结果</code>：如果查询可以被缓存，mysql会在这个阶段将结果存放到查询缓存中，8.0后移除。</li><li><code>流式返回</code>：一旦查询生成了第一条结果，就开始向客户端逐步发送结果，而不需要等待整个结果集生成完毕。</li></ul><h2 id="写入流程"><a class="markdownIt-Anchor" href="#写入流程"></a> 写入流程</h2><p><img src="/2022/02/26/Mysql/%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><ol><li><strong><code>开启新的事务</code></strong></li><li><strong><code>数据修改</code></strong>：执行INSERT、UPDATE或DELETE操作时，首先在缓冲池中修改数据页。如果所需页不在缓冲池中，则先从磁盘读取该页到缓冲池。</li><li><strong><code>日志记录</code></strong>：<ul><li><code>undo log</code>：对每项数据进行修改前都会记录数据修改前的状态（undo log），用于事务回滚。</li><li><code>redo log</code>：对每项数据进行修改都会生成重做日志条目（Redo log）并暂存到 <code>Log Buffer</code> 中。</li></ul></li><li><strong><code>索引处理</code></strong>：<ul><li><code>唯一索引检查</code>：如果修改涉及到唯一索引，必须检查新数据是否违反唯一性约束。</li><li><code>非唯一索引</code>：如果索引页不在缓冲池，先将索引的修改操作暂存到 <code>Change Buffer</code> 中，等待索引被加载后进行索引页合并。</li></ul></li><li><strong><code>事务提交</code></strong>：<ul><li><code>Prepare</code>（准备）：将 Log Buffer 中的 Redu Log 刷新到磁盘日志文件，用于数据异常恢复。</li><li><code>Commit</code>（提交）：在所有 Redo Log 成功写入磁盘后，在重做日志中添加一个 <code>事务提交</code> 的记录，标志着事务已经成功提交。<ul><li><code>bin log</code>：事务的binlog事件首先写入系统缓冲区，并根据 <code>sync_binlog</code> 的配置决定何时刷新到磁盘。</li></ul></li></ul></li></ol><p><strong>sync_binlog</strong>：</p><ul><li><code>值为 0</code>：Mysql不主动刷新缓冲区，由操作系统进行刷盘，效率最高。</li><li><code>值为 1</code>（默认）：事务提交后马上对 bin log 进行刷盘，增加数据安全。</li><li><code>值大于 1</code>：指定在这么多次事务提交后刷新 bin log 到磁盘，可在数据安全性和性能之间做出权衡。</li></ul><h2 id="bin-log"><a class="markdownIt-Anchor" href="#bin-log"></a> bin log</h2><p><code>binlog</code>，或称为二进制日志，用于记录数据库中所有修改数据的操作，如INSERT、UPDATE、DELETE和DDL（数据定义语言）操作如CREATE TABLE、ALTER TABLE。</p><p><strong>作用</strong>：</p><ol><li><strong><code>数据复制</code></strong>：<code>binlog</code>是MySQL主从复制的基础。主服务器上的<code>binlog</code>记录了所有的数据变更，这些记录会被复制到从服务器并重放，实现数据的一致性。</li><li><strong><code>数据恢复</code></strong>：在发生数据丢失时，可以使用 <code>binlog</code> 来恢复操作，将数据库恢复到特定的时间点。</li></ol><p><strong>三种模式</strong>：</p><ul><li><strong><code>Statement</code></strong>：基于语句的复制。这种模式下，<code>binlog</code>记录了执行的SQL语句。</li><li><strong><code>Row</code></strong>（8.0默认）：基于行的复制。记录了更改后行的内容。</li><li><strong><code>Mixed</code></strong>：混合模式，结合了语句和行模式。<ul><li><code>语句复制</code>：正常情况下使用。</li><li><code>行复制</code>：使用了自定义函数。</li></ul></li></ul><p class="note note-primary">SQL语句复制 Statement</p><p>把所有的修改语句都记录在bin log中。</p><ul><li><p><strong>优点</strong>：由于只记录了SQL语句本身，而非行级别的变化，减少I/O开销，从而提高性能。</p></li><li><p><strong>缺点</strong>：特殊场景可能导致主从数据不一致，尤其是当使用一些非确定性的函数（如NOW()、RAND()）或依赖于数据库状态的查询（如LAST_INSERT_ID()）时。</p></li></ul><p class="note note-primary">行复制 ROW</p><p>记录的是每行数据变更的具体内容，包括修改前和修改后的数据</p><p><strong>优点</strong>：</p><ul><li><strong><code>数据一致性</code></strong>：由于记录了具体的行变化，减少由于执行上下文差异引起的数据不一致问题。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>日志体积</code></strong>：较大的日志体积，特别是在进行大量数据变更的操作时（如批量插入或更新）。</li><li><strong><code>复制效率</code></strong>：进行大量数据变更的操作会产生大量日志，复制效率低。</li></ul><p class="note note-primary">混合复制</p><p>根据上下文自动选择语句复制或行复制。</p><p><strong>优点</strong>：</p><ul><li><strong><code>效率和一致性</code></strong>：通过自动转换模式找到复制效率和数据一致性的平衡点。</li><li><strong><code>灵活性</code></strong>：自动选择最合适的复制方式，根据不同类型的操作动态调整。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>复杂性</code></strong>：自动切换复制模式可能导致复制过程的复杂性增加，需要更细致的监控和管理。</li></ul><h1 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h1><h2 id="主键使用自增还是uuid"><a class="markdownIt-Anchor" href="#主键使用自增还是uuid"></a> 主键使用自增还是UUID</h2><p class="note note-primary">auto_increment</p><p><strong>优点</strong>：</p><ul><li><strong><code>性能提升</code></strong>：自增主键新数据插入在表的末尾，减少了页分裂，提升写入性能。</li><li><strong><code>空间效率</code></strong>：数字型主键占用空间小，比如INT或BIGINT类型，有利于提高检索性能。</li><li><strong><code>易于索引和排序</code></strong>：数字主键对索引和排序操作更为高效，因为数字比较操作通常比字符串或其他类型的比较更快。</li><li><strong><code>简化设计</code></strong>：自增主键由数据库自动管理，简化了数据插入过程，无需手动生成主键。</li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong><code>业务量暴露</code></strong>：自增主键可能暴露业务量等敏感信息，存在安全隐患。</p></li><li><p><strong><code>自增锁竞争</code></strong>：在高并发场景下，自增锁竞争可能降低数据库的吞吐能力。</p></li><li><p><strong><code>扩展性限制</code></strong>：在数据迁移、分库分表场景中，自增主键的全局唯一性维护困难。</p></li></ul><p class="note note-primary">UUID</p><p>UUID泛指自动生成单调递增的ID。</p><p><strong>优点</strong>：</p><ul><li><strong><code>全局唯一性</code></strong>：在全局范围内确保唯一性，适合 <code>分布式</code> 系统和需要唯一标识符的场景。</li><li><strong><code>提升插入性能</code></strong>：在应用层生成，无需数据库支持。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>实现复杂</code></strong>：增加系统复杂性，要保证全局唯一，单调递增。</li><li><strong><code>性能问题</code></strong>：如果非数字类型，会占用更大的存储空间，主键检索效率降低。</li><li><strong><code>数据页分裂</code></strong>：如果无法保证单调递增将导致数据库中的数据页分裂，影响插入操作的性能。</li></ul><h2 id="b树-b树的区别"><a class="markdownIt-Anchor" href="#b树-b树的区别"></a> B树、B+树的区别</h2><p><img src="https://upload-images.jianshu.io/upload_images/1446087-bc023e47bc74cfa1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong>数据存储</strong>：B树在每个节点中存储键和数据。而B+树叶子节点存储键和数据，非叶子节点仅存储键。</li><li><strong>范围查询</strong>：B+树叶子节点使用指针两两相连，便于支持范围查询和排序。</li><li><strong>I/O效率</strong>：B+树的非叶子节点不存储数据，可以存储更多的键，从而树的高度更低，在相同数据量的情况下减少磁盘I/O次数。</li></ul><p><img src="/2022/02/26/Mysql/%E7%AE%80%E5%8C%96B+%E6%A0%91.png" srcset="/img/loading.gif" lazyload alt></p><h2 id="myisam-和-innodb的区别"><a class="markdownIt-Anchor" href="#myisam-和-innodb的区别"></a> MyISAM 和 Innodb的区别</h2><p><font color="red">使用Innodb于MyIsam特性做比较</font></p><p class="note note-primary">MyISAM</p><p><a href="#myisam">MyISAM 存储引擎</a></p><ul><li>5.5版本之前的默认引擎。</li><li>支持全文索引。</li><li>不支持事务。</li><li>锁级别是表锁，不支持行级锁。</li><li>不支持外键约束。</li><li>索引和数据分开存储。</li></ul><p class="note note-primary">Innodb</p><p><a href="#innodb">InnoDB存储引擎</a></p><ul><li>支持事务，MVCC。</li><li>使用聚簇索引，索引和数据一起存储。</li><li>支持行级锁，间隙锁。</li><li>支持外键约束。</li></ul><h2 id="mysql的索引有哪些聚簇和非聚簇索引又是什么"><a class="markdownIt-Anchor" href="#mysql的索引有哪些聚簇和非聚簇索引又是什么"></a> mysql的索引有哪些，聚簇和非聚簇索引又是什么</h2><p>参考 <a href="#索引">索引</a></p><p class="note note-primary">按数据结构分</p><ul><li>B+树索引</li><li>hash索引</li></ul><p class="note note-primary">按特性分</p><ul><li>主键索引</li><li>唯一索引</li><li>普通索引</li><li>组合索引</li><li>前缀索引</li></ul><p><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">聚簇索引</a>：聚簇索引是一种数据组织方式，非叶子节点存储数据的键，叶子节点存储数据的键和值，叶子节点两两相连。</p><p><a href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95">非聚簇索</a>: 也叫二级索引，非聚簇索引是表的一个单独的索引结构，包含了索引列的值和对应行的主键值，但不包含行的完整数据。</p><p><a href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2">回表查询</a>:</p><ul><li>当通过非聚簇索引检索数据时，如果需要的数据不全部包含在索引中，就会进行回表查询。</li><li>回表查询是一个两步过程：首先，通过非聚簇索引找到对应行的主键；然后，使用这个主键去聚簇索引中检索完整的行数据。</li></ul><h2 id="什么是覆盖索引和回表"><a class="markdownIt-Anchor" href="#什么是覆盖索引和回表"></a> 什么是覆盖索引和回表</h2><ul><li><p><a href="#索引覆盖">索引覆盖</a></p></li><li><p><a href="#回表查询">回表查询</a></p></li></ul><h2 id="什么是索引下推"><a class="markdownIt-Anchor" href="#什么是索引下推"></a> 什么是索引下推</h2><p><a href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8">索引下推</a></p><p>在索引扫描阶段，MySQL能够在索引内部应用WHERE子句的一部分条件，从而仅检索那些可能符合所有搜索条件的行。</p><h2 id="什么是执行计划"><a class="markdownIt-Anchor" href="#什么是执行计划"></a> 什么是执行计划</h2><p><a href="#explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">explain 执行计划</a></p><h2 id="锁的类型有哪些"><a class="markdownIt-Anchor" href="#锁的类型有哪些"></a> 锁的类型有哪些</h2><p><a href="#%E9%94%81">数据库进阶 锁</a></p><p class="note note-primary">按粒度分</p><ul><li><a href="#%E5%85%A8%E5%B1%80%E9%94%81">全局锁</a></li><li><a href="#%E8%A1%A8%E7%BA%A7%E9%94%81">表级锁</a></li><li><a href="#%E8%A1%8C%E7%BA%A7%E9%94%81">行级锁</a></li></ul><p class="note note-primary">按类型分</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁</li><li>排他锁（X）：写锁是排他的，它会阻塞其他的写锁和读锁</li></ul><p class="note note-primary">按种类分</p><ul><li><a href="#%E5%85%A8%E5%B1%80%E9%94%81">全局锁</a></li><li><a href="#%E8%A1%A8%E7%BA%A7%E9%94%81">表级锁</a><ul><li><a href="#%E8%A1%A8%E9%94%81">表锁</a></li><li><a href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81">元数据锁</a></li><li><a href="#%E6%84%8F%E5%90%91%E9%94%81">意向锁</a></li></ul></li><li><a href="#%E8%A1%8C%E7%BA%A7%E9%94%81">行级锁</a><ul><li><a href="#%E8%A1%8C%E9%94%81">行锁</a></li><li><a href="#%E9%97%B4%E9%9A%99%E9%94%81">间隙锁</a></li><li><a href="#%E4%B8%B4%E9%94%AE%E9%94%81">临键锁</a></li></ul></li></ul><h2 id="事务的基本特性和隔离级别"><a class="markdownIt-Anchor" href="#事务的基本特性和隔离级别"></a> 事务的基本特性和隔离级别</h2><p><a href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86">事务原理</a></p><p class="note note-primary">基本特性</p><ul><li><strong><code>原子性</code>（Atomicity）</strong>：事务中的所有操作要么全部成功，要么全部失败，不会停留在中间状态。</li><li><strong><code>一致性</code>（Consistency）</strong>：事务必须保证数据库从一个一致性状态转移到另一个一致性状态。</li><li><strong><code>隔离性</code>（Isolation）</strong>：事务的执行不会被其他事务干扰，多个并发事务之间的数据库操作是隔离的。</li><li><strong><code>持久性</code>（Durability）</strong>：一旦事务完成，其对数据库的修改应该是永久性的，即使出现系统故障。</li></ul><p class="note note-primary">隔离级别</p><table><thead><tr><th><strong>隔离级别</strong>（+:允许出现，-:不允许出现）</th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th></tr></thead><tbody><tr><td>未提交读</td><td>+</td><td>+</td><td>+</td></tr><tr><td>提交读</td><td>-</td><td>+</td><td>+</td></tr><tr><td>可重复读</td><td>-</td><td>-</td><td>+</td></tr><tr><td>序列化读</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><table><thead><tr><th>问题</th><th>说明</th></tr></thead><tbody><tr><td>脏读</td><td>在一个事务中读取到了另一个事务未提交的数据。这可能导致读取到错误的信息。</td></tr><tr><td>不可重复读</td><td>在同一个事务中，对同一数据的多次读取结果不一致。这通常是由于在两次读取之间，另一个事务修改了数据。</td></tr><tr><td>幻读</td><td>在同一个事务中，两次执行相同的查询，返回的结果集不一致。通常是因为在两次查询之间，另一个事务插入或删除了数据行。</td></tr></tbody></table><p><a href="#%E4%B8%B4%E9%94%AE%E9%94%81">可重复读级别解决幻读</a>：在可重复读隔离级别下，InnoDB通过使用临键锁（结合行锁和间隙锁）防止了幻读问题。在进行 <code>范围查询</code> 或 <code>索引扫描</code> 时，InnoDB会在涉及的索引范围内设置间隙锁和行锁，防止其他事务在这些范围内插入或删除记录。</p><h2 id="acid靠什么保证"><a class="markdownIt-Anchor" href="#acid靠什么保证"></a> ACID靠什么保证</h2><p><a href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86">事务原理</a></p><h2 id="什么是幻读什么是mvcc"><a class="markdownIt-Anchor" href="#什么是幻读什么是mvcc"></a> 什么是幻读，什么是MVCC</h2><p><a href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">幻读</a></p><p><a href="#mvcc">MVCC</a></p><h2 id="什么是间隙锁"><a class="markdownIt-Anchor" href="#什么是间隙锁"></a> 什么是间隙锁</h2><p>间隙锁是<span style="border-bottom:2px dashed green">可重复读级别</span>下才会有的锁，用于解决幻读问题。</p><p><a href="#%E9%97%B4%E9%9A%99%E9%94%81">间隙锁</a></p><h2 id="分库分表怎么做"><a class="markdownIt-Anchor" href="#分库分表怎么做"></a> 分库分表怎么做</h2><p>首先分库分表分为垂直和水平两个方式，拆分的顺序是先垂直后水平。</p><p class="note note-primary">垂直分库</p><p><strong><code>定义</code></strong>：垂直分库是指按照业务模块或服务功能将数据库分成独立的部分，每个部分包含相关的表和数据。这种分库策略通常与微服务架构相结合，实现服务的数据隔离。</p><p><strong><code>实现方式</code></strong>：在微服务架构中，每个服务通常对应一个专用的数据库。这样，服务间的数据库操作互不干扰，实现了数据和业务的解耦。</p><p><strong>优点</strong>：</p><ul><li><strong><code>提高性能</code></strong>：由于数据库较小，查询效率更高。</li><li><strong><code>故障隔离</code></strong>：故障影响范围限于单个服务，不会波及整个系统。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>数据一致性</code></strong>：跨服务的数据一致性维护变得更加复杂。</li><li><strong><code>资源冗余</code></strong>：每个服务都需要单独的数据库实例，导致资源使用上的冗余。</li></ul><p class="note note-primary">垂直分表</p><p><img src="/2022/02/26/Mysql/%E5%9E%82%E7%9B%B4%E6%8B%86%E8%A1%A8.jpg" srcset="/img/loading.gif" lazyload alt></p><p><strong><code>定义</code></strong>：垂直分表是指将一个数据表按照字段进行拆分，将不同的字段划分到不同的表中。这种拆分通常基于字段的使用频率、数据大小或相关性</p><p><strong>实现方式</strong>：</p><ul><li><strong><code>常用字段和不常用字段分离</code></strong>：将频繁访问的字段和较少访问的字段分离到不同的表中。</li><li><strong><code>大字段分离</code></strong>：将数据量大的字段（如文本、BLOB等）从主表中分离出去，以优化主表的访问性能。</li></ul><p><strong>优点</strong>:</p><ul><li><strong><code>提高性能</code></strong>：减少单个查询的数据量，提高查询速度和效率。</li><li><strong><code>提高可维护性</code></strong>：简化了表结构，使得维护和管理更加容易。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>增加复杂性</code></strong>：查询涉及多个表时，需要进行表间的关联查询，增加了查询的复杂性。</li></ul><p class="note note-primary">水平分表</p><p><strong><code>定义</code></strong>：水平分表指的是将一个表中的行分割成多个较小的表，每个表包含相同的列，但只存储原始表中的一部分行。这种分割通常基于某些列的值，如时间戳、地理位置或其他业务相关的键。</p><ul><li><strong><code>时间分割法</code></strong>：是一种基于时间维度来进行水平分表的方法。比如按照月、季度、年或其他时间单位将数据分割到不同的表中。</li><li><strong><code>Hash取模法</code></strong>：是根据分片键的hash值对数据进行分表。选取一个或多个具有业务意义的字段作为分片键，对这个字段的值取hash，然后根据分表的数量进行取模运算来决定数据存储在哪个分表中。</li></ul><div class="note note-warning"><p><strong>映射法</strong></p><p>​	<img src="http://kenful.gitee.io/image/mysql/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%98%A0%E5%B0%84%E8%A1%A8.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>定义</strong>：分表映射法是将数据从一个大表分散到多个小表中，并使用一个额外的 <code>映射表</code> 来记录数据在这些分表中的位置（比如ID）。映射表根据关键查询字段来指向相应的分表和行，从而优化数据的检索过程。</p><p><strong>实现过程</strong>：</p><ol><li><strong><code>数据分散</code></strong>：根据一定的规则，如范围、哈希值或其他业务逻辑，将原始大表中的数据分散到多个小表中。</li><li><strong><code>创建映射表</code></strong>：建立一个映射表，包含用于查询的字段和子表的主键以及数据对应表的位置。</li><li><strong><code>查询流程</code></strong>：<ul><li>当需要查询特定数据时，首先在映射表中查询以确定目标数据存储在哪个分表的哪个位置（ID）。</li><li>然后直接访问该分表来获取详细数据。</li></ul></li></ol><p><strong>优点</strong>：</p><ul><li><strong><code>高效查询</code></strong>：映射表通过索引覆盖快速定位子表位置。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>跨子表查询的性能下降</code></strong>：如果查询需要涉及多个子表（尤其是跨表查询），会导致性能下降，因为这相当于在多个表上进行查询和汇总。</li><li><strong><code>关联查询</code></strong>：通过子表字段实现关联困难。</li></ul></div><div class="note note-warning"><p><strong>业务后缀法</strong></p><p>​	<img src="http://kenful.gitee.io/image/mysql/%E4%B8%9A%E5%8A%A1%E5%90%8E%E7%BC%80%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>定义</strong>：业务后缀法是一种将大表按照业务逻辑分割成多个小表的方法。每个小表都具有相同的结构，但表名通常会附加一个与业务相关的后缀，以标识它包含特定业务或数据段的数据。</p><p><strong>实现过程</strong>：</p><ol><li><strong><code>确定分表依据</code></strong>：根据业务逻辑选择适当的分表依据，如用户地区、用户类型、产品类别等。</li><li><strong><code>创建分表</code></strong>：对于每个业务维度或类别，创建一个单独的表。表名通常包含一个后缀，如<code>orders_us</code>、<code>orders_uk</code>等，表示不同地区的订单数据。</li><li><strong><code>数据分配</code></strong>：根据业务规则将数据插入到相应的分表中。</li></ol><p><strong>优点</strong>：</p><ul><li><p><strong><code>容易实现</code></strong>：根据业务快速实现水平分表，比如初始化。</p></li><li><p><strong><code>业务清晰</code></strong>：每个表对应特定的业务逻辑，使得数据组织更加清晰。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong><code>数据分布不均</code></strong>：如果业务分布不均衡，某些表可能会比其他表数据量大很多，导致性能瓶颈。</p></li><li><p><strong><code>维护难度</code></strong>：当业务逻辑变更时，可能需要调整分表策略，增加了维护的难度</p></li></ul></div><div class="note note-warning"><p><strong>基因注入法</strong></p><p><img src="http://kenful.gitee.io/image/mysql/%E5%9F%BA%E5%9B%A0%E6%B3%A8%E5%85%A5%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>定义</strong>：通过一个或多个业务字段生成一个key，把该key作为分片键。</p><p><strong>实现过程</strong>：</p><ol><li><strong><code>选择分片键</code></strong>：根据业务需求选择一个或多个字段，这些字段具有将数据合理分散的特性。</li><li><strong><code>生成分片键</code></strong>：通过这些字段计算得出一个分片键，可以是哈希值、组合键或其他形式的唯一标识符。</li><li><strong><code>数据分配</code></strong>：根据分片键的值将数据分散到不同的分表中。例如，可以根据分片键的哈希值对分表数量取模来决定数据应该存储在哪个表中。</li></ol><p><strong>优点</strong>：通过算法将数据更均匀分配到各个子表中。</p><p><strong>缺点</strong>：需要按照业务场景实现pub字段算法。</p></div><div class="note note-warning"><p><strong>时效分表法</strong></p><p>数据具有时效性</p><p>在某个时间段内双写表，某个时间后自动删除旧表</p><p><img src="http://kenful.gitee.io/image/mysql/%E6%97%B6%E6%95%88%E5%88%86%E8%A1%A8%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>使用场景</strong>：</p><ul><li>数据具有时效性。</li><li>比如系统消息。</li></ul><p><strong>定义</strong>：基于时间属性对数据进行分表，将数据插入到两张表中。在数据达到某个时间阈值后，通过删除或归档旧表来管理历史数据。</p><p><strong>要求</strong>：数据不会被频繁更新。</p><p><strong>实现过程</strong>：</p><ol><li><strong><code>时间段表</code></strong>：比如根据创建时间按月，按年分表。</li><li><strong><code>双写策略</code></strong>：将新数据同时写入当前活跃表和即将成为活跃的新表。这确保了在切换到新表时，数据的连续性和完整性。</li><li><strong><code>旧表处理</code></strong>：在切换到新表后的某个时间点，自动删除或归档旧表</li></ol><p><strong>优点</strong>：</p><ul><li><strong><code>防止成为大表</code></strong>：通过时间不段创建和删除表，控制数据规模。</li><li><strong><code>历史数据查询</code></strong>：通过双写策略，既保证了历史数据的可查询性，也保持了查询高效。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong><code>增加写入负载</code></strong>：在双写阶段，对两个表的写入会增加数据库的负载。</li></ul></div><h2 id="分表后的id怎么保证唯一性"><a class="markdownIt-Anchor" href="#分表后的id怎么保证唯一性"></a> 分表后的ID怎么保证唯一性</h2><p><strong>主键的选择要符合单调递增，有效减少页合并和分裂</strong></p><ul><li><p><strong>号段模式</strong></p><ul><li><code>描述</code>：使用数据库记录当前最大的全局ID，并每次分配一个固定范围的号段（如1到1000）给应用服务器。服务器在本地内存中缓存这些ID，并逐个使用。</li><li><code>适用场景</code>：适合高并发环境。</li><li><code>注意事项</code>：需要处理号段分配和回收，防止号段耗尽或冲突。</li></ul></li><li><p><strong>雪花算法（Snowflake）</strong></p><ul><li><code>描述</code>：结合时间戳、机器标识和序列号生成唯一ID。只要服务器时间保持向前，就能保证ID的唯一性。</li><li><code>适用场景</code>：分布式系统。</li><li><code>注意事项</code>：需要确保服务器时钟的准确性和同步。</li></ul></li><li><p><strong>Redis的<code>INCR</code>命令</strong></p><ul><li><code>描述</code>：使用Redis的单线程特性，通过<code>INCR</code>命令生成递增的唯一数字ID。</li><li><code>适用场景</code>：轻量级应用或非极端高唯一性要求的场景。</li><li><code>注意事项</code>：在Redis故障重启或数据丢失时可能存在风险。</li></ul></li><li><p><strong>美团Leaf</strong></p><ul><li><code>描述</code>：美团的Leaf是一个分布式ID生成服务，结合号段模式和雪花算法等多种策略来生成唯一ID。</li><li><code>适用场景</code>：需要高度定制化的大型分布式环境。</li><li><code>注意事项</code>：提供了高可用性和可扩展性，适合服务化部署。</li></ul></li></ul><h2 id="分表后非sharding_key的查询怎么处理"><a class="markdownIt-Anchor" href="#分表后非sharding_key的查询怎么处理"></a> 分表后非sharding_key的查询怎么处理</h2><ul><li><strong>使用索引表（映射表）</strong>：建立一个额外的索引表（或映射表），记录非sharding key与所在分表的映射关系。查询时，先查询索引表确定数据所在的分表，再对这些分表执行查询。</li><li><strong>使用搜索引擎ES</strong>：将分表数据同步给搜索引擎，使用搜索引擎对数据进行检索。</li><li><strong>使用中间件</strong>：使用支持分表的数据库中间件，如 <code>MyCAT</code>、<code>Shardingsphere</code>，这些中间件提供跨分表查询能力。</li></ul><h2 id="mysql主从同步怎么做的"><a class="markdownIt-Anchor" href="#mysql主从同步怎么做的"></a> MySql主从同步怎么做的</h2><p><img src="/2022/02/26/Mysql/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong><code>事务提交与二进制日志（Binlog）</code></strong>：在主服务器（master）上，提交的事务被写入二进制日志（binlog）。这个日志记录了改变数据库状态的所有操作。</li><li><strong><code>从服务器与主服务器建立连接</code></strong>：从服务器（slave）上的I/O线程连接到主服务器，并请求从上一次已知的binlog位置开始的binlog内容。</li><li><strong><code>主服务器的Dump线程</code></strong>：主服务器创建一个dump线程来处理来自从服务器的请求。该线程将binlog的内容发送到从服务器。</li><li><strong><code>中继日志（Relay Log）</code></strong>：从服务器上的I/O线程读取从主服务器接收到的binlog，并将其记录到本地的中继日志（relay log）中。</li><li><strong><code>执行同步操作</code></strong>：从服务器上的SQL线程读取中继日志中的事件，并在从服务器数据库上执行这些操作，从而实现数据的同步。</li><li><strong><code>从服务器的二进制日志</code></strong>：如果启用了从服务器的binlog（在进行链式复制或备份时），则从服务器上的操作也会被记录到其自己的binlog中。</li></ul><p class="note note-primary">同步模式</p><div class="note note-warning"><p><strong>异步复制</strong>（Asynchronous Replication 默认）</p><ul><li><strong><code>工作机制</code></strong>：在异步复制中，主服务器在事务提交后不等待从服务器确认即完成事务。主服务器的二进制日志事件（binlog events）被发送到从服务器，但主服务器不会等待从服务器确认它们已接收和处理这些事件。</li><li><strong><code>特点</code></strong>：<ul><li><code>性能</code>：更高的性能，因为主服务器不需要等待从服务器的响应。</li><li><code>数据延迟</code>：会出现数据延迟，从服务器可能落后于主服务器。</li></ul></li><li><strong><code>适用场景</code></strong>：适用于对数据实时性要求不高的场景。</li></ul></div><div class="note note-warning"><p><strong>半同步复制</strong>（Semi-Synchronous Replication）</p><ul><li><strong><code>工作机制</code></strong>：在半同步复制中，主服务器在事务提交后会等待至少一个从服务器确认已接收到二进制日志事件后才视为事务完成。如果在指定时间内没有从服务器确认，主服务器将退回到异步复制模式。</li><li><strong><code>特点</code></strong>：<ul><li><code>数据安全性</code>：提高了数据一致性和可靠性，减少了数据丢失的风险。</li><li><code>性能影响</code>：影响写入性能，因为主服务器需要等待从服务器的确认。</li></ul></li><li><strong><code>适用场景</code></strong>：适用于需要平衡数据可靠性和系统性能的场景。</li></ul></div><div class="note note-warning"><p><strong>全同步复制</strong>（Fully Synchronous Replication）</p><ul><li><strong><code>工作机制</code></strong>：全同步复制意味着所有的事务在主服务器和从服务器上几乎同时提交。比如使用多主节点复制系统（如<a target="_blank" rel="noopener" href="https://galeracluster.com/">Galera Cluster</a>）实现。</li><li><strong><code>特点</code></strong>：<ul><li><code>数据一致性</code>：提供强数据一致性保证。</li><li><code>性能影响</code>：写入性能最差，需要在所有节点上确认。</li></ul></li><li><strong><code>适用场景</code></strong>：适用于对数据一致性有严格要求的高可用性集群环境。</li></ul></div><h2 id="binlog同步支持哪些格式"><a class="markdownIt-Anchor" href="#binlog同步支持哪些格式"></a> binlog同步支持哪些格式</h2><p><a href="#bin-log">binlog</a></p><h2 id="主从的延迟怎么解决"><a class="markdownIt-Anchor" href="#主从的延迟怎么解决"></a> 主从的延迟怎么解决</h2><ul><li><strong><code>硬件和网络优化</code></strong></li><li><strong><code>并行复制</code></strong></li><li><strong><code>调整复制格式</code></strong><ul><li>比如使用行格式（<code>ROW</code>）的二进制日志可以减少从服务器应用更改所需的时间，因为它不需要解析SQL语句。</li></ul></li></ul><div class="note note-warning"><p><img src="/2022/02/26/Mysql/%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6.png" srcset="/img/loading.gif" lazyload alt></p><p>并行复制是指从服务器（slave）上并行（多线程）应用主服务器（master）的二进制日志（binlog）中的事件，以提高复制性能和减少延迟的机制。在传统的串行复制中，从服务器上的SQL线程会按照二进制日志中的事件顺序逐个执行这些事件。</p><p><strong>并行可选粒度</strong>：</p><ul><li><strong><code>数据库</code></strong>：<ul><li><strong>适用版本</strong>：MySQL 5.6及以上。</li><li><strong>粒度</strong>：以数据库为单位进行并行复制。这意味着来自不同数据库的事务可以在从服务器上并行执行。</li><li><strong>限制</strong>：同一数据库内的事务仍然会串行执行，这限制了并行度。</li></ul></li><li><strong><code>组提交</code></strong>：<ul><li><strong>适用版本</strong>：MySQL 5.7及以上。</li><li><strong>粒度</strong>：通过对事务进行分组，如果组内事务能同时提交成功，那么它们就不会共享任何锁（冲突）。</li><li><strong>优势</strong>：组内事务并行复制，提供了更高的并行度。</li></ul></li><li><strong><code>事务写集</code></strong>：<ul><li><strong>适用版本</strong>：MySQL 8.0及以上。</li><li><strong>写集</strong>：用行级别粒度判断事务之间的依赖关系，在有主键或唯一键的表中，只要两个事务没有更新同一行，就能并行回放。</li><li><strong>粒度</strong>：基于每个事务的写集（即事务修改的数据集合）来判断事务之间是否存在冲突，从而实现更细粒度的并行复制。</li><li><strong>优势</strong>：进一步提高并行复制的效率，特别是在事务修改不同行或列时。</li></ul></li></ul></div><h2 id="读写分离延迟导致数据不一致解决"><a class="markdownIt-Anchor" href="#读写分离延迟导致数据不一致解决"></a> 读写分离延迟导致数据不一致解决</h2><ul><li><strong>读取主库</strong><ul><li><strong><code>策略</code></strong>：对于需要立即读取最新写入数据的操作，直接从主库读取。</li><li><strong><code>实施</code></strong>：在应用层逻辑中判断，如果是刚刚写入的数据或对实时性要求高的查询，则直接连接到主数据库执行查询。</li></ul></li><li><strong>监控主从延迟</strong><ul><li><strong><code>策略</code></strong>：定期或在关键操作前检查主从同步的延迟。</li><li><strong><code>实施</code></strong>：使用 <code>SHOW SLAVE STATUS</code> 命令获取从服务器 <code>Seconds_Behind_Master</code> 的值，判断主从同步是否有显著延迟后动态切换。</li></ul></li><li><strong>同步模式</strong><ul><li><strong><code>策略</code></strong>：异步复制模式修改为半同步或全同步模式。</li><li><strong><code>实施</code></strong>：使用组复制或Galera Cluster集群方案。</li></ul></li><li><strong>使用缓存</strong><ul><li><strong><code>策略</code></strong>：使用缓存系统来存储最新写入的数据标记。</li><li><strong><code>实施</code></strong>：<ul><li>在写入数据后，将相关数据或标记存入缓存系统（如Redis、本地缓存、客户端缓存等）。</li><li>读取操作首先查询缓存，如果缓存中存在最新数据，则使用缓存数据；如果没有，则从数据库读取。</li></ul></li></ul></li></ul><h1 id="训练脚本"><a class="markdownIt-Anchor" href="#训练脚本"></a> 训练脚本</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student<br>(<br>sno       <span class="hljs-type">varchar</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">primary</span> key,<br>sname     <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>sex       <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>),<br>sbirthday datetime,<br>class     <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>)<br>) <span class="hljs-keyword">default</span> charset <span class="hljs-operator">=</span> utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;108&#x27;</span>, <span class="hljs-string">&#x27;曾华&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;1977-09-01&#x27;</span>, <span class="hljs-string">&#x27;95033&#x27;</span>),<br> (<span class="hljs-string">&#x27;105&#x27;</span>, <span class="hljs-string">&#x27;匡明&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;1975-10-02&#x27;</span>, <span class="hljs-string">&#x27;95031&#x27;</span>),<br> (<span class="hljs-string">&#x27;107&#x27;</span>, <span class="hljs-string">&#x27;王丽&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;1976-01-23&#x27;</span>, <span class="hljs-string">&#x27;95033&#x27;</span>),<br> (<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-string">&#x27;李军&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;1976-02-20&#x27;</span>, <span class="hljs-string">&#x27;95033&#x27;</span>),<br> (<span class="hljs-string">&#x27;109&#x27;</span>, <span class="hljs-string">&#x27;王芳&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;1975-02-10&#x27;</span>, <span class="hljs-string">&#x27;95031&#x27;</span>),<br> (<span class="hljs-string">&#x27;103&#x27;</span>, <span class="hljs-string">&#x27;陆君&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;1974-06-03&#x27;</span>, <span class="hljs-string">&#x27;95031&#x27;</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course<br>(<br>cno   <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">primary</span> key,<br>cname <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>tno   <span class="hljs-type">varchar</span>(<span class="hljs-number">3</span>)<br>) <span class="hljs-keyword">default</span> charset <span class="hljs-operator">=</span> utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-string">&#x27;计算机导论&#x27;</span>, <span class="hljs-string">&#x27;825&#x27;</span>),<br> (<span class="hljs-string">&#x27;3-245&#x27;</span>, <span class="hljs-string">&#x27;操作系统&#x27;</span>, <span class="hljs-string">&#x27;804&#x27;</span>),<br> (<span class="hljs-string">&#x27;6-166&#x27;</span>, <span class="hljs-string">&#x27;数字电路&#x27;</span>, <span class="hljs-string">&#x27;856&#x27;</span>),<br> (<span class="hljs-string">&#x27;9-888&#x27;</span>, <span class="hljs-string">&#x27;高等数学&#x27;</span>, <span class="hljs-string">&#x27;831&#x27;</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score<br>(<br>sno    <span class="hljs-type">varchar</span>(<span class="hljs-number">3</span>),<br>cno    <span class="hljs-type">varchar</span>(<span class="hljs-number">5</span>),<br>degree <span class="hljs-type">decimal</span>(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>) <span class="hljs-keyword">default</span> charset <span class="hljs-operator">=</span> utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> score<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;103&#x27;</span>, <span class="hljs-string">&#x27;3-245&#x27;</span>, <span class="hljs-number">86</span>),<br> (<span class="hljs-string">&#x27;105&#x27;</span>, <span class="hljs-string">&#x27;3-245&#x27;</span>, <span class="hljs-number">75</span>),<br> (<span class="hljs-string">&#x27;109&#x27;</span>, <span class="hljs-string">&#x27;3-245&#x27;</span>, <span class="hljs-number">68</span>),<br> (<span class="hljs-string">&#x27;103&#x27;</span>, <span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-number">92</span>),<br> (<span class="hljs-string">&#x27;105&#x27;</span>, <span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-number">88</span>),<br> (<span class="hljs-string">&#x27;109&#x27;</span>, <span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-number">76</span>),<br> (<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-number">64</span>),<br> (<span class="hljs-string">&#x27;107&#x27;</span>, <span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-number">91</span>),<br> (<span class="hljs-string">&#x27;108&#x27;</span>, <span class="hljs-string">&#x27;3-105&#x27;</span>, <span class="hljs-number">78</span>),<br> (<span class="hljs-string">&#x27;101&#x27;</span>, <span class="hljs-string">&#x27;6-166&#x27;</span>, <span class="hljs-number">85</span>),<br> (<span class="hljs-string">&#x27;107&#x27;</span>, <span class="hljs-string">&#x27;6-166&#x27;</span>, <span class="hljs-number">79</span>),<br> (<span class="hljs-string">&#x27;108&#x27;</span>, <span class="hljs-string">&#x27;6-166&#x27;</span>, <span class="hljs-number">81</span>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> teacher<br>(<br>tno       <span class="hljs-type">varchar</span>(<span class="hljs-number">3</span>),<br>tname     <span class="hljs-type">varchar</span>(<span class="hljs-number">8</span>),<br>tsex      <span class="hljs-type">varchar</span>(<span class="hljs-number">2</span>),<br>tbirthday datetime,<br>prof      <span class="hljs-type">varchar</span>(<span class="hljs-number">6</span>),<br>depart    <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<br>) <span class="hljs-keyword">default</span> charset <span class="hljs-operator">=</span> utf8;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> teacher<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;804&#x27;</span>, <span class="hljs-string">&#x27;李诚&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;1958-12-02&#x27;</span>, <span class="hljs-string">&#x27;副教授&#x27;</span>, <span class="hljs-string">&#x27;计算机系&#x27;</span>),<br> (<span class="hljs-string">&#x27;856&#x27;</span>, <span class="hljs-string">&#x27;张旭&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;1969-03-12&#x27;</span>, <span class="hljs-string">&#x27;讲师&#x27;</span>, <span class="hljs-string">&#x27;电子工程系&#x27;</span>),<br> (<span class="hljs-string">&#x27;825&#x27;</span>, <span class="hljs-string">&#x27;王萍&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;1972-05-05&#x27;</span>, <span class="hljs-string">&#x27;助教&#x27;</span>, <span class="hljs-string">&#x27;计算机系&#x27;</span>),<br> (<span class="hljs-string">&#x27;831&#x27;</span>, <span class="hljs-string">&#x27;刘冰&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;1977-08-14&#x27;</span>, <span class="hljs-string">&#x27;助教&#x27;</span>, <span class="hljs-string">&#x27;电子工程系&#x27;</span>);<br><br># 等级<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> grade<br>(<br>low    <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),<br>upp    <span class="hljs-type">int</span>(<span class="hljs-number">3</span>),<br>`rank` <span class="hljs-type">char</span>(<span class="hljs-number">1</span>)<br>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> grade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">90</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> grade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">80</span>, <span class="hljs-number">89</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> grade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">70</span>, <span class="hljs-number">79</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> grade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">60</span>, <span class="hljs-number">69</span>, <span class="hljs-string">&#x27;D&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> grade<br><span class="hljs-keyword">values</span> (<span class="hljs-number">0</span>, <span class="hljs-number">59</span>, <span class="hljs-string">&#x27;E&#x27;</span>);<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>Mysql</div><div>https://wugengfeng.cn/2022/02/26/Mysql/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年2月26日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/03/11/Sort/" title="Sort"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Sort</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/02/24/Kafka/" title="Kafka"><span class="hidden-mobile">Kafka</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>