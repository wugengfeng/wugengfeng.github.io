<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="背景和来源  导读 一文看懂DDD 本文章侧重于DDD的实践和落地，对于理论概念涉及交浅，建议配合《领域驱动设计 软件核心复杂性应对之道》这本书加深理解 领域：从事一种专门活动或事业的范围、部类或部门   背景  实体经济和ToB业务会成为未来的主战场 深化数字化转型 简单的系统已经被开发得差不多了（开箱即用的脚手架）  随着技术的发展，以后软件系统的开发方向有可能是挑战历史做不到的事情，这类系"><meta property="og:type" content="article"><meta property="og:title" content="DDD领域驱动设计"><meta property="og:url" content="https://wugengfeng.cn/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="背景和来源  导读 一文看懂DDD 本文章侧重于DDD的实践和落地，对于理论概念涉及交浅，建议配合《领域驱动设计 软件核心复杂性应对之道》这本书加深理解 领域：从事一种专门活动或事业的范围、部类或部门   背景  实体经济和ToB业务会成为未来的主战场 深化数字化转型 简单的系统已经被开发得差不多了（开箱即用的脚手架）  随着技术的发展，以后软件系统的开发方向有可能是挑战历史做不到的事情，这类系"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/ddd.png"><meta property="article:published_time" content="2022-12-21T06:22:37.000Z"><meta property="article:modified_time" content="2023-07-14T06:49:14.410Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/ddd.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>DDD领域驱动设计 - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="DDD领域驱动设计"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-12-21 14:22" pubdate>2022年12月21日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 32k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 270 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">DDD领域驱动设计</h1><div class="markdown-body"><h2 id="背景和来源"><a class="markdownIt-Anchor" href="#背景和来源"></a> 背景和来源</h2><h3 id="导读"><a class="markdownIt-Anchor" href="#导读"></a> 导读</h3><p><a target="_blank" rel="noopener" href="https://modelbaba.com/architecture/ddd/2100.html">一文看懂DDD</a></p><p>本文章侧重于DDD的实践和落地，对于理论概念涉及交浅，建议配合《领域驱动设计 软件核心复杂性应对之道》这本书加深理解</p><p>领域：从事一种专门活动或事业的范围、部类或部门</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/DDD%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><ul><li>实体经济和ToB业务会成为未来的主战场</li><li>深化数字化转型</li><li>简单的系统已经被开发得差不多了（开箱即用的脚手架）</li></ul><p>随着技术的发展，以后软件系统的开发方向有可能是挑战历史做不到的事情，这类系统往往庞大而复杂。而面对复杂的系统我们传统的设计模式便会显得捉襟见肘，亟需要新的理论来帮助我们设计复杂系统模型，<span style="border-bottom:2px dashed green">而领域驱动设计便是一套指导复杂系统分析和设计的方法论</span></p><p class="note note-primary">DDD的起源</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/DDD%E7%9A%84%E5%8F%91%E5%B1%95.png" srcset="/img/loading.gif" lazyload alt></p><p>DDD其实早在2003年便诞生了，刚诞生时并不火。直到微服务架构的流行，发现DDD能够解决微服务架构那些亟需解决的问题，<span class="green-line">包括项目复杂度的控制和服务的划分</span></p><h3 id="核心思想和解决的痛点"><a class="markdownIt-Anchor" href="#核心思想和解决的痛点"></a> 核心思想和解决的痛点</h3><h4 id="模型和建模"><a class="markdownIt-Anchor" href="#模型和建模"></a> 模型和建模</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt></p><p>模型是对现实的抽象和模拟</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%BA%E6%A8%A1.png" srcset="/img/loading.gif" lazyload alt></p><p>建模是针对特定问题建立领域的合理模型</p><p><code>总结</code>：<span class="green-line">同样的事物在面对不同领域（问题）的时候，它的模型是不一样的。建模一定是针对领域问题来建模。</span>上图中的两个系统中，进销存中的商品条码对超市来说比较重要。而在电商系统中的商品属性，标签，图片对电商系统特别重要</p><h4 id="软件系统复杂性来源"><a class="markdownIt-Anchor" href="#软件系统复杂性来源"></a> 软件系统复杂性来源</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E6%80%A7%E6%9D%A5%E6%BA%90.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>建模阶段：把领域知识和业务需求转换成领域模型</li><li>设计阶段：把模型转化成代码，需要考虑的是<code>技术实现</code></li></ul><p class="note note-primary">业务复杂导致模型复杂</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E5%A4%8D%E6%9D%82%E5%AF%BC%E8%87%B4%E5%BB%BA%E6%A8%A1%E5%A4%8D%E6%9D%82.png" srcset="/img/loading.gif" lazyload alt></p><p>由上图可知，同样的事物在不同的领域（财务、印钞、防伪）的复杂度是不一样的</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F.png" srcset="/img/loading.gif" lazyload alt></p><p>假设我们现在要为铸币厂设计一个内部系统，我们把上图的三个领域都放在一个模型中进行系统设计，那么我们将得到一个复杂的系统模型。<span style="border-bottom:2px dashed green">这其实就是传统的面向对象思想存在的一个问题，在DDD出现之前，这一直是个痛点问题。当业务变得越来越复杂后我们依然采用面向对象思想在一个单一的模型里描述一个系统，这个系统的复杂度将不可控制！</span></p><p>解决方案：<a href="#%E6%A8%A1%E5%9E%8B%E5%88%86%E8%A7%A3">模型分解</a></p><p class="note note-primary">技术实现引入额外复杂性</p><p>假设开发一个电商平台系统，系统中有两个团队进行开发，第一个团队专门负责数据接入开发，第二个团队负责商品服务开发</p><p>第一个团队：业务逻辑简单，当商家建立商品数据、门店时，只需要针对商品、门店建立实体写入表中</p><p>第二个团队：假设在商品搜索服务时，需要加入门店信息的搜索时，为了搜索的实时性，可能要求第一团队生成一张门店商品表（引入复杂性）</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BC%95%E5%85%A5%E5%A4%8D%E6%9D%82%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt></p><p>门店商品：商品服务需要实现根据门店距离实现进行商品搜索，那这个时候商品表和门店表的数据同步如何保持一致，无论哪张表延迟同步都有可能导致商品搜索不出来，因此又引入门店商品表，搜索时使用门店商品表进行搜索（门店商品表数据是在商家系统数据接入时生成的，同步给商品服务）</p><h4 id="解决痛点"><a class="markdownIt-Anchor" href="#解决痛点"></a> 解决痛点</h4><p><span class="green-line">领域驱动设计（英语：domain driven design，缩写 DDD）是一种用于指导软件设计的方法论，也是一种设计思维方式，用于解决软件复杂性问题，旨在加速那些必须处理复杂领域的软件项目的开发</span></p><p><code>解决痛点</code>：解决了面向对象思想无法解决的软件设计的复杂性问题（复杂领域）</p><h4 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想</h4><p class="note note-primary">模型分解</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%A8%A1%E5%9E%8B%E5%88%86%E8%A7%A3.png" srcset="/img/loading.gif" lazyload alt></p><p>对于一个复杂的系统，可以对模型进行分解，划分出不同的子领域，然后再针对不同的子领域进行建模，面向不同的子领域解决不同的问题，分而治之思想</p><p>DDD提供两个工具对模型进行分解</p><ul><li><code>领域划分</code>：面向问题空间</li><li><code>限界上下文</code>：面向解决方案空间</li></ul><p class="note note-primary">模型驱动设计</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.png" srcset="/img/loading.gif" lazyload alt></p><p>Model Driven Design，通过<code>分层架构</code>隔离领域层、仔细选择模型和设计方案等措施保持实现与模型的一致</p><h3 id="ooad敏捷和ddd的区别与联系"><a class="markdownIt-Anchor" href="#ooad敏捷和ddd的区别与联系"></a> OOAD敏捷和DDD的区别与联系</h3><p>在DDD诞生之前，在软件开发领域已经诞生一些思想和理论，其中的佼佼者就是<code>面向对象程序设计</code>和<code>敏捷开发</code></p><p class="note note-primary">DDD与OOAD</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/ooad.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><code>OOAD</code>：面向对象程序设计其实和DDD属于同一层面，因为它们都属于<code>设计层级</code>，<span class="green-line">目的都是将问题(领域)和需求转换成模型，再将模型转换成方案</span></li><li><code>OOP</code>：DDD的落地需要依赖于面向对象编程语言的实现</li></ul><p><code>OOAD的不足</code>：OOAD在面向大型系统设计时其实是有局限性的。原因是<span class="green-line">OOAD体系其实没有一个对系统有效划分的方法论，面向大规模复杂的系统，它会将多个子领域的问题放到一个模型中去考虑，得出的模型不管是对象本身的复杂性或对象和对象之间关系的复杂性都会变得异常复杂</span></p><p><code>DDD的优势</code>：<span class="green-line">有<code>战略设计</code>的部分，它会面对系统遇到的领域进行拆分，最后得到一个拆分后的模型，是一种分而治之的方案，最后系统复杂性也得到控制</span></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/OOAD%E4%B8%8EDDD.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">DDD与敏捷开发</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/DDD%E4%B8%8E%E6%95%8F%E6%8D%B7.png" srcset="/img/loading.gif" lazyload alt></p><p>在上个时代，每个软件工程的主体都是放在一个版本里开发的，软件工程会把这个版本划分为几个阶段，有细化阶段，需求分析阶段，实现阶段，测试阶段，部署阶段等。每个阶段的输出是下一个阶段的输入数据，顺序不会逆转回来，等项目上线后，一切尘埃落定。这种模式有一个明显的弊端，如果是前期的一些错误可能到项目的后期才会被发现，比如需求分析阶段，假设到了测试阶段才发现需求分析阶段的问题，那么纠正分析阶段的问题成本将异常的高，软件失败的风险也非常高。在这种缺陷下，敏捷开发应运而生。</p><p>敏捷开发主要包含两个方面的内容</p><ul><li><code>开发流程</code>：把一个大的目标分成多个迭代去完成，每个迭代为一个冲刺（传统开发好比马拉松，敏捷是把这个马拉松划分为若干个百米冲刺，敏捷开发不提倡开发前期的整体设计）</li><li><code>开发文化</code>：<a target="_blank" rel="noopener" href="https://agilemanifesto.org/iso/zhchs/manifesto.html">敏捷宣言</a></li></ul><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/DDD%E4%B8%8E%E6%95%8F%E6%8D%B7%E7%9A%84%E5%8C%BA%E5%88%AB%E8%81%94%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt></p><h2 id="战略设计"><a class="markdownIt-Anchor" href="#战略设计"></a> 战略设计</h2><h3 id="智慧零售项目介绍"><a class="markdownIt-Anchor" href="#智慧零售项目介绍"></a> 智慧零售项目介绍</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%9B%B6%E5%94%AE%E4%B8%BB%E4%BD%93.png" srcset="/img/loading.gif" lazyload alt></p><p>背景：线下零售依然占据GDP一定的比重，线上销售面临流量枯竭</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%99%BA%E6%85%A7%E9%9B%B6%E5%94%AE.png" srcset="/img/loading.gif" lazyload alt></p><p>智慧零售，自动售货机线下新零售。智慧零售的主要解决<code>人</code>、<code>货</code>、<code>场</code>的问题</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF1.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF2.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">团队背景</p><ul><li>A公司：SaaS公司，主要面向零售企业客户</li><li>SmartRM产品团队：一位资深产品经理，几位产品策划</li><li>SmartRM研发团队：一位架构师，10+开发，资深开发3至4位</li></ul><p class="note note-primary">客户背景</p><ul><li>B集团: 零售行业某头部商家</li><li>全国各地有大量商超和便利店，有成熟的内部系统和供应链</li><li>基于自动售卖机的零售业务是新业务</li></ul><p class="note note-primary">案例优势</p><ul><li>复杂度可覆盖DDD大部分知识点并体现其价值</li><li>智慧零售市场庞大且场景接近日常生活</li><li>有数据分析需求，可结合大数据分析场景</li></ul><h3 id="建模和设计的流程"><a class="markdownIt-Anchor" href="#建模和设计的流程"></a> 建模和设计的流程</h3><p class="note note-primary">目的：对DDD和在项目中的应用有一个全局的认识</p><p>重点</p><ul><li><p>软件系统从需求到最终技术方案包含的环节</p></li><li><p>各环节的目标和概要</p></li><li><p>常用建模方法</p></li></ul><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BB%BA%E6%A8%A1%E5%92%8C%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p>所谓的建模和设计就是把领域知识和需求转换成代码的过程，它可以分为四个阶段</p><ul><li>挖掘用户故事</li><li>建立通用语言</li><li>战略设计</li><li>战术设计</li></ul><p>这四个阶段的开始时间有先后，但并不是上一个阶段结束下一个阶段才开始，而是重叠的。对用户故事的挖掘和建立通用语言是最先开始的，可能会贯穿整个建模设计的过程。同样，战术设计的开始也不意味着战略设计的结束，在战术设计的过程中我们有可能发现战略设计的不合理从而回过头对战略设计进行优化。同时在战略设计中，我们也不断会对通用语言进行丰富，甚至发现业务流程中的优化点，从而回过头重新研究用户故事(建模涡流思想)</p><p>建模参与人员</p><ul><li><p><code>领域专家</code>：非常重要的角色，指的是在某个领域有深度经验的专业人士（比如医疗系统，医生就是领域专家）</p></li><li><p><code>产品团队</code>：现实中产品团队经常扮演领域专家角色，在有必要的情况下还是需要邀请领域专家进行讨论</p></li><li><p><code>研发团队</code>：负责将建立起来的模型以编码形式落地</p></li></ul><h4 id="用户故事"><a class="markdownIt-Anchor" href="#用户故事"></a> 用户故事</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>什么角色</li><li>希望做什么</li><li>最终达到什么目的</li></ul><p>用户故事更多的是对问题的描述，而不是解决方案，通过从问题出发，通过整个团队的讨论认证（领域专家，产品经理，研发人员，讨论过程中固化其图文）最终达到一个接近的解决方案</p><blockquote><p>售卖机用户故事：作为一个消费者，我希望通过手机支付从售卖机中购买商品，从而能够更方便购物</p><p>给出用户故事后团队就可以开始对故事进行讨论，一边讨论一边画图，通过图文可快速把讨论结果固化</p><p>通过这一讨论过程，会发现慢慢从问题空间进入方法空间（消费者怎么通过售卖机购买商品）</p></blockquote><h4 id="通用语言"><a class="markdownIt-Anchor" href="#通用语言"></a> 通用语言</h4><p><code>目的是拉齐各方人员的领域认知</code></p><ul><li>在讨论模型和定义模型时，团队使用的同一种语言</li><li>领域知识需要在团队内部高效流转，模型需要描述</li><li>通用语言要体现在代码里（类名 属性名等）</li></ul><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80.png" srcset="/img/loading.gif" lazyload alt></p><p>在对用户故事进行挖掘的时候，就已经实在建立通用语言了，在讨论的时候，大部分时间是领域专家进行讲解。其他人要做的是理解领域专家提到的各种概念，及时提问同时进行知识固化，对讨论中存在歧义的关键词汇建立统一认知，甚至固化下来形成文档</p><h4 id="战略设计-2"><a class="markdownIt-Anchor" href="#战略设计-2"></a> 战略设计</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1%E8%BE%93%E5%87%BA.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>DDD中对问题空间和解决方案空间进行分解的过程</li><li>目的是分解模型以控制复杂性</li><li>是DDD与传统建模和设计方法的核心区别之一</li></ul><p>包括内容</p><ul><li>领域划分</li><li>寻找限界上下文(BC)</li><li>确定上下文映射：上下文之间的关系，确定上下文映射的过程还会加入<a href="#%E9%98%B2%E8%85%90%E5%B1%82%E6%9E%84%E5%BB%BA">防腐层</a>（领域自我保护）</li></ul><h4 id="战术设计"><a class="markdownIt-Anchor" href="#战术设计"></a> 战术设计</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>对各个限界上下文的细节设计过程</li><li>限界上下文内部的模型结构与完整技术方案</li></ul><p>内容包含</p><ul><li>实体</li><li>值对象</li><li>服务</li><li>模块</li><li>聚合</li><li>工厂</li><li>资料库</li></ul><p>这些元素确定下来后代码基本也就确定下来了，战术设计包括编码环节（Eric Evans认为设计人员或者架构师是需要深度参与编码的）</p><h4 id="建模方法"><a class="markdownIt-Anchor" href="#建模方法"></a> 建模方法</h4><ul><li><p><a target="_blank" rel="noopener" href="https://domainstorytelling.org">领域叙事 Domain Storytelling</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.eventstorming.com/">事件风暴 Event Storming</a></p></li><li><p><a target="_blank" rel="noopener" href="http://apframework.com/2020/03/22/ddd-color">四色建模法 4C</a></p></li></ul><h3 id="从用户故事到通用语言"><a class="markdownIt-Anchor" href="#从用户故事到通用语言"></a> 从用户故事到通用语言</h3><p>用户故事和建立通用语言和战略设计的关系</p><p>因为建模一定要从问题空间出发，而且通用语言也要尽早开始建立，因为无论是描述模型还是团队沟通都需要通用语言。所以在正式开始战略设计之前，从用户故事开始对领域进行探索，可以使得开发人员迅速迅速学习领域知识并且在团队内部初步建立通用语言，为后面的领域划分寻找限界上下文等工作做好铺垫</p><h4 id="什么是用户故事"><a class="markdownIt-Anchor" href="#什么是用户故事"></a> 什么是用户故事</h4><blockquote><p>在软件开发中，用户故事是一种对软件系统特性的非正式的自然语言描述，是敏捷软件开发中从终端用户的角度对软件系统特性进行捕捉的一种方式。用户故事描述了不同类型的用户需要什么以及为什么需要，它可以帮助我们创建需求的简单描述。</p><p>总结：用户故事就是对问题的描述</p></blockquote><p>在软件开发的需求阶段，就让产品经理对软件的功能进行详细的设计（可能设计并不能落地），不仅是时间上的浪费，也会让团队过早陷入细节。用户故事就提供了一种恰到好处的粒度，直接对需求（问题）进行描述</p><p class="note note-primary">用户故事的构建</p><ol><li>简单描述用户需求；</li><li>围绕简单描述进行讨论;</li><li>明确如何<code>验证</code>；</li></ol><p>分别对应用户故事的三个元素，也就是3C： <code>Card(卡片)</code>、<code>Conversation(谈话)</code>、<code>Confirmation(验证)</code></p><p class="note note-primary">Card (卡片)</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/3w.png" srcset="/img/loading.gif" lazyload alt></p><p><code>卡片</code>就是指对用户故事的简述(传统上人们通过便利贴在白板上构建用户故事)，一个好的用户故事卡片包括三<br>个要素:</p><ol><li>谁：谁需要这个功能;</li><li>需要什么：想通过系统完成什么事情;</li><li>为什么：为什么需要这个功能，这个功能带来什么样的价值;</li></ol><p class="note note-primary">Conversation (谈话)</p><p>谈话是指<code>用户</code>、<code>领域专家</code>、<code>产品经理</code>、<code>研发</code>之间围绕用户故事进行的讨论，谈话是明确需求细节的必要环节。可以用文字对谈话进行简要记录，此外，也可以基于图形或其他工具进行讨论。(比如使用 <a target="_blank" rel="noopener" href="https://domainstorytelling.org">domain storytelling</a> 挖掘用户故事)</p><p class="note note-primary">Confirmation (验证)</p><p>验证代表了验收测试，描述了客户或者产品owner怎样确定用户故事已经被实现，且能够满足需求。一般可以用如<br>下模板写Confirmation:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">假设我是<span class="hljs-tag">&lt;<span class="hljs-name">角色</span>&gt;</span>，在xxx情况下，<br>当我<span class="hljs-tag">&lt;<span class="hljs-name">操作</span>&gt;</span>，<br>那么<span class="hljs-tag">&lt;<span class="hljs-name">结果</span>&gt;</span>。<br></code></pre></td></tr></table></figure><p>用户故事必须是可以验证的</p><p><a href="/2022/12/28/SmartRM%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E6%96%87%E6%A1%A3">SmartRM通用语言文档</a></p><p class="note note-primary">场景模拟</p><p><strong>售卖机扫码支付购物</strong></p><ul><li><p><strong>卡片</strong></p><p>作为用户，</p><p>我希望在售卖机上通过手机扫码支付购买商品，</p><p>以便快速便捷地购买商品。</p></li><li><p><strong>谈话</strong></p><p>P：用户在设备屏幕上选择商品后，设备展示支付二维码，用户使用微信扫描二维码，完成支付后，设备完成出货，交易结束，设备屏幕上回到商品列表界面</p><p>D：这里的设备是指自动售卖机吗?</p><p>P：是的。</p><p>D：那么我们以后统一用”售卖机“这个词吧? 英文用Vending Machine。</p><p>P：没问题。</p><p>D： 如果用户支付失败，会怎么样?</p><p>P：售卖机会等待一段时间，然后取消交易，回到商品列表界面</p><p>D：售卖机出货会失败吗?</p><p>P：有可能，不过我们还是要找懂这套售卖机的人了解下</p><p>D： 是的，我把运营人员O拉进来聊下。</p><p>P：0，我们在对SmartRM系统进行建模，想咨询一些售卖机相关的问题。售卖机出货会失败吗?</p><p>0：我们应用的售卖机主要包括<strong>自动称重式柜门机</strong>、<strong>弹货道售卖机</strong>、<strong>蛇形货道售卖机</strong>。其中，称重式柜门机特点是售卖的商品类型多，不会卡货，主要用于办公楼、商超、小区等室内外公共场所的<strong>饮料、零食、生鲜</strong>等商品的售卖，弹簧货道售卖机的特点是成本低，售卖商品类型多，卡货概率高，主要用于室内外等公共场所的饮料、零食的售卖，蛇形货道售卖机的特点是体积一般较大、<strong>库存容量大</strong>、卡货概率低、省电，但是只能用于饮料的售卖，主要放在<strong>体育场、工厂、学校、公园</strong>等室内或室外公共场所用于饮料售卖。目前我们有一部分存量弹簧货道售卖机，后面大部分室内的会替换成自动称重柜门机，但是仍然会保留一部分。我们的售卖机可靠性很优秀，但是还是会有几种出货失败的情况。比较常见的出货失败的情况有以下几种： 1) 卡货，2)售卖机网络问题，3) 库存错误</p><p><span style="border-bottom:2px dashed green"><code>意义</code>：用户故事的讨论能够让我们快速的明确流程，熟悉领域知识同时建立通用语言，同时让团队之间的理解达成一致</span></p></li><li><p><strong>验收标准</strong></p><p>假设我是一名用户，货道售卖机屏幕的商品列表上有商品A,B,C当我在售卖机屏幕上选择了商品A，并扫描展示的二维码完成支付后那么商品A就会从售卖机中弹出，我可以拿到商品A</p><ul><li>研发人员：单元测试的依据</li><li>测试人员：测试计划的依据</li><li>产品人员：验收的依据</li></ul></li></ul><h4 id="domain-storytelling"><a class="markdownIt-Anchor" href="#domain-storytelling"></a> Domain Storytelling</h4><p>通过上面的谈话我们能够发现其实是比较松散的，可以借助 <a target="_blank" rel="noopener" href="https://domainstorytelling.org">领域故事陈述 Domain Storytelling</a> 将关键细节记录起来，建立通用语言，形成简要文档</p><p><a target="_blank" rel="noopener" href="https://github.com/WPS/domain-story-modeler">domain story modeler 领域故事陈述工具</a></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/DomainStorytelling.png" srcset="/img/loading.gif" lazyload alt></p><p>通过领域故事陈述建立起的模型可以将不同角色的认知进行对齐，并且图例的关键词的统一其实就是建立通用语言的过程</p><h4 id="通用语言-2"><a class="markdownIt-Anchor" href="#通用语言-2"></a> 通用语言</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%802.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>一种描述模型且基于模型的语言</li><li>团队在进行所有交流时都使用它</li><li>代码中也要体现</li></ul><p class="note note-primary">包含的内容</p><ul><li>类和操作的名称</li><li>施加于模型之上的规则和约束（如商品补充的库存不能超过容量）</li><li>应用于领域模型的模式（工厂，资料库…）</li></ul><p>我们对用户故事进行storytelling，其实就是建立领域通用语言的过程，storytelling的输出结果 (上述的storytelling图)也就包含了领域通用语言的完整语句，对象、角色、活动、以及体现它们相互作用的完整语句在图中都可以一览无余。这里我们可以更进一步，将通用语言中的词汇提炼出来，将其中英文都列在通用语言词汇表中，这些词汇将会贯穿整个建模和设计过程，最终也会体现在代码中，因此团队中所有成员，都需要明确理解其含义，并且在相关讨论、模型、以及代码中使用它们</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E6%96%87%E6%A1%A3.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="领域划分和子域"><a class="markdownIt-Anchor" href="#领域划分和子域"></a> 领域划分和子域</h3><p><strong>内容</strong></p><ul><li>什么是领域划分和子域</li><li>为什么要进行领域划分</li><li>基于用户故事分解的领域划分方法</li></ul><p class="note note-primary">什么是领域划分</p><ul><li><p>领域：<span class="green-line">DDD会按规则细分业务领域，细分到一定程度，会将问题范围限定在特定边界，在该边界内建立领域模型，进而用代码实现该领域模型，解决相应业务问题，领域就是该边界内要解决的业务问题域（对业务进行边界划分）</span><span></span></p></li><li><p>子域：领域可进步划分为子领域。划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或业务范围</p></li><li><p><span class="green-line"><code>领域划分</code>是以<code>分离关注点</code>为原则对<code>问题空间</code>的划分</span></p></li><li><p>子域是领域中某个方面的问题和解决它所涉及的一切</p></li></ul><p class="note note-primary">为什么进行领域划分</p><p>领域划分是一个<code>分而治之</code>的思想，核心是将一个大而复杂的问题拆解成一个个较小的问题</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86%E9%87%8D%E5%8F%A0.png" srcset="/img/loading.gif" lazyload alt></p><p><code>问题点和领域知识重叠</code>：图中的两个研发都需要关注三个问题点，存在重复劳动，并且工作上可能还出现重叠</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%A8%A1%E5%9E%8B%E9%87%8D%E5%8F%A0.png" srcset="/img/loading.gif" lazyload alt></p><p><code>模型重叠</code>：抽象出的商品，订单，售卖机的模型设计工作由谁展开？</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%8D%E5%90%8C%E5%AD%90%E5%9F%9F%E8%81%9A%E7%84%A6%E4%B8%8D%E5%90%8C%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt></p><p><code>不同子域聚焦不同问题</code>：职责明确</p><p><code>工作效率低</code> <code>职责冲突</code></p><blockquote><p><strong>smartRM项目的六大顶级用户故事</strong></p><ul><li>售卖机扫码支付购物</li><li>柜门机免密购物</li><li>售卖机投放</li><li>补货</li><li>售卖机撤销</li><li>经营分析</li></ul></blockquote><p><strong>初步领域划分</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%AD%90%E5%9F%9F%E5%88%92%E5%88%86.png" srcset="/img/loading.gif" lazyload alt></p><p>按照面向的用户不同，可以把六大用户故事初步划分为交易域和运营域</p><h4 id="怎样进行领域划分"><a class="markdownIt-Anchor" href="#怎样进行领域划分"></a> 怎样进行领域划分</h4><p class="note note-primary">基于故事分解的领域划分</p><p>模拟交易域的用户故事分解</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E5%88%86%E8%A7%A31.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B%E5%88%86%E8%A7%A32.png" srcset="/img/loading.gif" lazyload alt></p><p>然后再根据拆分的用户故事进行归类，最终得到下面的图</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%AD%90%E5%9F%9F%E5%88%92%E5%88%862.png" srcset="/img/loading.gif" lazyload alt></p><p>最终根据团队的不断优化，一个系统被拆分为以下的领域</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%AD%90%E5%9F%9F%E6%8B%86%E5%88%863.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="核心域和精炼"><a class="markdownIt-Anchor" href="#核心域和精炼"></a> 核心域和精炼</h3><p class="note note-primary">子域的类型</p><ul><li><code>核心域</code>：决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。</li><li><code>通用域</code>：没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。</li><li><code>支撑域</code>：还有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。</li></ul><p class="note note-primary">核心域和研发力分配</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%A0%B8%E5%BF%83%E5%9F%9F%E5%88%86%E9%85%8D.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">DDD认为，对于项目和产品来说，最核心人员应该把精力投入到核心域的设计和开发里来，尽量减少团队在其他部分的投入，这样才能提升产品和业务的核心竞争力</span></p><p class="note note-primary">精炼</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%B2%BE%E7%82%BC.png" srcset="/img/loading.gif" lazyload alt></p><p>精炼就是不断提炼和压缩的过程</p><p>通过精炼，分理出领域普通的部分，最终得到一个核心域。精炼可以让团队用尽可能小的代价换取最大的成功概率</p><p>案例中的精炼</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%B2%BE%E7%82%BC2.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>战略设计要明确核心域，团队尽量减少非核心域投入</li><li>核心域的建立总是伴随着精炼，精炼有两种方法</li></ul><h3 id="限界上下文"><a class="markdownIt-Anchor" href="#限界上下文"></a> 限界上下文</h3><p><span class="green-line">限界上下文是一种语义上的上下文边界。意思是在这个边界里的软件模型组件都有它特定的含义并且做特定的事。</span>一个限界上下文内的组件都是上下文特定的并且语义明确的</p><p>前文已经提到，<span class="green-line">同一个事物在面向不同的场景、问题或领域(或限界上下文)时，表现的复杂度和语义是不一样的</span></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%94%AE%E5%8D%96%E6%9C%BA.png" srcset="/img/loading.gif" lazyload alt></p><p>同一台售卖机在运营眼里，用户眼里是不一样的。在运营眼里，它是一台库存不断消耗的又需要及时补充库存的商品容器，在用户眼里它就是一个购物平台。所以在运营和用户（或者叫上下文）眼里提到的售卖机其实是有差别的。我们要让这个词具备单一的含义，单一的作用那就需要明确指出来，它在哪个上下文。或者换句话说它的限界上下文是什么，这就是限界上下文本质的含义</p><p class="note note-primary">为什么需要限界上下文</p><ul><li>自然语言具有模糊性（同一个词在不场合在不同人眼里通常具有不同的意义）</li><li>同一个事物面向不同场景有不同模型（上文的售卖机）</li><li>软件系统需要分解模型以控制复杂性（需要通过限界上下文来分解复杂的模型）</li><li>限界上下文是分工的单位（高内聚低耦合特性，一个限界上下文可以交给一个研发或者团队负责）</li></ul><h4 id="如何划分限界上下文"><a class="markdownIt-Anchor" href="#如何划分限界上下文"></a> 如何划分限界上下文</h4><p class="note note-primary">Domain Storytelling (领域故事陈述法)</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%88%92%E5%88%86%E4%B8%8A%E4%B8%8B%E6%96%87.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%AD%90%E5%9F%9F%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png" srcset="/img/loading.gif" lazyload alt></p><p>这里识别边界主要利用了概念之间的语义差别</p><p>Domain storytelling中边界特征</p><ul><li>单向联系（库存计划到配送订单的箭头）</li><li>语义区别</li><li>活动的触发方式不一样（比如图中售卖机的投放和库存计划就是不同的触发方式，没有划分边界主要是考虑到售卖机的投放和库存计划的制订是紧密相关的，本质都是解决库存问题，设计前期的原则是宁缺毋滥）</li></ul><p class="note note-primary">Event Storming (事件风暴法 推荐)</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4.png" srcset="/img/loading.gif" lazyload alt></p><p>目前最热门的方法，DDD中最重要的建模方法，后续会讲</p><p class="note note-primary">基于子域概念提取</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%AD%90%E5%9F%9F%E5%88%92%E5%88%863.png" srcset="/img/loading.gif" lazyload alt></p><p>通过分别从各子领域的用户故事中提取关键概念，审视它们之间的关系，以及它们与外部系统之间的关系，我们可以梳理出系统中的限界上下文。如下图所示</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%88%92%E5%88%86%E4%B8%8A%E4%B8%8B%E6%96%872.png" srcset="/img/loading.gif" lazyload alt></p><p>把子域和限界上下文的划分结果整合</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%AD%90%E5%9F%9F%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%872.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>限界上下文和微服务</strong></p><p><a href="#DDD%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1">DDD和微服务</a></p><p>微服务是限界上下文的实现方式，一般一个限界上下文对应一个服务</p><h3 id="上下文映射模式"><a class="markdownIt-Anchor" href="#上下文映射模式"></a> 上下文映射模式</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%842.png" srcset="/img/loading.gif" lazyload alt></p><p>限界上下文并不是孤立的，它们之间需要协作才能完成系统的功能。划分之后的限界上下文以及团队之间如何进行协作，怎样去理解限界上下文之间的关系，这就引出了上下文映射的概念</p><p class="note note-primary">上下文映射(Context Mapping)</p><ul><li>上下文映射是指限界上下文之间的模型映射关系</li><li>描述团队之间的协作关系以及上下文之间的集成关系</li><li>决定上下文之间如何集成以及如何设置防腐层（代理层，将其他模型转换本上下文模型）</li></ul><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%84.png" srcset="/img/loading.gif" lazyload alt></p><p>上图的上下文中存在概念重叠的地方，比如支付二维码和商品，这种现象是正常的，这就是限界上下文的意义所在。但是在系统实现的过程中需要处理一个问题，当我们集成两个概念重叠的上下文需要怎么处理？是将其中一个转换成另一个或多个？还是其中一个向另外一个看齐？其实这就是模型和模型之间的映射关系。当需要集成另一个上下文，就需要看到这个上下文暴露出来的概念</p><p class="note note-primary">上下文映射模式</p><table><thead><tr><th>模式名称</th><th>备注</th></tr></thead><tbody><tr><td>Partenership</td><td>合伙人</td></tr><tr><td>Shared Kernel</td><td>共享内核</td></tr><tr><td>Customer/Supplier</td><td>客户/供应商</td></tr><tr><td>Conformist</td><td>顺从者</td></tr><tr><td>Anticorruption Layer</td><td>防腐层</td></tr><tr><td>Separate Ways</td><td>分道扬镰（独立方法）</td></tr><tr><td>Open Host Service</td><td>开放主机服务</td></tr><tr><td>Published Language</td><td>公开语言</td></tr><tr><td>Big Ball Of Mud</td><td>大泥球</td></tr></tbody></table><h4 id="开放主机服务"><a class="markdownIt-Anchor" href="#开放主机服务"></a> 开放主机服务</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BC%80%E6%94%BE%E4%B8%BB%E6%9C%BA%E6%9C%8D%E5%8A%A1.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>服务提供方为所有消费方提供一套公共的API</li><li>针对通用的功能和模型</li></ul><p>微信支付是支付上下文的上游，微信支付提供通用的支付API。通用API服务因为难以定制化，其隐含了另一种模式<code>顺从者</code></p><h4 id="顺从者"><a class="markdownIt-Anchor" href="#顺从者"></a> 顺从者</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%A1%BA%E4%BB%8E%E8%80%85.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>没有模型到模型的转换</li><li>一个上下文沿用另一个上下文的部分模型</li></ul><p>顺从者模式隐藏一个风险，当你顺从一个上下文的时候，其实也就表明了你允许其对你的侵入。如果有多个支付渠道，那么也就意味着需要引入多个上下文模型，如果不采用特殊方法处理，当前上下文可能会变得混乱可能会变成<code>大泥球</code></p><h4 id="大泥球"><a class="markdownIt-Anchor" href="#大泥球"></a> 大泥球</h4><ul><li>由混杂的模型构成的糟糕系统，模型不稳定且难于维护</li><li>与大泥球合作的上下文要确保自身不被污染，设置防腐层</li></ul><h4 id="防腐层"><a class="markdownIt-Anchor" href="#防腐层"></a> 防腐层</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%98%B2%E8%85%90%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>把上游上下文的模型转换成自己上下文的模型</li><li>是下游上下文中访问外部模型的一个代理层</li></ul><h4 id="共享内核"><a class="markdownIt-Anchor" href="#共享内核"></a> 共享内核</h4><ul><li><p>两个上下文共享部分模型</p></li><li><p>比如把核心源码封装为一个<code>jar</code>或者<code>starter</code>甚至是数据表等</p></li><li><p>慎用，仅当团队紧密合作且共享部分稳定，合作紧密的团队又隐含另一模式</p></li></ul><h4 id="合伙人"><a class="markdownIt-Anchor" href="#合伙人"></a> 合伙人</h4><ul><li>技术无关，是一种团队协作关系</li><li>两个团队之间可以随时互通有无，协同变更</li></ul><h4 id="客户供应商"><a class="markdownIt-Anchor" href="#客户供应商"></a> 客户/供应商</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BE%9B%E5%BA%94%E5%95%86.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>下游上下文可以向上游上下文提需求</p></li><li><p>一般用于核心域与非核心域之间的协作</p></li><li><p>核心域（下游）会向非核心域提需求（现实中支撑子域可能由外包团队负责）</p></li></ul><h4 id="分道扬镳独立方法"><a class="markdownIt-Anchor" href="#分道扬镳独立方法"></a> 分道扬镳（独立方法）</h4><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%88%86%E9%81%93%E6%89%AC%E9%95%B3.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>两个上下文无协作，各自独立</li><li>当两个上下文之间的集成成本过高</li></ul><p>比较常见的是新旧系统的集成，原本旧系统如果就是一个大泥球，旧系统的集成就会相对困难。新系统可能会放弃集成，自己实现</p><h4 id="公开语言"><a class="markdownIt-Anchor" href="#公开语言"></a> 公开语言</h4><ul><li>标准化与协议化的模型</li><li>所有上下文都可以与公开语言中的模型进行转换</li><li>对接了公开语言的上下文之间可以实现组件化对接</li></ul><p>例子</p><ul><li>蓝牙协议、tcp/ip</li><li>Java生态的jdbc、jvm标准等</li><li>SQL</li></ul><h3 id="分层架构"><a class="markdownIt-Anchor" href="#分层架构"></a> 分层架构</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BC%A0%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>严格按照领域模型来编写代码(通用语言命名)</li><li>建模和实现中都有破坏该原则的因素</li><li>架构分层能够避免模型在实现过程中被省略或者污染</li></ul><p>建立分层架构的目标是实现领域驱动设计中的一个重要原则，模型驱动设计。模型驱动设计简而言之就是我们需要遵循模型来编写代码，使得代码的设计不受到其他因素的干扰，代码和模型实现一致。但现实中这种原则很容易受到干扰，比如出于数据库性能考虑，我们代码会创造出领域不存在的实体，因此分层架构用于避免模型在实现过程中被省略或者污染</p><p class="note note-primary">传统分层</p><p><code>传统分层围绕数据结构编码</code></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BC%A0%E7%BB%9F%E5%88%86%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><p>传统架构分层的入口是<code>controller</code>,处理业务会调用<code>service</code>，如果处理的业务逻辑有远程调用则会调用<code>client</code>,最后会查询或保存数据调用<code>dao</code>层，返回数据用到<code>entity</code>和<code>vo</code>层。这样的分层架构看上去中规中矩，其实就是我们要尽量避免的反模式。因为在<code>entity</code>包中可能存在大量非领域实体的实体，在这种分层架构下，其实我们一直是围绕数据在编写代码，领域模型其实已经被我们忽略掉了，这个模型其实属于<code>贫血模型</code>。在这种分层架构下我们的设计其实都是在围绕这数据在设计（或者说围绕数据表结构设计，先设计表结构然后开始编码），这种模式最后会演变为业务代码被存储层绑架，业务逻辑和技术实现混杂在一起，领域模型最终也被技术方案绑架，传统的架构模型存在以下问题</p><ul><li>领域模型易被省略，变成贫血模型</li><li>容易演变成基于数据的设计，一切从表结构开始</li><li>领域模型与技术实现混杂，易被技术实现绑架</li></ul><h4 id="四层架构"><a class="markdownIt-Anchor" href="#四层架构"></a> 四层架构</h4><p><code>目的：让各层之间形成一个良性的单向依赖</code></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>四层架构是DDD中经典的架构，把架构分为</p><table><thead><tr><th>分层</th><th>英文</th><th>描述</th></tr></thead><tbody><tr><td>表现层</td><td><code>User Interface</code></td><td>用户界面层，或者表现层，负责向用户显示解释用户命令</td></tr><tr><td>应用层</td><td><code>Application Layer</code></td><td>定义软件要完成的任务，并且指挥协调领域对象进行不同的操作还包含事务的控制。该层不包含业务领域知识。</td></tr><tr><td>领域层</td><td><code>Domain Layer</code></td><td>或称为模型层，系统的核心，负责表达业务概念，业务状态信息以及业务规则。即包含了该领域（问题域）所有复杂的业务知识抽象和规则定义。该层主要精力要放在领域对象分析上，可以从实体，值对象，聚合（聚合根），领域服务，领域事件，仓储，工厂等方面入手</td></tr><tr><td>基础设施层</td><td><code>Infrastructure Layer</code></td><td>主要有2方面内容，一是为领域模型提供持久化机制，当软件需要持久化能力时候才需要进行规划；一是对其他层提供通用的技术支持能力，如消息通信，通用工具，配置等的实现；</td></tr></tbody></table><p class="note note-primary">四层架构落地</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9B%9B%E5%B1%82%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>接口层（表现层）</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%8E%A5%E5%8F%A3%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>领域层</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%A2%86%E5%9F%9F%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>应用层</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BA%94%E7%94%A8%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BA%94%E7%94%A8%E5%B1%822.png" srcset="/img/loading.gif" lazyload alt></p><p>应用服务不在访问数据层（直接操作dao类），应用服务会去协调领域层的元素，实体，资源库，领域服务等让它们配合完成请求。具体的业务逻辑被放到了领域层。通过四层架构，这里的设计和编码已经不围绕表结构去进行了（资料库是实体和表结构的解耦），领域模型就可以变得相对独立（模型不受表结构影响），不再被技术方案所绑架，这样设计人员才能把精力聚焦到领域模型的建立和实现上</p><p><strong>基础设施层</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>四层架构解决的问题</strong></p><ul><li>分离关注点</li><li>让领域模型层更独立</li><li>单向依赖</li></ul><p><strong>缺陷</strong></p><ul><li>领域层对基础设施层仍然有感知，领域模型和技术实现耦合（因为资料库的实现依赖于dao类）</li></ul><h4 id="六边形架构"><a class="markdownIt-Anchor" href="#六边形架构"></a> 六边形架构</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/378085465">洋葱架构，六边形架构</a></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>保持领域层的纯粹性，不受其他因素干扰</li><li>便于践行模型驱动设计，代码跟随模型</li><li>便于把团队精力集中到领域模型</li></ul><p>四层架构演化而来的，核心思想是把领域模型放到了核心层，领域层变得存粹和独立，本文参考了六边形架构和洋葱架构落地，将洋葱架构的<code>User Interface</code>层改为<code>Adapter</code>层</p><p><strong>应用层</strong></p><p>和上文没有太大区别</p><p><strong>领域层</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%82%E9%85%8D%E5%99%A8%E5%B1%82.png" srcset="/img/loading.gif" lazyload alt></p><p>资源库的实现类被移到了适配器层，领域层只保留了资料库的接口。因为资源库本质完成的是领域模型和存储层之间的数据交换</p><p><strong>基础设施层</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%B1%82%E6%94%B9%E5%8A%A8.png" srcset="/img/loading.gif" lazyload alt></p><p>把原先基础设施层远程服务调用拆分成两部分，接口放到了领域层，实现放到了适配器层。因为调用其他上下文的服务其实就是对上下文映射的一种实现，是领域模型之间的数据交换。需要在adapter层中完成其他模型到本模型数据的转换，防腐层可以在适配器层中实现</p><p><strong>适配器层</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%82%E9%85%8D%E5%99%A8%E5%B1%822.png" srcset="/img/loading.gif" lazyload alt></p><p>实现消息的收发（controller）</p><p>六边形架构的特点是让领域模型变得非常干净，领域模型非常独立，不再受到业务无关因素的影响</p><h2 id="初涉战术设计"><a class="markdownIt-Anchor" href="#初涉战术设计"></a> 初涉战术设计</h2><h3 id="环境准备约定"><a class="markdownIt-Anchor" href="#环境准备约定"></a> 环境准备，约定</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/kenful/smartrm/tree/master/smartrm-monolith">项目 smartrm-monolith</a></p><table><thead><tr><th>语言</th><th>Java</th></tr></thead><tbody><tr><td>IDE</td><td>IntelliJ IDEA</td></tr><tr><td>Jdk</td><td>Java SE Development Kit 8</td></tr><tr><td>依赖管理和构建应</td><td>Maven 3</td></tr><tr><td>应用开发框架</td><td>Spring boot 2.5.4</td></tr><tr><td>关系型数据库访问ORM</td><td>Mybatis 3.5.6</td></tr><tr><td>通用工具库</td><td>Guava 30.1.1-jre</td></tr><tr><td>定时任务调度</td><td>Quratz 2.3.2</td></tr></tbody></table><p>命名约定</p><table><thead><tr><th>对象含义</th><th>所处层</th><th>业内常用命</th><th>阿里规范</th><th>采用命名</th></tr></thead><tbody><tr><td>视图层对象</td><td>接口 (适配) 层</td><td>VO</td><td>VO</td><td>VO (能省则省)</td></tr><tr><td>数据传输对象</td><td>应用层</td><td>DTO</td><td>DTO</td><td>DTO</td></tr><tr><td>数据存储对象</td><td>基础设施层</td><td>PO(Persistent Object)</td><td>DO(Data Object)</td><td>DO</td></tr><tr><td>领域对象</td><td>领域层</td><td>DO(Domain Object)</td><td>BO(business object)</td><td>根据领域通用语言命名</td></tr></tbody></table><p>前期先使用单体架构实现DDD，后续重构为微服务架构</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/SmartRM%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%85%A8%E5%B1%80%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p>项目结构</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>包结构</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%8C%85%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="交易域准备工作"><a class="markdownIt-Anchor" href="#交易域准备工作"></a> 交易域准备工作</h3><ul><li>交易域业务流程熟悉</li><li>针对交易域进行战术设计分析</li><li>核心域上下文的依赖准备工作</li></ul><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79604739">货道售卖机操作流程</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/469002240">柜门售卖机操作流程</a></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/DomainStorytelling.png" srcset="/img/loading.gif" lazyload alt></p><p>在战略设计时（<a href="#%E5%9C%BA%E6%99%AF%E6%A8%A1%E6%8B%9F">场景模拟</a>），我们通过用户故事使用 Domain Storytelling(领域故事陈述法)建立起一个模型。在这个图中我们能够看到重要的角色和活动(标记序号的是活动)，角色有可能是领域中的某种用户或者某一种系统，活动就是从角色触发的领域中的某一种行为。在途中我们能看到角色和活动以及活动发生的顺序 ，但是我们看不到系统中的重要对象他们之间的关系。因为在战略设计的用户故事建模中我们围绕的就是对角色和活动进行分析，基本上没有机会去探讨对象之间的关系。所以通过这个图我们还是不知道系统中关键对象的特性是什么，对象之间又是怎样进行协作的，以至于我们不知道如何编写代码</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E6%88%98%E6%9C%AF%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%9F%9C%E9%97%A8%E6%9C%BA%E5%85%8D%E5%AF%86%E6%94%AF%E4%BB%98.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">因此我们必须针对战术设计进行分析，需要分析出对象之间的关联</span></p><p class="note note-primary">对象间关系</p><ul><li><p>一个对象为另一个对象的状态变更提供数据</p><p>比如售卖机商品列表，就需要商品库存提供信息过滤商品，也需要商品信息提供商品明细进行展示</p></li><li><p>一个对象的状态变更导致另一个对象的状态变更</p><p>订单状态的变化影响支付，支付状态的变化影响订单状态</p></li></ul><p><span class="green-line">战术设计阶段就是要尽量挖掘对象之间的关系，和战略设计分析的思路不同，重点不再围绕用户和其他领域中的角色以及从这些角色出发的活动进行分析。而转变到挖掘领域中的对象和对象之间的关联</span></p><p>domain-story-modeler 是以用户，角色，活动为核心，只有从角色出发的箭头才有标号（设备上下文到交易上下文无法放置标号），因此需要借用UML建模里的时序图</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>整合</strong></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%98%93%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p>将战术故事的领域故事陈述结合时序图后，就得到上下文交互图。箭头的标注我们能够看到上下文提供的接口</p><h3 id="实体和值对象"><a class="markdownIt-Anchor" href="#实体和值对象"></a> 实体和值对象</h3><p><a target="_blank" rel="noopener" href="https://zq99299.github.io/note-book2/ddd/01/04.html#%E5%AE%9E%E4%BD%93">参考 实体和值对象</a></p><ul><li><code>实体</code>：是指描述了领域中唯一的且可持续变化的抽象模型，有ID标识，有生命周期，有状态（用值对象来描述状态），实体通过ID进行区分；其二是要跟踪状态的变化；</li><li><code>值对象</code>：值对象的核心本质是值，与是否有复杂类型无关，值对象没有生命周期，通过两个值对象的值是否相同区分是否是同一个值对象</li></ul><p class="note note-primary">特征</p><p>实体</p><ul><li><p>ID相等性</p></li><li><p>要跟踪状态变化</p><p>比如身份证上的身份证号，头像</p></li></ul><p>值对象</p><ul><li><p>属性相等性</p></li><li><p>可互换</p></li><li><p>不变性</p><p>比如身份证上的出生地址</p></li></ul><p class="note note-primary">区分的原因</p><ul><li>值对象往往更轻量级</li><li>尽可能用值对象而不是实体</li><li>值对象不用跟踪变化</li><li>实体和值对象在领域中扮演的角色不一样</li></ul><p>实体可以作为一个聚合根，而值对象不可以</p><p class="note note-primary">区分</p><ul><li>通过特征区分</li><li>是否只读</li><li>生命周期是否跨越活动</li></ul><p>以身份证举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdCard</span> &#123;<br>    <span class="hljs-comment">// id</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <br>    <span class="hljs-comment">// 身份证号</span><br>    <span class="hljs-keyword">private</span> String IdNumber;<br>    <br>    <span class="hljs-comment">// 头像</span><br>    <span class="hljs-keyword">private</span> String avatar;<br>    <br>    <span class="hljs-comment">// 地址</span><br>    <span class="hljs-keyword">private</span> Address address;<br><br>    <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIdNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> IdNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIdNumber</span><span class="hljs-params">(String idNumber)</span> &#123;<br>        IdNumber = idNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAvatar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> avatar;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAvatar</span><span class="hljs-params">(String avatar)</span> &#123;<br>        <span class="hljs-built_in">this</span>.avatar = avatar;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 值对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String province, String city, String address, String detail)</span> &#123;<br>        <span class="hljs-built_in">this</span>.province = province;<br>        <span class="hljs-built_in">this</span>.city = city;<br>        <span class="hljs-built_in">this</span>.address = address;<br>        <span class="hljs-built_in">this</span>.detail = detail;<br>    &#125;<br><br>    <span class="hljs-comment">// 省份</span><br>    <span class="hljs-keyword">private</span> String province;<br>    <br>    <span class="hljs-comment">// 城市</span><br>    <span class="hljs-keyword">private</span> String city;<br>    <br>    <span class="hljs-comment">// 区</span><br>    <span class="hljs-keyword">private</span> String address;<br>    <br>    <span class="hljs-comment">// 详细地址</span><br>    <span class="hljs-keyword">private</span> String detail;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getProvince</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> province;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> city;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDetail</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> detail;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address1</span> <span class="hljs-operator">=</span> (Address) o;<br><br>        <span class="hljs-keyword">if</span> (province != <span class="hljs-literal">null</span> ? !province.equals(address1.province) : address1.province != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (city != <span class="hljs-literal">null</span> ? !city.equals(address1.city) : address1.city != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (address != <span class="hljs-literal">null</span> ? !address.equals(address1.address) : address1.address != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> detail != <span class="hljs-literal">null</span> ? detail.equals(address1.detail) : address1.detail == <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> province != <span class="hljs-literal">null</span> ? province.hashCode() : <span class="hljs-number">0</span>;<br>        result = <span class="hljs-number">31</span> * result + (city != <span class="hljs-literal">null</span> ? city.hashCode() : <span class="hljs-number">0</span>);<br>        result = <span class="hljs-number">31</span> * result + (address != <span class="hljs-literal">null</span> ? address.hashCode() : <span class="hljs-number">0</span>);<br>        result = <span class="hljs-number">31</span> * result + (detail != <span class="hljs-literal">null</span> ? detail.hashCode() : <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="领域对象的构造"><a class="markdownIt-Anchor" href="#领域对象的构造"></a> 领域对象的构造</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/domain/Order.java">Order</a></p><p>对象构造是谁的职责，如何确保相关对象的一致性</p><p>使用工厂模式解决领域对象的构造。<span class="green-line">一个聚合的领域对象一般是由<code>聚合根</code>提供构造方法的，而聚合根的构造一般在<code>领域服务</code>或者<code>应用层</code>被构造</span></p><ul><li>工厂方法模式</li><li>抽象工厂模式</li></ul><hr><p>如何兼顾对象构造的简便性和对象的封装性</p><ul><li>建造者模式</li></ul><hr><p>实体ID应该如何生成</p><ul><li>基于已有信息的拼接</li><li>基于数据库表自增ID</li><li>基于独立的ID生成器</li></ul><h3 id="资源库与持久化"><a class="markdownIt-Anchor" href="#资源库与持久化"></a> 资源库与持久化</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/domain/repository/OrderRepository.java">OrderRepository</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/adapter/repository/impl/OrderRepositoryImpl.java">OrderRepositoryImpl</a></p><p class="note note-primary">什么是资源库</p><ul><li>为每种需要全局访问的对象类型创建一个对象，这个对象相当于该类型的所有对象在内存中的一个集合的“替身”。通过一个众所周知的全局接口来提供访问</li><li>带必要管理功能的领域对象容器，与技术实现无关</li></ul><p class="note note-primary">资源库的意义</p><ul><li>提供一个管理领域对象的简单模型</li><li>使领域模型和持久化技术解耦，它可以屏蔽存储层的技术细节</li></ul><p>在领域层提供一个资源库接口暴露给上层使用，大多数情况下，资源库底层也是使用Dao类实现，主要完成表对象和领域对象的转换和解耦</p><p class="note note-primary">资源库的实现</p><p>领域实体通常也会使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/bxl_1986/article/details/79097493">充血模式</a>，实体除包含get set方法，还包含对象的持久化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderRepository</span> &#123;<br><br>  <span class="hljs-comment">// 根据订单id获取订单</span><br>  Order <span class="hljs-title function_">getOrderById</span><span class="hljs-params">(<span class="hljs-type">long</span> orderId)</span>;<br><br>  <span class="hljs-comment">// 新增订单</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOrder</span><span class="hljs-params">(Order order)</span>;<br><br>  <span class="hljs-comment">// 更新订单信息</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateOrder</span><span class="hljs-params">(Order order)</span>;<br><br>  <span class="hljs-comment">// 新增或修改订单信息</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">addOrUpdate</span><span class="hljs-params">(Order order)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderRepositoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderRepository</span> &#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  OrderMapper orderMapper;<br><br>  <span class="hljs-meta">@Autowired</span><br>  DomainEventBus eventBus;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrderById</span><span class="hljs-params">(<span class="hljs-type">long</span> orderId)</span> &#123;<br>    <span class="hljs-comment">// 表实体  </span><br>    <span class="hljs-type">OrderDo</span> <span class="hljs-variable">orderDo</span> <span class="hljs-operator">=</span> orderMapper.selectOne(orderId);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 字符串转对象</span><br>      StockedCommodityDo[] commodityDos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>()<br>          .readValue(orderDo.getCommodities(), StockedCommodityDo[].class);<br>      <span class="hljs-comment">// 表实体转领域实体，实现领域模型和底层存储的解耦  </span><br>      <span class="hljs-keyword">return</span> Order.Builder()<br>          .orderId(orderId)<br>          .paymentId(orderDo.getPaymentId())<br>          .type(OrderType.of(orderDo.getType()))<br>          .machineId(orderDo.getMachineId())<br>          .state(OrderState.of(orderDo.getState()))<br>          .commodities(Arrays.stream(commodityDos).map(<br>              d -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockedCommodity</span>(d.getCommodityId(),<br>                  d.getName(),<br>                  d.getImageUrl(),<br>                  d.getPrice(),<br>                  d.getCount())).collect(<br>              Collectors.toList()))<br>          .eventBus(eventBus).build();<br>    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(CommonError.PersistentDataError);<br>    &#125;<br>  &#125;<br>  ...<br></code></pre></td></tr></table></figure><h3 id="聚合"><a class="markdownIt-Anchor" href="#聚合"></a> 聚合</h3><p><code>聚合根提供外部访问聚合内部对象接口</code></p><p>限界上下文和聚合：<span class="green-line">一个限界上下文可能包含多个聚合</span></p><p><span class="green-line">聚合就是一组相关对象的集合，我们把它作为数据修改的单元。每个聚合都有一个根和一个边界。<code>聚合根</code>是聚合所包含的一个特定实体。对聚合而言，外部对象只可以引用<code>聚合根</code>，而边界内部的对象之间则可以互相引用</span></p><p>聚合是拥有事务一致性 (强一致性)的领域对象组合</p><ul><li>聚合内的实体适用事务一致性</li><li>聚合之间适用最终一致性</li><li>不脱离聚合根修改聚合内部对象</li></ul><p>聚合根有全局唯一标识，聚合内部实体只有局部标识</p><p>聚合根可以从资源库获取，聚合内部实体不能</p><p>比如一辆汽车，汽车就是聚合根，而引擎就是一个和汽车相关的对象。比如汽车引擎的维修必须通过汽车对象，首先必须把汽车拖进维修厂</p><p class="note note-primary">聚合解决什么问题</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E4%B8%8B%E9%99%90.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>优雅地实现一致性</li><li>聚合是限界上下文粒度的下限</li></ul><p class="note note-primary">聚合的识别</p><p>实体是否在所有活动中都协同变更</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E6%88%98%E6%9C%AF%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt></p><p>在本项目中，货道售卖机，订单，支付三个实体，是否属于同一个聚合？货道售卖机和订单不管是用户在选择商品之后或者是用户超时取消订单之后或扫码支付之后它们的状态是协同变更的，要么货道售卖机售卖机处于交易状态，订单处于开始状态；要么货道售卖机处于就绪状态，订单处于成功或取消状态。我们可以认为货道售卖机和订单属于同一个聚合，判断<code>聚合根</code>需要两个因素</p><ul><li>直接面向用户请求</li><li>谁的生命周期更长</li></ul><p>项目中货道售卖机是直接面向用户请求的，而且货道售卖机在处理一个订单后可以处理下一个新的订单，货道售卖机的生命周期会比订单长。所以货道售卖机是聚合根。支付这个实体和货道售卖机不属于同一个聚合，因为支付属于外部系统，无法保证一致性，因此支付和货道售卖机不属于同一个聚合</p><p class="note note-primary">实现聚合</p><p>应用层服务：<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/application/AppTradeService.java">AppTradeService</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户选择商品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> PaymentQrCode <span class="hljs-title function_">selectCommodity</span><span class="hljs-params">(SelectCommodityCmdDto cmd)</span> &#123;<br>  <span class="hljs-comment">// 获取聚合根</span><br>  <span class="hljs-type">SlotVendingMachine</span> <span class="hljs-variable">machine</span> <span class="hljs-operator">=</span> machineRepository.getSlotVendingMachineById(cmd.getMachineId());<br>  <span class="hljs-keyword">if</span> (machine == <span class="hljs-literal">null</span>) &#123;<br>    LOGGER.warn(<span class="hljs-string">&quot;vending machine not found:&#123;&#125;&quot;</span>, cmd.getMachineId());<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(TradeError.VendingMachineNotFound);<br>  &#125;<br><br>  <span class="hljs-comment">// 校验商品</span><br>  <span class="hljs-type">CommodityInfo</span> <span class="hljs-variable">commodityInfo</span> <span class="hljs-operator">=</span> commodityService.getCommodityDetail(cmd.getCommodityId());<br>  <span class="hljs-keyword">if</span> (commodityInfo == <span class="hljs-literal">null</span>) &#123;<br>    LOGGER.warn(<span class="hljs-string">&quot;commodity not exist:&#123;&#125;&quot;</span>, cmd.getCommodityId());<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(TradeError.CommodityNotExist);<br>  &#125;<br><br>  <span class="hljs-comment">// 构建库存商品</span><br>  <span class="hljs-type">StockedCommodity</span> <span class="hljs-variable">commodity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockedCommodity</span>(<br>      commodityInfo.getCommodityId(),<br>      commodityInfo.getCommodityName(),<br>      commodityInfo.getImageUrl(),<br>      commodityInfo.getPrice(),<br>      <span class="hljs-number">1</span><br>  );<br><br>  <span class="hljs-comment">// 远程调用，开始支付，获取二维码</span><br>  <span class="hljs-comment">// 支付和货到售卖机不属于同一个聚合</span><br>  <span class="hljs-type">PaymentQrCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> machine<br>      .selectCommodity(Lists.newArrayList(commodity), deviceService, payService,<br>          cmd.getPlatformType());<br>  Map&lt;String, Object&gt; params = Maps.newHashMap();<br>  params.put(<span class="hljs-string">&quot;orderId&quot;</span>, machine.getCurOrder().getOrderId());<br>  params.put(<span class="hljs-string">&quot;machineId&quot;</span>, machine.getMachineId());<br>  <span class="hljs-comment">// 超时支付设置</span><br>  scheduler.scheduleRetry(TradeExpireExecutor.class, params, <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> code;<br>&#125;<br></code></pre></td></tr></table></figure><p>聚合根：<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/domain/SlotVendingMachine.java">SlotVendingMachine</a></p><p>聚合根的聚合对象的持久化交给聚合根的资料库操作，聚合根负责和外部对象交互，被依赖的对象只能通过聚合根和外部对象交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 选择商品</span><br><span class="hljs-keyword">public</span> PaymentQrCode <span class="hljs-title function_">selectCommodity</span><span class="hljs-params">(Collection&lt;StockedCommodity&gt; commodities,</span><br><span class="hljs-params">                                     TradeDeviceService deviceService, TradePayService payService, PlatformType platformType)</span> &#123;<br>    <span class="hljs-comment">//校验设备状态</span><br>    <span class="hljs-keyword">if</span> (state != SlotVendingMachineState.Ready) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(TradeError.VendingMachineStateNotRight);<br>    &#125;<br><br>    <span class="hljs-comment">//校验库存</span><br>    <span class="hljs-keyword">if</span> (!checkInventory(commodities, deviceService)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(TradeError.InventoryCheckFail);<br>    &#125;<br><br>    <span class="hljs-comment">// 生成订单</span><br>    curOrder = <span class="hljs-built_in">this</span>.generateOrder(commodities);<br>    emitEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderCreatedEvent</span>(<span class="hljs-built_in">this</span>.machineId, curOrder));<br>    state = SlotVendingMachineState.Trading;<br><br>    <span class="hljs-comment">// 远程调用，开始支付，获取支付二维码</span><br>    <span class="hljs-type">PaymentQrCode</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> payService.startQrCodePayForOrder(platformType, curOrder);<br>    <span class="hljs-comment">// AOP切面，更新订单</span><br>    curOrder.setPaymentId(ret.getPaymentId());<br>    <span class="hljs-comment">// 乐观锁机制</span><br>    incVersion();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 订单和货道售卖机是聚合关系，售卖机可以看作是订单的聚合根</span><br><span class="hljs-keyword">private</span> Order <span class="hljs-title function_">generateOrder</span><span class="hljs-params">(Collection&lt;StockedCommodity&gt; commodities)</span> &#123;<br>    <span class="hljs-keyword">return</span> Order.Builder().commodities(commodities)<br>            .orderId(UniqueIdGeneratorUtil.instance().nextId())<br>            .state(OrderState.Start)<br>            .type(OrderType.SlotQrScanePaid)<br>            .machineId(<span class="hljs-built_in">this</span>.machineId)<br>            .eventBus(eventBus)<br>            .build();<br>&#125;<br><br><span class="hljs-comment">// 完成订单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishOrder</span><span class="hljs-params">(<span class="hljs-type">long</span> orderId, TradeDeviceService deviceService)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.curOrder == <span class="hljs-literal">null</span> || <span class="hljs-built_in">this</span>.curOrder.getOrderId() != orderId) &#123;<br>        LOGGER.warn(<span class="hljs-string">&quot;order finished when slot vending machine has release it:&#123;&#125;,&#123;&#125;&quot;</span>, machineId,<br>                orderId);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//弹出商品</span><br>    <span class="hljs-keyword">if</span> (curOrder.getCommodities().size() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(CommonError.UnExpected)<br>                .withMsg(<span class="hljs-string">&quot;slot vending machine only support one commodity order&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (StockedCommodity commodity : curOrder.getCommodities()) &#123;<br>        deviceService<br>                .popCommodity(curOrder.getMachineId(), commodity.getCommodityId(), curOrder.getOrderId());<br>    &#125;<br>    <span class="hljs-built_in">this</span>.curOrder.succeed();<br>    <span class="hljs-built_in">this</span>.state = SlotVendingMachineState.Popping;<br>    incVersion();<br>&#125;<br><br><span class="hljs-comment">// 取消订单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (curOrder == <span class="hljs-literal">null</span> || curOrder.getState() == OrderState.Canceled) &#123;<br>        LOGGER.warn(<span class="hljs-string">&quot;cancel order state not right.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    curOrder.cancel();<br>    state = SlotVendingMachineState.Ready;<br>    <span class="hljs-comment">//curOrder = null;</span><br>    <span class="hljs-comment">// 乐观锁机制</span><br>    incVersion();<br>&#125;<br></code></pre></td></tr></table></figure><p>聚合根资料库：<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/adapter/repository/impl/TradeVendingMachineRepositoryImpl.java">VendingMachineRepository</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateSlotVendingMachine</span><span class="hljs-params">(SlotVendingMachine machine)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!machine.isVersionInc()) &#123;<br>    <span class="hljs-comment">//版本号未改变时直接跳过</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">TradeSlotVendingMachineDo</span> <span class="hljs-variable">machineDo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TradeSlotVendingMachineDo</span>();<br>  machineDo.setMachineId(machine.getMachineId());<br>  machineDo.setState(machine.getState().code());<br>  machineDo.setCurOrderId(machine.getCurOrder() != <span class="hljs-literal">null</span> ? machine.getCurOrder().getOrderId() : <span class="hljs-number">0</span>);<br>  machineDo.setVersion(machine.getVersion());<br><br>  <span class="hljs-comment">// 聚合根资料库持久化聚合对象</span><br>  <span class="hljs-keyword">if</span> (machine.getCurOrder() != <span class="hljs-literal">null</span>) &#123;<br>    orderRepository.addOrUpdate(machine.getCurOrder());<br>  &#125;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">updated</span> <span class="hljs-operator">=</span> slotVendingMachineMapper.update(machineDo);<br>  <span class="hljs-keyword">if</span> (updated == <span class="hljs-number">0</span>) &#123;<br>    LOGGER.error(<span class="hljs-string">&quot;fail to update slot machine, version:&quot;</span> + machineDo.getVersion());<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(CommonError.ConcurrencyConflict);<br>  &#125;<br>  LOGGER.info(<span class="hljs-string">&quot;update slot machine, version:&quot;</span> + machineDo.getVersion());<br>&#125;<br></code></pre></td></tr></table></figure><p>这样聚合根就完成了聚合中的所有对象的操作，收敛了所有聚合对象的操作（只能通过聚合根操作）</p><h3 id="领域服务"><a class="markdownIt-Anchor" href="#领域服务"></a> 领域服务</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-trade/src/main/java/com/smartrm/smartrmtrade/trade/domain/service/TradeCommodityService.java">TradeCommodityService</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-trade/src/main/java/com/smartrm/smartrmtrade/trade/adapter/remote/TradeCommodityServiceImpl.java">TradeCommodityServiceImpl</a>，实现在适配层，因为需要进行模型转换</p><p><code>当领域中的某个重要的过程或转换操作不是实体或值对象的自然职责时</code>应该在模型中添加一个作为独立接口的操作，并将其声明为<code>领域服务</code>定义接口时要使用模型语言，并确保操作名称是通用语言中的术语。此外应该使领域服务成为<code>无状态</code>的，领域服务只包含<code>业务逻辑</code></p><p>场景：比如货道售卖机此时开展了运营活动，如果是新用户第一次购买商品时打八折，由于运营活动不是实体和值对象，因此可以使用领域服务声明一个ActivityService，用于计算新用户商品总额</p><h3 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h3><p>定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。<code>应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作</code></p><p>比如在一个汽车模型中，汽车的领域层包括，开门，关门，启动，刹车，转弯，倒车。而应用层是“从家里开车到公司”，那么应用层要实现汽车从家里开到公司只能是协调汽车的开门，关门，启动等操作后，最终才能完成家到公司的需求</p><p class="note note-primary">应用层的职责</p><p>应用层服务：<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/application/AppTradeService.java">AppTradeService</a></p><ul><li>事务控制</li><li>身份认证和访问权限</li><li>定时任务调度</li><li>事件订阅<ul><li>事件监听 (适配层，可能包含事件对象转换)<br>事件处理(应用层）</li></ul></li></ul><h2 id="深入战术设计"><a class="markdownIt-Anchor" href="#深入战术设计"></a> 深入战术设计</h2><p class="note note-primary">领域事件为什么重要</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/CQRS%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">在DDD中，聚合根的读写操作，出于对性能的考虑，其读模型和写模型可能是相对独立的。写模型落地到数据库后通过领域事件通知读模型进行数据同步，读模型对于性能的考量，采取性能更优秀的NoSql存储，比如Redis</span></p><ul><li>领域事件能够驱动建模</li><li>领域事件和很多重要思想相关<ul><li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/wdlpjosudoga34jutys9">CQRS 命令查询责任分离</a></li><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7117530345569779726#heading-6">CQRS 架构</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38968012">Event Soucing 事件溯源</a></li></ul></li><li>领域事件和大数据处理和分析相关</li></ul><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E8%BF%90%E8%90%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E4%BA%92.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">建模工具</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E5%BB%BA%E6%A8%A1.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">事件风暴建模法</p><ul><li>便利贴：线下开会</li><li>Miro：线上工具</li></ul><h3 id="领域事件"><a class="markdownIt-Anchor" href="#领域事件"></a> 领域事件</h3><p>订单支付使用领域事件：<a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/trade/domain/Order.java">Order</a></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/infracore/event/DomainEvent.java">DomainEvent 领域事件，单机模式使用spring自定义事件实现</a></p><p class="note note-primary">什么是领域事件</p><ul><li>领域中发生的任何领域专家感兴趣的事情</li><li>领域事件一般由聚合产生</li><li>领域事件不是技术概念</li></ul><p class="note note-primary">事件命名和基本属性</p><ul><li>命名方法：动词+名词 <code>finishOrder</code></li><li>事件ID：全局唯一</li><li>产生时间</li></ul><p class="note note-primary">发布订阅方式</p><ul><li>外部系统<ul><li>API定向通知，比如支付的回调</li><li>API定时拉取，提供公开API</li><li>消息队列</li></ul></li><li>内部系统<ul><li>观察者模式，单体架构</li><li>数据库流水（binlog）</li><li>消息队列</li></ul></li></ul><p class="note note-primary">事件存储</p><ul><li>直接使用消息中间件的存储（内存或文件）</li><li>基于数据库（mongodb就是不错的选择）</li></ul><p class="note note-primary">事件处理的要求</p><ul><li>顺序性<ul><li>聚合ID</li><li>存储分片</li><li>消费分组</li></ul></li><li>幂等性：（用幂等性代替分布式事务，最终一致性保证）</li></ul><p class="note note-primary">领域事件和大数据分析</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="事件风暴建模法"><a class="markdownIt-Anchor" href="#事件风暴建模法"></a> 事件风暴建模法</h3><p><a target="_blank" rel="noopener" href="https://www.eventstorming.com/">事件风暴</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Y7NzXl-ahtU">事件风暴讲解</a></p><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=a0lWpjlSRA0">事件风暴讲解2</a></p><ul><li>一种协作式的对复杂业务领域进行探索的讨论形式</li><li>一种灵活易调整的的轻量级的适用于DDD的建模方法</li></ul><p class="note note-primary">应用场景</p><ul><li>评估已有业务线的健康度并发现优化点</li><li>探索一个新业务模型的可行性</li><li>设想为各个参与方能带来最大利益的新服务</li><li>设计整洁的可维护的软件以支持快速推进的业务</li></ul><p class="note note-primary">事件风暴核心</p><ul><li>领域事件</li><li>聚台</li><li>决策命令</li><li>角色</li><li>读模型</li><li>策略</li><li>外部系统</li><li>问题/热点</li></ul><p class="note note-primary">参与角色</p><p>4 ~ 8人规模，人太多沟通效率太低</p><ul><li><p>研发人员</p></li><li><p>产品经理</p></li><li><p>领域专家</p></li></ul><p class="note note-primary">列出主要领域事件</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%89%E6%8B%A9%E5%95%86%E5%93%81.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B42.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>橙色便利贴</li><li>动词过去式</li><li>和领域专家相关</li></ul><p class="note note-primary">收集关注点和问题</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%97%AE%E9%A2%98.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>紫色便利贴</p></li><li><p>问题</p></li><li><p>风险/关注点</p></li><li><p>假设</p></li><li><p>讨论点</p></li></ul><p class="note note-primary">通过命令深入领域</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%B7%B1%E5%85%A5%E9%A2%86%E5%9F%9F.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>蓝色代表命令</li><li>黄色代表角色</li></ul><p class="note note-primary">找到聚合</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%89%BE%E5%88%B0%E8%81%9A%E5%90%88.png" srcset="/img/loading.gif" lazyload alt></p><p>从领域事件反向驱动出命令后就要找到聚合，聚合链接了领域事件和决策命令</p><ul><li>处理领域逻辑</li><li>处理命令</li><li>产生领域事件</li></ul><p class="note note-primary">找出读模型</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%89%BE%E5%87%BA%E8%AF%BB%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>帮助用户做出决策</li><li>数据查询</li></ul><p class="note note-primary">策略</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E7%AD%96%E7%95%A5.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>响应式逻辑</li><li>响应领域事件</li><li>触发命令</li></ul><p class="note note-primary">外部系统</p><ul><li><p>第三方服务</p></li><li><p>对当前领域来说是外部</p></li><li><p>比如微信支付</p></li></ul><p class="note note-primary">事件风暴的几个任务</p><ul><li>Big Picture（描绘出全景图）</li><li>业务处理流程</li><li>软件设计</li></ul><p class="note note-primary">高效事件风暴的注意事项</p><ul><li>首先关注学习和倾听</li><li>谈话和例子很关键</li><li>锚定到具体的业务用例</li><li>澄清模糊概念</li></ul><p class="note note-primary">正向驱动</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%AD%A3%E5%90%91%E9%A9%B1%E5%8A%A8.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">反向驱动</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%8F%8D%E5%90%91%E9%A9%B1%E5%8A%A8.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="运营域事件风暴建模"><a class="markdownIt-Anchor" href="#运营域事件风暴建模"></a> 运营域事件风暴建模</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E8%BF%90%E8%90%A5%E5%9F%9F%E4%B8%9A%E5%8A%A1%E8%83%8C%E6%99%AF.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="防腐层构建"><a class="markdownIt-Anchor" href="#防腐层构建"></a> 防腐层构建</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%A0%E5%B0%843.png" srcset="/img/loading.gif" lazyload alt></p><p>图中的运营上下文和ERP系统上下文间就存在一个防腐层，使用ACL标记。<span class="green-line">防腐层就是上下文之间的一个转换层，它的作用就是防止上游上下文的复杂和混乱扩散到下游上下文（上下文的自我保护层）</span></p><p>在案例中，当运营人员决定在某个地方投放安装售卖机的时候，需要在系统中下投放订单。最终提交到客户（第三方）的ERP系统内部，由客户的采购和运营人员最终执行，这里的ERP系统是一个业务复杂度非常高的系统，和我们的领域区别也比较大。我们的系统和客户ERP系统交互的过程中，如果没有任何隔离措施，那么ERP内部系统的复杂性，一些系统概念就会扩散到我们系统</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/ERP%E5%AF%B9%E6%8E%A5%E6%96%87%E6%A1%A3.png" srcset="/img/loading.gif" lazyload alt></p><p>上图为ERP的对接文档，这些字段在我们的上下文中不好理解，在领域上下文应该只要关注运营相关的概念就可以了，不需要关注外部系统的概念，否则外部系统概念入侵到运营域，会增加运营域的复杂度</p><p class="note note-primary">防腐层落地</p><p>将运营上下文的投放订单和客户ERP的采购订单进行转换</p><p>投放订单</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%8A%95%E6%94%BE%E8%AE%A2%E5%8D%95.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/operation/domain/VendingMachineInstallOrder.java">VendingMachineInstallOrder</a></p><p>ERP采购订单对象放在适配层</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%87%87%E8%B4%AD%E8%AE%A2%E5%8D%95.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/operation/adapter/erp/model/ERPNumberId.java">ERPNumberId</a></p></li><li><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/operation/adapter/erp/model/ERPPurchaseOrder.java">ERPPurchaseOrder</a></p></li><li><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/operation/adapter/erp/model/FPOOrderEntry.java">FPOOrderEntry</a></p></li></ul><p>投放订单服务</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%8A%95%E6%94%BE%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/operation/domain/remote/erp/DevicePurchaseService.java">DevicePurchaseService</a></p><p>投放订单服务实现放到设配层，因为需要对投放订单和ERP的采购订单进行转换</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%8A%95%E6%94%BE%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-monolith/src/main/java/com/smartrm/smartrmmonolith/operation/adapter/erp/DevicePurchaseServiceImpl.java">DevicePurchaseServiceImpl</a>：实现了领域值对象和外部系统对象的转换，将外部系统的业务逻辑隔离在适配层，方式外部系统的业务入侵</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: erp防腐层示例，调用采购服务申请安装售卖机</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DevicePurchaseServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DevicePurchaseService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ERP_BUSSINESS_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//业务类型</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ERP_BILL_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">//单据类型</span><br><br>    <span class="hljs-comment">// 售卖机型号Mapper</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> VendingMachineModelMapper machineModelMapper;<br><br>    <span class="hljs-keyword">private</span> K3CloudApi client;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">K3CloudApi</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">placeInstallOrder</span><span class="hljs-params">(VendingMachineInstallOrder order)</span> &#123;<br>        <span class="hljs-comment">// 获取售卖机物料信息</span><br>        <span class="hljs-type">VendingMachineModelDo</span> <span class="hljs-variable">modelData</span> <span class="hljs-operator">=</span> machineModelMapper<br>                .selectByCode(order.getDeviceModel().code());<br><br>        <span class="hljs-comment">//售卖机投放订单 -&gt; ERP系统采购订单</span><br>        <span class="hljs-type">FPOOrderEntry</span> <span class="hljs-variable">orderEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FPOOrderEntry</span>();<br>        orderEntry.setFEntryID(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//物料信息</span><br>        orderEntry.setFMaterialId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(modelData.getMaterialId()));<br>        orderEntry.setFMaterialDesc(modelData.getMaterialDesc());<br>        orderEntry.setFProductType(modelData.getProductType());<br>        orderEntry.setFProcesser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(modelData.getProcessor()));<br>        orderEntry.setFBomId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(modelData.getBomId()));<br>        <span class="hljs-comment">//数量</span><br>        orderEntry.setFStockQty(order.getCount());<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 填充订单项目更多字段</span><br><br>        <span class="hljs-comment">//创建采购订单</span><br>        <span class="hljs-type">ERPPurchaseOrder</span> <span class="hljs-variable">purchaseOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPPurchaseOrder</span>();<br>        purchaseOrder.setFBusinessType(ERP_BUSSINESS_TYPE);<br>        purchaseOrder.setFBillTypeID(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(ERP_BILL_TYPE));<br>        purchaseOrder.setFPurchaseOrgId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(modelData.getPurchaseOrgId()));<br>        purchaseOrder.setFPurchaseDeptId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(modelData.getPurchaseDeptId()));<br>        purchaseOrder.setFPurchaserId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ERPNumberId</span>(modelData.getPurchaserId()));<br>        purchaseOrder.setFDate(order.getCreatedTime().format(DateTimeFormatter.BASIC_ISO_DATE));<br>        purchaseOrder.addEntry(orderEntry);<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 填充采购订单更多字段</span><br><br>        <span class="hljs-comment">// 提交采购订单</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(purchaseOrder);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">resultString</span> <span class="hljs-operator">=</span> client.save(<span class="hljs-string">&quot;PUR_PurchaseOrder&quot;</span>, json);<br>            <span class="hljs-type">JsonNode</span> <span class="hljs-variable">resultJson</span> <span class="hljs-operator">=</span> objectMapper.readTree(resultString);<br>            <span class="hljs-keyword">if</span> (!resultJson.get(<span class="hljs-string">&quot;Result&quot;</span>).get(<span class="hljs-string">&quot;ResponseStatus&quot;</span>).get(<span class="hljs-string">&quot;IsSuccess&quot;</span>).asBoolean()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(OperationError.ERPError);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultJson.get(<span class="hljs-string">&quot;Result&quot;</span>).get(<span class="hljs-string">&quot;ID&quot;</span>).asText();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> resultJson.get(<span class="hljs-string">&quot;Result&quot;</span>).get(<span class="hljs-string">&quot;Number&quot;</span>).asText();<br>                order.setOrderId(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InstallOrderId</span>(id, number));<br>                <span class="hljs-comment">//提交订单</span><br>                <span class="hljs-type">ObjectNode</span> <span class="hljs-variable">submitRequest</span> <span class="hljs-operator">=</span> objectMapper.createObjectNode();<br>                submitRequest.putArray(<span class="hljs-string">&quot;Ids&quot;</span>).add(id);<br>                submitRequest.putArray(<span class="hljs-string">&quot;Numbers&quot;</span>).add(number);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">submitResult</span> <span class="hljs-operator">=</span> client<br>                        .submit(<span class="hljs-string">&quot;PUR_PurchaseOrder&quot;</span>, objectMapper.writeValueAsString(submitRequest));<br>                resultJson = objectMapper.readTree(submitResult);<br>                <span class="hljs-keyword">if</span> (!resultJson.get(<span class="hljs-string">&quot;Result&quot;</span>).get(<span class="hljs-string">&quot;ResponseStatus&quot;</span>).get(<span class="hljs-string">&quot;IsSuccess&quot;</span>).asBoolean()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(OperationError.ERPError);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (DomainException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="大数据服务实现经营数据分析"><a class="markdownIt-Anchor" href="#大数据服务实现经营数据分析"></a> 大数据服务实现经营数据分析</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%B4%E5%90%88.png" srcset="/img/loading.gif" lazyload alt></p><p>准备</p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62169178">使用JMeter 或 Locust 压测框架生成测试数据</a></p><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/744647">kafka数据同步到OSS</a></p><p><a target="_blank" rel="noopener" href="https://www.aliyun.com/product/bigdata/ide">阿里巴巴大数据治理平台 DataWorks</a></p><ul><li>使用压测工具模拟请求</li><li>交易上下文发布领域事件到Kafka</li><li>使用Datax消费Kafka数据，并同步到OSS对象存储</li><li>使用阿里巴巴 DataWorks 大数据解决方案，OSS作为数据输入源，配置数据形成大数据报表</li></ul><h2 id="ddd和微服务"><a class="markdownIt-Anchor" href="#ddd和微服务"></a> DDD和微服务</h2><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>单体架构开发虽然简单，但是多个上下文都在同一个项目中集成部署，上下文中遇到性能瓶颈非常难以排查。多个上下文共享同一个DB,当业务越来越庞大后，DB面临的读写压力也会越来越大</p><p class="note note-primary">微服务架构的好处</p><ul><li><code>技术异构性</code>：不同的服务可以使用不同的技术栈，甚至使用不同的语言开发</li><li><code>容错性</code>：服务之间的性能问题和故障不会相互影响</li><li><code>灵活扩展</code>：不同服务可以根据业务动态扩缩容</li><li><code>简化部署</code>：大服务拆分成模块化部署</li><li><code>与组织结构匹配</code>：多个开发团队可以同时开发不同的微服务模块</li><li><code>可组合性</code>：多个服务可以组合成新的应用</li><li><code>方便替代和升级</code>：当需要替换或重构某个服务的时候不会牵连其他服务（保证暴露接口的一致性即可）</li></ul><p class="note note-primary">微服务的基础</p><ul><li>服务注册和发现</li><li>服务监控</li><li>熔断降级（高峰期服务节点分配给核心业务，周边服务节点让出资源）</li><li>流量控制</li><li>安全性</li><li>配置管理</li></ul><h3 id="微服务的问题和ddd的答案"><a class="markdownIt-Anchor" href="#微服务的问题和ddd的答案"></a> 微服务的问题和DDD的答案</h3><p class="note note-primary">服务划分</p><p><a href="#%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87">如何划分限界上下文</a></p><p>服务划分一直是微服务落地一个比较具有争议性的问题，服务划分的边界和粒度按照不同的理解有不同的划分手段，DDD给出的答案是根据限界上下文划分微服务，每个限界上下文都是一个独立的服务，上下文之间互不影响</p><h3 id="微服务框架基础设施"><a class="markdownIt-Anchor" href="#微服务框架基础设施"></a> 微服务框架基础设施</h3><p>微服务架构的落地需要解决服务治理问题，而服务治理依赖良好的底层方案。当前，微服务的底层方案总的来说可以分为两种：微服务SDK务框架）和服务网格</p><p class="note note-primary">微服务SDK</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1SDK.png" srcset="/img/loading.gif" lazyload alt></p><p>应用程序通过接入SDK来实现服务治理，SDK运行在应用程序的上下文（相同进程），构建后成为应用程序的一部分，常见有实现方式有</p><ul><li>Spring Cloud OpenFeign 打包 jar包暴露服务API</li><li>Dubbo 将服务Interface打包成 jar包暴露服务</li></ul><p>SDK的方式通常伴随代码入侵，当SDK升级不向下兼容时，下游的服务不管是否有业务变更也得被迫升级</p><p class="note note-primary">服务网格</p><p>通过Sidecar模式，用单独的代理进程接管应用程序的网络流量，从而实现服务治理，借助代理进程，可以实现服务的流量控制（访问权限控制流、熔断等等）、服务发现、负载均衡等等服务治理相关功能</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Istio%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC.png" srcset="/img/loading.gif" lazyload alt></p><p>Istio 服务网格从逻辑上分为<strong>数据平面</strong>和<strong>控制平面</strong>。</p><ul><li><strong>数据平面</strong> 由一组智能代理（<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/">Envoy</a>）组成，被部署为 Sidecar。这些代理负责协调和控制微服务之间的所有网络通信。它们还收集和报告所有网格流量的遥测数据。</li><li><strong>控制平面</strong> 管理并配置代理来进行流量路由</li></ul><p><a target="_blank" rel="noopener" href="https://istio.io/latest/zh/docs/ops/deployment/architecture/">Istio</a></p><p><a target="_blank" rel="noopener" href="https://istio.io/v1.2/zh/docs/concepts/what-is-istio/">Istio组件</a></p><p><a target="_blank" rel="noopener" href="https://istio.io/latest/zh/docs/tasks/observability/kiali/">网格可视化</a></p><p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/701239.html">微服务框架的选择</a></p><p class="note note-primary">服务发现对比</p><p>SpringCloud</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/springCloud%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1.png" srcset="/img/loading.gif" lazyload alt></p><p>Istio</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/Istio%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://ifeve.com/load-balancing/">Istio 服务发现与负载</a></p><h3 id="基于ddd思想进行服务拆分"><a class="markdownIt-Anchor" href="#基于ddd思想进行服务拆分"></a> 基于DDD思想进行服务拆分</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services">smartrm-micro-services</a></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%85%A8%E5%B1%80%E6%A1%86%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt></p><p>使用限界上下文拆分服务</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">领域事件改造</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-infracore/src/main/java/com/smartrm/infracore/event/DomainEvent.java">DomainEvent</a>：领域事件接口，微服务不再使用Spring自定义事件</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-infracore/src/main/java/com/smartrm/infracore/event/DomainEventBus.java">DomainEventBus</a>：时间总线接口，用于发布事件， 队列名称就是事件类名</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-infracore/src/main/java/com/smartrm/infracore/event/impl/SimpleEventBusImpl.java">SimpleEventBusImpl</a>：消息总线实现，底层使用Kafka发布事件</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-infracore/src/main/java/com/smartrm/infracore/event/DomainEventHandler.java">DomainEventHandler</a>：事件处理器接口</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-infracore/src/main/java/com/smartrm/infracore/event/DomainEventListener.java">DomainEventListener</a>：领域事件监听器，其底层主要是kafkaConsumer，利用构造函数传入的事件类型和Handler监听和处理事件</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-infracore/src/main/java/com/smartrm/infracore/event/DomainEventListenerAppRunner.java">DomainEventListenerAppRunner</a>：Kafka配置</p><p class="note note-primary">交易上下文微服务改造</p><p>因为交易上下文和其他上下文交互最多，因此选择交易上下文作为例子</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E4%BA%A4%E6%98%93%E4%B8%8A%E4%B8%8B%E6%96%87.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt></p><p>涉及到跨领域调用的需要在交易服务添加一个共享层。共享模型可以考虑抽取公共jar包或者放在共享内核（弊端是可能会导致共享内核频繁升级）</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-trade/src/main/java/com/smartrm/smartrmtrade/trade/application/AppTradeService.java">AppTradeService</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> PaymentQrCode <span class="hljs-title function_">selectCommodity</span><span class="hljs-params">(SelectCommodityCmdDto cmd)</span> &#123;<br>  <span class="hljs-type">SlotVendingMachine</span> <span class="hljs-variable">machine</span> <span class="hljs-operator">=</span> machineRepository.getSlotVendingMachineById(cmd.getMachineId());<br>  <span class="hljs-keyword">if</span> (machine == <span class="hljs-literal">null</span>) &#123;<br>    LOGGER.warn(<span class="hljs-string">&quot;vending machine not found:&#123;&#125;&quot;</span>, cmd.getMachineId());<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(TradeError.VendingMachineNotFound);<br>  &#125;<br><br>  <span class="hljs-comment">// 远程服务调用，接口订单在领域层，实现在适配层，因为需要进行Dto到本领域实体的转换</span><br>  <span class="hljs-type">CommodityInfo</span> <span class="hljs-variable">commodityInfo</span> <span class="hljs-operator">=</span> commodityService.getCommodityDetail(cmd.getCommodityId());<br>  <span class="hljs-keyword">if</span> (commodityInfo == <span class="hljs-literal">null</span>) &#123;<br>    LOGGER.warn(<span class="hljs-string">&quot;commodity not exist:&#123;&#125;&quot;</span>, cmd.getCommodityId());<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(TradeError.CommodityNotExist);<br>  &#125;<br>  <span class="hljs-type">StockedCommodity</span> <span class="hljs-variable">commodity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StockedCommodity</span>(<br>      commodityInfo.getCommodityId(),<br>      commodityInfo.getCommodityName(),<br>      commodityInfo.getImageUrl(),<br>      commodityInfo.getPrice(),<br>      <span class="hljs-number">1</span><br>  );<br>  <span class="hljs-type">PaymentQrCode</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> machine<br>      .selectCommodity(Lists.newArrayList(commodity), deviceService, payService,<br>          cmd.getPlatformType());<br>  Map&lt;String, Object&gt; params = Maps.newHashMap();<br>  params.put(<span class="hljs-string">&quot;orderId&quot;</span>, machine.getCurOrder().getOrderId());<br>  params.put(<span class="hljs-string">&quot;machineId&quot;</span>, machine.getMachineId());<br>  scheduler.scheduleRetry(TradeExpireExecutor.class, params, <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> code;<br>&#125;<br></code></pre></td></tr></table></figure><p>应用层使用远程服务调用商品信息，远程服务调用底层使用的是RestTemplate</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-trade/src/main/java/com/smartrm/smartrmtrade/trade/adapter/remote/RestTemplateConfig.java">RestTemplateConfig</a>：RestTemplate配置类</p><p><a target="_blank" rel="noopener" href="https://gitee.com/-/ide/project/kenful/smartrm/edit/master/-/smartrm-micro-services/smartrm-trade/src/main/java/com/smartrm/smartrmtrade/trade/adapter/remote/TradeCommodityServiceImpl.java">TradeCommodityServiceImpl</a>：商品远程服务调用实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> RestTemplate commodityRestTemplate;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> CommodityInfo <span class="hljs-title function_">getCommodityDetail</span><span class="hljs-params">(String commodityId)</span> &#123;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/detail/&quot;</span> + commodityId;<br>   ParameterizedTypeReference&lt;CommonResponse&lt;CommodityInfoDto&gt;&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParameterizedTypeReference</span>&lt;CommonResponse&lt;CommodityInfoDto&gt;&gt;() &#123;<br>   &#125;;<br>   ResponseEntity&lt;CommonResponse&lt;CommodityInfoDto&gt;&gt; response = commodityRestTemplate<br>       .exchange(path, HttpMethod.GET, <span class="hljs-literal">null</span>, reference);<br>   <span class="hljs-keyword">if</span> (!response.getStatusCode().is2xxSuccessful()) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(CommonError.UnExpected)<br>         .withMsg(response.getStatusCode().toString());<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.getBody().getCode() != CommonError.NoError.getCode()) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DomainException</span>(CommonError.UnExpected).withMsg(response.getBody().getMsg());<br>   &#125;<br>   <span class="hljs-comment">// Dto和领域实体转换  </span><br>   <span class="hljs-type">CommodityInfoDto</span> <span class="hljs-variable">dto</span> <span class="hljs-operator">=</span> response.getBody().getData();<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommodityInfo</span>(dto.getCommodityId(), dto.getCommodityName(), dto.getImageUrl(),<br>       dto.getPrice());<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>改造好后的微服务架构图</p><h3 id="k8s容器编排"><a class="markdownIt-Anchor" href="#k8s容器编排"></a> k8s容器编排</h3><ul><li>Kubernetes是容器集群管理系统，是一个开源的平台</li><li>硬件资源管理调度、应用部署的事实标准</li><li>业务架构师需要懂运维架构</li></ul><p class="note note-primary">K8S架构原理</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/K8S%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/406369532">K8S 服务类型</a></p><p>Kubernetes集群由一个Master节点（为了高可用也可以使用多Master互为备份）和多个Worker节点构成</p><p>​	Master节点中主要包含三个组件：API Server、Scheduler、Controller。其中API Server负责对集群内外提供集群信息的restful接口，从etcd读据；Controller是集群的管理控制组件，负责感知和调整集群状态，根据用户的请求控制集群，Controller包含多种不同的Controller，如ReplicationController，Node Controller等等，分别执行集群中不同方面的管理工作；Scheduler是调度器，负责为应用的Pod分配部署的Worker节点</p><p>​	Worker节点主要由两部分构成：kubelet 和 kube-proxy。kubelet主要负责Worker节点上的容器管理，它会向Master汇报当前节点的状态信息，从Master节点获取和执行指令，对节点上Pod的生命周期进行管理，使节点的状态向目标状态靠拢；kube-proxy则负责节点上的网络管理，负责消息的路由转发（确切说是负责相应路由规则的配置）</p><h3 id="服务网格"><a class="markdownIt-Anchor" href="#服务网格"></a> 服务网格</h3><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" srcset="/img/loading.gif" lazyload alt></p><p>Istio核心组件</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E9%93%BE%E8%B7%AF%E8%B0%83%E7%94%A8%E8%B7%9F%E8%B8%AA.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>Trace:整个调用链</li><li>Span:某个服务调用</li></ul><p>链路调用跟踪的核心是在每个请求中生成一个TraceID,当A服务调用B服务调用C服务将TraceID向下传递(其实就是埋点)，最终达到全链路跟踪目的</p><p>常用开源的组件有 <code>zipkin</code>和<code>SkyWalking</code></p><h2 id="实践中的问题和关键"><a class="markdownIt-Anchor" href="#实践中的问题和关键"></a> 实践中的问题和关键</h2><h3 id="持续集成"><a class="markdownIt-Anchor" href="#持续集成"></a> 持续集成</h3><p class="note note-primary">什么是CI/CD</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%89%8D.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%B0%E7%8A%B6.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>CI(持续集成)<br>通过自动化流程持续把各个开发者的工作集成到一起避免过大的集成成本</li><li>CD(持续交付)<br>通过自动化测试和部署流程使软件系统随时处于可发布状态</li></ul><p>CI/CD也是微服务的重要基础</p><p>持续集成工具对比：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7044057207704387598">Flow vs Jenkins</a></p><p class="note note-primary">CI/CD核心</p><ul><li>单元测试：代码覆盖率（尽量代码覆盖）</li><li>集成测试：上下文边界</li><li>功能测试</li><li>回归测试</li></ul><p>所有的测试工作尽可能通过代码自动进行</p><h3 id="领域沟通和建模避免漏掉重要细节"><a class="markdownIt-Anchor" href="#领域沟通和建模避免漏掉重要细节"></a> 领域沟通和建模避免漏掉重要细节</h3><p class="note note-primary">深层模型</p><p>若开发人员识别出设计中隐含的某个概念或是在讨论中受到启发而发现一个概念时，就会对领域模型和相应的代码进行许多转换，在模型中加入一个或多个对象或关系，从而将此概念显式地表达出来。有时这种从隐式概念到显式概念的转换可能是一次突破，使我们得到一个深层模型</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E6%9F%9C%E9%97%A8%E6%9C%BA%E5%85%8D%E5%AF%86%E8%B4%AD%E7%89%A9.png" srcset="/img/loading.gif" lazyload alt></p><p>在之前的篇章中，我们和领域专家在谈话的过程中使用领域叙事构建了上图柜门及免密购物的模型，在整个谈话的过程中，我们都是围绕用户的行为在做一系列讨论，整个过程很顺畅，没有什么问题，但是和下图我们最终建立起的模型后发现有很大的区别</p><p><img src="/2022/12/21/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/%E8%B4%A7%E6%9F%9C%E6%9C%BA%E5%85%8D%E5%AF%86%E8%B4%AD%E7%89%A9.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">我们漏掉了一个很重要的实体<code>账号</code>，导致漏掉了整个用户上下文，在前期和领域专家的谈话过程中，我们根本就没有发现用户这个实体，因为在领域专家或业务专家的眼里是看不到用户这个概念的，他们只能看到用户拿着手机在购物，以及用户和微信的交互，他们可能不清楚免密支付是需要用户签署支付协议，下单支付时需要依赖用户实体的（技术层面）。</span>所以在谈话过程中就没有出现账号这个词，但是在我们的系统实现过程中，是离不开用户这个对象的。首先遇到的问题就是判断用户是否要打开柜门这个权限，并且其他子域中可能对用户上下文也有依赖，比如运营域要对用户进行深入分析…</p><p class="note note-primary">原因</p><ul><li>以活动作为建模的核心，模型过于偏向业务</li><li>漏掉重要分支</li><li>复杂系统难免漏掉细节</li></ul><p class="note note-primary">应对方法</p><ul><li>不要单纯以角色的行为(活动)为中心进行沟通和建模</li><li>领域沟通过程中，研发人员发挥主动性</li><li>场景走查</li></ul><p>建模是一个不断完善自我修复的过程，建模完成后不是一成不变的</p><h3 id="ddd的争论和局限性"><a class="markdownIt-Anchor" href="#ddd的争论和局限性"></a> DDD的争论和局限性</h3><p class="note note-primary">资源库与领域服务的区别</p><ul><li>资源库：负责实体发的读写逻辑</li><li>领域服务：负责处理业务逻辑</li></ul><p class="note note-primary">DDD是否过度设计</p><p>“按照DDD写代码的话似乎对编码的要求与系统理解更复杂了，一个业务是由多个领域对象同时分担处理，要是此时项目紧急加人进来做新业务，完全无法了解这些领域对象究竟具体提供了哪些服务，有一种系统被过度设计的感觉。”</p><ul><li>DDD落地到业务逻辑简单，性能要求高的系统</li><li>模型问题，DDD就是根据需求建立通用语言后设计的模型，领域专家和技术专家应该能够理解领域对象</li></ul><p>DDD的出现只是辅助复杂系统的分析和设计，并不是解决所有代码结构问题</p><p class="note note-primary">战略设计和战术设计</p><p>DDD就是一套方法论，一个作用是用于拉齐项目中各个角色对于需求的认知，高效率的让项目中涉及的”知识”在团队内流转，这个是战略设计的作用，另一个作用就是将战略设计划分的领域模型，通过使用战术设计的各种“武器”，比如实体，值对象，仓储层，防腐层等等，将领域模型落地成高度抽象且领域层稳定的代码</p><p class="note note-primary">DDD是否被神化</p><p>《领域驱动设计 软件核心复杂性应对之道》书名已经给出了答案，觉得DDD被神化之前，首先需要有一个概念，什么事复杂系统？一个由几个微服务组成的系统算复杂系统吗？ 个人认为，觉得DDD被神化可能有一个原因是拿DDD和目前正在进行的项目进行模拟落地对比。要知道，DDD不是一套通用的方法论，他提供的是一套面向复杂系统指导和设计的方法论。我们可以向淘宝，京东看齐，他们的电商系统有多少个类？面对这样庞大的复杂系统，DDD能够做的是指导架构设计合理化，以便架构能够适应业务的落地和变化，降低架构设计失误的风险（前几年有多少借着微服务的风口重构了不适应业务变化的系统？），这才是大厂核心部门要推行DDD的原因。所以觉得DDD被神化需要看到的它对复杂系统架构的指导意义，不要盲目拿DDD和现有系统进行落地比较</p><p class="note note-primary">DDD是一套不完善的方法论</p><p>DDD其实是一套由工程师梳理出来的方法论和模式（聚合，聚合根，值对象），它指导了复杂系统的分析和设计，贴合业务建模是它的侧重点（建立通用语言，战略设计）。但是它在对理论落地的性能方面并没有相关指导，比如聚合根的读写效率（一个庞大的聚合根的读写可能最后会是压垮DB的最后一根稻草）。因此DDD寻找的是一种贴合业务（对象使用领域实体命名），便于业务理解的建模和代码落地方法论。落地DDD性能调优也将会是一个大的挑战</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>DDD领域驱动设计</div><div>https://wugengfeng.cn/2022/12/21/DDD领域驱动设计/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年12月21日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/04/14/MongoDB/" title="MongoDB"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MongoDB</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/11/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" title="响应式编程"><span class="hidden-mobile">响应式编程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>