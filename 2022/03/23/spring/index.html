<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="spring核心类分析 ​	要想读懂spring源码就需要知道spring核心类的脉络，及核心类的作用。先有核心类的脉络体系知识后，带着脉络看源码调用流程事半功倍   ApplicationContext    ​	ApplicationContext接口代表了Spring Ioc容器，它负责实例化、配置、组装bean。容器通过读取配置元数据获取对象的实例化、配置和组装的描述信息  ​	Spri"><meta property="og:type" content="article"><meta property="og:title" content="spring"><meta property="og:url" content="https://wugengfeng.cn/2022/03/23/spring/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="spring核心类分析 ​	要想读懂spring源码就需要知道spring核心类的脉络，及核心类的作用。先有核心类的脉络体系知识后，带着脉络看源码调用流程事半功倍   ApplicationContext    ​	ApplicationContext接口代表了Spring Ioc容器，它负责实例化、配置、组装bean。容器通过读取配置元数据获取对象的实例化、配置和组装的描述信息  ​	Spri"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/spring.png"><meta property="article:published_time" content="2022-03-23T15:11:21.000Z"><meta property="article:modified_time" content="2023-07-14T06:49:17.938Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/spring.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>spring - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="spring"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-03-23 23:11" pubdate>2022年3月23日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 31k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 257 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">spring</h1><div class="markdown-body"><h2 id="spring核心类分析"><a class="markdownIt-Anchor" href="#spring核心类分析"></a> spring核心类分析</h2><p>​	要想读懂spring源码就需要知道spring核心类的脉络，及核心类的作用。先有核心类的脉络体系知识后，带着脉络看源码调用流程事半功倍</p><br><h3 id="applicationcontext"><a class="markdownIt-Anchor" href="#applicationcontext"></a> ApplicationContext</h3><blockquote><p><img src="/2022/03/23/spring/Application%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="Application类图"></p><br><p>​	<strong><code>ApplicationContext</code>接口代表了Spring Ioc容器，它负责实例化、配置、组装bean</strong>。容器通过读取配置元数据获取对象的实例化、配置和组装的描述信息</p><br><p>​	Spring提供几个开箱即用的<code>ApplicationContext</code>接口的实现类</p><ul><li><p><code>ClassPathXmlApplicationContext</code></p><ul><li><p>从classpath的XML配置文件中读取上下文</p></li><li><p>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p></li></ul></li><li><p><code>FileSystemXmlApplicationContext</code></p><ul><li>由文件系统中的XML配置文件读取上下文</li><li>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</li></ul></li><li><p><code>XmlWebApplicationContext</code></p><ul><li>由Web应用的XML文件读取上下文</li></ul></li><li><p><code>AnnotationConfigApplicationContext</code></p><ul><li>spring boot使用的基于注解的上下文</li></ul></li></ul></blockquote><br><h3 id="beanfactory-和-applicationcontext"><a class="markdownIt-Anchor" href="#beanfactory-和-applicationcontext"></a> BeanFactory 和 ApplicationContext</h3><blockquote><p><strong>尽量使用ApplicationContext除非你有更好的理由不用它</strong></p><p><strong>因为ApplicationContext包括了BeanFactory的所有功能</strong>，通常也优于BeanFactory,除非一些少数的场景，例如：在受资源约束的嵌入式设备上运行一个嵌入式应用，它的内存消耗可能至关重要，并且可能会产生字节。然而，对于大多数典型的企业级应用和系统来说，ApplicationContext才是你想使用的。<strong>Spring大量使用了BeanPostProcessor扩展点</strong>（以便使用代理等）。如果你仅仅只使用简单的BeanFactory，很多的支持功能将不会有效，例如：事务和AOP，但至少不会有额外的步骤。这可能会比较迷惑，毕竟配置又没有错。</p><table><thead><tr><th style="text-align:left">Feature</th><th style="text-align:left">BeanFactory</th><th style="text-align:left">ApplicationContext</th></tr></thead><tbody><tr><td style="text-align:left">Bean实例化/装配</td><td style="text-align:left">是</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">BeanPostProcessor自动注册</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">BeanFactoryPostProcessor自动注册</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">MessageSource便捷访问（针对i18n）</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">ApplicationEvent 发布</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr></tbody></table><br><p><strong>区别</strong>：</p><p>BeanFactory提供了ioc容器的基本功能，主要负责bean的实例化和装配，ApplicationContext代表了spring ioc容器，ApplicationContext继承于BeanFactory包含BeanFactory的所有功能，并且还提供了BeanPostProcessor，ApplicationEvent等功能，比BeanFaction功能更加强大</p></blockquote><br><h3 id="annotationconfigapplicationcontext"><a class="markdownIt-Anchor" href="#annotationconfigapplicationcontext"></a> AnnotationConfigApplicationContext</h3><p><img src="/2022/03/23/spring/AnnotationConfigApplicationContext.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>AnnotationConfigApplicationContext</strong>，在 Spring 3.0 中 是 新加入的,从此spring进入注解配置时代，支持注解配置</p><ul><li><p>@Configuration</p></li><li><p>@Bean</p></li><li><p>@Component</p></li><li><p>@Autowired</p><p>…</p></li></ul><p>从类图结构中看出，<code>AbstractApplicationContext</code>是所有开箱即用的<code>ApplicationContext</code>接口的实现类的中枢，图中出现另一个重要spring顶级接口体系<code>AliasRegistry (别名注册表)</code>及它的子接口<code>BeanDefinitionRegistry (Bean 定义注册表)</code></p></blockquote><br><h3 id="注册表体系"><a class="markdownIt-Anchor" href="#注册表体系"></a> 注册表体系</h3><p><img src="/2022/03/23/spring/%E6%B3%A8%E5%86%8C%E8%A1%A8%E4%BD%93%E7%B3%BB.jpg" srcset="/img/loading.gif" lazyload alt></p><p><strong>注册表体系主要提供了bean别名注册，单例bean注册，bean循环依赖三级缓存</strong></p><h4 id="aliasregistry"><a class="markdownIt-Anchor" href="#aliasregistry"></a> AliasRegistry</h4><blockquote><p><img src="/2022/03/23/spring/AliasRegistry.jpg" srcset="/img/loading.gif" lazyload alt></p><p>bean别名注册表，作为bean定义的最顶层接口，这个接口定义了管理别名的一些方法，主要作用是将名字-别名映射存到内存中。提供查找和校验的接口</p><ul><li>registerAlias 注册一个bean的别名</li><li>removeAlias 删除注册的别名</li><li>isAlias 确定一个名字是否是别名</li><li>getAliases 返回一个名字注册的别名列表。当传入bean的名称带有<code>&amp;</code>前缀时，转换为别名后也会返回带<code>&amp;</code>前缀的别名，这种特殊处理参考<a href="#beanfactory">BeanFactory#FACTORY_BEAN_PREFIX</a></li></ul></blockquote><br><h4 id="beandefinition"><a class="markdownIt-Anchor" href="#beandefinition"></a> BeanDefinition</h4><blockquote><p><img src="/2022/03/23/spring/BeanDefinition.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/23/spring/BeanDefinition%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt></p><p><strong>在了解<code>BeanDefinitionRegistry (Bean 定义注册表)</code>之前必须知道<code>BeanDefinition</code>是什么</strong></p><p>在 Spring 容器中，我们广泛使用的是一个一个的 Bean，BeanDefinition（接口） 从名字上就可以看出是关于 Bean 的定义</p><p>事实上就是这样，我们在 XML 文件中，java配置类中配置的 Bean 的各种属性，这些属性不仅仅是和对象相关，Spring 容器还要解决 Bean 的生命周期、销毁、初始化等等各种操作，我们定义的关于 Bean 的生命周期、销毁、初始化等操作总得有一个对象来承载，那么这个对象就是 BeanDefinition的实现类。文章后续会讲到spring如何将bean的配置转成<code>BeanDefinition</code>,又是如何使用<code>BeanDefinitionRegistryPostProcessor</code>后置处理器使用<code>BeanDefinition</code>对bean进行注册流程</p><br><ol><li>首先一开始定义了两个变量用来描述 Bean 是不是单例的，后面的 setScope/getScope 方法可以用来修改/获取 scope 属性。</li><li>ROLE_xxx 用来描述一个 Bean 的角色，ROLE_APPLICATION 表示这个 Bean 是用户自己定义的 Bean；ROLE_SUPPORT 表示这个 Bean 是某些复杂配置的支撑部分；ROLE_INFRASTRUCTURE 表示这是一个 Spring 内部的 Bean，通过 setRole/getRole 可以修改。</li><li>setParentName/getParentName 用来配置 parent 的名称，这块可能有的小伙伴使用较少，这个对应着 XML 中的 <code>&lt;bean parent=&quot;&quot;&gt;</code> 配置。</li><li>setBeanClassName/getBeanClassName 这个就是配置 Bean 的 Class 全路径，对应 XML 中的 <code>&lt;bean class=&quot;&quot;&gt;</code> 配置。</li><li>setLazyInit/isLazyInit 配置/获取 Bean 是否懒加载，这个对应了 XML 中的 <code>&lt;bean lazy-init=&quot;&quot;&gt;</code> 配置。</li><li>setDependsOn/getDependsOn 配置/获取 Bean 的依赖对象，这个对应了 XML 中的 <code>&lt;bean depends-on=&quot;&quot;&gt;</code> 配置。</li><li>setAutowireCandidate/isAutowireCandidate 配置/获取 Bean 是否是自动装配，对应了 XML 中的 <code>&lt;bean autowire-candidate=&quot;&quot;&gt;</code> 配置。</li><li>setPrimary/isPrimary 配置/获取当前 Bean 是否为首选的 Bean，对应了 XML 中的 <code>&lt;bean primary=&quot;&quot;&gt;</code> 配置。</li><li>setFactoryBeanName/getFactoryBeanName 配置/获取 FactoryBean 的名字，对应了 XML 中的 <code>&lt;bean factory-bean=&quot;&quot;&gt;</code> 配置，factory-bean 松哥在之前的入门视频中讲过，小伙伴们可以参考这里:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Wv41167TU%E3%80%82">https://www.bilibili.com/video/BV1Wv41167TU。</a></li><li>setFactoryMethodName/getFactoryMethodName 和上一条成对出现的，对应了 XML 中的 <code>&lt;bean factory-method=&quot;&quot;&gt;</code> 配置，不再赘述。</li><li>getConstructorArgumentValues 返回该 Bean 构造方法的参数值。</li><li>hasConstructorArgumentValues 判断上一条是否是空对象。</li><li>getPropertyValues 这个是获取普通属性的集合。</li><li>hasPropertyValues 判断上一条是否为空对象。</li><li>setInitMethodName/setDestroyMethodName 配置 Bean 的初始化方法、销毁方法。</li><li>setDescription/getDescription 配置/返回 Bean 的描述。</li><li>isSingleton Bean 是否为单例。</li><li>isPrototype Bean 是否为原型。</li><li>isAbstract Bean 是否抽象。</li><li>getResourceDescription 返回定义 Bean 的资源描述。</li><li>getOriginatingBeanDefinition 如果当前 BeanDefinition 是一个代理对象，那么该方法可以用来返回原始的 BeanDefinition</li></ol><br><p><strong>BeanDefinition实现类</strong></p><p><img src="/2022/03/23/spring/BeanDefinition%E5%AE%9E%E7%8E%B0%E7%B1%BB.jpg" srcset="/img/loading.gif" lazyload alt></p></blockquote><br><h4 id="beandefinitionregistry"><a class="markdownIt-Anchor" href="#beandefinitionregistry"></a> BeanDefinitionRegistry</h4><blockquote><p>BeanDefinitionRegistry类图</p><p><img src="/2022/03/23/spring/BeanDefinitionRegistry.jpg" srcset="/img/loading.gif" lazyload alt></p><br><p>​	我们定义bean时不管是通过java config方式，还是xml配置文件的方式，最终都会解析成BeanDefinition，而这些BeanDefinition都需要注册到容器中，这个注册的过程是通过接口org.springframework.beans.factory.support.BeanDefinitionRegistry来定义的，也就是说BeanDefinitionRegistry子类具备注册bean的定义到ioc容器的能力</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;org.springframework.beans.factory.support.BeanDefinitionRegistry<br><br>&gt;<span class="hljs-comment">// 定义bean定义的注册相关方法的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AliasRegistry</span> &#123;<br><br>	<span class="hljs-comment">// 在注册中心注册一个bean定义，必须支持RootBeanDefinition和ChildBeanDefinition</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span><br>			<span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>	<span class="hljs-comment">// 移除对应bean名称的bean定义</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>	<span class="hljs-comment">// 返回给定bean名称对应的bean定义</span><br>	BeanDefinition <span class="hljs-title function_">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>	<span class="hljs-comment">// 检查注册中心是否包含指定名称的bean定义</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span>;<br><br>	<span class="hljs-comment">// 返回注册中心中所有的bean定义的名称的数组</span><br>	String[] getBeanDefinitionNames();<br><br>	<span class="hljs-comment">// 返回注册中心中bean定义的个数</span><br>	<span class="hljs-type">int</span> <span class="hljs-title function_">getBeanDefinitionCount</span><span class="hljs-params">()</span>;<br><br>	<span class="hljs-comment">// 返回beanName是否被占用，即已经在注册中心中注册了bean定义</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>bean注册的流程</strong></p><pre class="mermaid">sequenceDiagram
后置处理器 ->> 扫描配置 : xml、java config
扫描配置 ->> BeanDefinition : 解析生成bean定义对象
BeanDefinition ->> DefaultListableBeanFactory : BeanDefinition注册
DefaultListableBeanFactory ->> DefaultSingletonBeanRegistry : 单例bean实例化注册到ioc容器</pre><br><h4 id="singletonbeanregistry"><a class="markdownIt-Anchor" href="#singletonbeanregistry"></a> SingletonBeanRegistry</h4><blockquote><p><img src="/2022/03/23/spring/SingletonBeanRegistry.jpg" srcset="/img/loading.gif" lazyload alt></p><p>单例bean注册表接口，这个是单例bean注册的顶级接口，主要是用于管理单例的注册、获取</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SingletonBeanRegistry</span> &#123;<br><br>    <span class="hljs-comment">//  以指定的名字  把Object放进去</span><br>    <span class="hljs-comment">// 1、给定的Object必须是被完全初始化了的(比如new出来的)</span><br>    <span class="hljs-comment">// 2、此注册接口不会提供任何用以初始化的回调函数(比如：InitializingBean、afterPropertiesSet都是不会执行的)</span><br>    <span class="hljs-comment">// 3、如果此接口的实现类是一个BeanFactory，最好最好最好将你的类注册成Bean Definition而不是直接使用对象(这样就可以使你定义的Bean收到initialization和destruction回调)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span>;<br><br>    <span class="hljs-comment">// 仅仅返回已经初始化完成的Bean，对于还没有初始化的Bean Definition不予以考虑</span><br>    <span class="hljs-comment">// 但是要注意，此方法**并不支持使用别名**对Bean进行查找，如果只有别名的话，要先通过BeanFactory的接口获取到Bean对应的全限定名称（transformedBeanName()）</span><br>    Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span>;<br><br>    <span class="hljs-comment">// 检查此实例是否包含指定名字的并且！！！已经初始化完成的单例Bean（不支持别名查找）</span><br>    <span class="hljs-comment">// BeanFactory#containsBean是containsSingleton(beanName) || containsBeanDefinition(beanName)</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsSingleton</span><span class="hljs-params">(String beanName)</span>;<br><br>    <span class="hljs-comment">// 返回所有单例 Bean 的名称</span><br>    String[] getSingletonNames();<br><br>    <span class="hljs-comment">// 返回已注册的单例 Bean 实例数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getSingletonCount</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 返回当前使用的单例锁，主要提供给外部协作者使用</span><br>    Object <span class="hljs-title function_">getSingletonMutex</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="defaultsingletonbeanregistry"><a class="markdownIt-Anchor" href="#defaultsingletonbeanregistry"></a> *DefaultSingletonBeanRegistry</h4><p><img src="/2022/03/23/spring/DefaultSingletonBeanRegistry_UML.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/23/spring/DefaultSingletonBeanRegistry.jpg" srcset="/img/loading.gif" lazyload alt></p><blockquote><p><strong>DefaultSingletonBeanRegistry是整个ioc容器比较核心的类，因为它负责存储、提供单例的bean实例、维护bean之间关系以及维护已经注册的bean的名称</strong></p><ul><li>解决循环依赖的三级缓存,存储单例bean</li><li>注册单例bean</li><li>添加单例bean到ioc容器</li><li>获取单例bean</li></ul></blockquote><p><strong>重要属性说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单例对象的缓存:从beanname到bean实例  一级缓存，存放完整的 Bean</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><span class="hljs-comment">// 单例工厂的缓存:从beanname到ObjectFactory	三级缓存，存放的是 Bean 工厂，主要是生产 Bean，解决循环</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 早期单例对象的缓存:从beanname到bean实例 	二级缓存 解决循环依赖二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 一组已注册的单例，包含按注册顺序排列的beanname</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><span class="hljs-comment">// 正在创建的单例的beanName的集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><span class="hljs-comment">// 当前不检查的bean的集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; inCreationCheckExclusions = Collections.newSetFromMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>));<br><span class="hljs-comment">// 异常集合</span><br><span class="hljs-keyword">private</span> Set&lt;Exception&gt; suppressedExceptions;<br><span class="hljs-comment">// 当前是否在销毁bean中</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">singletonsCurrentlyInDestruction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 具有销毁能力的bean实例，DisposableBean的实现类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; disposableBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><span class="hljs-comment">// 内部bean和外部bean之间关系</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><span class="hljs-comment">// 指定bean与依赖指定bean的集合，比如bcd依赖a，那么就是key为a，bcd为value</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">64</span>);<br><span class="hljs-comment">// 指定bean与指定bean依赖的集合，比如a依赖bcd，那么就是key为a，bcd为value</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">64</span>);<br></code></pre></td></tr></table></figure><br><p><strong>重要方法说明</strong></p><ul><li><p><strong>registerSingleton</strong></p><p>这个是对 <a href="#singletonbeanregistry">SingletonBeanRegistry <em>（此注册方法不会提供任何用以初始化的回调函数）</em></a> 接口方法的实现，<strong>调用这个方法注册bean的一般都是框架自身的bean</strong>，比如spring准备上下文需要的bean <code>StandardServletEnvironment</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> <span class="hljs-keyword">throws</span> IllegalStateException &#123;<br>    Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    Assert.notNull(singletonObject, <span class="hljs-string">&quot;Singleton object must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">oldObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>        <span class="hljs-comment">// 如果缓存有，说明已经注册过</span><br>        <span class="hljs-keyword">if</span> (oldObject != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Could not register object [&quot;</span> + singletonObject +<br>                    <span class="hljs-string">&quot;] under bean name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;: there is already object [&quot;</span> + oldObject + <span class="hljs-string">&quot;] bound&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 缓存没有，开始注册</span><br>        addSingleton(beanName, singletonObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>addSingleton</strong></p><p>单例bean加入到缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">// 加入单例对象的缓存（一级缓存）</span><br>        <span class="hljs-built_in">this</span>.singletonObjects.put(beanName, singletonObject);<br>        <span class="hljs-comment">// 既然加入了单例对象的缓存，那singletonFactories和earlySingletonObjects就不再持有</span><br>        <span class="hljs-comment">// 删除三级级缓存</span><br>        <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>        <span class="hljs-comment">// 删除二级缓存</span><br>        <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>        <span class="hljs-comment">// 加入已注册的bean</span><br>        <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>addSingletonFactory</strong></p><p>添加三级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//增加单例工程的单例，取单例的时候调用getObject方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>    Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br>            <span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br>            <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>            <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectFactory</span>&lt;T&gt; &#123;<br>	T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>getSingleton</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-comment">// 允许早期依赖</span><br>    <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>    <span class="hljs-comment">//如果一级缓存有直接返回</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-comment">//缓存没有的情况但正在创建</span><br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">//如果早期缓存中有，说明正在加载，则不处理直接返回</span><br>            <span class="hljs-comment">//一级缓存拿不到尝试去二级缓存拿</span><br>            singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br>            <span class="hljs-comment">//allowEarlyReference允许是否从singletonFactories读取</span><br>            <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>                <span class="hljs-comment">// 某些方法提前初始化的时候会调用addSingletonFactory，把ObjectFactory缓存在singletonFactories中</span><br>                <span class="hljs-comment">// 二级缓存拿不到到三级缓存拿</span><br>                ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//如果singletonFactories有，调用getObject方法返回</span><br>                    singletonObject = singletonFactory.getObject();<br>                    <span class="hljs-comment">// singletonFactories产生的对象放入earlySingletonObjects中</span><br>                    <span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                    <span class="hljs-comment">// 已经产生过一次对象了，所以就不能再用了，后面直接用earlySingletonObjects获取</span><br>                    <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>    Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">// 已经创建过了，直接返回</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 当前在销毁bean，不能创建</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.singletonsCurrentlyInDestruction) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationNotAllowedException</span>(beanName,<br>                        <span class="hljs-string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +<br>                        <span class="hljs-string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 创建前检查，记录正在加载状态</span><br>            beforeSingletonCreation(beanName);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">newSingleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果当前没有异常，初始化异常集合</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">recordSuppressedExceptions</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.suppressedExceptions == <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过ObjectFactory的getObject创建bean，实际是回调createBean方法</span><br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>                <span class="hljs-comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span><br>                <span class="hljs-comment">// if yes, proceed with it since the exception indicates that state.</span><br>                <span class="hljs-comment">// 有可能是其他方式创建的bean</span><br>                singletonObject = <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                    <span class="hljs-keyword">for</span> (Exception suppressedException : <span class="hljs-built_in">this</span>.suppressedExceptions) &#123;<br>                        ex.addRelatedCause(suppressedException);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                    <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 创建后检查，移除加载状态</span><br>                afterSingletonCreation(beanName);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>                <span class="hljs-comment">// 是新创建的bean，就加入到缓存中并移除其他缓存，如果是其他方式创建的bean，说明已经加入过缓存了，这边不再加入</span><br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singletonObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>removeSingleton</strong></p><p>移除单例bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">// 移除一级缓存</span><br>        <span class="hljs-built_in">this</span>.singletonObjects.remove(beanName);<br>        <span class="hljs-comment">// 移除三级缓存</span><br>        <span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>        <span class="hljs-comment">// 移除二级缓存</span><br>        <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>        <span class="hljs-comment">// 移除已注册的beanName名单</span><br>        <span class="hljs-built_in">this</span>.registeredSingletons.remove(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>beforeSingletonCreation</strong></p><p>创建单例bean之前的检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-comment">// 如果这个beanName要检查，看看add的时候返回什么，如果返回false，说明已经在创建了，抛异常</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>afterSingletonCreation</strong></p><p>创建单例bean之后的检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonCreation</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-comment">// 如果这个beanName要检查，看看remove返回什么，如果返回false，说明已经创建完了。</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-built_in">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Singleton &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; isn&#x27;t currently in creation&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>registerDisposableBean</strong></p><p>注册具有销毁业务的bean，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDisposableBean</span><span class="hljs-params">(String beanName, DisposableBean bean)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.disposableBeans) &#123;<br>        <span class="hljs-built_in">this</span>.disposableBeans.put(beanName, bean);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DisposableBean</span> &#123;<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><br><h3 id="beanfactory体系"><a class="markdownIt-Anchor" href="#beanfactory体系"></a> BeanFactory体系</h3><h4 id="beanfactory"><a class="markdownIt-Anchor" href="#beanfactory"></a> BeanFactory</h4><ul><li><p><strong>BeanFactory为Spring的IoC功能提供了底层的基础</strong>，但是它仅仅被用于和第三方框架的集成，现在对于大部分的Spring用户来说都是历史了。BeanFactory及其相关的接口，例如：BeanFactoryAware，InitializingBean，DisposableBean，在Spring中仍然有所保留，目的就是为了让大量的第三方框架和Spring集成时保持向后兼容</p></li><li><p><strong>BeanFactory和类加载器一样，也是有父BeanFactory的，具体体现在<a href="#hierarchicalbeanfactory">HierarchicalBeanFactory</a>接口</strong></p></li></ul><p><img src="/2022/03/23/spring/BeanFactory%E4%BD%93%E7%B3%BBUML.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/23/spring/BeanFactory%E5%92%8CApplicationContext.jpg" srcset="/img/loading.gif" lazyload alt="BeanFactory和ApplicationContext"></p><br><p><img src="/2022/03/23/spring/BeanFactory.jpg" srcset="/img/loading.gif" lazyload alt="BeanFactory"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;a会得到那个Factory</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">FACTORY_BEAN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 四个不同形式的getBean方法，获取实例</span><br><span class="hljs-comment">     */</span><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBean</span><span class="hljs-params">(String name)</span>; <span class="hljs-comment">// 是否存在</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<span class="hljs-comment">// 是否为单实例</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<span class="hljs-comment">// 是否为原型（多实例）</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; targetType)</span><br>            <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<span class="hljs-comment">// 名称、类型是否匹配</span><br><br>    Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException; <span class="hljs-comment">// 获取类型</span><br><br>    String[] getAliases(String name);<span class="hljs-comment">// 根据实例的名字获取实例的别名</span><br><br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>FACTORY_BEAN_PREFIX`</strong></p><ul><li><code>String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</code></li><li>根据beanName从spring容器获取实例，如果该实例不是FactoryBean类型，则直接返回该实例，这也是我们平时用的最多的、最普通的情况；如果该实例是<strong>FactoryBean类型，而name又是以&amp;开头，也直接返回该实例，说明我们想要的就是FactoryBean实例</strong>；如果name不是以&amp;开头，而该实例又是FactoryBean类型，则会调用该实例的getObject()来创建我们需要的目标实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义UserFactoryBean并使用别名注册</span><br><span class="hljs-meta">@Component(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;User&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 假设User的实例化过程比较复杂，在此处进行User的实例化</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> User.class;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这种写法是获取 UserFactoryBean 实例</span><br>applicationContext.getBean(BeanFactory.FACTORY_BEAN_PREFIX + <span class="hljs-string">&quot;user&quot;</span>);<br><br><span class="hljs-comment">// 这种写法是获取 User实例</span><br>applicationContext.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br></code></pre></td></tr></table></figure><br><h4 id="autowirecapablebeanfactory"><a class="markdownIt-Anchor" href="#autowirecapablebeanfactory"></a> *AutowireCapableBeanFactory</h4><p><strong><font color="red">定义BeanFactory自动装配接口</font></strong></p><ul><li>对于想拥有<strong>自动装配能力</strong>，并且想要把这种能力暴露给外部应用的beanfactory需要实现该接口</li><li>正常情况下，不要实现该接口，应该实现BeanFactory或者ListableBeanFactory接口</li><li>需要注意的是ApplicationContext并没实现该接口。如果需要用到自动装配功能的话，可以调用ApplicationContext.getAutowireCapableBeanFactory()方法，来获取此接口实例</li><li>如果一个接口实现了该接口，很大程度上，还要实现BeanFactoryWare接口，这样子就能在上下文中返回BeanFactory</li></ul><p><img src="/2022/03/23/spring/AutowireCapableBeanFactory.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AutowireCapableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br><br>    <span class="hljs-comment">//变量指明工厂没有自动装配的bean</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">AUTOWIRE_NO</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//根据名称自动装配</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">AUTOWIRE_BY_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//根据类型自动装配</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">AUTOWIRE_BY_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">//标识按照贪婪策略匹配出的最符合的构造方法来自动装配的常量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">AUTOWIRE_CONSTRUCTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <br>    <span class="hljs-comment">//根据bean的class内部自动装配，但是Spring3.0后被弃用</span><br>    <span class="hljs-comment">//先使用constructor进行装配，如果不成功就使用byType来装配</span><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">AUTOWIRE_AUTODETECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br><br>    <br><br>     <span class="hljs-comment">//参数：bean的class类型</span><br>     <span class="hljs-comment">//返回：bean的实例</span><br>     <span class="hljs-comment">//功能：根据bean的class类型，创建对应的bean实例</span><br>    &lt;T&gt; T <span class="hljs-title function_">createBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br><br>    <span class="hljs-comment">//使用autowireBeanProperties装配属性</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">autowireBean</span><span class="hljs-params">(Object existingBean)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//自动装配属性</span><br>    Object <span class="hljs-title function_">configureBean</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br><br>    <span class="hljs-comment">//-------------------------------------------------------------------------</span><br>    <span class="hljs-comment">// Specialized methods for fine-grained control over the bean lifecycle</span><br>    <span class="hljs-comment">//-------------------------------------------------------------------------</span><br>    <span class="hljs-comment">//对bean的生命周期进行细粒度控制的专门方法</span><br>    <br>    <span class="hljs-comment">//执行完整的bean初始化（包括：initializedBean和BeanPostProcessors）</span><br>    <span class="hljs-comment">//autowireMode：根据名字或类型来决定自动装配的方式</span><br>    Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-type">int</span> autowireMode, <span class="hljs-type">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//根据bean的类型和自动装配方式来自动装配</span><br>    Object <span class="hljs-title function_">autowire</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-type">int</span> autowireMode, <span class="hljs-type">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//根据自动装配方式来装配bean的属性</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">autowireBeanProperties</span><span class="hljs-params">(Object existingBean, <span class="hljs-type">int</span> autowireMode, <span class="hljs-type">boolean</span> dependencyCheck)</span><br>            <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//将参数中指定了那么的Bean，注入给定实例当中</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">applyBeanPropertyValues</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//初始化参数中指定的Bean，调用任何其注册的回调函数如setBeanName、setBeanFactory等。</span><br>    Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//调用参数中指定Bean的postProcessBeforeInitialization方法(如果实现了BeanPostProcessor接口)</span><br>    Object <span class="hljs-title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br>            <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//调用参数中指定Bean的postProcessorsAfterInitialization方法(如果实现了BeanPostProcessor接口)</span><br>    Object <span class="hljs-title function_">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span><br>            <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//销毁参数中指定的Bean，同时调用此Bean上的DisposableBean和DestructionAwareBeanPostProcessors方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyBean</span><span class="hljs-params">(Object existingBean)</span>;<br><br><br>    <span class="hljs-comment">//-------------------------------------------------------------------------</span><br>    <span class="hljs-comment">// Delegate methods for resolving injection points</span><br>    <span class="hljs-comment">//-------------------------------------------------------------------------</span><br><br>    <span class="hljs-comment">//销毁参数中指定的bean,同时调用此Bean上的DisposableBean和DestructionAwareBeanPostProcessors方法</span><br>    &lt;T&gt; NamedBeanHolder&lt;T&gt; <span class="hljs-title function_">resolveNamedBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//查找唯一符合指定类的实例，如果有，则返回实例的名字和实例本身</span><br>    Object <span class="hljs-title function_">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, String requestingBeanName)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>    <span class="hljs-comment">//查找唯一符合指定类的实例，如果有，则返回实例的名字和实例本身</span><br>    Object <span class="hljs-title function_">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, String requestingBeanName,</span><br><span class="hljs-params">            Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="listablebeanfactory"><a class="markdownIt-Anchor" href="#listablebeanfactory"></a> ListableBeanFactory</h4><p><strong><font color="red">提供一次性获取当前BeanFactory 所有bean信息能力</font></strong></p><p>​	ListableBeanFactory实现了<a href="#beanfactory">BeanFactory</a>接口， Listable意思是可列表的，ListableBeanFactory可以枚举它们的所有bean信息，而不用一个个通过bean的名称或类型一个个查找 <em>(比如通过bean类型获取所有的bean)</em> 。如果容器是有层级的，比如实现了<a href="#hierarchicalbeanfactory">HierarchicalBeanFactory</a>接口，返回值不考虑层级的信息，只读取当前容器定义的信息</p><p><img src="/2022/03/23/spring/ListableBeanFactory.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br> <br>	<span class="hljs-comment">//判断是否包含指定名称的BeanDefinition</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span>;<br> <br>	<span class="hljs-comment">//获取BeanDefinition的数量</span><br>	<span class="hljs-type">int</span> <span class="hljs-title function_">getBeanDefinitionCount</span><span class="hljs-params">()</span>;<br> <br>	<span class="hljs-comment">//获取所有BeanDefinition的名称</span><br>	String[] getBeanDefinitionNames();<br> <br>	<br>	 <span class="hljs-comment">//获取指定类型的所有Bean的名称,包括子类</span><br>    <span class="hljs-comment">//通过bean 定义或者FactoryBean的getObjectType判断.</span><br>	String[] getBeanNamesForType(Class&lt;?&gt; type);<br> <br>	<span class="hljs-comment">//获取指定类型的所有Bean的名称,包括子类</span><br>    <span class="hljs-comment">//通过bean 定义或者FactoryBean的getObjectType判断.</span><br>    <span class="hljs-comment">//includeNonSingletons 是否只要单例</span><br>    <span class="hljs-comment">//allowEagerInit 是否初始化懒加载的单例,FactoryBean初始化的类和工厂方法初始化的类.就是说执行这个方法会执行对应的初始化.</span><br>	String[] getBeanNamesForType(Class&lt;?&gt; type, <span class="hljs-type">boolean</span> includeNonSingletons, <span class="hljs-type">boolean</span> allowEagerInit);<br> <br>	<span class="hljs-comment">// 根据类型（包括子类）返回指定Bean名和Bean的Map</span><br>	&lt;T&gt; Map&lt;String, T&gt; <span class="hljs-title function_">getBeansOfType</span><span class="hljs-params">(Class&lt;T&gt; type)</span> <span class="hljs-keyword">throws</span> BeansException;<br> <br>	<span class="hljs-comment">//根据类型（包括子类）返回指定Bean名和Bean的Map</span><br>     <span class="hljs-comment">//includeNonSingletons 是否只要单例</span><br>    <span class="hljs-comment">//allowEagerInit 是否初始化懒加载的单例,FactoryBean初始化的类和工厂方法初始化的类.就是说执行这个方法会执行对应的初始化.</span><br>	&lt;T&gt; Map&lt;String, T&gt; <span class="hljs-title function_">getBeansOfType</span><span class="hljs-params">(Class&lt;T&gt; type, <span class="hljs-type">boolean</span> includeNonSingletons, <span class="hljs-type">boolean</span> allowEagerInit)</span><br>			<span class="hljs-keyword">throws</span> BeansException;<br> <br>    <span class="hljs-comment">//获取注解类型的Bean</span><br>    String[] getBeanNamesForAnnotation(Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationType);<br> <br>    <span class="hljs-comment">// 找到使用注解的类</span><br>    <span class="hljs-comment">//并放在指定Bean名和Bean的Map</span><br>	Map&lt;String, Object&gt; <span class="hljs-title function_">getBeansWithAnnotation</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    <br>    <span class="hljs-comment">//查找一个类上的注解,如果找不到,父类,接口使用注解也算.</span><br>	<span class="hljs-comment">// 根据指定Bean名和注解类型查找指定的Bean</span><br>	&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; A <span class="hljs-title function_">findAnnotationOnBean</span><span class="hljs-params">(String beanName, Class&lt;A&gt; annotationType)</span><br>			<span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><br><h4 id="hierarchicalbeanfactory"><a class="markdownIt-Anchor" href="#hierarchicalbeanfactory"></a> HierarchicalBeanFactory</h4><p>HierarchicalBeanFactory<strong>继承BeanFactory并扩展使其支持层级结构</strong> <em>(对BeanFactory提供分层)</em></p><p><img src="/2022/03/23/spring/HierarchicalBeanFactory.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HierarchicalBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br><br>    <span class="hljs-comment">//返回本Bean工厂的父工厂</span><br>    BeanFactory <span class="hljs-title function_">getParentBeanFactory</span><span class="hljs-params">()</span>;<br><br>     <span class="hljs-comment">//判断本地工厂是否包含这个Bean（忽略其他所有父工厂）。这也是分层思想的体现</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsLocalBean</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="configurablebeanfactory"><a class="markdownIt-Anchor" href="#configurablebeanfactory"></a> ConfigurableBeanFactory</h4><p><img src="/2022/03/23/spring/ConfigurableBeanFactory.jpg" srcset="/img/loading.gif" lazyload alt></p><p>​	ConfigurableBeanFactory继承了<a href="#hierarchicalbeanfactory">HierarchicalBeanFactory</a>, <a href="#singletonbeanregistry">SingletonBeanRegistry</a>两个接口。定义了一些对BeanFactory的配置功能，比如通过<strong>addBeanPostProcessor配置Bean后置处理器</strong>，<strong>setParentBeanFactory设置双亲Ioc容器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">SCOPE_SINGLETON</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;singleton&quot;</span>;<span class="hljs-comment">//单例</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">SCOPE_PROTOTYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;prototype&quot;</span>;<span class="hljs-comment">//原型</span><br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置容器的父容器,获取父容器方法在父接口HierarchicalBeanFactory里</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParentBeanFactory</span><span class="hljs-params">(BeanFactory parentBeanFactory)</span> <span class="hljs-keyword">throws</span> IllegalStateException;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置和获取类加载器,主要用于加载Bean,默认是线上上下文的loader</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader beanClassLoader)</span>;<br>   <span class="hljs-meta">@Nullable</span><br>   ClassLoader <span class="hljs-title function_">getBeanClassLoader</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置获取临时类加载器</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTempClassLoader</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader tempClassLoader)</span>;<br>   <span class="hljs-meta">@Nullable</span><br>   ClassLoader <span class="hljs-title function_">getTempClassLoader</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置是否缓存给定BeanDefinition和确定Bean类型的元数据,默认是开启状态.</span><br><span class="hljs-comment">    * 关掉flag缓存会启用beanDefinition对象的热刷新.任何bean实例的创建都将重新查询bean class loader来确定这个Bean最新的类型</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCacheBeanMetadata</span><span class="hljs-params">(<span class="hljs-type">boolean</span> cacheBeanMetadata)</span>;<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCacheBeanMetadata</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 为beanDefinition值中的表达式提供解决策略.默认的BeanFactory里是没有激活的表达式支持的.</span><br><span class="hljs-comment">    * 一个ApplicationContext通常会设置一个标准的表达式策略,以一种统一的EL兼容风格支持“#&#123;&#125;”表达式.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanExpressionResolver</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> BeanExpressionResolver resolver)</span>;<br>   <span class="hljs-meta">@Nullable</span><br>   BeanExpressionResolver <span class="hljs-title function_">getBeanExpressionResolver</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置和获取ConversionService接口,进行数据类型转换</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> conversionService</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConversionService</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ConversionService conversionService)</span>;<br>   <span class="hljs-meta">@Nullable</span><br>   ConversionService <span class="hljs-title function_">getConversionService</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 添加一个PropertyEditorRegistrar应用于所有bean的创建过程.</span><br><span class="hljs-comment">    * 一个Registrar创建了一个新的PropertyEditor实例,并且会将他们注册到一个给定的Registry中,并尝试刷新每个bean的创建.</span><br><span class="hljs-comment">    * 这就避免了自定义Editor的同步应用需求.因此通常更倾向于使用这个方法来代替registerCustomEditor.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">addPropertyEditorRegistrar</span><span class="hljs-params">(PropertyEditorRegistrar registrar)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 为所有给定类型的属性注册一个给定的自定义属性编辑器.通常在factory配置期间被调用.</span><br><span class="hljs-comment">    * 注意这个方法注册一个共享的自定义属性编辑器实例;为了线程安全,需要授权该实例去进行同步操作.</span><br><span class="hljs-comment">    * 通常更倾向于使用addPropertyEditorRegistrar来代替这个方法,这就避免了自定义编辑器同步的需要</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerCustomEditor</span><span class="hljs-params">(Class&lt;?&gt; requiredType, Class&lt;? extends PropertyEditor&gt; propertyEditorClass)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 使用一个已经在BeanFactory里注册过的自定义属性编辑器来初始化给定的PropertyEditorRegistry.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyRegisteredEditorsTo</span><span class="hljs-params">(PropertyEditorRegistry registry)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置或获取自定义的类型转换器,BeanFactory用它来对Bean的属性值,构造参数等进行转换.这将会覆盖默认的PropertyEditor机制,</span><br><span class="hljs-comment">    * 因此,使用无关的自定义Editor或自定义Editor Registrars.因为TypeConverter通常不是线程安全的,所以每次调用都会产生一个新的实例.</span><br><span class="hljs-comment">    * 如果默认的PropertyEditor机制被激活,获取typeConverter方法将会返回所有已被注册的自定义的typeConverter</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeConverter</span><span class="hljs-params">(TypeConverter typeConverter)</span>;<br>   TypeConverter <span class="hljs-title function_">getTypeConverter</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用来增加一个嵌入式的StringValueResolver,比如说注解的属性.可以参考SpringMVC中的ArgumentResolver.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver valueResolver)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 确定是否有一个嵌入式的value resolver已经在这个bean factory中注册了,并且可以通过resolveEmbeddedValue函数来应用.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasEmbeddedValueResolver</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 决定一个给定的嵌入式的值,例如注解中的属性</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Nullable</span><br>   String <span class="hljs-title function_">resolveEmbeddedValue</span><span class="hljs-params">(String value)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *添加一个新的BeanPostProcessor,通过这个工厂所创建的beans将会应用这个后置处理器.</span><br><span class="hljs-comment">    * 在工厂的配置期间调用.注意这里的Post-processor提交将会按着registration的顺序被依次应用.</span><br><span class="hljs-comment">    * 任何通过Ordered这个接口所实现的顺序语义将会被忽略.也要注意到自动检测的后置处理器将会在以编程方式注册的那些后置处理器之后执行.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBeanPostProcessor</span><span class="hljs-params">(BeanPostProcessor beanPostProcessor)</span>;<br><br>   <span class="hljs-comment">//获取已经注册的Bean后置处理器的个数</span><br>   <span class="hljs-type">int</span> <span class="hljs-title function_">getBeanPostProcessorCount</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *注册一个给定的scope,支持Scope的实现类.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerScope</span><span class="hljs-params">(String scopeName, Scope scope)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 返回所有当前注册过的scope的名字.这个方法只返回明确注册过的scope的名字,内置的(Built-in)scopes像”singleton”和”prototype”不会被暴露.</span><br><span class="hljs-comment">    * 如果没有返回的是空数组.</span><br><span class="hljs-comment">    */</span><br>   String[] getRegisteredScopeNames();<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 如果有的话,返回给定名字的Scope实现.和上一个函数一样,将只返回明确注册过的scope,内置的(Built-in)scopes像”singleton”和”prototype”不会被暴露.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Nullable</span><br>   Scope <span class="hljs-title function_">getRegisteredScope</span><span class="hljs-params">(String scopeName)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 提供一个与这个工厂相关的安全的访问控制上下文.这个绝不会为空.</span><br><span class="hljs-comment">    */</span><br>   AccessControlContext <span class="hljs-title function_">getAccessControlContext</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 从给定的工厂中拷贝所有相关的配置信息.应该包括了所有标准的配置,也包括了BeanPostProcessor,Scopes和factory-specific内置的一些配置.</span><br><span class="hljs-comment">    * 应该不包括任何真实Bean的metadata信息,像BeanDefinition对象和bean的别名等</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyConfigurationFrom</span><span class="hljs-params">(ConfigurableBeanFactory otherFactory)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 给定一个bean的名字,创建它的别名.这个方法的典型应用是支持那些在XML的ids里是无效的名字(被用于Bean的命名).</span><br><span class="hljs-comment">    * 通常都是在factory的配置期间被调用,但是也可以用于别名的registration的运行时.所以一个实现了该函数的接口应该同步别名访问.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAlias</span><span class="hljs-params">(String beanName, String alias)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 处理所有目标名称的别名和在这个工厂注册过的别名,然后为它们应用给定的StringValueResolver.</span><br><span class="hljs-comment">    * 这个value resolver是处理像目标bean名称甚或在别名名称里的占位符而设置的.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveAliases</span><span class="hljs-params">(StringValueResolver valueResolver)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 返回一个给定名字的合并后的BeanDefinition,如果有必要会将子BeanDefinition和父BeanDefinition进行合并.</span><br><span class="hljs-comment">    * 并且也会考虑祖先容器中的BeanDefinition</span><br><span class="hljs-comment">    */</span><br>   BeanDefinition <span class="hljs-title function_">getMergedBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>   <span class="hljs-comment">//判断给定名字的Bean是否是一个FactoryBean.</span><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFactoryBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 设置Bean的当前创建状态</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> beanName</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> inCreation Bean是否正在创建中</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentlyInCreation</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> inCreation)</span>;<br><br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCurrentlyInCreation</span><span class="hljs-params">(String beanName)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 为给定名称的Bean注册一个依赖Bean,并且该依赖Bean会在给定的Bean被销毁之前进行销毁</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDependentBean</span><span class="hljs-params">(String beanName, String dependentBeanName)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *如果有的话,返回依赖于给定名字Bean的所有Bean名称.</span><br><span class="hljs-comment">    */</span><br>   String[] getDependentBeans(String beanName);<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 如果有的话,返回给定名字Bean所依赖的所有Bean名称.</span><br><span class="hljs-comment">    */</span><br>   String[] getDependenciesForBean(String beanName);<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 依据BeanDefinition,销毁给定Bean的实例,(通常会从这个工厂中获取一个原型实例).</span><br><span class="hljs-comment">    * 在销毁期间所抛出的任何异常都应该用捕获来取代往这个方法的调用者那里抛出.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyBean</span><span class="hljs-params">(String beanName, Object beanInstance)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 如果有的话,在当前目标Scope中销毁指定的ScopeBean.</span><br><span class="hljs-comment">    * 在销毁期间所抛出的任何异常都应该用捕获来取代往这个方法的调用者那里抛出</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyScopedBean</span><span class="hljs-params">(String beanName)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 销毁这个工厂中所有的singleton bean,包括一次性的已经注册的内嵌Bean.在工厂关闭的时候会被调用.</span><br><span class="hljs-comment">    * 在销毁期间所抛出的任何异常都应该用捕获来取代往这个方法的调用者那里抛出.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroySingletons</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><br><h4 id="configurablelistablebeanfactory"><a class="markdownIt-Anchor" href="#configurablelistablebeanfactory"></a> ConfigurableListableBeanFactory</h4><p>​	ConfigurableListableBeanFactory继承了<a href="#listablebeanfactory">ListableBeanFactory</a>, <a href="#autowirecapablebeanfactory">AutowireCapableBeanFactory</a>, <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020898453">ConfigurableBeanFactory</a>。在<a href="#configurablebeanfactory">ConfigurableBeanFactory</a>的基础上，<strong>并扩展了忽略依赖,自动装配判断,冻结bean的定义,枚举所有bean名称的功能</strong></p><p><img src="/2022/03/23/spring/ConfigurableListableBeanFactory_uml.jpg" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/23/spring/ConfigurableListableBeanFactory.jpg" srcset="/img/loading.gif" lazyload alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ConfigurableListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ListableBeanFactory</span>, AutowireCapableBeanFactory, ConfigurableBeanFactory &#123;<br><br>    <span class="hljs-comment">//在装配的时候忽略指定的依赖类型</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">ignoreDependencyType</span><span class="hljs-params">(Class&lt;?&gt; type)</span>;<br><br>    <span class="hljs-comment">//在装配的时候忽略指定的接口</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">ignoreDependencyInterface</span><span class="hljs-params">(Class&lt;?&gt; ifc)</span>;<br><br>    <span class="hljs-comment">//使用相应的自动装配值注册特殊依赖关系类型(ObjectFactory)。</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">registerResolvableDependency</span><span class="hljs-params">(Class&lt;?&gt; dependencyType, <span class="hljs-meta">@Nullable</span> Object autowiredValue)</span>;<br><br>    <span class="hljs-comment">//确定指定的bean是否有资格作为autowire候选者，注入到声明匹配类型依赖关系的其他bean中。</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">isAutowireCandidate</span><span class="hljs-params">(String beanName, DependencyDescriptor descriptor)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-comment">//返回指定bean的已注册BeanDefinition，允许访问其属性值和构造函数参数值（可以在bean工厂后处理期间修改）。</span><br>	BeanDefinition <span class="hljs-title function_">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>    <span class="hljs-comment">//返回所有bean名称的迭代对象</span><br>	Iterator&lt;String&gt; <span class="hljs-title function_">getBeanNamesIterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//清除合并的bean定义缓存，删除尚未被认为有资格进行完整元数据缓存的bean条目。</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">clearMetadataCache</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//冻结所有bean定义，表明注册的bean定义不会被修改或进一步后处理。</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">freezeConfiguration</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回是否冻结此工厂的bean定义</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-title function_">isConfigurationFrozen</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//确保所有非lazy-init单例都被实例化</span><br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="abstractbeanfactory"><a class="markdownIt-Anchor" href="#abstractbeanfactory"></a> AbstractBeanFactory</h4><br><h4 id="abstractautowirecapablebeanfactory"><a class="markdownIt-Anchor" href="#abstractautowirecapablebeanfactory"></a> AbstractAutowireCapableBeanFactory</h4><br><h4 id="defaultlistablebeanfactory"><a class="markdownIt-Anchor" href="#defaultlistablebeanfactory"></a> *DefaultListableBeanFactory</h4><br><h3 id="bean初始化的全过程"><a class="markdownIt-Anchor" href="#bean初始化的全过程"></a> *Bean初始化的全过程</h3><br><h3 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h3><h4 id="spring中有哪些方式可以把bean注入到ioc容器"><a class="markdownIt-Anchor" href="#spring中有哪些方式可以把bean注入到ioc容器"></a> Spring中有哪些方式可以把Bean注入到IOC容器</h4><blockquote><ul><li>使用xml文件的方式来定义bean,在spring启动的时候会解析这个xml，把bean装载到IOC容器</li><li>使用@ComponentScan注解来扫描声明了 @Controller、@Service、@Component注解的类</li><li>使用@Configuration注解声明配置类，并使用@Bean实现bean的定义</li><li>使用@Import注解导入配置类或普通的Bean</li><li>使用FactoryBean这一个工厂Bean来构建一个Bean的实例</li><li>实现ImportBeanDefinitionRegistrat这个接口，可以动态注入bean实例</li><li>实现ImportSelector接口。动态批量注入Bean对象</li></ul></blockquote><br><h4 id="spring为什么要用三级缓存来解决循环依赖"><a class="markdownIt-Anchor" href="#spring为什么要用三级缓存来解决循环依赖"></a> Spring为什么要用三级缓存来解决循环依赖</h4><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>singletonObjects</td><td>一级缓存，存放完整的 Bean</td></tr><tr><td>earlySingletonObjects</td><td>二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 init 方法</td></tr><tr><td>singletonFactories</td><td>三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中</td></tr></tbody></table><br><h4 id="什么是依赖注入di什么是控制反转ioc-在-spring-中有几种依赖注入方式"><a class="markdownIt-Anchor" href="#什么是依赖注入di什么是控制反转ioc-在-spring-中有几种依赖注入方式"></a> 什么是依赖注入（DI）？什么是控制反转(IOC)？ 在 Spring 中，有几种依赖注入方式？</h4><blockquote><p><strong>依赖注入</strong>：对象的创建过程由框架管理；对象外部资源的获取由对象本身反转到Ioc容器</p><p><strong>控制反转</strong>：</p><ul><li><h4 id="控制ioc容器控制了对象ioc容器控制对象的创建和外部资源的获取"><a class="markdownIt-Anchor" href="#控制ioc容器控制了对象ioc容器控制对象的创建和外部资源的获取"></a> 控制：Ioc容器控制了对象；IOC容器控制对象的创建和外部资源的获取</h4></li><li><h4 id="反转对象的创建和外部资源的获取由程序本身反转到ioc容器"><a class="markdownIt-Anchor" href="#反转对象的创建和外部资源的获取由程序本身反转到ioc容器"></a> 反转：对象的创建和外部资源的获取由程序本身反转到Ioc容器</h4></li></ul></blockquote><br><h4 id="spring的依赖注入有哪些方式"><a class="markdownIt-Anchor" href="#spring的依赖注入有哪些方式"></a> spring的依赖注入有哪些方式</h4><blockquote><ul><li>变量注入: @Autowired</li><li>构造器注入</li><li>set方法注入</li></ul></blockquote><br><h4 id="spring自动装配的方式"><a class="markdownIt-Anchor" href="#spring自动装配的方式"></a> <strong>Spring自动装配的方式</strong></h4><blockquote><ul><li>byName</li><li>byType</li><li>constructor</li><li>autodetect：首先尝试使用<strong>constructor</strong>来自动装配，如果无法工作，则使用<strong>byType</strong>方式</li></ul></blockquote><br><h4 id="spring是如何创建一个bean对象的"><a class="markdownIt-Anchor" href="#spring是如何创建一个bean对象的"></a> spring是如何创建一个Bean对象的</h4><p>bean -&gt; 推断构造函数 -&gt; 反射生成对象 -&gt; 依赖注入（属性填充）-&gt; 初始化前（@PostConstruct） -&gt; Aware接口 -&gt; 初始化（InitializingBean）-&gt; 初始化后（AOP）-&gt; 代理对象 -&gt; 放入一级缓存</p><br><h4 id="spring事务传播行为"><a class="markdownIt-Anchor" href="#spring事务传播行为"></a> Spring事务传播行为</h4><table><thead><tr><th>传播属性</th><th>描述</th></tr></thead><tbody><tr><td>REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中（默认）</td></tr><tr><td>REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起</td></tr><tr><td>SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行</td></tr><tr><td>NOT_SUPPORTED</td><td>不支持事务，如果当前存在事务就将事务挂起</td></tr><tr><td>MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常</td></tr><tr><td>NEVER</td><td>不支持事务，如果当前存在事务，则抛出异常</td></tr><tr><td>NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与REQUIRED类似的操作</td></tr></tbody></table><p><strong>嵌套事务：（部分事务提交）内层事务的回滚不影响外层事务的提交</strong></p><br><h4 id="什么是单例池作用是什么"><a class="markdownIt-Anchor" href="#什么是单例池作用是什么"></a> 什么是单例池？作用是什么？</h4><p>DefaultSingletonBeanRegistry#singletonObjects 这个 ConcurrentHashMap就是单例池</p><p>作用就是缓存单例bean对象</p><br><h4 id="bean对象和普通对象之间的区别是什么"><a class="markdownIt-Anchor" href="#bean对象和普通对象之间的区别是什么"></a> Bean对象和普通对象之间的区别是什么</h4><p>区别：对象的创建流程不同，spring的bean创建包含了依赖注入，初始化前操作，初始化，初始化后操作（AOP）</p><br><h4 id="推断构造方法是什么意思"><a class="markdownIt-Anchor" href="#推断构造方法是什么意思"></a> 推断构造方法是什么意思</h4><p>spring 需要通过构造函数反射创建对象，这个时候就面临构造函数选择（如果有多个），默认使用无参构造函数</p><ul><li>如果没有无参构造函数并且有多个有参构造函数，则抛出异常（不知如何选择），除非给其中一个构造函数加@Autowired注解（暗示spring使用它）</li><li>如果没有无参构造函数，并且只有一个有参构造函数，则使用它（没得选择）</li></ul><br><h4 id="单例bean和单例模式之间有什么关系"><a class="markdownIt-Anchor" href="#单例bean和单例模式之间有什么关系"></a> 单例Bean和单例模式之间有什么关系</h4><p>单例bean：通过相同的依赖注入条件能获取到同一个对象，ioc容器能注册多个类型相同的单例bean.<strong>单例bean是相对依赖注入条件而言的</strong></p><p>单例模式：整个JVM虚拟机中只允许存在这个类型的一个实例</p><br><h4 id="什么是先bytype再byname"><a class="markdownIt-Anchor" href="#什么是先bytype再byname"></a> 什么是先bytype再byname</h4><p><strong>在构造函数注入中</strong>：假设在ioc容器中注册了多个类型相同的单例bean,根据类型能够获取多个单例bean,那么就再按照变量名称匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SysUserEntity <span class="hljs-title function_">sysUserEntity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysUserEntity</span>().setUserId(<span class="hljs-number">1L</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SysUserEntity <span class="hljs-title function_">sysUserEntity2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysUserEntity</span>().setUserId(<span class="hljs-number">2L</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SysUserEntity <span class="hljs-title function_">sysUserEntity3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysUserEntity</span>().setUserId(<span class="hljs-number">3L</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    SysUserEntity sysUserEntity;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  spring在ioc容器中能匹配到多个 SysUserEntity 实例,分别为</span><br><span class="hljs-comment">     *  name            userId</span><br><span class="hljs-comment">     *  sysUserEntity   userId = 1</span><br><span class="hljs-comment">     *  sysUserEntity2  userId = 2</span><br><span class="hljs-comment">     *  sysUserEntity3  userId = 3</span><br><span class="hljs-comment">     *  那么再根据构造函数的形式参数名称判断，最终选择sysUserEntity2</span><br><span class="hljs-comment">     *  这就是先bytype再byname</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserService</span><span class="hljs-params">(SysUserEntity sysUserEntity2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sysUserEntity = sysUserEntity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="spring-aop底层是怎么工作的"><a class="markdownIt-Anchor" href="#spring-aop底层是怎么工作的"></a> Spring AOP底层是怎么工作的</h4><br><h4 id="spring事务底层是怎么工作的"><a class="markdownIt-Anchor" href="#spring事务底层是怎么工作的"></a> Spring事务底层是怎么工作的</h4><br><h4 id="同类方法调用为什么会事务失效"><a class="markdownIt-Anchor" href="#同类方法调用为什么会事务失效"></a> 同类方法调用为什么会事务失效</h4><br><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>spring</div><div>https://wugengfeng.cn/2022/03/23/spring/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年3月23日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/03/29/jvm/" title="jvm"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">jvm</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/03/11/Sort/" title="Sort"><span class="hidden-mobile">Sort</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>