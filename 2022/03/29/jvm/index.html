<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload='this.media="all"'><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="wugengfeng"><meta name="keywords" content="wugengfeng"><meta name="description" content="JVM 内存区域  线程共享区域   堆（Heap） 堆是JVM中最大的一块内存区域，用于存放对象实例，几乎所有的对象实例都在堆中分配。堆是线程共享的，每个线程都可以访问堆中的对象 堆又分为新生代和老年代，新生代又分为Eden区、Survivor区（一般有两个，称为From区和To区）   方法区（元空间） 方法区是用于存放类的元信息、常量池、静态变量等数据。在JDK1.8及以前的版本，方法区是"><meta property="og:type" content="article"><meta property="og:title" content="jvm"><meta property="og:url" content="https://wugengfeng.cn/2022/03/29/jvm/index.html"><meta property="og:site_name" content="技术博客"><meta property="og:description" content="JVM 内存区域  线程共享区域   堆（Heap） 堆是JVM中最大的一块内存区域，用于存放对象实例，几乎所有的对象实例都在堆中分配。堆是线程共享的，每个线程都可以访问堆中的对象 堆又分为新生代和老年代，新生代又分为Eden区、Survivor区（一般有两个，称为From区和To区）   方法区（元空间） 方法区是用于存放类的元信息、常量池、静态变量等数据。在JDK1.8及以前的版本，方法区是"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wugengfeng.cn/img/banner/jvm.png"><meta property="article:published_time" content="2022-03-29T14:19:52.000Z"><meta property="article:modified_time" content="2023-09-22T06:30:40.421Z"><meta property="article:author" content="wugengfeng"><meta property="article:tag" content="wugengfeng"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://wugengfeng.cn/img/banner/jvm.png"><meta name="baidu-site-verification" content="codeva-uJ0fkFPmHB"><title>jvm - 技术博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"wugengfeng.cn",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!1,element:"h9",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="技术博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>吴耿锋</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="jvm"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-03-29 22:19" pubdate>2022年3月29日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 47k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 394 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">jvm</h1><div class="markdown-body"><h2 id="jvm-内存区域"><a class="markdownIt-Anchor" href="#jvm-内存区域"></a> JVM 内存区域</h2><p><img src="/2022/03/29/jvm/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">线程共享区域</p><ul><li><p>堆（Heap）</p><p>堆是JVM中最大的一块内存区域，用于存放对象实例，几乎所有的对象实例都在堆中分配。堆是线程共享的，每个线程都可以访问堆中的对象</p><p>堆又分为新生代和老年代，新生代又分为Eden区、Survivor区（一般有两个，称为From区和To区）</p></li><li><p>方法区（元空间）</p><p>方法区是用于存放<code>类的元信息</code>、<code>常量池</code>、<code>静态变量</code>等数据。在JDK1.8及以前的版本，方法区是位于永久代的，而在JDK1.8及以后的版本，方法区被移动到了元空间</p><p>方法区主要存储以下内容：</p><ul><li><code>类的Class对象</code>：类加载器加载类后，会在方法区中为该类创建一个Class对象。</li><li><code>方法信息</code>：存放类中声明的每个方法的信息，包括方法名、返回值类型、参数类型等。</li><li><code>字符串常量池</code>：用于存放字符串常量。</li><li><code>静态变量</code>：存放类的静态变量。</li></ul></li></ul><p class="note note-primary">非线程共享区域</p><p><img src="/2022/03/29/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><p>虚拟机栈</p><ul><li><p>栈帧 Java调用一个方法就是压入一个栈帧的过程</p><ul><li><p>局部变量表</p><p>​	用于存放方法参数和方法内部定义的变量（局部变量必须赋予初始值）</p></li><li><p>操作数栈</p><p>​	虚拟机计算的临时存储区域，JVM虚拟机对数据的操作是通过指定的压栈和弹栈完成的</p></li><li><p>动态链接</p><p>​	指定了栈帧所属方法的引用</p></li><li><p>方法出口</p><p>​	指定了方法执行完毕或者异常后需要被调用的位置，程序才能继续执行</p></li></ul></li></ul></li><li><p>本地方法栈</p><p>​	java跨语言调用 native方法（本地C类库方法）的相关信息</p></li><li><p>程序计数器</p><p>​	记录字节码执行位置。多线程环境（避免线程上下文切换忘记之前代码执行到哪里）</p></li></ul><p class="note note-primary">方法区详解</p><p>JDK1.7 及之后版本的 JVM 已经将<code>运行时常量池</code>从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。符号引用转移到直接内存(native heap)</p><p><code>元空间</code>：JDK1.8开始，取消了方法区，取而代之的是位于直接内存的元空间（metaSpace）</p><ul><li>字符串常量池</li><li>静态变量</li></ul><p><code>符号引用</code>：符号引用是一个字符串，它给出了被引用内容的描述，类的引用必须是全类名组成的，符号描述能精准定位被引用的内容（类，方法，字符）</p><p><code>作用</code>：帮助JVM快速定位加载类</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">类：Java.lang.<span class="hljs-type">String</span><br>对应描述符：Ljava/lang/<span class="hljs-type">String</span>;<br></code></pre></td></tr></table></figure><p><code>方法信息</code></p><p>类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码</p><p><code>类的Class对象</code></p><p>类加载将二进制流转为方法区运行时数据会将加载类的Class对象分配到方法区</p><p class="note note-primary">元空间</p><p>Java7之前，方法区位于永久代，永久代和堆虽然是内存隔离的。但是本质上使用的还是JVM内存，如果JVM内存设置过小，永久代就会有内存溢出风险，因此Java8之后废弃了永久代，使用了元空间，元空间不再使用JVM内存，而是使用本地内存，减少了OOM风险</p><h3 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h3><p><img src="/2022/03/29/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt></p><p>类加载器是Java虚拟机（JVM）的一部分，用于将类的字节码加载到内存中，并在运行时创建类的对象</p><ul><li><p>Bootstrap ClassLoader</p><p>​	启动类加载器：最顶层的加载类，<strong>主要加载核心类库</strong>，也就是我们环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等</p></li><li><p>Extention ClassLoader</p><p>​	加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件</p></li><li><p>Application ClassLoader</p><p>​	<span class="green-line">加载当前应用的classpath的所有类</span></p></li></ul><h4 id="自定义类加载器"><a class="markdownIt-Anchor" href="#自定义类加载器"></a> 自定义类加载器</h4><ul><li>定义一个类，继承 <code>ClassLoader</code></li><li>重写findClass 方法</li><li>使用defineClass() 实例化Class对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        Class&lt;?&gt; clazz = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (name.equals(<span class="hljs-string">&quot;com.example.luckdraw.test.TestObject&quot;</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Desktop\\TestObject.class&quot;</span>);<br>                <span class="hljs-type">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inputStream.available()];<br>                inputStream.read(buff);<br>                clazz = defineClass(name, buff, <span class="hljs-number">0</span>, buff.length);<br>            &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            clazz = <span class="hljs-built_in">super</span>.findClass(name);<br>        &#125;<br>        <span class="hljs-keyword">return</span> clazz;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双亲委派原则"><a class="markdownIt-Anchor" href="#双亲委派原则"></a> 双亲委派原则</h4><p><img src="/2022/03/29/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8E%9F%E5%88%99.png" srcset="/img/loading.gif" lazyload alt></p><p><code>委派</code>：当类加载器收到加载任务会先委派给父加载器进行加载（自下向顶为委派）</p><p><code>加载</code>：当父类加载不到此类则丢给子类加载器加载（自顶向下加载）</p><p><code>作用</code>：保证核心类被正确加载（java源码级别的类）</p><p><code>好处</code>：因为类加载后会被缓存，所以保证类的一致性和避免类的冲突</p><p>双亲委派原则只是一种规范或约定，并不是Java虚拟机的强制要求。在特定的情况下，用户也可以自定义类加载器，来实现自己的加载逻辑</p><h4 id="破坏双亲委派"><a class="markdownIt-Anchor" href="#破坏双亲委派"></a> 破坏双亲委派</h4><p class="note note-primary">JDBC</p><p><span class="green-line">根据类加载机制，当被加载的类引用了另外一个类的时候，虚拟机就会使用加载第一个类的类加载器加载被引用的类</span></p><ul><li>JDBC驱动程序通常是由第三方提供的，由Application ClassLoader加载，而且这些驱动程序需要访问JDBC API的内部实现</li><li>JDBC API是Java的核心类，由Bootstrap ClassLoader加载，因此需要破坏双亲委派</li></ul><p class="note note-primary">Tomcat</p><p><code>破坏双亲委派</code>：每个Tomcat的<code>WebApp ClassLoader</code>加载自己的目录下的class文件，不会传递给父类加载器</p><ul><li>对于各个 <code>webapp</code>中的 <code>class</code>和 <code>lib</code>，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况</li><li>热部署</li></ul><h3 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h3><p><img src="/2022/03/29/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">加载</p><p>将类的字节码文件加载到内存，并方法区对应生成一个Class对象</p><p class="note note-primary">链接</p><p>对加载的类进行校验</p><ul><li><p><strong>验证</strong></p><p>验证二进制流是否符合规范，是否存在安全问题</p></li><li><p><strong>准备</strong></p><p>为静态变量开辟内存空间并赋予初始值</p></li><li><p><strong>解析</strong></p><p>将类的符号引用改为直接引用</p><p>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">类：Java.lang.<span class="hljs-type">String</span><br>对应描述符：Ljava/lang/<span class="hljs-type">String</span>;<br></code></pre></td></tr></table></figure><p>直接引用：直接指向目标的指针</p></li></ul><p class="note note-primary">初始化</p><p>​	当一个类被主动使用时，Java虚拟机就会对其初始化</p><ul><li>只对static修饰的变量或静态代码块进行初始化</li><li>如果存在父类，则优先初始化父类</li><li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行</li></ul><h3 id="类加载时机"><a class="markdownIt-Anchor" href="#类加载时机"></a> 类加载时机</h3><p>类没有被主动使用，没有被加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constant</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a=10&quot;</span>);<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 类被加载但是没有被主动使用，所以没有执行初始化</span><br>        System.out.println(Constant.class);<br>    &#125;<br>&#125;<br><br>输出 <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.example.demo.model.Constant<br></code></pre></td></tr></table></figure><p><strong>主动使用类，JVM会调用类的构造器收集 static修饰的变量和语句进行初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constant</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a=10&quot;</span>);<br>        a = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 主动使用类，JVM会调用类的构造器收集 static修饰的变量和语句进行初始化</span><br>        System.out.println(Constant.a);<br>    &#125;<br>&#125;<br><br>输出<br>a=<span class="hljs-number">10</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>加载时机</p><ul><li>创建某个类的实例</li><li>访问某个类的静态方法</li><li>使用某个类的静态字段</li><li>初始化某个类的子类</li><li>使用反射机制访问类</li><li>程序的启动类（包含main方法）</li></ul><h3 id="对象创建过程"><a class="markdownIt-Anchor" href="#对象创建过程"></a> 对象创建过程</h3><p><img src="/2022/03/29/jvm/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>使用 new 关键字或者反射机制</li><li>根据new的参数在 <span class="green-line">常量池中定位一个类的符号引用</span></li><li>如果没有找到这个类的符号引用，说明类没有被加载，则进行类的加载，解析和初始化</li><li>虚拟机为对象分配内存空间<ul><li>指针碰撞（内存相对规整的情况，也就是垃圾回收器带内存整理压缩功能的）</li><li>空闲链表</li></ul></li><li>对齐填充，<span class="green-line">对象的大小始终为8的整数倍，原因是便于内存寻址</span></li><li>将分配的内存初始化为0</li><li>设置对象头，包括分代年龄，对象的HashCode</li><li>调用对象的构造方法</li></ul><h3 id="对象结构"><a class="markdownIt-Anchor" href="#对象结构"></a> 对象结构</h3><p><img src="/2022/03/29/jvm/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt></p><p>Head 头信息</p><ul><li><code>hash值</code>：对象的hashCode</li><li><code>分代年龄</code>：默认为0，用于分代年龄计算</li><li><code>锁状态标识位</code>：标记当前对象是否上锁</li><li><code>持有锁的线程</code>：当前对象锁属于哪个线程所有</li><li><code>类型指针</code>：标记当前对象属于哪个Class</li></ul><p>对象实例数据</p><p><code>对齐填充</code>：无意义，JVM要求对象大小必须是8字节的整数倍</p><h3 id="classload和classforname"><a class="markdownIt-Anchor" href="#classload和classforname"></a> ClassLoad和Class.forName</h3><ul><li>ClassLoad只是将类加载到JVM</li><li>Class.forName除了类加载还会执行静态代码块</li><li>Class.forName还可以对类进行实例化</li></ul><h3 id="指令重排序"><a class="markdownIt-Anchor" href="#指令重排序"></a> 指令重排序</h3><p><span class="green-line">在代码实际运行时，代码指令可能不按照代码语句顺序执行的。只要程序的结果和顺序性执行代码的结果一致，那么指令的执行顺序就可以不和代码顺序一致，这就是指令重排序<span></span></span></p><p><code>原因</code>：现代处理器架构采用乱序执行方法，在条件允许的情况下，直接执行后面的指令，通过乱序执行技术提高处理器的执行效率</p><ul><li><code>编译器优化的重排序</code>。编译器在不改变单线程程序的语义前提下，可以重新安排语句的执行顺序</li><li><code>指令级并行的重排序</code>。现在处理器采用了指令集并行技术，来将多条指令重叠执行。如果不存在依赖性，处理器可以改变语句对应的机器指令的执行顺序</li><li><code>内存系统的重排序</code>。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul><h3 id="内存屏障"><a class="markdownIt-Anchor" href="#内存屏障"></a> 内存屏障</h3><p>内存屏障（Memory Barrier）是指一组指令，用于控制处理器和内存之间的访问顺序和可见性</p><p><code>作用</code>：</p><ul><li>阻止屏障两侧的指令重排序</li><li>强制缓冲区数据刷新到主内存或强制从主内存加载最新数据到缓冲区</li></ul><p><code>分类</code>：</p><ul><li>读屏障：在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li><li>写屏障：在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</li></ul><h4 id="volatile语义中的内存屏障"><a class="markdownIt-Anchor" href="#volatile语义中的内存屏障"></a> volatile语义中的内存屏障</h4><ol><li><code>可见性</code>：对一个volatile变量的写操作对其他线程的读操作是可见的，即写操作立即刷新到主内存中，读操作从主内存中获取最新的值。</li><li><code>有序性</code>：对一个volatile变量的写操作不会与之前的写操作发生重排序，也不会与之后的写操作发生重排序。保证了volatile写操作的有序性。</li><li><code>禁止指令重排序</code>：volatile变量的读写操作都会插入内存屏障，禁止指令重排序。</li></ol><p>具体来说，volatile语义的内存屏障包括以下几种屏障：</p><ul><li>在每个volatile写操作前插入StoreStore屏障，保证在写操作前的所有写操作对其他线程/CPU可见。</li><li>在每个volatile写操作后插入StoreLoad屏障，保证volatile写操作对其他线程/CPU的读操作可见。</li><li>在每个volatile读操作前插入LoadLoad屏障，保证volatile读操作之前的读操作完成。</li><li>在每个volatile读操作后插入LoadStore屏障，保证volatile读操作后的所有读操作都能看到volatile读操作之前的写操作。</li></ul><h4 id="final语义中的内存屏障"><a class="markdownIt-Anchor" href="#final语义中的内存屏障"></a> final语义中的内存屏障</h4><p><code>防止指令重排序</code></p><ul><li>对于final域，编译器和CPU会遵循两个排序规则：</li></ul><blockquote><ol><li>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</li><li>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</li></ol></blockquote><ul><li>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</li><li>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。</li><li>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</li><li>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略</li></ul><h3 id="contended"><a class="markdownIt-Anchor" href="#contended"></a> @Contended</h3><p><code>@sun.misc.Contended</code> 是 Java 8 新增的一个注解，对某字段加上该注解则表示该字段会单独占用一个 <code>缓存行（Cache Line）</code></p><p>这里的缓存行是指 CPU 缓存的存储单元，常见的缓存行大小为 64 字节</p><p><code>注意</code>：JVM 添加 -XX:-RestrictContended 参数后 @sun.misc.Contended 注解才有效</p><p class="note note-primary">单独使用一个缓存行避免伪共享</p><p>为了提高读取速度，每个 CPU 有自己的缓存，CPU 读取数据后会存到自己的缓存里。而且为了节省空间，一个缓存行可能存储着多个变量，即 <code>伪共享</code>。但是这对于共享变量，会造成性能问题：</p><ul><li>当一个 CPU 要修改某共享变量 A 时会先 <code>锁定</code> 自己缓存里 A 所在的缓存行，并且把其他 CPU 缓存上相关的缓存行设置为 <code>无效</code></li><li>但如果被锁定或失效的缓存行里，还存储了其他不相干的变量 B，其他线程此时就访问不了 B，或者由于缓存行失效需要重新从内存中读取加载到缓存里，这就造成了 <code>开销</code>。<span class="green-line">所以让共享变量 A 单独使用一个缓存行就不会影响到其他线程的访问。</span></li></ul><p><code>适用场景</code>：主要适用于频繁写的共享数据上。如果不是频繁写的数据，那么 CPU 缓存行被锁的几率就不多，所以没必要使用了，否则不仅占空间还会浪费 CPU 访问操作数据的时间。</p><h2 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h2><p><span class="green-line"><code>synchronized</code> 用的锁标志是存在Java对象头里的</span></p><p><img src="/2022/03/29/jvm/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/29/jvm/synchronized%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.jpg" srcset="/img/loading.gif" lazyload alt="synchronized重量级锁"></p><p class="note note-primary">底层实现</p><p>在Java中，每个对象都关联一个 <code>monitor</code>（监视器锁，锁的粒度是对象，如果是静态资源则对应Class对象），在HotSpot虚拟机中它是由<code>ObjectMonitor</code>实现的（C++实现）。当线程进入synchronized代码块时，它会尝试获取对象的监视器锁。如果该锁未被其他线程占用，则该线程会立即获得该锁，并继续执行synchronized代码块。如果该锁已经被其他线程占用，则当前线程会进入该对象的等待队列中，等待其他线程释放该锁。当其他线程释放该锁时，等待队列中的线程会被唤醒，然后它们会再次尝试获取该锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ObjectMonitor</span>() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;	<span class="hljs-comment">// 用于存储对象监视器的头部信息，初始化为NULL</span><br>    _count        = <span class="hljs-number">0</span>;  	<span class="hljs-comment">// 线程获取锁的次数</span><br>    _waiters      = <span class="hljs-number">0</span>,		<span class="hljs-comment">// 当前等待获取该对象监视器的线程数，初始化为0</span><br>    _recursions   = <span class="hljs-number">0</span>; 		<span class="hljs-comment">// 当前线程获取该对象监视器的重入次数，初始化为0</span><br>    _object       = <span class="hljs-literal">NULL</span>;	<span class="hljs-comment">// 被监视的对象，初始化为NULL</span><br>    _owner        = <span class="hljs-literal">NULL</span>; 	<span class="hljs-comment">// 指向持有ObjectMonitor对象的线程地址</span><br>    _WaitSet      = <span class="hljs-literal">NULL</span>; 	<span class="hljs-comment">// 等待获取该对象监视器的线程组成的双向循环链表，初始化为NULL，表示没有等待线程</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;		<span class="hljs-comment">// 保护等待线程链表的自旋锁，初始化为0</span><br>    _Responsible  = <span class="hljs-literal">NULL</span> ;	<span class="hljs-comment">// 如果某个线程为了获取该对象监视器而阻塞，在唤醒时这个字段指向阻塞线程的Successor</span><br>    _succ         = <span class="hljs-literal">NULL</span> ;	<span class="hljs-comment">// 当前线程阻塞时的Successor，初始化为NULL</span><br>    _cxq          = <span class="hljs-literal">NULL</span> ;	<span class="hljs-comment">// 多线程竞争锁进入时的单向链表，初始化为NULL</span><br>    FreeNext      = <span class="hljs-literal">NULL</span> ;	<span class="hljs-comment">// 用于释放已经不再需要的对象监视器的单向链表，初始化为NULL</span><br>    _EntryList    = <span class="hljs-literal">NULL</span> ;  <span class="hljs-comment">// 等待被_owner线程唤醒时的线程节点组成的双向循环链表，初始化为NULL</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;		<span class="hljs-comment">// 用于自旋次数的计数，初始化为0</span><br>    _SpinClock    = <span class="hljs-number">0</span> ;		<span class="hljs-comment">// 用于自旋的时钟，初始化为0</span><br>    OwnerIsThread = <span class="hljs-number">0</span> ;		<span class="hljs-comment">// 持有者是否为线程的标记，初始化为0</span><br>  &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">加锁过程</p><ul><li>当一个线程尝试进入一个synchronized块时，它会先尝试获取对象监视器的锁</li><li>如果锁没有被其他线程持有，那么当前线程立即获得锁，可以继续执行synchronized块中的代码</li><li>如果锁已经被其他线程持有，那么当前线程会进入阻塞状态，被放入锁的等待队列中（_WaitSet）</li><li>当一个线程释放锁时，ObjectMonitor会将等待队列中（_WaitSet）唤醒一个线程，让其获得锁</li></ul><p class="note note-primary">释放锁</p><ul><li>线程执行完synchronized代码块中的代码，或者发生了异常导致代码块提前退出</li><li>执行一个monitor.exit指令，该指令会释放当前线程持有的锁</li><li>在释放锁之前，线程会将持有锁的计数减1，如果计数为0，则表示锁被完全释放；如果计数大于0，表示锁被重入了多次</li><li>线程释放锁后，JVM 会从等待队列中选择一个线程唤醒，让其获得锁</li></ul><p class="note note-primary">使用</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chang-LeHung/p/16560331.html">Synchroinzed 用法</a></p><ul><li>synchronized修饰实例方法</li><li>synchronized修饰静态方法</li><li>synchronized修饰实例方法的代码块</li><li>synchronized修饰静态方法的代码块</li></ul><p>JDK1.6之后对 <code>synchronized</code> 做了下面三点优化，在之后的JDK版本里性能和 <code>ReentrantLock</code> 不相上下</p><h3 id="锁升级"><a class="markdownIt-Anchor" href="#锁升级"></a> 锁升级</h3><ul><li><strong>无锁</strong> ：对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放对象分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01</li><li><strong>偏向锁</strong>： 在偏向锁中划分更细，还是开辟 25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 Epoch，4bit 存放对象分代年龄，1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01</li><li><strong>轻量级锁</strong>：在轻量级锁中直接开辟 30bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00</li><li><strong>重量级锁</strong>： 在重量级锁中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为11</li></ul><h4 id="无锁"><a class="markdownIt-Anchor" href="#无锁"></a> 无锁</h4><p><img src="/2022/03/29/jvm/%E6%97%A0%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p>无锁（也称为乐观锁）是指当多个线程同时访问共享资源时，没有线程进行阻塞，通常是使用CAS机制实现的</p><h4 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h4><p><img src="/2022/03/29/jvm/%E5%81%8F%E5%90%91%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p>当一个线程第一次访问共享资源时，JVM会将锁的对象头设置为偏向模式，并将线程ID记录在对象头中。在接下来的访问中，线程只需要检查对象头中的线程ID是否是自己，如果是，则无需进行锁的获取操作</p><h4 id="轻量级锁自旋锁"><a class="markdownIt-Anchor" href="#轻量级锁自旋锁"></a> 轻量级锁（自旋锁）</h4><p><img src="/2022/03/29/jvm/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，<strong>其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能</strong></p><p><strong>轻量级锁的获取主要由两种情况</strong></p><ul><li><p>当关闭偏向锁功能时 <code>-XX:-UseBiasedLocking=false</code></p></li><li><p>由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁</p><p>当多个线程同时访问同一个共享资源时，JVM会将锁的对象头设置为轻量级锁模式，并尝试使用CAS + 自旋操作将对象头中的锁指针指向当前线程，如果CAS操作成功，则当前线程获得锁</p></li></ul><h4 id="重量级锁"><a class="markdownIt-Anchor" href="#重量级锁"></a> 重量级锁</h4><p><img src="/2022/03/29/jvm/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">重量级锁显然，此忙等是有限度的(自旋，有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改)。</span>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁，当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起并加入等待队列，等待锁释放后被唤醒</p><p><strong>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态</strong></p><h3 id="锁消除"><a class="markdownIt-Anchor" href="#锁消除"></a> 锁消除</h3><p><strong>锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行</p><p><span class="green-line">比如一个使用 <code>synchronized</code> 修饰的方法，它并没有访问共享资源，不存在并发问题，此时没有资源竞争自然就不需要加锁</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Synchroinzed</span> &#123;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 逃逸分析</span><br><span class="hljs-comment">     * 1.没有共享数据竞争</span><br><span class="hljs-comment">     * 2.没有返回值，方法体内创建的对象直接在栈上内存分配，其他线程无法访问到，不存在线程安全问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + System.currentTimeMillis());<br>       <span class="hljs-keyword">try</span> &#123;<br>           TimeUnit.SECONDS.sleep(<span class="hljs-number">500</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>   &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Synchroinzed</span>().test()).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="锁粗化"><a class="markdownIt-Anchor" href="#锁粗化"></a> 锁粗化</h3><p>将多次连续的同步块合并为一次更大的同步块，从而减少锁竞争的次数，提高程序的执行效率</p><p>如果JVM检测到有连续的操作都是对同一对象的加锁，将会<strong>扩大加锁同步的范围（即锁粗化）到整个操作序列的外部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Synchroinzed</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>     System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + System.currentTimeMillis());<br>     <span class="hljs-keyword">try</span> &#123;<br>         TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">50</span>);<br>     &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">Synchroinzed</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Synchroinzed</span>();<br><br>     <span class="hljs-comment">// 创建10个线程</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>                 <span class="hljs-comment">// 连续对同一对象加锁解锁</span><br>                 <span class="hljs-keyword">synchronized</span> (sync) &#123;<br>                     sync.test();<br>                 &#125;<br>             &#125;<br>         &#125;).start();<br>     &#125;<br> &#125;<br>&#125;<br><br>线程编号输出相对规整，说明做了锁粗话，但还是建议放在循环体外面<br>Thread-<span class="hljs-number">0</span>:<span class="hljs-number">1650645031133</span><br>Thread-<span class="hljs-number">0</span>:<span class="hljs-number">1650645031183</span><br>Thread-<span class="hljs-number">0</span>:<span class="hljs-number">1650645031233</span><br>Thread-<span class="hljs-number">0</span>:<span class="hljs-number">1650645031283</span><br>Thread-<span class="hljs-number">0</span>:<span class="hljs-number">1650645031333</span><br>Thread-<span class="hljs-number">4</span>:<span class="hljs-number">1650645031383</span><br>Thread-<span class="hljs-number">4</span>:<span class="hljs-number">1650645031433</span><br>Thread-<span class="hljs-number">4</span>:<span class="hljs-number">1650645031483</span><br>Thread-<span class="hljs-number">4</span>:<span class="hljs-number">1650645031533</span><br>Thread-<span class="hljs-number">4</span>:<span class="hljs-number">1650645031583</span><br>Thread-<span class="hljs-number">3</span>:<span class="hljs-number">1650645031633</span><br>Thread-<span class="hljs-number">3</span>:<span class="hljs-number">1650645031683</span><br>Thread-<span class="hljs-number">3</span>:<span class="hljs-number">1650645031733</span><br>Thread-<span class="hljs-number">3</span>:<span class="hljs-number">1650645031783</span><br>Thread-<span class="hljs-number">3</span>:<span class="hljs-number">1650645031833</span><br>Thread-<span class="hljs-number">2</span>:<span class="hljs-number">1650645031883</span><br>Thread-<span class="hljs-number">2</span>:<span class="hljs-number">1650645031933</span><br>Thread-<span class="hljs-number">2</span>:<span class="hljs-number">1650645031983</span><br>Thread-<span class="hljs-number">2</span>:<span class="hljs-number">1650645032033</span><br>Thread-<span class="hljs-number">2</span>:<span class="hljs-number">1650645032083</span><br>Thread-<span class="hljs-number">1</span>:<span class="hljs-number">1650645032133</span><br>Thread-<span class="hljs-number">1</span>:<span class="hljs-number">1650645032183</span><br>Thread-<span class="hljs-number">1</span>:<span class="hljs-number">1650645032233</span><br>Thread-<span class="hljs-number">1</span>:<span class="hljs-number">1650645032283</span><br>Thread-<span class="hljs-number">1</span>:<span class="hljs-number">1650645032333</span>    <br></code></pre></td></tr></table></figure><h2 id="jit-即时编译器"><a class="markdownIt-Anchor" href="#jit-即时编译器"></a> JIT 即时编译器</h2><p>JIT编译器（Just-In-Time Compiler）是Java虚拟机（JVM）中的一种编译器，它的主要作用是将Java字节码（bytecode）实时编译为本地机器码（native code），以提高程序的执行效率。</p><p>JIT编译器的工作原理如下：</p><ol><li>解释器解释字节码：当Java程序被执行时，JVM会先将字节码交给解释器进行解释执行。解释器将逐条解释执行字节码指令，将其转换为对应的机器指令并执行。这种方式的好处是可移植性强，适用于任何平台。</li><li>监控热点代码：JIT编译器会监控程序的执行情况，识别出频繁执行的热点代码。热点代码通常是被多次执行的方法或循环体。</li><li>编译热点代码：一旦识别出热点代码，JIT编译器会将其编译为本地机器码。与解释执行相比，本地机器码的执行速度更快。</li><li>优化编译：在编译过程中，JIT编译器会进行一些优化操作。例如，方法内联、循环展开、去除无用代码等。这些优化措施可以进一步提高程序的执行效率。</li></ol><p>热点代码：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><p>缺点：</p><ul><li>内存占用：JIT编译器需要将编译后的本地机器码保存在内存中，这会增加内存的占用。</li><li>编译时间：JIT编译器需要一定的时间来进行编译，这可能会导致程序的启动时间延长。</li></ul><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">推荐文章 美团技术沙龙</a></p><h2 id="gc-garbage-collectors"><a class="markdownIt-Anchor" href="#gc-garbage-collectors"></a> GC (Garbage Collectors)</h2><h3 id="内存区域划分"><a class="markdownIt-Anchor" href="#内存区域划分"></a> 内存区域划分</h3><p><img src="/2022/03/29/jvm/GC%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">Eden</p><p>基本上所有新建的对象都在这个区域</p><p><em>因为还存在大对象直接进入老年代和栈上内存分配情况</em></p><p><code>Eden:Survivor_from:Survivor_to 8:1:1</code></p><p class="note note-primary">Survivor</p><p>被<code>Minor GC</code> 后移入的存活区, 分为<code>Survivor_from</code>和<code>Survivor_to</code>两个区域，<code>Survivor</code>区域在GC时采用<code>复制算法</code>进行对象淘汰，当对象多次GC（默认15次）后存在的仍然存活就会进入老年代</p><p><code>Eden:Survivor_from:Survivor_to 8:1:1</code></p><p class="note note-primary">Old</p><p>老年代，长期存活的对象存放的区域，只有<code>Full GC</code>才会清理这个区域的对象</p><p><code>新生代:老年代 1：2</code></p><h3 id="minorgc-majorgc-fullgc和mixed-gc"><a class="markdownIt-Anchor" href="#minorgc-majorgc-fullgc和mixed-gc"></a> MinorGC、MajorGC 、FullGC和Mixed GC</h3><p><img src="/2022/03/29/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><code>Minor GC</code>：从年轻代（Eden和survivor区域）回收内存，这个区域的对象生存周期短，发生gc的次数比较频繁，回收速度比较快，一般采用复制算法</p><p><code>Major GC</code>： 是清理老年代</p><p><code>Full GC</code>：清理整个堆空间，包含年轻代，老年代，永久代（方法区和元空间）的垃圾回收，一般耗时比较长，因此必须降低FullGC的频率</p><ul><li>老年代空间不足，Survivor晋升对象大小大于老年代剩余空间</li><li>Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</li><li>Metaspace区内存达到阈值（20M）</li><li>达到收集器收集的阈值（90%）</li></ul><p><code>Mixed GC</code>：对新生代和老年代同时进行垃圾回收，将新生代和部分老年代一起进行回收，以减少<code>SWT</code>的时间</p><p><code>stop the word 现象</code> GC线程执行垃圾对象回收而挂起所有工作线程，程序会出现卡顿现象</p><h3 id="内存分配策略"><a class="markdownIt-Anchor" href="#内存分配策略"></a> 内存分配策略</h3><p class="note note-primary">优先分配到Eden</p><p>基本上几乎所有新建的对象都会被分配到 <code>Eden</code>区域，<code>Eden</code>区域每次发生<code>GC</code>都会被清除</p><p class="note note-primary">大对象直接分配到老年代</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">PretenureSizeThreshold</span>=6M 指定多大的对象直接放进老年区<br>生效的垃圾收集器 Serial,ParNew,G1<br></code></pre></td></tr></table></figure><p class="note note-primary">长期存活的对象分配到老年代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">默认是<span class="hljs-number">15</span>次GC后进入老年代，可以有参数设置，也非必要<span class="hljs-number">15</span>次Minor GC才能进入老年代，因为还有动态对象年龄分配<br>-XX:MaxTenuringThreshold=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p class="note note-primary">动态对象年龄判断</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">Survivor区中相同年龄的对象大小的总和大于Survivor空间的一半，大于或等于该年龄的对象可以直接进入老年代<br></code></pre></td></tr></table></figure><p class="note note-primary">空间分配担保</p><p>触发场景：<code>Eden</code>区域有对象要进入<code>Survivor</code>区域，<code>Survivor</code>区域满了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1.6</span>后默认开启，不用手动设置<br>老年代的连续空间大于新生代对象总大小或者历次新生代对象晋升老年代平均大小就会进行Minor <span class="hljs-built_in">GC</span>（将survivor区域复制到老年代），否则将进行Full <span class="hljs-built_in">GC</span><br></code></pre></td></tr></table></figure><p class="note note-primary">逃逸分析与栈上分配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:+DoEscapeAnalysis <span class="hljs-number">1.6</span>后默认开启<br>逃逸分析：对象仅在当前作用于下有效（成员变量会发生逃逸）<br>为了提高GC的回收效率，对象实例的内存分配不一定必须存在于堆区中，还可采用堆外分配。而最常见的堆外分配就是采用逃逸分析筛选出未发生逃逸的对象，在栈帧中分配内存空间<br></code></pre></td></tr></table></figure><h3 id="判断对象是否死亡"><a class="markdownIt-Anchor" href="#判断对象是否死亡"></a> 判断对象是否死亡</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡，<span class="green-line"><strong>当一个对象不再被任何存活的对象继续引用的时候，就可以宣判为死亡了</strong></span></p><p><strong>分代内存区域划分</strong></p><p>Eden : Survivor1 : Survivor2 = 8 : 1 : 1</p><p>新生代：老年代 = 1：3</p><h4 id="引用计数法"><a class="markdownIt-Anchor" href="#引用计数法"></a> 引用计数法</h4><p><img src="/2022/03/29/jvm/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>引用计数算法（Reference Counting）比较简单，<strong>对每个对象保存一个整型的引用计数器属性</strong>。用于记录对象被引用的情况。</li><li>对于一个对象A，<strong>只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收</strong></li></ul><p><strong>优点</strong>：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p><strong>缺点</strong>：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li><span class="green-line">引用计数器有一个严重的问题，即<font color="red"><strong>无法处理循环引用</strong></font>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。<span></span></span></li></ul><p><code>在 Netty 的直接内存缓冲区中有实际落地场景</code></p><h4 id="可达性分析算法"><a class="markdownIt-Anchor" href="#可达性分析算法"></a> 可达性分析算法</h4><p><img src="/2022/03/29/jvm/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" srcset="/img/loading.gif" lazyload alt></p><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ul><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ul><p class="note note-primary">实现思路</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p class="note note-primary">GC ROOT</p><ul><li>虚拟机栈中局部变量表引用的对象</li><li>方法区中静态变量引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（StringTable）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>系统类加载器</li></ul><p><code>总之只要不会被GC所回收的对象都能被当作GC ROOT</code></p><p><strong>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合</strong> <em>（比如Minor GC 使用老年代对象作为 GC Root）</em></p><p class="note note-primary">注意</p><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么<strong>分析工作必须在一个能保障一致性的快照中进行</strong>。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须<code>Stop The World</code>的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ul><h4 id="三色标记"><a class="markdownIt-Anchor" href="#三色标记"></a> 三色标记</h4><p><img src="/2022/03/29/jvm/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0.png" srcset="/img/loading.gif" lazyload alt></p><p>Java的三色标记法是一种垃圾收集算法，它的核心思想是将对象分为三种颜色来标记其状态，从而决定哪些对象可以被回收。</p><ol><li>白色（White，垃圾对象）：表示尚未扫描的对象。在初始标记阶段，所有的对象都是白色的。</li><li>灰色（Gray）：没有完全扫描的对象。</li><li>黑色（Black）：完全扫描的对象，对象是可达的，不会被垃圾回收。</li></ol><p>但仅仅将对象划分成三个颜色还不够，真正关键的是：实现根可达算法的时候，将整个过程拆分成了<code>初始标记</code>、<code>并发标记</code>、<code>重新标记</code>、<code>并发清除</code>四个阶段</p><ul><li>初始标记阶段，指的是标记 GCRoots 直接引用的节点，将它们标记为灰色，这个阶段需要 STW</li><li>并发标记阶段，指的是从灰色节点开始，去扫描整个引用链，然后将它们标记为黑色，这个阶段不需要 STW</li><li>重新标记阶段，指的是去校正并发标记阶段的错误，这个阶段需要（漏标） STW</li><li>并发清除，指的是将已经确定为垃圾的对象清除掉，这个阶段不需要 STW</li></ul><p class="note note-primary">多标</p><p>多标问题指的是原本应该回收的对象，被多余地标记为黑色存活对象，从而导致该垃圾对象没有被回收</p><p><code>原因</code>：多标问题会出现，是因为在并发标记阶段，有可能之前已经被标记为存活的对象，其引用被删除，从而变成了不可达对象</p><p><img src="/2022/03/29/jvm/%E5%A4%9A%E6%A0%87.png" srcset="/img/loading.gif" lazyload alt="多标"></p><p>多标问题会导致内存产生浮动垃圾，但好在其可以再下次 GC 的时候被回收，因此问题还不算很严重</p><p class="note note-primary">漏标</p><p>原本存活的对象，被遗漏标记为黑色，从而导致该对象被错误回收</p><p><code>原因</code>：并发标记和对象引用关系的变化导致的</p><p>条件</p><ul><li>至少一个黑色对象引用了白色对象</li><li>所有的灰色对象在扫描完成之前断开对白色对象的引用</li></ul><p><img src="/2022/03/29/jvm/%E6%BC%8F%E6%A0%87.png" srcset="/img/loading.gif" lazyload alt="漏标"></p><p>解决漏标</p><ul><li>CMS采用的是 <code>增量更新</code></li><li>G1采用的是 <code>原始快照</code></li></ul><h3 id="对象的-finalization-机制"><a class="markdownIt-Anchor" href="#对象的-finalization-机制"></a> 对象的 finalization 机制</h3><p>Finalization机制是一种对象销毁前的回调函数，通常通过重写对象的 <code>finalize()</code> 方法来实现，finalize()只会被GC线程调用一次</p><ul><li>当一个垃圾对象被回收前，总会先调用这个对象的finalize()方法。</li><li>它允许在对象被垃圾回收之前执行一些特定的清理操作（已不推荐使用）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待被重写</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">不主动调用finalize()方法</p><ul><li>在 <code>finalize()</code> 方法中可能导致对象复活，使其从垃圾状态恢复为存活状态。</li><li><code>finalize()</code> 方法的执行时机是不确定的，由垃圾回收线程决定</li><li>一个糟糕的 <code>finalize()</code> 方法可能严重影响垃圾回收的性能。比如finalize是个死循环</li></ul><p class="note note-primary">对象的生命周期</p><p>Finalization机制存在的情况下，Java对象可以处于三种状态：</p><ol><li><strong>可触及的（Reachable）</strong>：从根节点出发，可以访问到这个对象，它处于活动状态</li><li><strong>可复活的（Finalizable）</strong>：对象的所有引用都被释放，但对象有可能在 <code>finalize()</code> 方法中复活，它处于一种临时状态</li><li><strong>不可触及的（Unreachable）</strong>：对象的 <code>finalize()</code> 方法已被调用，且没有复活，对象进入不可触及状态，不可再被引用或复活</li></ol><p class="note note-primary">对象的自救</p><p>要判断一个对象是否可回收，需要经历两次标记过程：</p><ul><li>如果对象无法从任何根节点访问到，首先进行第一次标记</li><li>进行筛选，判断对象是否需要执行 <code>finalize()</code> 方法：<ul><li>如果对象没有重写 <code>finalize()</code> 方法，或者 <code>finalize()</code> 方法已经被调用过，视为不需要执行，对象被判定为不可触及</li><li>如果对象重写了 <code>finalize()</code> 方法且未执行过，对象被插入到Finalizer队列中，由Finalizer线程触发其<code>finalize()</code>方法执行</li></ul></li></ul><p><code>finalize()</code> 方法是对象逃脱死亡的最后机会。如果在 <code>finalize()</code> 方法中与引用链上的任何一个对象建立了联系，对象将被移出&quot;即将回收&quot;集合。然后，对象会再次处于没有引用的状态，此时 <code>finalize()</code> 方法不会再次被调用，对象变为不可触及状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanReliveObj</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj obj;<span class="hljs-comment">//类变量，属于 GC Root</span><br><br><br>    <span class="hljs-comment">//此方法只能被调用一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>        obj = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanReliveObj</span>();<br>            <span class="hljs-comment">// 对象第一次成功拯救自己</span><br>            obj = <span class="hljs-literal">null</span>;<br>            System.gc();<span class="hljs-comment">//调用垃圾回收器</span><br>            System.out.println(<span class="hljs-string">&quot;第1次 gc&quot;</span>);<br>            <span class="hljs-comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第2次 gc&quot;</span>);<br>            <span class="hljs-comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span><br>            obj = <span class="hljs-literal">null</span>;<br>            System.gc();<br>            <span class="hljs-comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br>输出 <br>第<span class="hljs-number">1</span>次 gc<br>调用当前类重写的finalize()方法<br>obj is still alive<br>第<span class="hljs-number">2</span>次 gc<br>obj is dead<br><br></code></pre></td></tr></table></figure><p><strong>如果注释掉finalize()方法,输出结果:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">第<span class="hljs-number">1</span>次 gc<br>obj is dead<br>第<span class="hljs-number">2</span>次 gc<br>obj is dead<br></code></pre></td></tr></table></figure><h3 id="垃圾回收算法"><a class="markdownIt-Anchor" href="#垃圾回收算法"></a> 垃圾回收算法</h3><p><strong>垃圾清除阶段</strong></p><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><h4 id="标记-清除算法"><a class="markdownIt-Anchor" href="#标记-清除算法"></a> 标记-清除算法</h4><p><img src="/2022/03/29/jvm/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" srcset="/img/loading.gif" lazyload alt></p><p><code>空闲链表</code> <code>空间碎片</code></p><p>执行过程</p><p>用于在堆中清理不再使用的对象。它的执行过程可以分为两个阶段 <code>标记</code> 阶段和 <code>清除</code> 阶段</p><ol><li><strong>标记阶段（Mark Phase）</strong>：<ul><li>在标记清除算法的第一阶段，垃圾收集器从根对象开始，遍历整个对象图，并标记所有可以从根对象访问到的对象。</li><li>垃圾收集器会将已标记的对象标记为&quot;存活&quot;，而未标记的对象被视为&quot;垃圾&quot;。</li></ul></li><li><strong>清除阶段（Sweep Phase）</strong>：<ul><li>在清除阶段，垃圾收集器遍历特定的内存区域，将未标记的对象（即垃圾对象）进行回收，释放它们占用的内存空间。</li><li>清除操作通常是通过将对象所在的内存标记为空闲来实现的，使其可以用于后续的内存分配。</li></ul></li></ol><p class="note note-primary">缺点</p><ul><li>效率低下：需要找到未被标记的对象进行回收</li><li>停顿时间长：垃圾回收期间停止整个应用程序的运行（STW，Stop-The-World），以便进行标记和清除操作</li><li>内存碎片：使用空闲链表标记已回收的内存空间，内存不连续，使用效率低</li></ul><h4 id="复制算法"><a class="markdownIt-Anchor" href="#复制算法"></a> 复制算法</h4><p><img src="/2022/03/29/jvm/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><code>指针碰撞</code> <code>需要两倍内存空间</code></p><p>复制算法被广泛应用于新生代垃圾收集器中。它的核心思想是：</p><ol><li>将内存分成两个相等大小的区域</li><li>然后将活跃对象复制到一个新的内存区域（Eden区和Survivor的From和To区）</li><li>最后将不活跃的对象清除掉</li></ol><p class="note note-primary">优缺点</p><p><code>优点</code></p><ul><li>实现简单，运行高效</li><li>活跃对象被复制后，会直接释放整块内存区域，不存在内存碎片</li></ul><p><code>缺点</code></p><ul><li>需要两倍的内存空间（空间换时间）</li><li>其他对象要更新移动对象的引用关系，有额外的性能开销</li></ul><h4 id="标记-压缩算法"><a class="markdownIt-Anchor" href="#标记-压缩算法"></a> 标记-压缩算法</h4><p><img src="/2022/03/29/jvm/%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" lazyload alt></p><p><code>指针碰撞</code> <code>整理空间碎片，效率更低</code></p><p class="note note-primary">背景</p><ul><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法</strong></li><li>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生</li><li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本</li></ul><p class="note note-primary">实现</p><ul><li>对象标记完成后，存活对象往内存的一端移动，非存活对象往反方向移动</li><li>移动存活对象时，需要更新所有引用这些对象的引用地址</li><li>找到存活对象的内存的临界点，释放临界点外的内存</li></ul><p class="note note-primary">比较</p><ul><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法</li><li>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策</li><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销</li></ul><p class="note note-primary">优缺点</p><p><code>优点</code></p><ul><li>消除了标记-清除算法当中存在内存碎片问题</li><li>消除了复制算法当中，内存使用翻倍成本</li></ul><p><code>缺点</code></p><ul><li>效率相对较低，标记-整理算法要低于复制算法</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整对象引用的地址</li><li>移动过程中，需要全程暂停用户应用程序，造成STW</li></ul><h4 id="分代收集算法"><a class="markdownIt-Anchor" href="#分代收集算法"></a> 分代收集算法</h4><p>分代收集算法并不是一种新的算法，而是根据场景不同使用不同的算法，比如新生代中使用复制算法，老年代中使用标记-清除，标记-压缩算法</p><p><strong>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点</p><ul><li>年轻代（Young Gen）<ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li></ul></li><li>老年代（Tenured Gen）<ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现<ul><li>标记阶段的开销与存活对象的数量成正比</li><li>清除阶段的开销与所管理区域的大小成正相关</li><li>压缩阶段的开销与存活对象的数据成正比</li></ul></li></ul></li><li>以HotSpot中的CMS回收器为例，CMS是基于标记-清除算法实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于标记-压缩算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。<br>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代​</li></ul><p>​</p><h4 id="垃圾回收算法小结"><a class="markdownIt-Anchor" href="#垃圾回收算法小结"></a> 垃圾回收算法小结</h4><ul><li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存</li><li>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</li></ul><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h3 id="评估gc的性能指标"><a class="markdownIt-Anchor" href="#评估gc的性能指标"></a> 评估GC的性能指标</h3><table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td>吞吐量</td><td>运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</td></tr><tr><td>垃圾收集开销</td><td>吞吐量的补数，垃圾收集所用时间与总运行时间的比例</td></tr><tr><td>暂停时间</td><td>执行垃圾收集时，程序的工作线程被暂停的时间</td></tr><tr><td>收集频率</td><td>相对于应用程序的执行，收集操作发生的频率</td></tr><tr><td>内存占用</td><td>Java堆区所占的内存大小</td></tr><tr><td>快速</td><td>一个对象从诞生到被回收所经历的时间</td></tr></tbody></table><ul><li><strong>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”</strong>。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li><li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li><li>简单来说，主要抓住两点：<ul><li>吞吐量</li><li>暂停时间</li></ul></li></ul><p class="note note-primary">吞吐量（throughput）</p><ol><li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<span class="green-line">吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</span><ul><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li></ul></li><li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li><li>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2=0.4</li></ol><p><img src="/2022/03/29/jvm/%E5%90%9E%E5%90%90%E9%87%8F.png" srcset="/img/loading.gif" lazyload alt="img"></p><p class="note note-primary">暂停时间（pause time）</p><ol><li><code>暂停时间</code>是指一个时间段内应用程序线程暂停，让GC线程执行的状态。<ul><li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li></ul></li><li>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1=0.5，但是总的GC时间可能会长</li></ol><p><img src="/2022/03/29/jvm/%E4%BD%8E%E5%BB%B6%E8%BF%9F.png" srcset="/img/loading.gif" lazyload alt="img"></p><h3 id="垃圾回收器"><a class="markdownIt-Anchor" href="#垃圾回收器"></a> 垃圾回收器</h3><p><img src="/2022/03/29/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th>回收器</th><th>特点</th><th>线程模型</th><th>新/老年代</th><th>回收算法</th></tr></thead><tbody><tr><td>Serial</td><td>单线程串行收集器</td><td>串行收集器</td><td>新生代</td><td>复制算法</td></tr><tr><td>ParNew</td><td>多线程并行Serial收集器</td><td>并行收集器</td><td>新生代</td><td>复制算法</td></tr><tr><td>Parallel Scavenge</td><td>并行吞吐量优先收集器</td><td>并行收集器</td><td>新生代</td><td>复制算法</td></tr><tr><td>Serial Old</td><td>Serial单线程收集器老年代版本</td><td>串行收集器</td><td>老年代</td><td>标记-压缩</td></tr><tr><td>CMS(Concurrent Mark Sweep)</td><td>并行最短停顿时间收集器</td><td>并发收集器</td><td>老年代</td><td>标记-清除</td></tr><tr><td>Parallel Old</td><td>Parallel Scavenge并行收集器老年代版本</td><td>并行收集器</td><td>老年代</td><td>标记-压缩</td></tr><tr><td>G1</td><td>面向局部收集和基于Region内存布局的新型低延时收集器</td><td>并发/并行收集器</td><td>新生代/老年代</td><td>三色标记</td></tr></tbody></table><p><strong>JDK8 默认垃圾收集器是Parallel Scavenge+Parallel Old</strong></p><h4 id="serial"><a class="markdownIt-Anchor" href="#serial"></a> Serial</h4><p><img src="/2022/03/29/jvm/seria.png" srcset="/img/loading.gif" lazyload alt></p><p><code>新生代</code> <code>串行执行</code> <code>复制算法</code></p><p>它是一种单线程的垃圾回收器，意味着它在执行垃圾回收操作时只使用一个线程，因此在垃圾回收过程中会暂停应用程序的执行，吞吐量较差</p><ul><li><code>单线程执行</code>：它在执行垃圾回收操作时只使用一个线程。这使得它在多核处理器上的性能表现相对较差。因为它是串行的，所以它执行垃圾回收时会暂停应用程序的所有线程</li><li><code>复制算法</code>： Serial垃圾回收器通常用于新生代（Young Generation）的垃圾回收。在新生代中，它使用复制算法回收垃圾对象</li><li><code>适用于客户端应用</code>：由于Serial垃圾回收器的特点，它通常用于客户端应用程序，如桌面应用程序或移动应用程序，对吞吐量要求不高的场景</li><li><code>最悠久的垃圾回收器</code>：Serial收集器是最基本、历史最悠久的垃圾收集器了，JDK1.3之前回收新生代唯一的选择</li><li><code>指定Serial收集器</code>：<code>-XX:+UseSerialGC</code></li></ul><h4 id="serial-old"><a class="markdownIt-Anchor" href="#serial-old"></a> Serial Old</h4><p><code>串行执行</code> <code>标记-整理算法</code></p><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了串行回收和&quot;Stop the World&quot;机制，只不过内存回收算法使用的是 <code>标记-压缩算法</code></p><ul><li><p><code>简单高效</code>：对于单核CPU来说，Serial收集器没有线程切换的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择</p></li><li><p><code>标记-整理算法</code>： Serial Old垃圾收集器使用标记-整理（Mark-Sweep-Compact）算法，有助于减少内存碎片，提高内存利用率</p></li><li><p><code>不适用于高吞吐量需求</code>：Serial Old垃圾回收器是单线程的，不适合要求高吞吐量的大型服务器应用程序，因为它可能导致较长的垃圾回收停顿时间，影响应用程序的响应性</p></li><li><p><code>指定Serial收集器</code>：<code>-XX:+UseSerialGC</code> 等价于新生代用Serial GC，且老年代用Serial Old GC</p></li></ul><p class="note note-primary">Server模式下的用途</p><p>Serial Old是运行在 <code>Client模式</code> 下默认的老年代的垃圾回收器，Serial Old在 <code>Server模式</code> 下主要有两个用途</p><ul><li>与新生代的Parallel Scavenge配合使用</li><li>作为老年代CMS收集器内存整理的方案</li></ul><h4 id="parnew"><a class="markdownIt-Anchor" href="#parnew"></a> ParNew</h4><p><img src="/2022/03/29/jvm/ParNewr.png" srcset="/img/loading.gif" lazyload alt></p><p><code>新生代</code> <code>多线程并行回收</code> <code>复制算法</code> <code>提高吞吐量</code> <code>配合CMS使用</code></p><ul><li><p><code>多线程执行</code>： ParNew是Serial的多线程版本，利用多个处理器核心并行执行垃圾回收操作，从而提高了吞吐量</p></li><li><p><code>适用于多核处理器</code>：ParNew是多线程的垃圾回收器，因此在多核处理器上表现良好，适用于需要更高吞吐量的应用程序</p></li><li><p><code>与CMS配合使用</code>：早期这种组合旨在最大程度地减少应用程序的停顿时间，适用于需要低延迟的应用</p></li><li><p><code>启用选项</code>：</p><ul><li>设置新生代垃圾收集器，不影响老年代 <code>-XX:+UseParNewGC</code></li><li>限制并行线程数，默认开启和CPU核心相同的线程数，<code>-XX:ParallelGCThreads</code></li></ul></li></ul><p class="note note-primary">ParNew 回收器与 Serial 回收器比较</p><p>由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p><ol><li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li><li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li></ol><h4 id="parallel-scavenge"><a class="markdownIt-Anchor" href="#parallel-scavenge"></a> <strong>Parallel Scavenge</strong></h4><p><img src="/2022/03/29/jvm/parallel.png" srcset="/img/loading.gif" lazyload alt></p><p><code>复制算法</code> <code>并行回收</code> <code>吞吐量优先</code> <code>自适应调节策略</code></p><p>吞吐量 = 程序运行时间 /（程序运行时间 + GC时间）</p><ul><li>注重提供高吞吐量和可控制的垃圾回收延迟</li><li>吞吐量优先<ul><li>尽可能地减少垃圾回收停顿时间的同时，也更关注程序的总吞吐量</li><li>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li></ul></li></ul><p class="note note-primary">自适应调节策略</p><p><span class="green-line">开启后就不需要人工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 与 <code>Survisor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、直接晋升老年代对象大小（<code>-XX:PretenureSizeThreshold</code>）</span></p><ul><li><code>-XX:+UseParallelGC</code>: 手动指定年轻代使用Parallel并行收集器执行内存回收任务</li><li><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能</li><li><code>-XX:MaxGCPauseMillis</code>: <strong>设置垃圾收集器最大停顿时间</strong>（即STW的时间），单位是毫秒 （<strong>设置越小堆空间可能越小，GC越频繁</strong>）</li><li><code>-XX:GCTimeRatio</code>: <strong>垃圾收集时间占总时间的比例</strong>，即等于 1 / (N+1) ，用于衡量吞吐量的大小<ul><li>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1</li><li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code> 设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong><ul><li><strong>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整</strong>，已达到在堆大小、吞吐量和停顿时间之间的平衡点</li></ul></li></ul><h4 id="parallel-old"><a class="markdownIt-Anchor" href="#parallel-old"></a> Parallel Old</h4><p><code>多线程</code> <code>标记-压缩</code></p><p><code>适合场景</code>：配合 Parallel Scavenge 运行在不太关注停顿时间的后台计算任务</p><ul><li><p><strong>标记-整理</strong></p></li><li><p><strong>自适应调节</strong></p><ul><li>调整垃圾回收线程</li><li>调整吞吐量</li></ul></li><li><p><strong>多线程执行</strong>：Java 1.6 用户代替老年代Serial Old单线程收集器</p></li><li><p><strong>吞吐量优先</strong>：设计目标是提供高吞吐量。它在尽可能减少垃圾回收停顿时间的同时，更关注程序的总吞吐量</p></li><li><p><strong>不适用于低延迟需求</strong>：由于Parallel Old更关注的是吞吐量（吞吐量优先），它不适合对低停顿时间有极高要求的应用程序</p></li><li><p><span class="green-line"><strong>在Java8中，默认是此垃圾收集器。</strong></span></p></li></ul><p class="note note-primary">参数</p><p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel并行收集器执行内存回收任务</p><p><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器</p><ul><li>分别适用于新生代和老年代</li><li>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</li></ul><h4 id="cms"><a class="markdownIt-Anchor" href="#cms"></a> CMS</h4><p><img src="/2022/03/29/jvm/cms.png" srcset="/img/loading.gif" lazyload alt></p><p><code>已经被ZGC干掉</code> <code>最求停顿时间和用户体验</code> <code>第一款并行并发回收器</code> <code>主打停顿时间</code> <code>三色标记</code> <code>标记-清除</code></p><p>CMS 旨在减小垃圾回收的停顿时间（在JDK1.5时期推出），适用于那些需要低延迟和响应性能的应用程序。它是第一款真正意义上的并发收集器，<span class="green-line">第一次实现了垃圾收集线程与用户线程同时工作</span>，并且使用的是 <code>标记-清除</code> 算法</p><p class="note note-primary">优点</p><ul><li><strong>低停顿时间</strong>：CMS与用户线程并发工作，使得在标记阶段应用程序的停顿时间极短</li><li><strong>并发执行</strong>：允许用户线程和垃圾回收线程同时执行，缩短SWT时间</li><li><strong>可控停顿时间</strong>：可设置期望最大的停顿时间，控制程序的停顿时间，提高用户体验</li><li><strong>适用于大堆</strong>：由于其并发特性，CMS能够高效地处理大规模内存，避免出现过长的停顿</li></ul><p class="note note-primary">缺点</p><ul><li><strong>内存碎片</strong>：标记-清除算法导致内存碎片，随着时间推移，可能会累积，降低内存的有效利用率</li><li><strong>CPU开销</strong>：垃圾回收器线程与应用程序线程竞争CPU资源，这可能会影响应用程序的整体性能</li><li><strong>无法处理浮动垃圾</strong>：在并发标记阶段，用户线程和垃圾收集线程同时运行或者交叉运行。如果产生新的垃圾对象，CMS将无法对其进行标记</li><li><strong>需要整理内存碎片</strong>：内存碎片问题需要委托给Serial Old来处理，随着堆的增大，可能会导致较长的停顿时间</li></ul><p class="note note-primary">三色标记</p><p>使用三色标记判断对象是否垃圾对象的过程</p><p>三色</p><ul><li><strong>黑色（Black）</strong>：这些对象是被标记为可达的，不是垃圾对象。</li><li><strong>灰色（Gray）</strong>：这些对象是初始标记和并发标记阶段被标记为可达的，但还未经过重新标记。它们需要重新标记后才能确定是否为垃圾对象。</li><li><strong>白色（White）</strong>：这些对象是未被标记为可达的，被认定为垃圾对象，将在清理阶段被回收。</li></ul><p>过程</p><ul><li><strong>初始标记</strong>：CMS首先对根对象进行标记，将它们标记为灰色。这是一个STW（Stop-The-World）的短暂停顿阶段，用于确定哪些对象是直接可达的。这些被标记的对象是灰色</li><li><strong>并发标记</strong>：GC线程与用户线程并行执行，继续标记从根对象可达的对象，以及它们所引用的对象，直到无法再继续标记新对象为止。这些被标记的对象是黑色</li><li><strong>重新标记</strong>：在重新标记阶段，CMS对并发标记期间发生状态变化的对象进行修正，例如在并发标记期间某些对象可能由于应用程序活动而变成了可达状态。这一阶段需要一次STW停顿，但持续时间通常很短</li><li><strong>并发清理</strong>：GC线程与用户线程并行执行，清理白色对象</li></ul><p class="note note-primary">参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td>手动启用CMS垃圾回收器，执行内存回收任务。开启此参数会自动启用ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</td></tr><tr><td>-XX:CMSInitiatingOccupanyFraction</td><td>设置触发CMS回收的堆内存使用率阈值。JDK5及以前版本默认值为68%，JDK6及以上版本默认值为92%。可以根据内存增长情况调整，以优化性能。</td></tr><tr><td>-XX:+UseCMSCompactAtFullCollection</td><td>指定在执行完Full GC后对内存空间进行压缩整理，以避免内存碎片。注意，这会增加停顿时间。</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>设置在执行多少次Full GC后对内存空间进行压缩整理。</td></tr><tr><td>-XX:ParallelCMSThreads</td><td>设置CMS的线程数量。</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>设置最大停顿时间。</td></tr><tr><td>其他信息</td><td>CMS默认启动的线程数是 (ParallelGCThreads + 3) / 4，其中ParallelGCThreads是年轻代并行收集器的线程数，这可能会影响应用程序性能。</td></tr></tbody></table><p class="note note-primary">漏标解决</p><p><img src="/2022/03/29/jvm/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0.png" srcset="/img/loading.gif" lazyload alt="增量更新"></p><p><code>漏标</code>：在并发标记阶段，某些对象由于并发执行和对象状态的变化，未能被正确标记为可达对象</p><p>为了应对漏标问题，CMS采用了 <code>增量更新</code>（Incremental Update）方法来解决：</p><ul><li><strong>记录状态变化</strong>：并发标记阶段，如果某个对象从可达状态变为不可达状态（例如，被删除或修改），CMS会详细记录这个状态变化</li><li><strong>重新标记阶段</strong>：重新标记阶段，CMS会根据记录的状态变化信息，有针对性地重新检查那些发生变化的对象，并确保它们被正确地标记为不可达状态</li></ul><h4 id="g1"><a class="markdownIt-Anchor" href="#g1"></a> G1</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/121724998">G1详解</a></p><p><code>动态Region管理</code> <code>无传统分代</code> <code>优先级回收</code> <code>可控停顿时间</code> <code>三色标记</code> <code>标记整理</code></p><p>G1垃圾收集器采用一种非传统的内存布局方式，它不再将堆内存严格划分为新生代和老年代，而是将整个堆内存划分为大小相等的逻辑内存块，称为&quot;Region&quot;。每个Region都是逻辑上连续的内存段，其具体大小会根据堆的实际大小而定，通常在1MB到32MB之间，而且必须是2的幂次方大小。与传统内存布局不同的是，G1不再要求相同类型的Region在物理内存上相邻，而是允许通过动态分配来实现逻辑上的连续性。</p><p><span class="green-line">G1垃圾收集器的核心思想是跟踪每个Region中垃圾的堆积情况，并根据预设的垃圾回收时间目标来确定回收的优先级。这使得G1能够避免全堆垃圾回收，而是选择回收优先级最高的区域。</span>这种方式能够显著减少程序停顿（stop-the-world）的时间，使其更加短暂和可预测。同时，G1垃圾收集器在有限的时间内能够获得最高的垃圾回收效率。</p><p class="note note-primary">分区Region</p><p><img src="/2022/03/29/jvm/Region.png" srcset="/img/loading.gif" lazyload alt></p><p><code>G1</code> 垃圾收集器将堆内存划分为若干个 Region，每个区域只扮演其中一个角色，包括 <code>Eden区</code>、<code>Survivor区</code> 和 <code>Old区</code>。这种划分允许新生代的Region在需要时直接转化为老年代的Region</p><p><strong>H区（Humongous）</strong>：这个特殊区域专门用于存放巨大对象。G1垃圾回收器将对象大小超过Region容量的 <code>50%以上</code> 的对象标记为巨大对象。在其他垃圾回收器中，这类巨大对象通常会被分配到老年代，但这可能导老年代频繁GC</p><p>如果一个H区无法容纳一个巨型对象，G1会寻找连续的H分区来存储该对象。如果找不到足够的连续H区，G1可能会被迫触发 <code>Full GC</code></p><p class="note note-primary">Remember Set</p><p>在分代算法的场景下，线程执行的过程中，对象可能存储在新生代，也可能在老年代。那么，如果对象之间的引用关系，大概率会存在对象 <code>跨代引用</code></p><p><img src="/2022/03/29/jvm/RememberedSet.png" srcset="/img/loading.gif" lazyload alt></p><p>在触发新生代GC 的时候，由于 GC Roots 到 E 和 G 是不可达的，那么 E 和 G 将会被当作垃圾对象回收。导致 H 和 J 指向的地址不再是存放 E 和 G，并且是不确定的，这将会造成程序崩溃</p><p><span class="green-line">Remember Set主要用于帮助G1垃圾回收器跟踪对象之间的引用关系</span></p><p>在G1垃圾回收器中，Remember Set 用于记录哪些非收集区域的对象引用了收集区域的对象。具体来说，在新生代GC中，Remember Set 记录哪些老年代对象（非收集区域）引用了新生代对象（收集区域）</p><p>作用</p><ul><li><p><code>跟踪跨区域引用关系</code>：记录其他区域对象对本区域对象的引用</p></li><li><p><code>辅助垃圾回收</code>：使用Remembered Set，G1可以更快地确定哪些区域与其他区域有较少的交互引用，从而回收收益更大的内存区域</p></li></ul><p class="note note-primary">写屏障</p><p>写屏障是一个机制（类似AOP），它的目的是在写操作发生时，通知垃圾回收器，以便更新记忆集。当一个对象引用另一个对象，或者引用关系被取消时，写屏障会记录这些变化（记录原始快照）</p><p>G1中写屏障的一般工作流程：</p><ol><li>当对象引用发生变化时，例如，一个对象引用了另一个对象，JVM会在执行此引用变化的地方插入写屏障代码</li><li>写屏障代码负责将这个引用变化记录到相应的记忆集中，以便在垃圾回收时可以找到受影响的对象</li><li>垃圾回收器描这些记忆集，防止对象被错误标记</li></ol><p>写屏障用于Rset记录对象间的引用，不直接修改Rset是因为存在并发修改，是把脏卡片放到队列中慢慢更新的</p><p>JVM注入的一小段代码，用于记录指针变化（类似AOP记录原始快照STAB）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设 A 是老年代，B是新生代的跨区引用</span><br>A.b = B<br></code></pre></td></tr></table></figure><ul><li>当指针更新时<ul><li>将A对应的 Card 标记为 Dirty Card</li><li>将 Card 存入 Dirty Card Queue</li><li>队列有白/绿/黄/红四个颜色</li></ul></li></ul><p><img src="/2022/03/29/jvm/DirtyCard.png" srcset="/img/loading.gif" lazyload alt="Dirty Card Queue"></p><ul><li><code>白色</code>：RSet修改缓慢，一切正常</li><li><code>绿色</code>：Refinement线程（优化线程池）开始被激活，开始更新RS<ul><li>具体操作：正常的从队列中拿出DirtyCard，并更新到对应的RSet中</li></ul></li><li><code>黄色</code>：当产生藏卡片的速度非常快，所有的Refinement线程开始激活<ul><li>目的：全力以赴的把队列排空，目标就是不要让队列太慢</li></ul></li><li><code>红色</code>：应用线程也参与排空（清理Dirty Card Queue）队列的操作<ul><li>目的：GC线程和用户线程一起清空，使得Refinement能够得到及时的执行完毕</li></ul></li></ul><p class="note note-primary">Card</p><p><img src="/2022/03/29/jvm/%E5%8D%A1%E7%89%87.png" srcset="/img/loading.gif" lazyload alt="卡片"></p><p><code>拆分Region, 堆内存最小可用粒度</code></p><p>一个 Card Table 将一个 Region 在逻辑上划分为若干个固定大小（介于128到512字节之间）的连续区域，每个区域称之为卡片 Card。<span class="green-line">Card作用是跟踪区域内对象引用关系的变化，帮助确定哪些区域需要进行垃圾回收</span></p><p>具体而言，当一个对象引用了另一个对象时，G1垃圾回收器会将对应的卡片标记为 <code>脏卡片</code>，表示该卡片中的对象引用发生了变化。当垃圾回收器需要进行垃圾回收时，它可以快速检查哪些卡片是脏的，从而确定需要扫描和处理的区域</p><ul><li><strong>写屏障</strong>（记录原始快照）：Card还用于实现G1的写屏障机制。在对象引用关系变化时，将变化写入脏卡片后加入Dirty Card Queue，进行对象关系更新</li><li><strong>并发标记</strong>：对象引用关系更新，对应的卡片会被标记为脏卡片，G1通过扫描卡片来判断哪些区域中的对象是活动的，以便在标记过程中准确地识别垃圾对象</li></ul><p class="note note-primary">Card Table</p><p><img src="/2022/03/29/jvm/Card.png" srcset="/img/loading.gif" lazyload alt></p><p><span class="green-line">Card Table是一种数据结构，由一组字节组成，每个字节对应一个Card。用于跟踪对象之间的引用关系。它的主要目的是在垃圾回收过程中快速确定哪些对象是活跃的，从而只对这些对象执行回收操作，以提高回收效率</span></p><p>每个Card代表一个固定大小的内存区域，通常是一个内存页。默认情况下，所有的Card都被标记为未引用状态</p><p>当一个线程修改某个Region内部的引用时，它会通知Card Table，并更新相应的Card。这意味着当引用发生变化时，相关的Card将被标记为已引用状态，对应的Card的字节值会被标记为&quot;1&quot;，表示该地址空间中的对象是活跃的</p><p>为了更高效地跟踪引用变化，G1垃圾回收器将内存划分为许多Region，并为每个Region维护一个对应的Card Table。这样，当进行垃圾回收时，只需要处理与已标记为引用的Card相关的对象，而无需扫描整个堆</p><p class="note note-primary">Collect Set</p><p>​	<span class="green-line"><code>Collect Set</code>（CSet）是指，在回收阶段，由G1垃圾回收器选择的待回收的Region集合</span>，G1的目标是在限定的停顿时间内回收尽可能多的垃圾。因此，它会基于每个区域的存活对象的数量和其他历史数据来选择哪些区域应该被包含在Collection Set中。优先选择那些包含大量垃圾的区域可以确保在回收时获得最大的空间回报</p><p class="note note-primary">G1解决漏标</p><p><img src="/2022/03/29/jvm/%E5%8E%9F%E5%A7%8B%E5%BF%AB%E7%85%A7.png" srcset="/img/loading.gif" lazyload alt="原始快照 STAB"></p><p>STAB解决漏标问题的基本思想是，在进行并发标记的同时，跟踪并记录在并发标记过程开始之后发生的所有写操作（通过写屏障）。当发生写操作时（对象引用发生变化），STAB会将相关的对象引用信息记录在一个日志中，该日志称为 Remembered Set（记忆集）</p><p>当G1回收器需要对某个Region进行垃圾回收时，它会首先检查该Region对应的Remembered Set中的引用信息，重新检查对象的引用情况。从而将漏标的对象进行正确标记，避免错误地回收</p><p class="note note-primary">调参</p><table><thead><tr><th><strong>选项/默认值</strong></th><th>说明</th></tr></thead><tbody><tr><td><code>-XX:+UseG1GC</code></td><td>使用 G1 (Garbage First) 垃圾收集器</td></tr><tr><td><code>-XX:MaxGCPauseMillis=n</code></td><td>设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指<br>标(soft goal), JVM 会尽量去达成这个目标.</td></tr><tr><td><code>-XX:InitiatingHeapOccupancyPercent=n</code></td><td>启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来<br>触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比.<br>值为 0 则表示&quot;一直执行GC循环&quot;. 默认值为 45.</td></tr><tr><td><code>-XX:NewRatio=n</code></td><td>新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2.</td></tr><tr><td><code>-XX:SurvivorRatio=n</code></td><td>eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td></tr><tr><td><code>-XX:MaxTenuringThreshold=n</code></td><td>提升年老代的最大临界值(tenuring threshold). 默认值为 15.</td></tr><tr><td><code>-XX:ParallelGCThreads=n</code></td><td>设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台<br>不同而不同</td></tr><tr><td><code>-XX:ConcGCThreads=n</code></td><td>并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.</td></tr><tr><td><code>-XX:G1ReservePercent=n</code></td><td>设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认<br>值是 10.</td></tr><tr><td><code>-XX:G1HeapRegionSize=n</code></td><td>使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定<br>每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为<br>1Mb, 最大值为 32Mb.</td></tr></tbody></table><p class="note note-primary">收集过程</p><p><img src="/2022/03/29/jvm/G1%E6%94%B6%E9%9B%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload alt></p><ul><li><strong>初始标记</strong>：这是一个短暂的停顿阶段，主要标记与GC Roots 直接关联的对象，例如Remembered Set 中的引用。这个阶段的目标是快速确定哪些对象是存活的。</li><li><strong>并发标记</strong>：在这个阶段，G1垃圾回收器从GC Roots开始进行可达性分析，找出要回收的对象。与用户程序并发执行，不会导致长时间的停顿。它使用写屏障记录STAB（Snapshot-at-the-Beginning）信息到Remembered Set，以跟踪对象引用关系。</li><li><strong>最终标记</strong>：这是一个短暂的停顿阶段，用于重新处理并发标记阶段结束后遗留下来的少量SATB（Snapshot-at-the-Beginning）记录。它确保了标记过程的完整性。</li><li><strong>筛选回收</strong>：在这个阶段，G1垃圾回收器根据Region的回收价值和成本进行排序，并制定回收计划，以满足用户期望的停顿时间。然后，它将要回收的一部分Region中的存活对象复制到空的Region中，清理掉整个旧Region的全部空间。这个阶段也是与用户程序并发执行的。</li></ul><p class="note note-primary">Fully Yong GC</p><ul><li>STW（Stop The World）<ul><li>构建CS【Collection Set】（Eden+Survivor）</li><li>扫描GC Roots</li><li>Update RS：排空Dirty Card Queue，并更新Remember Set</li><li>Process RS：在Remember Set中找到被哪些老年代的对象跨代引用的。</li><li>Object Copy：常规的对新生代进行标记复制算法（复制到空的 Region 中）</li><li>Reference Processing：回收可以被回收的引用类型</li></ul></li></ul><p><code>调优</code></p><ul><li>G1记录每个阶段的时间，用于自动调优</li><li>记录Eden/Survivor的数量和GC时间<ul><li>根据暂停目标自动调整Region数量（如果达不到你设定的时间，则减少该Region的数量） 如果你设置了Eden区GC时间只能小于5ms，但是你一次回收了100ms，只能减少Eden区的数量来尽量满足你对该Region的GC最小暂停时间的设置</li><li>暂停目标越短，Eden数量越少 如果你设置的Eden区的Region过于短，那么可能会导致Eden区过于少，从而导致CPU大部分时间都在回收Eden区上。导致吞吐量下降（工作线程运行时长/运行总时长）</li><li>打印自适应的尺寸调节策略：<code>-XX:+PrintAdaptiveSizePolicy</code></li><li>打印老年代的提升的分布：<code>-XX:+PrintTenuringDistribution</code></li></ul></li></ul><p class="note note-primary">Old GC</p><ul><li>当堆用量达到一定程度时除法<ul><li>三色标记</li><li>-XX:IntiatingHeapOccupancyPercent=N</li><li>45 by default（默认是45）</li><li>Old GC是并发(concurrent)进行的</li></ul></li></ul><h4 id="zgc"><a class="markdownIt-Anchor" href="#zgc"></a> ZGC</h4><blockquote><p>TODO</p></blockquote><h2 id="jvm调优篇"><a class="markdownIt-Anchor" href="#jvm调优篇"></a> JVM调优篇</h2><h3 id="jvm调优参数"><a class="markdownIt-Anchor" href="#jvm调优参数"></a> JVM调优参数</h3><h4 id="jvm参数设置"><a class="markdownIt-Anchor" href="#jvm参数设置"></a> JVM参数设置</h4><table><thead><tr><th>参数</th><th>描述</th><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始化堆空间大小</td><td>-Xms64M</td><td>默认值：物理内存的1/64(&lt;1GB)</td></tr><tr><td>-Xmx</td><td>最大堆空间大小</td><td>-Xmx128M</td><td>默认值：物理内存的1/4(&lt;1GB)</td></tr><tr><td>-Xmn</td><td>新生代的空间大小</td><td>-Xmn32M</td><td>此处的大小是（eden+ 2 survivor space).<br>与jmap -heap中显示的New gen是不同的<br><br><strong>相当于对-XX:newSize、-XX:MaxnewSize<br>同时设置</strong><br><br>整个堆大小=新生代大小 + 老年代大小 +<br>持久代大小<br><br>增大年轻代会较少老年代,可能影响性能,<br>Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>新生代初始化内存的大小</td><td>-XX:NewSize=64M</td><td>注意：该值需要小于-Xms的值</td></tr><tr><td>-XX:MaxNewSize</td><td>新生代可被分配的内存的最大上限</td><td>-XX:MaxNewSize=1024M</td><td>默认：堆最大值的1/3</td></tr><tr><td>-XX:MetaspaceSize</td><td>元空间初始化空间大小</td><td>-XX:MetaspaceSize=256M</td><td>默认：物理内存的1/64</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>元空间可被分配内存的最大上限</td><td>-XX:MaxMetaspaceSize=1024M</td><td>最大：物理内存的1/4</td></tr><tr><td>-Xss</td><td>设置线程栈空间大小</td><td>-Xss512k</td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K，这个值和线程数量成反比</td></tr><tr><td>-XX:ThreadStackSize</td><td>和Xss类似</td><td>-XX:ThreadStackSize=2M</td><td>设置线程对堆栈大小</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor<br>区)与年老代的比值(除去持久代)</td><td>-XX:NewRatio=4</td><td>设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td>-XX:SurvivorRatio=8</td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄<br><code>Serial</code>、<code>ParNew</code>有效</td><td>-XX:MaxTenuringThreshold=15</td><td>默认：15<br><br>如果设置为0的话,则年轻代对象不经过<br>Survivor区,直接进入年老代. 对于年老<br>代比较多的应用,可以提高效率.如果将<br>此值设置为一个较大值,则年轻代对象<br>会在Survivor区进行多次复制,这样可<br>以增加对象在年轻代的存活时间,增加<br>在年轻代即被回收的概率<br><br>该参数只有在串行GC时才有效.</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大直接在老年代分配</td><td>-XX:PretenureSizeThreshold=1000000</td><td>默认值是0，意味着任何对象都会现在新生代分配内存</td></tr></tbody></table><h4 id="jvm辅助信息参数设置"><a class="markdownIt-Anchor" href="#jvm辅助信息参数设置"></a> JVM辅助信息参数设置</h4><table><thead><tr><th>参数</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>打印GC信息</td><td>输出形式:[GC 118250K-&gt;113543K(130112K),<br>0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K),<br>0.0650971 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印GC明细</td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K),<br>0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs]<br>[GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs]<br>[Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs]<br>121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td>-XX:PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息</td><td></td></tr><tr><td>-verbose:gc</td><td>输出虚拟机GC详情</td><td>-XX:+PrintGCDetails 稳定版</td></tr><tr><td>-XX:+PrintCommandLineFlags</td><td>查看当前垃圾回收器</td><td></td></tr></tbody></table><h4 id="printgcdetails-日志详解"><a class="markdownIt-Anchor" href="#printgcdetails-日志详解"></a> PrintGCDetails 日志详解</h4><p><img src="/2022/03/29/jvm/PrintGCDetails1.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/29/jvm/PrintGCDetails2.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="jvm参数疑问解答"><a class="markdownIt-Anchor" href="#jvm参数疑问解答"></a> JVM参数疑问解答</h4><p>JVM参数 <code>-Xmn</code>，<code>-XX:NewSize</code> / <code>-XX:MaxNewSize</code>，以及 <code>-XX:NewRatio</code> 这三组参数都可以影响年轻代的大小。在混合使用这些参数时，它们的优先级如下：</p><ul><li><p><strong>高优先级：<code>-XX:NewSize</code> / <code>-XX:MaxNewSize</code></strong>：这两个参数具有最高优先级，因为它们直接设置年轻代的初始大小和最大大小。如果同时设置了这两个参数，它们会覆盖其他参数对年轻代大小的影响。</p></li><li><p><strong>中优先级：<code>-Xmn</code></strong>：如果你设置了 <code>-Xmn</code> 参数，它会以默认等效 <code>-Xmn=-XX:NewSize=-XX:MaxNewSize</code> 的方式影响年轻代的大小。这意味着 <code>-Xmn</code> 与 <code>-XX:NewSize</code> / <code>-XX:MaxNewSize</code> 具有相同的优先级。</p></li><li><p><strong>低优先级：<code>-XX:NewRatio</code></strong>：<code>-XX:NewRatio</code> 参数设置年轻代与老年代的大小比例。它具有较低的优先级，因为它会在已经设置了上述参数的情况下进一步影响年轻代大小。</p></li><li><p>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境</p></li></ul><h3 id="调优策略"><a class="markdownIt-Anchor" href="#调优策略"></a> 调优策略</h3><p><img src="/2022/03/29/jvm/%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5.png" srcset="/img/loading.gif" lazyload alt></p><p>优化JVM并不是首要选择，而应该优先考虑对应用程序本身的优化。JVM调优通常被视为一种最后的手段，用于解决性能问题或满足特定的需求。在程序优化中，以下是一般的优化顺序：</p><ol><li><code>程序本身的优化</code>：首先应该关注应用程序的代码和算法。通过改进代码结构、减少不必要的计算、使用更高效的算法等方式，可以显著提高应用程序的性能。</li><li><code>数据库和存储优化</code>：如果应用程序涉及数据库操作或文件存储，优化数据库查询、索引和数据访问，以及存储方案可以提高性能。</li><li><code>JVM调优</code>：只有在上述步骤都得到了满足，而且性能问题仍然存在，才考虑JVM调优。这可能包括调整内存分配、垃圾回收策略等JVM参数。</li></ol><h4 id="选择合适的垃圾回收器"><a class="markdownIt-Anchor" href="#选择合适的垃圾回收器"></a> 选择合适的垃圾回收器</h4><table><thead><tr><th>场景</th><th>垃圾回收器</th><th>原因</th></tr></thead><tbody><tr><td>高吞吐量任务，例如后台计算任务</td><td><code>Parallel Scavenge + Parallel Old</code></td><td>这个组合适用于高吞吐量场景，通过并行回收方式可以减少同一时间段的GC次数，虽然单次GC停顿时间较长，但适合计算密集型应用，能够充分利用多核CPU资源。</td></tr><tr><td>用户停顿时间敏感，面向用户应用程序，<br>JVM内存小于等于4GB，JDK版本小于1.8</td><td><code>ParNew + CMS</code></td><td>在内存较小（4GB以内）且要求用户停顿时间敏感的场景下，可以选择ParNew和CMS组合。这两个垃圾回收器都支持多线程并行回收，有助于降低GC停顿时间。CMS使用标记-清除算法，可以降低老年代的回收时间。</td></tr><tr><td>用户停顿时间敏感，JDK版本大于等于1.8，<br>JVM内存大于等于6GB</td><td><code>G1</code></td><td>对于要求可控停顿时间、内存较大（6GB以上）的场景，推荐使用G1垃圾回收器。G1回收器可以提供可预测的停顿时间，同时在大内存下具有高回收效率，适合处理复杂的内存管理需求。</td></tr></tbody></table><h4 id="调整内存"><a class="markdownIt-Anchor" href="#调整内存"></a> 调整内存</h4><p><strong>现象</strong>：频繁的垃圾收集操作</p><p><strong>原因</strong>：垃圾收集频繁的原因可能是堆内存过小，导致需要频繁进行垃圾收集以释放足够的内存来创建新的对象。因此，增加堆内存大小通常会显著减少垃圾收集的频率。</p><p><strong>注意</strong>：值得注意的是，如果垃圾收集次数非常频繁，但每次垃圾收集只能回收很少的对象，那么问题可能不是堆内存大小太小，而可能是内存泄漏导致的对象无法被回收，从而导致频繁的垃圾收集。</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-comment"># 调整初始堆大小</span><br><span class="hljs-literal">-</span>Xms2g<br><br><span class="hljs-comment"># 调整最大堆大小</span><br><span class="hljs-literal">-</span>Xmx4g<br><br><span class="hljs-comment"># 如果新生代GC频繁，可以考虑分配更多内存给新生代</span><br><span class="hljs-literal">-</span>Xmn2g<br></code></pre></td></tr></table></figure><h4 id="设置符合预期的停顿时间"><a class="markdownIt-Anchor" href="#设置符合预期的停顿时间"></a> 设置符合预期的停顿时间</h4><p><strong>现象</strong>：程序出现间歇性的卡顿现象</p><p><strong>原因</strong>：如果没有明确设置垃圾收集器的停顿时间目标，垃圾收集器通常以吞吐量为主要目标，这可能导致垃圾收集时间的不稳定性，从而引发程序卡顿。</p><p><strong>注意</strong>：在设置停顿时间目标时，应避免设置过于不切实际的停顿时间，因为较短的停顿时间可能需要更频繁的垃圾收集操作，从而增加GC的次数，甚至影响性能。</p><p><strong>适用垃圾收集器</strong>：建议使用<code>Parallel Scavenge</code>和<code>G1</code>垃圾收集器来实现可控制的停顿时间。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 设置垃圾收集器的最大停顿时间目标，需要进行反复测试以确定合适的值</span><br>-XX:<span class="hljs-attribute">MaxGCPauseMillis</span>=200<br></code></pre></td></tr></table></figure><h4 id="调整内存区域大小比率"><a class="markdownIt-Anchor" href="#调整内存区域大小比率"></a> 调整内存区域大小比率</h4><p><strong>现象</strong>：某一个区域的GC频繁，其他区域正常。</p><p><strong>原因</strong>：可能的原因是对应区域的空间不足，导致需要频繁进行GC以释放空间。在JVM堆内存无法增加的情况下，可以考虑调整对应区域的大小比率。</p><p><strong>注意</strong>：也有可能并非仅仅是空间不足，而是由于内存泄露导致内存无法被回收，从而引发频繁的GC。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 调整新生代和老年代的比例。例如，设置为<span class="hljs-number">1</span>表示新生代和老年代的大小相等。默认值是<span class="hljs-number">2</span>，意味着老年代是新生代的两倍。<br>-XX:NewRatio=<span class="hljs-number">1</span> <br><br><span class="hljs-regexp">//</span> 调整survivor区和Eden区的大小比率。例如，设置为<span class="hljs-number">6</span>表示Eden区的大小是一个Survivor区的<span class="hljs-number">6</span>倍。<br>-XX:SurvivorRatio=<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><ol><li><strong>扩大新生代的比例</strong>:<ul><li><strong>对象生命周期短</strong>：如果应用主要产生的是短生命周期的对象，那么扩大新生代可以减少老年代的GC频率，因为对象会在新生代中被回收。</li><li><strong>频繁的Full GC</strong>：如果老年代经常满，导致频繁的Full GC，增大新生代可能有助于减少对象到老年代的晋升速度。</li><li><strong>频繁的Minor GC</strong>：如果新生代经常触发Minor GC，并且每次GC后新生代仍然很满，这可能意味着新生代的空间不足，需要扩大。</li><li><strong>老年代使用不足</strong>：如果通过监控工具观察到老年代的使用率持续很低，而新生代经常接近满载，这可能是一个信号，表明可以安全地增大新生代的比例。</li></ul></li><li><strong>缩小新生代的比例</strong>:<ul><li><strong>对象生命周期长</strong>：如果应用产生大量的长生命周期对象或大对象，这些对象很快就会晋升到老年代，那么可能需要减少新生代的大小，为老年代分配更多空间。</li><li><strong>老年代GC频繁</strong>：如果老年代经常触发GC，特别是Full GC，并且每次GC后老年代仍然很满，这可能意味着老年代的空间不足，需要为其分配更多的空间。</li></ul></li><li><strong>增大Survivor区的比率</strong>:<ul><li><strong>对象晋升过快</strong>：如果大量对象在经历了很少的GC周期后就晋升到老年代，可能需要增大Survivor区，以便对象在新生代中停留更长时间。</li><li><strong>Survivor区溢出</strong>：如果Survivor区经常填满，导致对象提前晋升到老年代，增大Survivor区可以帮助缓解这个问题。</li><li><strong>应用的对象生命周期</strong>：如果应用中有大量的中生命周期对象（即不是很短暂，也不是很长久的对象），增大Survivor区可能有助于提高性能。</li></ul></li><li><strong>缩小Survivor区的比率</strong>:<ul><li><strong>对象生命周期很短</strong>：如果大部分对象都是短暂的，并且很快在Eden区被回收，那么可以缩小Survivor区，为Eden区分配更多空间。</li><li><strong>Survivor区使用率低</strong>：通过JVM监控工具，如果观察到Survivor区的使用率持续很低，这意味着大部分对象要么很快被回收，要么很快晋升，这时可以考虑缩小Survivor区。</li><li><strong>频繁的Minor GC但Eden区回收效果不佳</strong>：如果Eden区经常触发Minor GC，但每次回收后仍然很满，这可能意味着需要为Eden区分配更多空间，从而缩小Survivor区的比率。</li></ul></li></ol><h4 id="调整对象晋升老年代的年龄"><a class="markdownIt-Anchor" href="#调整对象晋升老年代的年龄"></a> 调整对象晋升老年代的年龄</h4><p><strong>现象</strong>：老年代频繁GC，每次回收的对象数量较多。</p><p><strong>原因</strong>：如果晋升年龄设置得太小，新生代的对象会很快晋升到老年代，导致老年代对象数量增多。而这些对象可能在短时间内就可以被回收。为了解决老年代频繁GC的问题，可以考虑调整对象的晋升年龄，使对象不那么容易晋升到老年代。</p><p><strong>注意</strong>：增加晋升年龄后，对象在新生代的停留时间会增加，这可能导致新生代GC的频率上升。同时，由于这些对象需要在新生代中经历更多的GC，Minor GC的暂停时间也可能增加。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 设置对象晋升到老年代的初始年龄阈值，默认值为<span class="hljs-number">15</span><br>-XX:InitialTenuringThreshold=<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="调整大对象的标准"><a class="markdownIt-Anchor" href="#调整大对象的标准"></a> 调整大对象的标准</h4><p><strong>现象</strong>：老年代频繁进行GC，每次回收的对象数量较多，且这些对象的体积都比较大。</p><p><strong>原因</strong>：大对象如果直接分配到老年代，会导致老年代容易被填满，从而引发频繁的GC。可以通过设置一个阈值，使得超过此阈值的对象直接在老年代分配。</p><p><strong>注意</strong>：当这些大对象被分配到新生代时，可能会增加新生代的GC频率和暂停时间。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 设置对象的大小阈值，超过此值的对象直接在老年代分配。单位是字节，<span class="hljs-number">0</span>代表没有限制，全部分配在新生代。<br>-XX:PretenureSizeThreshold=<span class="hljs-number">1000000</span> <br></code></pre></td></tr></table></figure><p><code>-XX:PretenureSizeThreshold</code> 参数只在使用 <code>Serial</code> 和 <code>ParNew</code> 垃圾收集器时有效。</p><h4 id="调整gc的触发时机"><a class="markdownIt-Anchor" href="#调整gc的触发时机"></a> 调整GC的触发时机</h4><p><strong>适用于</strong>：<code>CMS</code>、<code>G1</code></p><p><strong>现象</strong>：<code>CMS</code> 和 <code>G1</code> 经常进行 <code>Full GC</code>，导致程序卡顿严重。</p><p><strong>原因</strong>：在 <code>G1</code> 和 <code>CMS</code> 的部分GC阶段，垃圾收集是并发进行的，这意味着业务线程和垃圾收集线程会同时运行。因此，业务线程在GC过程中会生成新的对象。为了容纳这些新对象，需要预留一部分内存空间。如果内存空间不足以容纳新产生的对象，JVM会停止并发收集并暂停所有业务线程（STW），以确保垃圾收集可以正常进行。为了避免这种情况，可以提前触发GC，从而预留出足够的空间来容纳业务线程创建的新对象。</p><p><strong>注意</strong>：提前触发GC可能会增加老年代GC的频率。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 当老年代使用率达到此比例时，开始CMS收集。默认值是<span class="hljs-number">68</span>%。如果频繁发生Full GC卡顿，应该调小此值。<br>-XX:CMSInitiatingOccupancyFraction=<span class="hljs-number">65</span><br><br><span class="hljs-regexp">//</span> 在G1混合垃圾回收周期中，设置旧区域的占用率阈值。默认值为<span class="hljs-number">65</span>%。<br>-XX:G1MixedGCLiveThresholdPercent=<span class="hljs-number">65</span> <br></code></pre></td></tr></table></figure><h4 id="调整-jvm本地内存大小"><a class="markdownIt-Anchor" href="#调整-jvm本地内存大小"></a> 调整 JVM本地内存大小</h4><p><strong>现象</strong>：虽然GC的次数、时间和回收的对象都正常，且堆内存空间充足，但仍然报出OOM错误。</p><p><strong>原因</strong>：JVM除了堆内存之外，还有一块被称为 <code>本地内存</code> 或 <code>直接内存</code> 的区域。这块内存区域不会主动触发GC，只有在堆内存区域触发GC时才会尝试回收本地内存中的对象。如果本地内存分配不足，将直接抛出OOM异常。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">MaxDirectMemorySize</span>=512m<br></code></pre></td></tr></table></figure><p>如果不显式设置 <code>-XX:MaxDirectMemorySize</code>，那么默认的直接内存大小是基于Java堆的最大大小。像NIO等其他框架如果有使用直接内存，需要关注此设置。</p><h3 id="调优实例"><a class="markdownIt-Anchor" href="#调优实例"></a> 调优实例</h3><h4 id="网站流量浏览量暴增后网站反应页面响很慢"><a class="markdownIt-Anchor" href="#网站流量浏览量暴增后网站反应页面响很慢"></a> 网站流量浏览量暴增后，网站反应页面响很慢</h4><p><strong>策略</strong>：</p><ul><li>调整JVM内存配置</li><li>选择合适的垃圾回收器</li></ul><ol><li><strong>问题推测</strong>：尽管在测试环境中响应速度快，但生产环境变慢。可能的原因是垃圾收集导致的业务线程停顿。</li><li><strong>定位</strong>：使用<code>jstat -gc</code>指令在线上观察，发现JVM的GC频率很高，且GC所占用的时间也长。这表明GC频繁导致业务线程经常停顿，从而使页面响应变慢。</li><li><strong>解决方案</strong>：由于高流量导致对象创建速度快，堆内存容易被填满，从而频繁触发GC。问题可能在于新生代内存设置得太小。为了解决这个问题，我们将JVM的内存从2G增加到6G。</li><li><strong>第二个问题</strong>：虽然增加内存后常规请求变快了，但偶尔会出现更长时间的卡顿。</li><li><strong>问题推测</strong>：考虑到之前的内存增加，可能是因为单次GC的时间变长导致的间歇性卡顿。</li><li><strong>定位</strong>：通过<code>jstat -gc</code>指令再次观察，发现FGC（Full GC）的次数并不多，但每次FGC所花费的时间非常长，有时甚至达到几十秒。</li><li><strong>解决方案</strong>：默认的JVM使用的是<code>Parallel Scavenge + Parallel Old</code>组合，这两者在标记和收集阶段都会导致STW（Stop-The-World）。内存增加后，每次GC所需的时间也变长。为了减少单次GC的时间，我们需要切换到并发收集器。考虑到当前的JDK版本是1.7，我们选择CMS收集器（如果是1.8，可以考虑使用G1）。根据之前的GC日志，我们还为CMS设置了一个预期的停顿时间。这样，网站的卡顿问题得到了解决。</li></ol><h4 id="后台导出数据引发的oom"><a class="markdownIt-Anchor" href="#后台导出数据引发的oom"></a> 后台导出数据引发的OOM</h4><p><strong>问题描述</strong>：公司后台系统偶尔出现OOM异常，导致堆内存溢出。</p><ol><li><strong>初步判断</strong>：由于问题是偶发性的，最初的猜测是堆内存不足。因此，我们将堆内存从4G增加到8G。</li><li><strong>问题复现</strong>：尽管增加了堆内存，问题仍然存在。为了进一步定位问题，我们启用了<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，以在OOM时获取堆内存的dump文件。</li><li><strong>堆分析</strong>：使用<code>MAT</code>工具对dump文件进行分析。通过<code>MAT</code>的内存泄露报告和<code>Top Consumers</code>功能，我们识别出了大量的大对象。</li><li><strong>代码审查</strong>：进一步分析线程和代码，我们注意到一个正在运行的业务线程与“导出订单信息”方法有关。</li><li><strong>问题定位</strong>：考虑到订单信息导出可能涉及数万条数据，这个方法首先从数据库查询订单信息，然后将其转换为Excel。这个过程会生成大量的String对象和其他临时数据。</li><li><strong>前端交互问题</strong>：为了验证这个猜测，我们尝试在后台进行测试。令人惊讶的是，我们发现导出订单的按钮在前端没有禁用点击交互。因此，如果用户发现点击后页面没有反应，他们可能会连续点击多次。这导致了大量的请求涌入后台，生成了大量的订单和Excel对象。由于这些方法执行很慢，这些对象在短时间内无法被回收，从而导致内存溢出。</li><li><strong>解决方案</strong>：了解问题原因后，我们决定不调整JVM参数。而是在前端的“导出订单”按钮上添加了禁用状态，直到后端响应完成后才重新启用。此外，我们还对导出接口进行了限流，以防止用户通过刷新页面连续点击，从而彻底解决了OOM问题。</li></ol><h4 id="cpu经常100-问题定位"><a class="markdownIt-Anchor" href="#cpu经常100-问题定位"></a> CPU经常100% 问题定位</h4><p><strong>问题描述</strong>：CPU使用率经常达到100%，可能是由于锁竞争激烈或其他原因导致。</p><ol><li><p><strong>定位高CPU使用的进程</strong>： 使用<code>top</code>命令查看系统中各进程的资源占用情况。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span><br></code></pre></td></tr></table></figure></li><li><p><strong>定位进程中的高CPU使用线程</strong>： 根据上一步找到的进程ID，列出该进程中各线程的资源占用情况。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span> -Hp 进程ID<br></code></pre></td></tr></table></figure></li><li><p><strong>获取线程的堆栈信息</strong>：</p><ul><li><p>首先，将线程ID转换为16进制格式：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span> <span class="hljs-string">&quot;%x\n&quot;</span> 线程ID<br></code></pre></td></tr></table></figure></li><li><p>然后，使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jstack</span><br></code></pre></td></tr></table></figure><p>命令打印出进程的所有线程堆栈信息，并从中找到上一步转换为16进制的线程ID对应的堆栈信息：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jstack </span>进程ID<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>分析堆栈信息定位问题</strong>： 通过分析堆栈信息，查看是否有线程长时间处于<code>WAITING</code>或<code>BLOCKED</code>状态。</p><ul><li>如果线程长期处于<code>WAITING</code>状态，关注<code>waiting on xxxxxx</code>部分，这表示线程正在等待某个锁。根据锁的地址，可以找到持有该锁的线程。</li><li>如果线程长期处于<code>BLOCKED</code>状态，这通常意味着线程正在尝试获取一个已被其他线程持有的锁。</li></ul></li></ol><p>最后，根据堆栈信息，您可以深入到具体的代码逻辑中，找到可能导致高CPU使用或锁竞争的部分，并进行相应的优化。</p><h4 id="数据分析平台系统频繁-full-gc"><a class="markdownIt-Anchor" href="#数据分析平台系统频繁-full-gc"></a> 数据分析平台系统频繁 Full GC</h4><p><strong>问题背景</strong>：数据分析平台的主要功能是对用户在App中的行为进行定时分析统计，并提供报表导出功能。系统的老年代使用了<code>CMS</code>垃圾回收器。</p><p><strong>问题描述</strong>：数据分析师在使用平台时发现，系统页面打开时经常出现卡顿。通过使用<code>jstat</code>命令监控，发现每次Young GC后，大约有10%的存活对象被晋升到老年代。</p><p><strong>问题原因</strong>：经过分析，确定问题的原因是<code>Survivor</code>区域设置得过小。每次Young GC后，由于存活对象在<code>Survivor</code>区域放不下，这导致它们提前被晋升到老年代。</p><p><strong>解决方案</strong>：为了解决这个问题，我们调整了<code>Survivor</code>区的大小，确保它可以容纳Young GC后的存活对象。这样，对象会在<code>Survivor</code>区经历多次Young GC，只有当它们达到一定的年龄阈值时才会被晋升到老年代。</p><p><strong>效果</strong>：调整后，每次Young GC后进入老年代的存活对象数量大大减少，稳定运行时仅有几百Kb。这大大降低了Full GC的频率，从而提高了系统的响应速度。</p><h4 id="mq消费者-oom"><a class="markdownIt-Anchor" href="#mq消费者-oom"></a> MQ消费者 OOM</h4><p><strong>问题背景</strong>：系统主要功能是消费Kafka数据，进行数据处理和计算，然后将处理后的数据转发到另一个Kafka队列。</p><p><strong>问题描述</strong>：系统在运行几小时后出现OOM（内存溢出）异常。即使重启系统，几小时后仍然会再次出现OOM。</p><p><strong>问题定位</strong>：为了定位问题，我们使用<code>jmap</code>工具导出了系统的堆内存快照。然后，我们使用<code>eclipse MAT</code>工具对这个快照进行了分析。</p><p><strong>问题原因</strong>：分析结果显示，大量的对象在内存中堆积，等待被同步打印到日志。进一步的代码审查发现，我们在代码中异步打印了某个业务Kafka的<code>topic</code>数据。由于这个业务的数据量非常大，这导致了大量的对象在内存中堆积，最终导致了OOM。</p><p><strong>解决方案</strong>：为了解决这个问题，使用日志框架的异步打印方式，并设置异步队列的大小，确保不会有大量的对象在内存中堆积。此外，我们还增加了适当的流控制和内存监控，以确保系统在面对大量数据时仍能稳定运行。</p><h3 id="jvm监控工具"><a class="markdownIt-Anchor" href="#jvm监控工具"></a> JVM监控工具</h3><h4 id="jps"><a class="markdownIt-Anchor" href="#jps"></a> jps</h4><p><code>jps</code> (Java Virtual Machine Process Status Tool) 是 Java JDK 中的一个实用工具，用于列出正在运行的 JVM 进程。它可以帮助你快速查找 Java 进程的进程ID。</p><ul><li><code>-l</code>: 输出完整的包名和应用主类。</li><li><code>-m</code>: 输出传递给 JVM 的参数。</li><li><code>-v</code>: 输出传递给 JVM 的 JVM 参数。</li><li><code>-q</code>: 只输出进程ID，不输出类名、jar名或参数。</li></ul><p class="note note-primary">jsp</p><p>查看启动类名和进程id</p><p><img src="/2022/03/29/jvm/jps.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">jps –l</p><p>输出主类或者jar的完全路径名</p><p><img src="/2022/03/29/jvm/jsp2.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">jps –v</p><p>输出jvm参数</p><p><img src="/2022/03/29/jvm/jps3.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="jstat"><a class="markdownIt-Anchor" href="#jstat"></a> jstat</h4><p><code>jstat</code> 是一个用于监控Java HotSpot VM性能的命令行工具。它可以提供有关类加载、即时编译和垃圾收集的统计信息。</p><p>使用方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">jstat <span class="hljs-selector-attr">[option]</span> <span class="hljs-selector-attr">[vmid]</span> <span class="hljs-selector-attr">[interval]</span> <span class="hljs-selector-attr">[count]</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>option</code> 是你想要的统计信息的类型。</li><li><code>vmid</code> 是虚拟机的进程ID。</li><li><code>interval</code> 和 <code>count</code> 是可选的，用于指定多久收集一次数据和总共收集多少次数据。</li></ul><p>常用的选项：</p><ul><li><code>-class</code>: 显示类加载器的行为统计。</li><li><code>-compiler</code>: 显示即时编译的统计。</li><li><code>-gc</code>: 显示垃圾收集的统计。</li><li><code>-gccapacity</code>: 显示各个代的当前和最大容量。</li><li><code>-gcutil</code>: 显示各个代的使用百分比。</li><li><code>-gcnew</code>: 显示新生代的统计。</li><li><code>-gcnewcapacity</code>: 显示新生代的容量。</li><li><code>-gcold</code>: 显示老年代的统计。</li><li><code>-gcoldcapacity</code>: 显示老年代的容量。</li></ul><p class="note note-primary">jstat -gc pid</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">如下表示分析进程id为<span class="hljs-number">31736</span> 的<span class="hljs-keyword">gc</span>情况，每隔<span class="hljs-number">1000</span>ms打印一次记录，打印<span class="hljs-number">10</span>次停止，每<span class="hljs-number">3</span>行后打印指标头部<br>jstat -<span class="hljs-keyword">gc</span> -h<span class="hljs-number">3</span> <span class="hljs-number">31736</span> <span class="hljs-number">1000</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/29/jvm/jstat.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>S0C</td><td>当前 Survivor 0 区的容量 (KB)</td></tr><tr><td>S1C</td><td>当前 Survivor 1 区的容量 (KB)</td></tr><tr><td>S0U</td><td>当前 Survivor 0 区已使用的空间 (KB)</td></tr><tr><td>S1U</td><td>当前 Survivor 1 区已使用的空间 (KB)</td></tr><tr><td>EC</td><td>当前 Eden 区的容量 (KB)</td></tr><tr><td>EU</td><td>当前 Eden 区已使用的空间 (KB)</td></tr><tr><td>OC</td><td>当前老年代的容量 (KB)</td></tr><tr><td>OU</td><td>当前老年代已使用的空间 (KB)</td></tr><tr><td>MC</td><td>元空间的容量 (KB) (Java 8及以后版本)</td></tr><tr><td>MU</td><td>元空间已使用的空间 (KB) (Java 8及以后版本)</td></tr><tr><td>CCSC</td><td>压缩类空间的容量 (KB) (仅在使用压缩Oops时)</td></tr><tr><td>CCSU</td><td>压缩类空间已使用的空间 (KB) (仅在使用压缩Oops时)</td></tr><tr><td>YGC</td><td>从应用启动到当前时刻发生的次要垃圾收集事件的次数</td></tr><tr><td>YGCT</td><td>从应用启动到当前时刻次要垃圾收集所花费的总时间</td></tr><tr><td>FGC</td><td>从应用启动到当前时刻发生的完全垃圾收集事件的次数</td></tr><tr><td>FGCT</td><td>从应用启动到当前时刻完全垃圾收集所花费的总时间</td></tr><tr><td>GCT</td><td>从应用启动到当前时刻垃圾收集所花费的总时间 (YGCT + FGCT)</td></tr></tbody></table><p class="note note-primary">jstat -gcutil pid</p><p>显示各个代的使用百分比</p><p><img src="/2022/03/29/jvm/jstat2.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">S0</td><td style="text-align:center">幸存1区当前使用比例</td></tr><tr><td style="text-align:center">S1</td><td style="text-align:center">幸存2区当前使用比例</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">伊甸园区使用比例</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">老年代使用比例</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">元数据区使用比例</td></tr><tr><td style="text-align:center">CCS</td><td style="text-align:center">压缩使用比例</td></tr><tr><td style="text-align:center">YGC</td><td style="text-align:center">年轻代垃圾回收次数</td></tr><tr><td style="text-align:center">YGCT</td><td style="text-align:center">年轻代垃圾回收消耗时间</td></tr><tr><td style="text-align:center">FGC</td><td style="text-align:center">老年代垃圾回收次数</td></tr><tr><td style="text-align:center">FGCT</td><td style="text-align:center">老年代垃圾回收消耗时间</td></tr><tr><td style="text-align:center">GCT</td><td style="text-align:center">垃圾回收消耗总时间</td></tr></tbody></table><p class="note note-primary">jstat -gcnew pid</p><p>新生代垃圾回收统计</p><p><img src="/2022/03/29/jvm/jstat3.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">S0C</td><td style="text-align:center">第一个幸存区大小</td></tr><tr><td style="text-align:center">S1C</td><td style="text-align:center">第二个幸存区的大小</td></tr><tr><td style="text-align:center">S0U</td><td style="text-align:center">第一个幸存区的使用大小</td></tr><tr><td style="text-align:center">S1U</td><td style="text-align:center">第二个幸存区的使用大小</td></tr><tr><td style="text-align:center">TT</td><td style="text-align:center">对象在新生代存活的次数</td></tr><tr><td style="text-align:center">MTT</td><td style="text-align:center">对象在新生代存活的最大次数</td></tr><tr><td style="text-align:center">DSS</td><td style="text-align:center">期望的幸存区大小</td></tr><tr><td style="text-align:center">EC</td><td style="text-align:center">伊甸园区的大小</td></tr><tr><td style="text-align:center">EU</td><td style="text-align:center">伊甸园区的使用大小</td></tr><tr><td style="text-align:center">YGC</td><td style="text-align:center">年轻代垃圾回收次数</td></tr><tr><td style="text-align:center">YGCT</td><td style="text-align:center">年轻代垃圾回收消耗时间</td></tr></tbody></table><p class="note note-primary">jstat -gcold pid</p><p>老年代垃圾回收统计</p><p><img src="/2022/03/29/jvm/jstat5.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">MC</td><td style="text-align:center">方法区大小</td></tr><tr><td style="text-align:center">MU</td><td style="text-align:center">方法区使用大小</td></tr><tr><td style="text-align:center">CCSC</td><td style="text-align:center">压缩类空间大小</td></tr><tr><td style="text-align:center">CCSU</td><td style="text-align:center">压缩类空间使用大小</td></tr><tr><td style="text-align:center">OC</td><td style="text-align:center">老年代大小</td></tr><tr><td style="text-align:center">OU</td><td style="text-align:center">老年代使用大小</td></tr><tr><td style="text-align:center">YGC</td><td style="text-align:center">年轻代垃圾回收次数</td></tr><tr><td style="text-align:center">FGC</td><td style="text-align:center">老年代垃圾回收次数</td></tr><tr><td style="text-align:center">FGCT</td><td style="text-align:center">老年代垃圾回收消耗时间</td></tr><tr><td style="text-align:center">GCT</td><td style="text-align:center">垃圾回收消耗总时间</td></tr></tbody></table><p class="note note-primary">jstat -gccapacity pid</p><p>堆内存统计</p><p><img src="/2022/03/29/jvm/jstat4.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NGCMN</td><td style="text-align:center">新生代最小容量</td></tr><tr><td style="text-align:center">NGCMX</td><td style="text-align:center">新生代最大容量</td></tr><tr><td style="text-align:center">NGC</td><td style="text-align:center">当前新生代容量</td></tr><tr><td style="text-align:center">S0C</td><td style="text-align:center">第一个幸存区大小</td></tr><tr><td style="text-align:center">S1C</td><td style="text-align:center">第二个幸存区的大小</td></tr><tr><td style="text-align:center">EC</td><td style="text-align:center">伊甸园区的大小</td></tr><tr><td style="text-align:center">OGCMN</td><td style="text-align:center">老年代最小容量</td></tr><tr><td style="text-align:center">OGCMX</td><td style="text-align:center">老年代最大容量</td></tr><tr><td style="text-align:center">OGC</td><td style="text-align:center">当前老年代大小</td></tr><tr><td style="text-align:center">OC</td><td style="text-align:center">当前老年代大小</td></tr><tr><td style="text-align:center">MCMN</td><td style="text-align:center">最小元数据容量</td></tr><tr><td style="text-align:center">MCMX</td><td style="text-align:center">最大元数据容量</td></tr><tr><td style="text-align:center">MC</td><td style="text-align:center">当前元数据空间大小</td></tr><tr><td style="text-align:center">CCSMN</td><td style="text-align:center">最小压缩类空间大小</td></tr><tr><td style="text-align:center">CCSMX</td><td style="text-align:center">最大压缩类空间大小</td></tr><tr><td style="text-align:center">CCSC</td><td style="text-align:center">当前压缩类空间大小</td></tr><tr><td style="text-align:center">YGC</td><td style="text-align:center">年轻代GC次数</td></tr><tr><td style="text-align:center">FGC</td><td style="text-align:center">老年代GC次数</td></tr></tbody></table><h4 id="jinfo"><a class="markdownIt-Anchor" href="#jinfo"></a> jinfo</h4><p><code>jinfo</code> 用于获取 Java 进程的配置信息和 JVM 参数。它可以显示和调整运行时的 JVM 参数</p><p><strong>jinfo pid</strong></p><p><img src="/2022/03/29/jvm/jinfo.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="jstack"><a class="markdownIt-Anchor" href="#jstack"></a> jstack</h4><p><code>线程状态快照</code> <code>死锁分析</code></p><p><code>jstack</code>（Java Virtual Machine Stack Trace）用于生成 Java 线程的堆栈跟踪。这个工具对于诊断性能问题、锁竞争、死锁和其他线程相关的问题非常有用。</p><p><img src="/2022/03/29/jvm/jstack.png" srcset="/img/loading.gif" lazyload alt></p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-F</td><td style="text-align:center">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:center">如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</td></tr></tbody></table><p class="note note-primary">线程状态</p><ul><li><p><code>New</code>：创建后尚未启动的线程处于这种状态，不会出现在Dump中。</p></li><li><p><code>RUNNABLE</code>：包括Running和Ready。线程开启start（）方法，会进入该状态，在虚拟机内执行的。</p></li><li><p><code>Waiting</code>：无限的等待另一个线程的特定操作。</p></li><li><p><code>Timed Waiting</code>：有时限的等待另一个线程的特定操作。</p></li><li><p><code>阻塞（Blocked）</code>：在程序等待进入同步区域的时候，线程将进入这种状态，在等待监视器锁。</p></li><li><p><code>结束（Terminated）</code>：已终止线程的线程状态，线程已经结束执行。</p></li></ul><p class="note note-primary">死锁排查</p><p>死锁代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;获得两把锁&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;获得两把锁&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                f1();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                f2();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行命令： <code>jstack -l 244</code></p><p><img src="/2022/03/29/jvm/%E6%AD%BB%E9%94%81%E7%BA%BF%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">CPU过载分析</p><p><a href="#%E8%B0%83%E4%BC%98%E5%AE%9E%E4%BE%8B">参考 调优实例 CPU经常100% 问题定位</a></p><h4 id="jmap"><a class="markdownIt-Anchor" href="#jmap"></a> jmap</h4><p>java9后改用 <code>jhsdb</code></p><p>用于生成 Java 堆转储 (heap dump) 和查询堆内存的详细信息。这个工具对于诊断内存泄漏、分析对象的内存占用和其他与内存相关的问题非常有用。</p><p><strong>jmap [option]</strong></p><ul><li><p><code>heap</code>：打印Java堆概要信息，包括使用的GC算法、堆配置参数和各代中堆内存使用情况；</p></li><li><p><code>histo[:live]</code>： 打印Java堆中对象直方图，通过该图可以获取每个class的对象数目，占用内存大小和类全名信息，带上:live，则只统计活着的对象；</p></li><li><p><code>finalizerinfo</code>： 打印等待回收的对象信息</p></li><li><p><code>dump</code>：以hprof二进制格式将Java堆信息输出到文件内，该文件可以用MAT、VisualVM或jhat等工具查看；</p></li></ul><p class="note note-primary">jmap -heap pid</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs awk">&gt; jmap -heap <span class="hljs-number">10352</span><br><br>jmap -heap <span class="hljs-number">10352</span><br>Attaching to process ID <span class="hljs-number">10352</span>, please wait...<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is <span class="hljs-number">25.201</span>-b09<br><br>using thread-local object allocation.<br>Parallel GC with <span class="hljs-number">4</span> thread(s)<br><br>Heap Configuration:<br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(defalut <span class="hljs-number">40</span>)<br>   MinHeapFreeRatio         = <span class="hljs-number">0</span> <br>   <span class="hljs-regexp">//</span>对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default <span class="hljs-number">70</span>)<br>   MaxHeapFreeRatio         = <span class="hljs-number">100</span><br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小<br>   MaxHeapSize              = <span class="hljs-number">4280287232</span> (<span class="hljs-number">4082.0</span>MB)<br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小<br>   NewSize                  = <span class="hljs-number">89128960</span> (<span class="hljs-number">85.0</span>MB)<br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小<br>   MaxNewSize               = <span class="hljs-number">1426587648</span> (<span class="hljs-number">1360.5</span>MB)<br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老年代’的大小<br>   OldSize                  = <span class="hljs-number">179306496</span> (<span class="hljs-number">171.0</span>MB)<br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率<br>   NewRatio                 = <span class="hljs-number">2</span><br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值<br>   SurvivorRatio            = <span class="hljs-number">8</span><br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:MetaspaceSize=&lt;value&gt;:设置JVM堆的‘元空间’的初始大小<br>   <span class="hljs-regexp">//</span> jdk1.<span class="hljs-number">8</span> 永久代已经被元空间所取代<br>   MetaspaceSize            = <span class="hljs-number">21807104</span> (<span class="hljs-number">20.796875</span>MB)<br>   CompressedClassSpaceSize = <span class="hljs-number">1073741824</span> (<span class="hljs-number">1024.0</span>MB)<br>   <span class="hljs-regexp">//</span>对应jvm启动参数-XX:MaxMetaspaceSize= :设置JVM堆的‘元空间’的最大大小<br>   MaxMetaspaceSize         = <span class="hljs-number">17592186044415</span> MB<br>   G1HeapRegionSize         = <span class="hljs-number">0</span> (<span class="hljs-number">0.0</span>MB)<br><span class="hljs-regexp">//</span>堆内存分布<br>Heap Usage:<br><span class="hljs-regexp">//</span>新生代的内存分布<br>PS Young Generation<br><span class="hljs-regexp">//</span>Eden区内存分布<br>Eden Space:<br>   <span class="hljs-regexp">//</span>Eden区总容量<br>   capacity = <span class="hljs-number">1425539072</span> (<span class="hljs-number">1359.5</span>MB)<br>   <span class="hljs-regexp">//</span>Eden区已使用<br>   used     = <span class="hljs-number">28510792</span> (<span class="hljs-number">27.19001007080078</span>MB)<br>   <span class="hljs-regexp">//</span>Eden区剩余容量<br>   free     = <span class="hljs-number">1397028280</span> (<span class="hljs-number">1332.3099899291992</span>MB)<br>   <span class="hljs-regexp">//</span>Eden区使用比率<br>   <span class="hljs-number">2.0000007407724003</span>% used<br>From Space:<br>   capacity = <span class="hljs-number">524288</span> (<span class="hljs-number">0.5</span>MB)<br>   used     = <span class="hljs-number">65536</span> (<span class="hljs-number">0.0625</span>MB)<br>   free     = <span class="hljs-number">458752</span> (<span class="hljs-number">0.4375</span>MB)<br>   <span class="hljs-number">12.5</span>% used<br>To Space:<br>   capacity = <span class="hljs-number">524288</span> (<span class="hljs-number">0.5</span>MB)<br>   used     = <span class="hljs-number">0</span> (<span class="hljs-number">0.0</span>MB)<br>   free     = <span class="hljs-number">524288</span> (<span class="hljs-number">0.5</span>MB)<br>   <span class="hljs-number">0.0</span>% used<br>PS Old Generation<br>   capacity = <span class="hljs-number">128974848</span> (<span class="hljs-number">123.0</span>MB)<br>   used     = <span class="hljs-number">24006808</span> (<span class="hljs-number">22.894676208496094</span>MB)<br>   free     = <span class="hljs-number">104968040</span> (<span class="hljs-number">100.1053237915039</span>MB)<br>   <span class="hljs-number">18.613557893086256</span>% used<br><br><span class="hljs-number">13410</span> interned Strings occupying <span class="hljs-number">1194568</span> bytes.<br></code></pre></td></tr></table></figure><p class="note note-primary">jmap -histo pid</p><p>展示class的内存情况，类似<code>MAT</code>的直方图</p><p><img src="/2022/03/29/jvm/jmap.png" srcset="/img/loading.gif" lazyload alt></p><p class="note note-primary">jmap -dump:format=b,file=D:\dump\dump.hprof 11404</p><p>导出dump文件到指定文件夹</p><h4 id="jhat"><a class="markdownIt-Anchor" href="#jhat"></a> jhat</h4><p><code>jhat</code> (Java Heap Analysis Tool) 用于分析 Java 堆转储文件。它可以帮助你诊断内存泄漏、分析对象的内存占用和其他与内存相关的问题。</p><p><code>jhat</code> 的一个特点是它可以启动一个 Web 服务器，允许你通过 Web 浏览器浏览堆转储的内容。这为分析大型堆转储提供了一个方便的界面。</p><p><code>jhat [ options ] heap-dump-file</code></p><p><img src="/2022/03/29/jvm/jhat.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/29/jvm/jhat2.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="jconsole"><a class="markdownIt-Anchor" href="#jconsole"></a> jconsole</h4><p>Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。</p><p>命令行下数据启动命令 <code>jconsole</code></p><p><img src="/2022/03/29/jvm/jconsole.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/29/jvm/jconsole2.png" srcset="/img/loading.gif" lazyload alt></p><h4 id="jvisualvm"><a class="markdownIt-Anchor" href="#jvisualvm"></a> jvisualvm</h4><p><a target="_blank" rel="noopener" href="https://visualvm.github.io/download.html">下载</a></p><p>VisualVM 是一款免费的，集成了多个 JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在 MBeans 上进行浏览和操作</p><p>命令行下数据启动命令 <code>jvisualvm</code></p><p>下载额外插件</p><p><img src="/2022/03/29/jvm/jvisualvm.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2022/03/29/jvm/jvisualvm2.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="mat-内存数据分析"><a class="markdownIt-Anchor" href="#mat-内存数据分析"></a> MAT 内存数据分析</h3><p><a href="/2022/09/26/MAT%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3">MAT中文文档</a></p><h3 id="arthas-诊断工具"><a class="markdownIt-Anchor" href="#arthas-诊断工具"></a> Arthas 诊断工具</h3><p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dashboard.html#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></p><p><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">Arthas 阿尔萨斯</a> 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率</p><p class="note note-primary">jvm 相关</p><ul><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a> - 当前系统的实时数据面板</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/getstatic.html">getstatic</a> - 查看类的静态属性</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/heapdump.html">heapdump</a> - dump java heap, 类似 jmap 命令的 heap dump 功能</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jvm.html">jvm</a> - 查看当前 JVM 的信息</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/logger.html">logger</a> - 查看和修改 logger</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/mbean.html">mbean</a> - 查看 Mbean 的信息</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/memory.html">memory</a> - 查看 JVM 的内存信息</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/ognl.html">ognl</a> - 执行 ognl 表达式</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/perfcounter.html">perfcounter</a> - 查看当前 JVM 的 Perf Counter 信息</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysenv.html">sysenv</a> - 查看 JVM 的环境变量</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sysprop.html">sysprop</a> - 查看和修改 JVM 的系统属性</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/thread.html">thread</a> - 查看当前 JVM 的线程堆栈信息</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/vmoption.html">vmoption</a> - 查看和修改 JVM 里诊断相关的 option</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/vmtool.html">vmtool</a> - 从 jvm 里查询对象，执行 forceGc</li></ul><p class="note note-primary">class/classloader 相关</p><ul><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/classloader.html">classloader</a> - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/dump.html">dump</a> - dump 已加载类的 byte code 到特定目录</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/jad.html">jad</a> - 反编译指定已加载类的源码</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/mc.html">mc</a> - 内存编译器，内存编译<code>.java</code>文件为<code>.class</code>文件</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/redefine.html">redefine</a> - 加载外部的<code>.class</code>文件，redefine 到 JVM 里</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/retransform.html">retransform</a> - 加载外部的<code>.class</code>文件，retransform 到 JVM 里</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sc.html">sc</a> - 查看 JVM 已加载的类信息</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/sm.html">sm</a> - 查看已加载类的方法信息</li></ul><p class="note note-primary">monitor/watch/trace 相关</p><blockquote><p>注意</p><p>请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 <code>stop</code> 或将增强过的类执行 <code>reset</code> 命令。</p></blockquote><ul><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/monitor.html">monitor</a> - 方法执行监控</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/stack.html">stack</a> - 输出当前方法被调用的调用路径</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/trace.html">trace</a> - 方法内部调用路径，并输出方法路径上的每个节点上耗时</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/tt.html">tt</a> - 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</li><li><a target="_blank" rel="noopener" href="https://arthas.aliyun.com/doc/watch.html">watch</a> - 方法执行数据观测</li></ul><h3 id="内存溢出自动dump"><a class="markdownIt-Anchor" href="#内存溢出自动dump"></a> 内存溢出自动dump</h3><p>-Xmx2048m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/data/oom</p><p>指定最大堆内存大小，当发生OOM异常时，将堆内存数据dump到指定的文件夹下</p><h2 id="jmm-内存模型"><a class="markdownIt-Anchor" href="#jmm-内存模型"></a> JMM 内存模型</h2><p><img src="/2022/03/29/jvm/JMM.png" srcset="/img/loading.gif" lazyload alt></p><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/739920a92d0d27e2053174ef2">参考 InfoQ Simon郎 文章</a></p><h2 id="string问题"><a class="markdownIt-Anchor" href="#string问题"></a> String问题</h2><p>String str = “R”; 一共创建了几个对象</p><p><strong>思路分析：&quot;R&quot;是一个字面量，会放在字符串常量池子中</strong></p><p><strong>两种情况</strong></p><ul><li>如果字符串常量池中已经存在“R“，那么创建0个对象</li><li>如果字符串常量池不存在“R“，那么在常量池中创建1个对象</li></ul><p>new String(“R”); 创建了几个对象？</p><p><strong>思路分析：</strong> new 关键字一定会在内存中创建一个对象，还要把字面量“R“提取出来分析</p><br><p><strong>两种情况</strong></p><ul><li>如果字符串常量池中已经存在“R“，那么创建1个对象(堆中1个)</li><li>如果字符串常量池不存在“R“，那么在常量池中创建2个对象(字符串常量池1个，堆中1个)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> “Java“;<br>为什么 str == str2  为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路分析</strong>：java对于常量（字面量）会存储在字符串常量池中，str1第一次赋值时在常量池中添加了“Java“并返回其引用, str2第二次赋值直接</p><p>引用字符串常量池。两个都是常量池 “Java” 的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Ja&quot;</span> + <span class="hljs-string">&quot;va&quot;</span>;<br>为什么 str == str2  为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>思路分析：参考上面，常量拼接还是常量(编译期优化)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br>为什么 str == str2  为<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路分析：</strong> String str = “Java”; 内存存储区域在字符串常量池，new String(“Java”);内存存储区域在堆</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> str1 = <span class="hljs-string">&quot;java&quot;</span>;<br><span class="hljs-type">String</span> str2 = <span class="hljs-string">&quot;ja&quot;</span>;<br><span class="hljs-type">String</span> str3 = str2 + <span class="hljs-string">&quot;va&quot;</span>;<br>为什么 str1 == str3 为<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路分析：因为两者属于不同对象，第一个对象在常量池中，第二个对象在堆中</strong></p><p><strong>str2 + “va”</strong>;	<strong>字符串拼接底层使用的是 StringBuilder#append，最终使用StringBuilder#toString方法返回String对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 创建一个新的String对象</span><br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, <span class="hljs-number">0</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stringinertn"><a class="markdownIt-Anchor" href="#stringinertn"></a> String.inertn()</h3><p>String.intern()方法设计的初衷就是：<strong>重用字符串对象，以便节省内存</strong></p><p>JDK1.8, 先判断常量池中当前字符串是否存在</p><ul><li>如果不存在：不会将当前字符串复制到常量池，<strong>而是将当前字符串的引用复制到常量池</strong></li><li>如果存在：不会改变常量池已经存在的引用，并<strong>直接返回常量池中字符串引用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Strign</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Ja&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;va&quot;</span>);<br>str1 == str2.intern(); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><strong>思路分析</strong>：因为“java”已经创建并存在str1，所以str2.intern()返回的是常量池已存在的字符串str1的引用，两者并非同一字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Strign</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ja&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;va&quot;</span>);<br>str1 == str2.intern(); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>思路分析</strong>：因为常量池不纯在时，不会将当前字符串复制到常量池，而是将当前字符串的引用复制到常量池，两者是同一对象</p><h3 id="java存在的引用"><a class="markdownIt-Anchor" href="#java存在的引用"></a> java存在的引用</h3><table><thead><tr><th>引用类型</th><th>回收时间</th><th>用途</th></tr></thead><tbody><tr><td>强引用</td><td>永不回收</td><td>普通对象引用</td></tr><tr><td>软引用</td><td>在内存不足回收</td><td>缓存对象</td></tr><tr><td>弱引用</td><td>垃圾回收时</td><td>缓存对象</td></tr><tr><td>虚引用</td><td>不确定</td><td>不确定</td></tr></tbody></table><p class="note note-primary">强引用</p><p><strong>强引用</strong>：强应用就是我们平时对象的引用，JVM不会回收带有强引用的对象，即使内存不足导致OOM</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><p><strong>我们平时使用变量对对象的引用就是强引用</strong>，user持有这个对象的存储地址引用</p><p class="note note-primary">软引用</p><p><strong>软引用</strong>：如果一个对象只有软引用</p><ul><li>在内存空间足够的情况下，垃圾回收器就不会回收它</li><li>如果内存空间不够了，就会对这些只有软引用的对象进行回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置堆内存 -Xmx20M</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>]);<br>        System.out.println(softReference.get());<br>        System.gc();<br>        System.out.println(softReference.get());<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>];<br>        System.out.println(softReference.get());<br>    &#125;<br><br>输出<br>[B@6956de9<br>[B@6956de9<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p class="note note-primary">弱引用</p><p><strong>弱引用</strong>：在垃圾回收器扫描内存区域时，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会进行回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        WeakReference&lt;String&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;java&quot;</span>));<br>        System.out.println(weakReference.get());<br>        System.gc();<br>        System.out.println(weakReference.get());<br>        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br><br>        <span class="hljs-comment">// 错误用法，因为这里的java会被放在常量池属于强引用</span><br>        WeakReference&lt;String&gt; weakReference1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(weakReference1.get());<br>        System.gc();<br>        System.gc();<br>        System.gc();<br>        System.out.println(weakReference1.get());<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用WeakHashMap 作为缓存</span><br>        WeakHashMap&lt;String, Object&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// key不能使用常量</span><br>        cache.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;java&quot;</span>), <span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(cache);<br>        System.gc();;<br>        System.out.println(cache);<br>    &#125;<br>输出<br>&#123;java=java&#125;<br>&#123;&#125;<br></code></pre></td></tr></table></figure><p>当WeakHashMap没有被正确使用就可能造成OOM,退化成hashMap</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>       <span class="hljs-comment">// 使用WeakHashMap 作为缓存</span><br>       <span class="hljs-title class_">WeakHashMap</span>&lt;<span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span>&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>       <span class="hljs-comment">// test会被放入常量池，变成强引用</span><br>       cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);<br>       <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>           <span class="hljs-title class_">System</span>.<span class="hljs-title function_">gc</span>();<br>       &#125;<br>       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(cache);<br>   &#125;<br></code></pre></td></tr></table></figure><p class="note note-primary">虚引用</p><p><strong>虚引用</strong>：顾名思义就是形同虚设，虚引用不决定对象的生命周期，如果一个对象仅持有虚引用那么它就和没有任何引用一样在任何时候都能被垃圾回收器回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// 需要配合引用队列使用</span><br>       ReferenceQueue&lt;String&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>       PhantomReference&lt;String&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;java&quot;</span>), referenceQueue);<br>   &#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>jvm</div><div>https://wugengfeng.cn/2022/03/29/jvm/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>wugengfeng</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年3月29日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/04/07/Mybatis/" title="Mybatis"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Mybatis</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/03/23/spring/" title="spring"><span class="hidden-mobile">spring</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>